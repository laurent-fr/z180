ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 1.
Hexadecimal [16-Bits]



                              1 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                              2 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                              3 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                              4 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                              5 ; the original ROM code (checksum 0xA934). PA
                              6 
                              7 .z180
                              8 
                              9 .area CODE (ABS)
                             10 
                             11 
                             12 ; MONITOR EQUATES (RESTART INSTRUCTIONS)
                             13 
                     00F7    14 _ROUT   .equ     0xF7            ; ROUT - Output char in A
                     7BDF    15 _BLNK   .equ     0x7BDF          ; SCAL BLINK - Get input char in A
                     63DF    16 _INLN   .equ     0x63DF          ; SCAL INLIN - Get input line
                     5FDF    17 _MFLP   .equ     0x5FDF          ; SCAL MFLP - Toggle tape drv LED
                     5BDF    18 _MRET   .equ     0x5BDF          ; SCAL MRET - Return to monitor
                     52DF    19 _READ   .equ     0x52DF          ; SCAL READ
                     62DF    20 _RIN    .equ     0x62DF          ; SCAL RIN - Scan for input char
                     56DF    21 _VRFY   .equ     0x56DF          ; SCAL VERIFY
                     57DF    22 _WRIT   .equ     0x57DF          ; SCAL WRITE
                             23 
                             24 ; GENERAL .equATES
                             25 
                     0001    26 UARTD   .equ     0x01             ; UART data port
                     0002    27 UARTS   .equ     0x02             ; UART status port
                     0003    28 CTRLC   .equ     0x03             ; Control "C"
                     0007    29 CTRLG   .equ     0x07             ; Control "G"
                     0008    30 BKSP    .equ     0x08             ; Back space
                     000A    31 LF      .equ     0x0A             ; Line feed
                     000C    32 CS      .equ     0x0C             ; Clear screen
                     000D    33 CR      .equ     0x0D             ; Carriage return
                     000F    34 CTRLO   .equ     0x0F             ; Control "O"
                     0012    35 CTRLR   .equ     0x12             ; Control "R"
                     0013    36 CTRLS   .equ     0x13             ; Control "S"
                     0015    37 CTRLU   .equ     0x15             ; Control "U"
                     001A    38 CTRLZ   .equ     0x1A             ; Control "Z"
                     001B    39 ESC     .equ     0x1B             ; Escape
                     001C    40 TBRK    .equ     0x1C             ; "T" monitor break
                     001D    41 TBS     .equ     0x1D             ; "T" monitor back space
                     001E    42 TCS     .equ     0x1E             ; "T" monitor clear screen
                     001F    43 TCR     .equ     0x1F             ; "T" monitor carriage return
                     007F    44 DEL     .equ     0x7F             ; Delete
                             45 
                             46 ; MONITOR LOCATIONS
                             47 
                     0000    48 MONSTT  .equ     0x0000           ; Start of monitor
                     000D    49 STMON   .equ     0x000D           ; NAS-SYS initialisation
                     0051    50 MFLP    .equ     0x0051           ; Flip tape LED ("T")
                     008D    51 MONTYP  .equ     0x008D           ; Type of "T" monitor
                     03D1    52 T2DUMP  .equ     0x03D1           ; "T2" Dump routine
                     0400    53 T4WR    .equ     0x0400           ; "T4" Write routine
                     070C    54 T4READ  .equ     0x070C           ; "T4" Read routine
                     0800    55 VDU     .equ     0x0800           ; NASCOM Video RAM base
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 2.
Hexadecimal [16-Bits]



                             56 
                             57 ; MONITOR WORK SPACE LOCATIONS
                             58 
                     0C00    59 PORT0   .equ     0x0C00           ; Copy of output port 0
                     0C0C    60 ARG1    .equ     0x0C0C           ; Argument 1
                     0C0E    61 ARG2    .equ     0x0C0E           ; Argument 2
                     0C18    62 TCUR    .equ     0x0C18           ; "T" monitor cursor
                     0C29    63 CURSOR  .equ     0x0C29           ; NAS-SYS Cursor
                     0C2B    64 ARGN    .equ     0x0C2B           ; Number of ARGS
                     0C4A    65 TOUT    .equ     0x0C4A           ; "T" Output reflection
                     0C4D    66 TIN     .equ     0x0C4D           ; "T" Input reflection
                     0C75    67 CIN     .equ     0x0C75           ; NAS-SYS Input table
                     0C7E    68 NMI     .equ     0x0C7E           ; NAS-SYS NMI Jump
                             69 
                             70 ; BASIC WORK SPACE LOCATIONS
                             71 
                     1000    72 WRKSPC  .equ     0x1000           ; BASIC Work space
                     1003    73 USR     .equ     0x1003           ; "USR (x)" jump
                     1006    74 OUTSUB  .equ     0x1006           ; "OUT p,n"
                     1007    75 OTPORT  .equ     0x1007           ; Port (p)
                     1009    76 DIVSUP  .equ     0x1009           ; Division support routine
                     100A    77 DIV1    .equ     0x100A           ; <- Values
                     100E    78 DIV2    .equ     0x100E           ; <-   to
                     1012    79 DIV3    .equ     0x1012           ; <-   be
                     1015    80 DIV4    .equ     0x1015           ; <-inserted
                     1017    81 SEED    .equ     0x1017           ; Random number seed
                     103A    82 LSTRND  .equ     0x103A           ; Last random number
                     103E    83 INPSUB  .equ     0x103E           ; #INP (x)" Routine
                     103F    84 INPORT  .equ     0x103F           ; PORT (x)
                     1041    85 NULLS   .equ     0x1041           ; Number of nulls
                     1042    86 LWIDTH  .equ     0x1042           ; Terminal width
                     1043    87 COMMAN  .equ     0x1043           ; Width for commas
                     1044    88 NULFLG  .equ     0x1044           ; Null after input byte flag
                     1045    89 CTLOFG  .equ     0x1045           ; Control "O" flag
                     1046    90 LINESC  .equ     0x1046           ; Lines counter
                     1048    91 LINESN  .equ     0x1048           ; Lines number
q                            92 0xCKSUM  .equ     104AH           ; Array load/save check sum
                     104C    93 NMIFLG  .equ     0x104C           ; Flag for NMI break routine
                     104D    94 BRKFLG  .equ     0x104D           ; Break flag
                     104E    95 RINPUT  .equ     0x104E           ; Input reflection
                     1051    96 POINT   .equ     0x1051           ; "POINT" reflection (unused)
                     1054    97 PSET    .equ     0x1054           ; "SET"   reflection
                     1057    98 RESET   .equ     0x1057           ; "RESET" reflection
                     105A    99 STRSPC  .equ     0x105A           ; Bottom of string space
                     105C   100 LINEAT  .equ     0x105C           ; Current line number
                     105E   101 BASTXT  .equ     0x105E           ; Pointer to start of program
                     1061   102 BUFFER  .equ     0x1061           ; Input buffer
                     1066   103 STACK   .equ     0x1066           ; Initial stack
                     10AB   104 CURPOS  .equ     0x10AB           ; Character position on line
                     10AC   105 LCRFLG  .equ     0x10AC           ; Locate/Create flag
                     10AD   106 TYPE    .equ     0x10AD           ; Data type flag
                     10AE   107 DATFLG  .equ     0x10AE           ; Literal statement flag
                     10AF   108 LSTRAM  .equ     0x10AF           ; Last available RAM
                     10B1   109 TMSTPT  .equ     0x10B1           ; Temporary string pointer
                     10B3   110 TMSTPL  .equ     0x10B3           ; Temporary string pool
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 3.
Hexadecimal [16-Bits]



                     10BF   111 TMPSTR  .equ     0x10BF           ; Temporary string
                     10C3   112 STRBOT  .equ     0x10C3           ; Bottom of string space
                     10C5   113 CUROPR  .equ     0x10C5           ; Current operator in EVAL
                     10C7   114 LOOPST  .equ     0x10C7           ; First statement of loop
                     10C9   115 DATLIN  .equ     0x10C9           ; Line of current DATA item
                     10CB   116 FORFLG  .equ     0x10CB           ; "FOR" loop flag
                     10CC   117 LSTBIN  .equ     0x10CC           ; Last byte entered
                     10CD   118 READFG  .equ     0x10CD           ; Read/Input flag
                     10CE   119 BRKLIN  .equ     0x10CE           ; Line of break
                     10D0   120 NXTOPR  .equ     0x10D0           ; Next operator in EVAL
                     10D2   121 ERRLIN  .equ     0x10D2           ; Line of error
                     10D4   122 CONTAD  .equ     0x10D4           ; Where to CONTinue
                     10D6   123 PROGND  .equ     0x10D6           ; End of program
                     10D8   124 VAREND  .equ     0x10D8           ; End of variables
                     10DA   125 ARREND  .equ     0x10DA           ; End of arrays
                     10DC   126 NXTDAT  .equ     0x10DC           ; Next data item
                     10DE   127 FNRGNM  .equ     0x10DE           ; Name of FN argument
                     10E0   128 FNARG   .equ     0x10E0           ; FN argument value
                     10E4   129 FPREG   .equ     0x10E4           ; Floating point register
                     10E7   130 FPEXP   .equ     FPREG+3         ; Floating point exponent
                     10E8   131 SGNRES  .equ     0x10E8           ; Sign of result
                     10E9   132 PBUFF   .equ     0x10E9           ; Number print buffer
                     10F6   133 MULVAL  .equ     0x10F6           ; Multiplier
                     10F9   134 PROGST  .equ     0x10F9           ; Start of program text area
                     115D   135 STLOOK  .equ     0x115D           ; Start of memory test
                            136 
                            137 ; BASIC ERROR CODE VALUES
                            138 
                     0000   139 NF      .equ     0x00             ; NEXT without FOR
                     0002   140 SN      .equ     0x02             ; Syntax error
                     0004   141 RG      .equ     0x04             ; RETURN without GOSUB
                     0006   142 OD      .equ     0x06             ; Out of DATA
                     0008   143 FC      .equ     0x08             ; Function call error
                     000A   144 OV      .equ     0x0A             ; Overflow
                     000C   145 OM      .equ     0x0C             ; Out of memory
                     000E   146 UL      .equ     0x0E             ; Undefined line number
                     0010   147 BS      .equ     0x10             ; Bad subscript
                     0012   148 DD      .equ     0x12             ; Re-DIMensioned array
                     0014   149 DZ      .equ     0x14             ; Division by zero (/0)
                     0016   150 ID      .equ     0x16             ; Illegal direct
                     0018   151 TM      .equ     0x18             ; Type miss-match
                     001A   152 OS      .equ     0x1A             ; Out of string space
                     001C   153 LS      .equ     0x1C             ; String too long
                     001E   154 ST      .equ     0x1E             ; String formula too complex
                     0020   155 CN      .equ     0x20             ; Can't CONTinue
                     0022   156 UF      .equ     0x22             ; UnDEFined FN function
                     0024   157 MO      .equ     0x24             ; Missing operand
                            158 
q                           159         ORG     0x0E000
                            160 
   0000 C3 03 00      [ 9]  161 START:  JP      STARTB          ; Jump for restart jump
   0003 F3            [ 3]  162 STARTB: DI                      ; No interrupts
a  0004               [ 3]  163         LD      IX,0            ; Flag cold start
   0004 C3 0E 00      [ 9]  164         JP      CSTART          ; Jump to initialise
                            165 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 4.
Hexadecimal [16-Bits]



   0007 60 06               166         .dw      DEINT           ; Get integer -32768 to 32767
   0009 9F 0C               167         .dw      ABPASS          ; Return integer in AB
                            168 
   000B C3 79 04      [ 9]  169         JP      LDNMI1          ; << NO REFERENCE TO HERE >>
                            170 
a  000E               [ 9]  171 CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
   000E F9            [ 4]  172         LD      SP,HL           ; Set up a temporary stack
   000F C3 8C 17      [ 9]  173         JP      INITST          ; Go to initialise
                            174 
a  0012               [ 9]  175 INIT:   LD      DE,INITAB       ; Initialise workspace
a  0012               [ 9]  176         LD      B,INITBE-INITAB+3; Bytes to copy
a  0012               [ 9]  177         LD      HL,WRKSPC       ; Into workspace RAM
   0012 1A            [ 6]  178 COPY:   LD      A,(DE)          ; Get source
   0013 77            [ 7]  179         LD      (HL),A          ; To destination
   0014 23            [ 4]  180         INC     HL              ; Next destination
   0015 13            [ 4]  181         INC     DE              ; Next source
   0016 05            [ 4]  182         DEC     B               ; Count bytes
   0017 C2 12 00      [ 9]  183         JP      NZ,COPY         ; More to move
   001A F9            [ 4]  184         LD      SP,HL           ; Temporary stack
   001B CD 8F 02      [16]  185         CALL    CLREG           ; Clear registers and stack
   001E CD 07 08      [16]  186         CALL    PRNTCR          ; Output CRLF
   0021 32 AA 10      [13]  187         LD      (BUFFER+72+1),A ; Mark end of buffer
   0024 32 F9 10      [13]  188         LD      (PROGST),A      ; Initialise program area
a  0027               [13]  189 MSIZE:  LD      HL,MEMMSG       ; Point to message
   0027 CD 92 0D      [16]  190         CALL    PRS             ; Output "Memory size"
   002A CD A9 02      [16]  191         CALL    PROMPT          ; Get input with "?"
   002D CD 4B 05      [16]  192         CALL    GET0xCR          ; Get next character
   0030 B7            [ 4]  193         OR      A               ; Set flags
   0031 C2 46 00      [ 9]  194         JP      NZ,TSTMEM       ; If number - Test if RAM there
a  0034               [ 9]  195         LD      HL,STLOOK       ; Point to start of RAM
   0034 23            [ 4]  196 MLOOP:  INC     HL              ; Next byte
   0035 7C            [ 4]  197         LD      A,H             ; Above address FFFF ?
   0036 B5            [ 4]  198         OR      L
   0037 CA 56 00      [ 9]  199         JP      Z,SETTOP        ; Yes - 64K RAM
   003A 7E            [ 6]  200         LD      A,(HL)          ; Get contents
   003B 47            [ 4]  201         LD      B,A             ; Save it
   003C 2F            [ 3]  202         CPL                     ; Flip all bits
   003D 77            [ 7]  203         LD      (HL),A          ; Put it back
   003E BE            [ 6]  204         CP      (HL)            ; RAM there if same
   003F 70            [ 7]  205         LD      (HL),B          ; Restore old contents
   0040 CA 34 00      [ 9]  206         JP      Z,MLOOP         ; If RAM - test next byte
   0043 C3 56 00      [ 9]  207         JP      SETTOP          ; Top of RAM found
                            208 
   0046 CD 70 06      [16]  209 TSTMEM: CALL    ATOH            ; Get high memory into DE
   0049 B7            [ 4]  210         OR      A               ; Set flags on last byte
   004A C2 86 01      [ 9]  211         JP      NZ,SNERR        ; ?SN Error if bad character
   004D EB            [ 3]  212         EX      DE,HL           ; Address into HL
   004E 2B            [ 4]  213         DEC     HL              ; Back one byte
aq 004F               [ 4]  214         LD      A,11011001B     ; Test byte
   004F 46            [ 6]  215         LD      B,(HL)          ; Get old contents
   0050 77            [ 7]  216         LD      (HL),A          ; Load test byte
   0051 BE            [ 6]  217         CP      (HL)            ; RAM there if same
   0052 70            [ 7]  218         LD      (HL),B          ; Restore old contents
   0053 C2 27 00      [ 9]  219         JP      NZ,MSIZE        ; Ask again if no RAM
                            220 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 5.
Hexadecimal [16-Bits]



   0056 2B            [ 4]  221 SETTOP: DEC     HL              ; Back one byte
a  0057               [ 4]  222         LD      DE,STLOOK-1     ; See if enough RAM
   0057 CD D7 03      [16]  223         CALL    CP0xDEL          ; Compare DE with HL
   005A DA 27 00      [ 9]  224         JP      C,MSIZE         ; Ask again if not enough RAM
   005D 00            [ 3]  225         NOP
   005E 00            [ 3]  226         NOP
   005F 00            [ 3]  227         NOP
   0060 00            [ 3]  228         NOP
   0061 00            [ 3]  229         NOP
   0062 00            [ 3]  230         NOP
   0063 00            [ 3]  231         NOP
   0064 00            [ 3]  232         NOP
   0065 00            [ 3]  233         NOP
a  0066               [ 3]  234         LD      DE,0-50         ; 50 Bytes string space
   0066 22 AF 10      [16]  235         LD      (LSTRAM),HL     ; Save last available RAM
   0069 19            [ 7]  236         ADD     HL,DE           ; Allocate string space
   006A 22 5A 10      [16]  237         LD      (STRSPC),HL     ; Save string space
   006D CD 6A 02      [16]  238         CALL    CLRPTR          ; Clear program area
   0070 2A 5A 10      [15]  239         LD      HL,(STRSPC)     ; Get end of memory
a  0073               [15]  240         LD      DE,0-17         ; Offset for free bytes
   0073 19            [ 7]  241         ADD     HL,DE           ; Adjust HL
a  0074               [ 7]  242         LD      DE,PROGST       ; Start of program text
   0074 7D            [ 4]  243         LD      A,L             ; Get LSB
   0075 93            [ 4]  244         SUB     E               ; Adjust it
   0076 6F            [ 4]  245         LD      L,A             ; Re-save
   0077 7C            [ 4]  246         LD      A,H             ; Get MSB
   0078 9A            [ 4]  247         SBC     A,D             ; Adjust it
   0079 67            [ 4]  248         LD      H,A             ; Re-save
   007A E5            [11]  249         PUSH    HL              ; Save bytes free
a  007B               [11]  250         LD      HL,SIGNON       ; Sign-on message
   007B CD 92 0D      [16]  251         CALL    PRS             ; Output string
   007E E1            [ 9]  252         POP     HL              ; Get bytes free back
   007F CD FA 13      [16]  253         CALL    PRNTHL          ; Output amount of free memory
a  0082               [16]  254         LD      HL,BFREE        ; " Bytes free" message
   0082 CD 92 0D      [16]  255         CALL    PRS             ; Output string
                            256 
a  0085               [16]  257 WARMST: LD      SP,STACK        ; Temporary stack
   0085 CD 8F 02      [16]  258 BRKRET: CALL    CLREG           ; Clear registers and stack
   0088 C3 B1 01      [ 9]  259         JP      PRNTOK          ; Go to get command line
                            260 
q  008B                     261 BFREE:  DB      " Bytes free",CR,0,0
                            262 
q  008B                     263 SIGNON: DB      "NASCOM ROM BASIC Ver 4.7   ",CR
q                           264         DB      "Copyright (C) 1978 by Microsoft",CR,0,0
                            265 
q  008B                     266 MEMMSG: DB      "Memory size",0
                            267 
                            268 ; FUNCTION ADDRESS TABLE
                            269 
   008B B0 12               270 FNCTAB: .dw      SGN
   008D 4E 13               271         .dw      INT
   008F BA 12               272         .dw      ABS
   0091 03 10               273         .dw      USR
   0093 80 0C               274         .dw      FRE
   0095 89 0F               275         .dw      INP
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 6.
Hexadecimal [16-Bits]



   0097 A4 0C               276         .dw      POS
   0099 A4 14               277         .dw      SQR
   009B 44 15               278         .dw      RND
   009D 9A 11               279         .dw      LOG
   009F ED 14               280         .dw      EXP
   00A1 89 15               281         .dw      COS
   00A3 8C 15               282         .dw      SIN
   00A5 C1 15               283         .dw      TAN
   00A7 D6 15               284         .dw      ATN
   00A9 AC 10               285         .dw      PEEK
   00AB B1 16               286         .dw      DEEK
   00AD 51 10               287         .dw      POINT
   00AF E3 0E               288         .dw      LEN
   00B1 2F 0D               289         .dw      STR
   00B3 65 0F               290         .dw      VAL
   00B5 EF 0E               291         .dw      ASC
q  00B7 0C 00               292         .dw      0xCR
   00B9 0B 0F               293         .dw      LEFT
   00BB 36 0F               294         .dw      RIGHT
   00BD 40 0F               295         .dw      MID
                            296 
                            297 ; RESERVED WORD LIST
                            298 
q  00BF                     299 WORDS:  DB      "E"+0x80,"ND"
q                           300         DB      "F"+0x80,"OR"
q                           301         DB      "N"+0x80,"EXT"
q                           302         DB      "D"+0x80,"ATA"
q                           303         DB      "I"+0x80,"NPUT"
q                           304         DB      "D"+0x80,"IM"
q                           305         DB      "R"+0x80,"EAD"
q                           306         DB      "L"+0x80,"ET"
q                           307         DB      "G"+0x80,"OTO"
q                           308         DB      "R"+0x80,"UN"
q                           309         DB      "I"+0x80,"F"
q                           310         DB      "R"+0x80,"ESTORE"
q                           311         DB      "G"+0x80,"OSUB"
q                           312         DB      "R"+0x80,"ETURN"
q                           313         DB      "R"+0x80,"EM"
q                           314         DB      "S"+0x80,"TOP"
q                           315         DB      "O"+0x80,"UT"
q                           316         DB      "O"+0x80,"N"
q                           317         DB      "N"+0x80,"ULL"
q                           318         DB      "W"+0x80,"AIT"
q                           319         DB      "D"+0x80,"EF"
q                           320         DB      "P"+0x80,"OKE"
q                           321         DB      "D"+0x80,"OKE"
q                           322         DB      "S"+0x80,"CREEN"
q                           323         DB      "L"+0x80,"INES"
q                           324         DB      "C"+0x80,"LS"
q                           325         DB      "W"+0x80,"IDTH"
q                           326         DB      "M"+0x80,"ONITOR"
q                           327         DB      "S"+0x80,"ET"
q                           328         DB      "R"+0x80,"ESET"
q                           329         DB      "P"+0x80,"RINT"
q                           330         DB      "C"+0x80,"ONT"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 7.
Hexadecimal [16-Bits]



q                           331         DB      "L"+0x80,"IST"
q                           332         DB      "C"+0x80,"LEAR"
q                           333         DB      "C"+0x80,"LOAD"
q                           334         DB      "C"+0x80,"SAVE"
q                           335         DB      "N"+0x80,"EW"
q                           336         DB      "T"+0x80,"AB("
q                           337         DB      "T"+0x80,"O"
q                           338         DB      "F"+0x80,"N"
q                           339         DB      "S"+0x80,"PC("
q                           340         DB      "T"+0x80,"HEN"
q                           341         DB      "N"+0x80,"OT"
q                           342         DB      "S"+0x80,"TEP"
                            343 
q                           344         DB      "+"+0x80
q                           345         DB      "-"+0x80
q                           346         DB      "*"+0x80
q                           347         DB      "/"+0x80
q                           348         DB      "^"+0x80
q                           349         DB      "A"+0x80,"ND"
q                           350         DB      "O"+0x80,"R"
q                           351         DB      ">"+0x80
q                           352         DB      "="+0x80
q                           353         DB      "<"+0x80
                            354 
q                           355         DB      "S"+0x80,"GN"
q                           356         DB      "I"+0x80,"NT"
q                           357         DB      "A"+0x80,"BS"
q                           358         DB      "U"+0x80,"SR"
q                           359         DB      "F"+0x80,"RE"
q                           360         DB      "I"+0x80,"NP"
q                           361         DB      "P"+0x80,"OS"
q                           362         DB      "S"+0x80,"QR"
q                           363         DB      "R"+0x80,"ND"
q                           364         DB      "L"+0x80,"OG"
q                           365         DB      "E"+0x80,"XP"
q                           366         DB      "C"+0x80,"OS"
q                           367         DB      "S"+0x80,"IN"
q                           368         DB      "T"+0x80,"AN"
q                           369         DB      "A"+0x80,"TN"
q                           370         DB      "P"+0x80,"EEK"
q                           371         DB      "D"+0x80,"EEK"
q                           372         DB      "P"+0x80,"OINT"
q                           373         DB      "L"+0x80,"EN"
q                           374         DB      "S"+0x80,"TR$"
q                           375         DB      "V"+0x80,"AL"
q                           376         DB      "A"+0x80,"SC"
q                           377         DB      "C"+0x80,"HR$"
q                           378         DB      "L"+0x80,"EFT$"
q                           379         DB      "R"+0x80,"IGHT$"
q                           380         DB      "M"+0x80,"ID$"
q                           381         DB      0x80             ; End of list marker
                            382 
                            383 ; KEYWORD ADDRESS TABLE
                            384 
   00BF 7C 05               385 WORDTB: .dw      PEND
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 8.
Hexadecimal [16-Bits]



   00C1 AD 04               386         .dw      FOR
   00C3 2C 09               387         .dw      NEXT
   00C5 1A 07               388         .dw      DATA
   00C7 64 08               389         .dw      INPUT
   00C9 00 0B               390         .dw      DIM
   00CB 8B 08               391         .dw      READ
   00CD 29 07               392         .dw      LET
   00CF E3 06               393         .dw      GOTO
   00D1 CD 06               394         .dw      RUN
   00D3 97 07               395         .dw      IF
   00D5 55 05               396         .dw      RESTOR
   00D7 D6 06               397         .dw      GOSUB
   00D9 FF 06               398         .dw      RETURN
   00DB 1A 07               399         .dw      REM
   00DD 7B 05               400         .dw      STOP
   00DF 95 0F               401         .dw      POUT
   00E1 7E 07               402         .dw      ON
   00E3 B3 05               403         .dw      NULL
   00E5 9B 0F               404         .dw      WAIT
   00E7 AC 0C               405         .dw      DEF
   00E9 B3 10               406         .dw      POKE
   00EB BC 16               407         .dw      DOKE
   00ED D6 16               408         .dw      SCREEN
   00EF A2 16               409         .dw      LINES
   00F1 84 16               410         .dw      CLS
   00F3 9A 16               411         .dw      WIDTH
   00F5 75 17               412         .dw      MONITR
   00F7 54 10               413         .dw      PSET
   00F9 57 10               414         .dw      RESET
   00FB B8 07               415         .dw      PRINT
   00FD A2 05               416         .dw      CONT
   00FF 23 04               417         .dw      LIST
   0101 8B 06               418         .dw      CLEAR
   0103 2E 10               419         .dw      CLOAD
   0105 01 10               420         .dw      CSAVE
   0107 69 02               421         .dw      NEW
                            422 
                            423 ; RESERVED WORD TOKEN VALUES
                            424 
                     0080   425 ZEND    .equ     0x080            ; END
                     0081   426 ZFOR    .equ     0x081            ; FOR
                     0083   427 ZDATA   .equ     0x083            ; DATA
                     0088   428 ZGOTO   .equ     0x088            ; GOTO
                     008C   429 ZGOSUB  .equ     0x08C            ; GOSUB
                     008E   430 ZREM    .equ     0x08E            ; REM
                     009E   431 ZPRINT  .equ     0x09E            ; PRINT
                     00A4   432 ZNEW    .equ     0x0A4            ; NEW
                            433 
                     00A5   434 ZTAB    .equ     0x0A5            ; TAB
                     00A6   435 ZTO     .equ     0x0A6            ; TO
                     00A7   436 ZFN     .equ     0x0A7            ; FN
                     00A8   437 ZSPC    .equ     0x0A8            ; SPC
                     00A9   438 ZTHEN   .equ     0x0A9            ; THEN
                     00AA   439 ZNOT    .equ     0x0AA            ; NOT
                     00AB   440 ZSTEP   .equ     0x0AB            ; STEP
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 9.
Hexadecimal [16-Bits]



                            441 
                     00AC   442 ZPLUS   .equ     0x0AC            ; +
                     00AD   443 ZMINUS  .equ     0x0AD            ; -
                     00AE   444 ZTIMES  .equ     0x0AE            ; *
                     00AF   445 ZDIV    .equ     0x0AF            ; /
                     00B2   446 ZOR     .equ     0x0B2            ; OR
                     00B3   447 ZGTR    .equ     0x0B3            ; >
                     00B4   448 ZEQUAL  .equ     0x0B4            ; M
                     00B5   449 ZLTH    .equ     0x0B5            ; <
                     00B6   450 ZSGN    .equ     0x0B6            ; SGN
                     00C7   451 ZPOINT  .equ     0x0C7            ; POINT
                     00CD   452 ZLEFT   .equ     0x0CD            ; LEFT$
                            453 
                            454 ; ARITHMETIC PRECEDENCE TABLE
                            455 
q  0109                     456 PRITAB: DB      0x79             ; Precedence value
   0109 E6 13               457         .dw      PADD            ; FPREG = <last> + FPREG
                            458 
q                           459         DB      0x79             ; Precedence value
   010B CC 10               460         .dw      PSUB            ; FPREG = <last> - FPREG
                            461 
q                           462         DB      0x7C             ; Precedence value
   010D BD 11               463         .dw      MULT            ; PPREG = <last> * FPREG
                            464 
q                           465         DB      0x7C             ; Precedence value
   010F 08 12               466         .dw      DIV             ; FPREG = <last> / FPREG
                            467 
q                           468         DB      0x7F             ; Precedence value
   0111 AA 14               469         .dw      POWER           ; FPREG = <last> ^ FPREG
                            470 
q                           471         DB      0x50             ; Precedence value
   0113 6B 0A               472         .dw      PAND            ; FPREG = <last> AND FPREG
                            473 
q                           474         DB      0x46             ; Precedence value
   0115 6B 0A               475         .dw      POR             ; FPREG = <last> OR FPREG
                            476 
                            477 ; BASIC ERROR CODE LIST
                            478 
q  0117                     479 ERRORS: DB      "NF"            ; NEXT without FOR
q                           480         DB      "SN"            ; Syntax error
q                           481         DB      "RG"            ; RETURN without GOSUB
q                           482         DB      "OD"            ; Out of DATA
q                           483         DB      "FC"            ; Illegal function call
q                           484         DB      "OV"            ; Overflow error
q                           485         DB      "OM"            ; Out of memory
q                           486         DB      "UL"            ; Undefined line
q                           487         DB      "BS"            ; Bad subscript
q                           488         DB      "DD"            ; Re-DIMensioned array
q                           489         DB      "/0"            ; Division by zero
q                           490         DB      "ID"            ; Illegal direct
q                           491         DB      "TM"            ; Type mis-match
q                           492         DB      "OS"            ; Out of string space
q                           493         DB      "LS"            ; String too long
q                           494         DB      "ST"            ; String formula too complex
q                           495         DB      "CN"            ; Can't CONTinue
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 10.
Hexadecimal [16-Bits]



q                           496         DB      "UF"            ; Undefined FN function
q                           497         DB      "MO"            ; Missing operand
                            498 
                            499 ; INITIALISATION TABLE
                            500 
   0117 C3 85 00      [ 9]  501 INITAB: JP      WARMST          ; Warm start jump
   011A C3 6D 06      [ 9]  502         JP      FCERR           ; "USR (X)" jump (Set to Error)
                            503 
   011D D3 00         [10]  504         OUT     (0),A           ; "OUT p,n" skeleton
   011F C9            [ 9]  505         RET
                            506 
a  0120               [ 9]  507         SUB     0               ; Division support routine
   0120 6F            [ 4]  508         LD      L,A
   0121 7C            [ 4]  509         LD      A,H
a  0122               [ 4]  510         SBC     A,0
   0122 67            [ 4]  511         LD      H,A
   0123 78            [ 4]  512         LD      A,B
a  0124               [ 4]  513         SBC     A,0
   0124 47            [ 4]  514         LD      B,A
a  0125               [ 4]  515         LD      A,0
   0125 C9            [ 9]  516         RET
                            517 
q                           518         DB      0,0,0                   ; Random number seed
                            519                                         ; Table used by RND
q                           520         DB      0x035,04AH,0CAH,099H     ;-2.65145E+07
q                           521         DB      0x039,01CH,076H,098H     ; 1.61291E+07
q                           522         DB      0x022,095H,0B3H,098H     ;-1.17691E+07
q                           523         DB      0x00A,0DDH,047H,098H     ; 1.30983E+07
q                           524         DB      0x053,0D1H,099H,099H     ;-2-01612E+07
q                           525         DB      0x00A,01AH,09FH,098H     ;-1.04269E+07
q                           526         DB      0x065,0BCH,0CDH,098H     ;-1.34831E+07
q                           527         DB      0x0D6,077H,03EH,098H     ; 1.24825E+07
q                           528         DB      0x052,0C7H,04FH,080H     ; Last random number
                            529 
   0126 DB 00         [ 9]  530         IN      A,(0)           ; INP (x) skeleton
   0128 C9            [ 9]  531         RET
                            532 
q                           533         DB      1               ; POS (x) number (1)
q                           534         DB      47              ; Terminal width (47)
q                           535         DB      28              ; Width for commas (3 columns)
q                           536         DB      0               ; No nulls after input bytes
q                           537         DB      0               ; Output enabled (^O off)
                            538 
   0129 05 00               539         .dw      5               ; Initial lines counter
   012B 05 00               540         .dw      5               ; Initial lines number
   012D 00 00               541         .dw      0               ; Array load/save check sum
                            542 
q                           543         DB      0               ; Break not by NMI
q                           544         DB      0               ; Break flag
                            545 
   012F C3 7A 03      [ 9]  546         JP      TTYLIN          ; Input reflection (set to TTY)
   0132 C3 21 18      [ 9]  547         JP      POINTB          ; POINT reflection unused
   0135 C3 F4 17      [ 9]  548         JP      SETB            ; SET reflection
   0138 C3 07 18      [ 9]  549         JP      RESETB          ; RESET reflection
                            550 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 11.
Hexadecimal [16-Bits]



   013B 5D 11               551         .dw      STLOOK          ; Temp string space
   013D FE FF               552         .dw      -2              ; Current line number (cold)
   013F FA 10               553         .dw      PROGST+1        ; Start of program text
   0141                     554 INITBE:                         ; END OF INITIALISATION TABLE
                            555 
q  0141                     556 ERRMSG: DB      " Error",0
q  0141                     557 INMSG:  DB      " in ",0
u                    FFFFFFFF   558 ZERBYT  .equ     $-1             ; A zero byte
q  0141                     559 OKMSG:  DB      "Ok",CR,0,0
q  0141                     560 BRKMSG: DB      "Break",0
                            561 
a  0141               [ 9]  562 BAKSTK: LD      HL,4            ; Look for "FOR" block with
   0141 39            [ 7]  563         ADD     HL,SP           ; same index as specified
   0142 7E            [ 6]  564 LOKFOR: LD      A,(HL)          ; Get block ID
   0143 23            [ 4]  565         INC     HL              ; Point to index address
a  0144               [ 4]  566         CP      ZFOR            ; Is it a "FOR" token
   0144 C0            [10]  567         RET     NZ              ; No - exit
   0145 4E            [ 6]  568         LD      C,(HL)          ; BC = Address of "FOR" index
   0146 23            [ 4]  569         INC     HL
   0147 46            [ 6]  570         LD      B,(HL)
   0148 23            [ 4]  571         INC     HL              ; Point to sign of STEP
   0149 E5            [11]  572         PUSH    HL              ; Save pointer to sign
   014A 69            [ 4]  573         LD      L,C             ; HL = address of "FOR" index
   014B 60            [ 4]  574         LD      H,B
   014C 7A            [ 4]  575         LD      A,D             ; See if an index was specified
   014D B3            [ 4]  576         OR      E               ; DE = 0 if no index specified
   014E EB            [ 3]  577         EX      DE,HL           ; Specified index into HL
   014F CA 56 01      [ 9]  578         JP      Z,INDFND        ; Skip if no index given
   0152 EB            [ 3]  579         EX      DE,HL           ; Index back into DE
   0153 CD D7 03      [16]  580         CALL    CP0xDEL          ; Compare index with one given
a  0156               [16]  581 INDFND: LD      BC,16-3         ; Offset to next block
   0156 E1            [ 9]  582         POP     HL              ; Restore pointer to sign
   0157 C8            [10]  583         RET     Z               ; Return if block found
   0158 09            [ 7]  584         ADD     HL,BC           ; Point to next block
   0159 C3 42 01      [ 9]  585         JP      LOKFOR          ; Keep on looking
                            586 
   015C CD 72 01      [16]  587 MOVUP:  CALL    ENFMEM          ; See if enough memory
   015F C5            [11]  588 MOVSTR: PUSH    BC              ; Save end of source
   0160 E3            [16]  589         EX      (SP),HL         ; Swap source and dest" end
   0161 C1            [ 9]  590         POP     BC              ; Get end of destination
   0162 CD D7 03      [16]  591 MOVLP:  CALL    CP0xDEL          ; See if list moved
   0165 7E            [ 6]  592         LD      A,(HL)          ; Get byte
   0166 02            [ 7]  593         LD      (BC),A          ; Move it
   0167 C8            [10]  594         RET     Z               ; Exit if all done
   0168 0B            [ 4]  595         DEC     BC              ; Next byte to move to
   0169 2B            [ 4]  596         DEC     HL              ; Next byte to move
   016A C3 62 01      [ 9]  597         JP      MOVLP           ; Loop until all bytes moved
                            598 
q                           599 0xCKSTK: PUSH    HL              ; Save code string address
   016D 2A DA 10      [15]  600         LD      HL,(ARREND)     ; Lowest free memory
a  0170               [15]  601         LD      B,0             ; BC = Number of levels to test
   0170 09            [ 7]  602         ADD     HL,BC           ; 2 Bytes for each level
   0171 09            [ 7]  603         ADD     HL,BC
q                           604         DB      0x3E             ; Skip "PUSH HL"
   0172 E5            [11]  605 ENFMEM: PUSH    HL              ; Save code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 12.
Hexadecimal [16-Bits]



ua 0173               [11]  606         LD      A,LOW -48       ; 48 Bytes minimum RAM
   0173 95            [ 4]  607         SUB     L
   0174 6F            [ 4]  608         LD      L,A
ua 0175               [ 4]  609         LD      A,HIGH -48      ; 48 Bytes minimum RAM
   0175 9C            [ 4]  610         SBC     A,H
   0176 DA 7D 01      [ 9]  611         JP      C,OMERR         ; Not enough - ?OM Error
   0179 67            [ 4]  612         LD      H,A
   017A 39            [ 7]  613         ADD     HL,SP           ; Test if stack is overflowed
   017B E1            [ 9]  614         POP     HL              ; Restore code string address
   017C D8            [10]  615         RET     C               ; Return if enough mmory
a  017D               [10]  616 OMERR:  LD      E,OM            ; ?OM Error
   017D C3 86 01      [ 9]  617         JP      ERROR
                            618 
   0180 2A C9 10      [15]  619 DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
   0183 22 5C 10      [16]  620         LD      (LINEAT),HL     ; Save as current line
a  0186               [16]  621 SNERR:  LD      E,SN            ; ?SN Error
q                           622         DB      0x01             ; Skip "LD E,DZ"
a  0186               [16]  623 DZERR:  LD      E,DZ            ; ?/0 Error
q                           624         DB      0x01             ; Skip "LD E,NF"
a  0186               [16]  625 NFERR:  LD      E,NF            ; ?NF Error
q                           626         DB      0x01             ; Skip "LD E,DD"
a  0186               [16]  627 DDERR:  LD      E,DD            ; ?DD Error
q                           628         DB      0x01             ; Skip "LD E,UF"
a  0186               [16]  629 UFERR:  LD      E,UF            ; ?UF Error
q                           630         DB      0x01             ; Skip "LD E,OV
a  0186               [16]  631 OVERR:  LD      E,OV            ; ?OV Error
q                           632         DB      0x01             ; Skip "LD E,TM"
a  0186               [16]  633 TMERR:  LD      E,TM            ; ?TM Error
                            634 
   0186 CD 8F 02      [16]  635 ERROR:  CALL    CLREG           ; Clear registers and stack
   0189 32 45 10      [13]  636         LD      (CTLOFG),A      ; Enable output (A is 0)
   018C CD FF 07      [16]  637         CALL    STTLIN          ; Start new line
a  018F               [16]  638         LD      HL,ERRORS       ; Point to error codes
   018F 57            [ 4]  639         LD      D,A             ; D = 0 (A is 0)
a  0190               [ 4]  640         LD      A,"?"
   0190 CD E7 03      [16]  641         CALL    OUTC            ; Output "?"
   0193 19            [ 7]  642         ADD     HL,DE           ; Offset to correct error code
   0194 7E            [ 6]  643         LD      A,(HL)          ; First character
   0195 CD E7 03      [16]  644         CALL    OUTC            ; Output it
   0198 CD 4B 05      [16]  645         CALL    GET0xCR          ; Get next character
   019B CD E7 03      [16]  646         CALL    OUTC            ; Output it
a  019E               [16]  647         LD      HL,ERRMSG       ; "Error" message
   019E CD 92 0D      [16]  648 ERRIN:  CALL    PRS             ; Output message
   01A1 2A 5C 10      [15]  649         LD      HL,(LINEAT)     ; Get line of error
a  01A4               [15]  650         LD      DE,-2           ; Cold start error if -2
   01A4 CD D7 03      [16]  651         CALL    CP0xDEL          ; See if cold start error
   01A7 CA 0E 00      [ 9]  652         JP      Z,CSTART        ; Cold start error - Restart
   01AA 7C            [ 4]  653         LD      A,H             ; Was it a direct error?
   01AB A5            [ 4]  654         AND     L               ; Line = -1 if direct error
   01AC 3C            [ 4]  655         INC     A
   01AD C4 F5 13      [16]  656         CALL    NZ,LINEIN       ; No - output line of error
q                           657         DB      0x3E             ; Skip "POP BC"
   01B0 C1            [ 9]  658 POPNOK: POP     BC              ; Drop address in input buffer
                            659 
   01B1 AF            [ 4]  660 PRNTOK: XOR     A               ; Output "Ok" and get command
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 13.
Hexadecimal [16-Bits]



   01B2 32 45 10      [13]  661         LD      (CTLOFG),A      ; Enable output
   01B5 CD FF 07      [16]  662         CALL    STTLIN          ; Start new line
a  01B8               [16]  663         LD      HL,OKMSG        ; "Ok" message
   01B8 CD 92 0D      [16]  664         CALL    PRS             ; Output "Ok"
a  01BB               [16]  665 GETCMD: LD      HL,-1           ; Flag direct mode
   01BB 22 5C 10      [16]  666         LD      (LINEAT),HL     ; Save as current line
   01BE CD 67 03      [16]  667         CALL    GETLIN          ; Get an input line
   01C1 DA BB 01      [ 9]  668         JP      C,GETCMD        ; Get line again if break
   01C4 CD 4B 05      [16]  669         CALL    GET0xCR          ; Get first character
   01C7 3C            [ 4]  670         INC     A               ; Test if end of line
   01C8 3D            [ 4]  671         DEC     A               ; Without affecting Carry
   01C9 CA BB 01      [ 9]  672         JP      Z,GETCMD        ; Nothing entered - Get another
   01CC F5            [11]  673         PUSH    AF              ; Save Carry status
   01CD CD 70 06      [16]  674         CALL    ATOH            ; Get line number into DE
   01D0 D5            [11]  675         PUSH    DE              ; Save line number
   01D1 CD B2 02      [16]  676         CALL    CRUN0xC          ; Tokenise rest of line
   01D4 47            [ 4]  677         LD      B,A             ; Length of tokenised line
   01D5 D1            [ 9]  678         POP     DE              ; Restore line number
   01D6 F1            [ 9]  679         POP     AF              ; Restore Carry
   01D7 D2 37 05      [ 9]  680         JP      NC,EXCUTE       ; No line number - Direct mode
   01DA D5            [11]  681         PUSH    DE              ; Save line number
   01DB C5            [11]  682         PUSH    BC              ; Save length of tokenised line
   01DC AF            [ 4]  683         XOR     A
   01DD 32 CC 10      [13]  684         LD      (LSTBIN),A      ; Clear last byte input
   01E0 CD 4B 05      [16]  685         CALL    GET0xCR          ; Get next character
   01E3 B7            [ 4]  686         OR      A               ; Set flags
   01E4 F5            [11]  687         PUSH    AF              ; And save them
   01E5 CD 49 02      [16]  688         CALL    SR0xCLN          ; Search for line number in DE
   01E8 DA F1 01      [ 9]  689         JP      C,LINFND        ; Jump if line found
   01EB F1            [ 9]  690         POP     AF              ; Get status
   01EC F5            [11]  691         PUSH    AF              ; And re-save
   01ED CA FC 06      [ 9]  692         JP      Z,ULERR         ; Nothing after number - Error
   01F0 B7            [ 4]  693         OR      A               ; Clear Carry
   01F1 C5            [11]  694 LINFND: PUSH    BC              ; Save address of line in prog
   01F2 D2 08 02      [ 9]  695         JP      NC,INEWLN       ; Line not found - Insert new
   01F5 EB            [ 3]  696         EX      DE,HL           ; Next line address in DE
   01F6 2A D6 10      [15]  697         LD      HL,(PROGND)     ; End of program
   01F9 1A            [ 6]  698 SFTPRG: LD      A,(DE)          ; Shift rest of program down
   01FA 02            [ 7]  699         LD      (BC),A
   01FB 03            [ 4]  700         INC     BC              ; Next destination
   01FC 13            [ 4]  701         INC     DE              ; Next source
   01FD CD D7 03      [16]  702         CALL    CP0xDEL          ; All done?
   0200 C2 F9 01      [ 9]  703         JP      NZ,SFTPRG       ; More to do
   0203 60            [ 4]  704         LD      H,B             ; HL - New end of program
   0204 69            [ 4]  705         LD      L,C
   0205 22 D6 10      [16]  706         LD      (PROGND),HL     ; Update end of program
                            707 
   0208 D1            [ 9]  708 INEWLN: POP     DE              ; Get address of line,
   0209 F1            [ 9]  709         POP     AF              ; Get status
   020A CA 2C 02      [ 9]  710         JP      Z,SETPTR        ; No text - Set up pointers
   020D 2A D6 10      [15]  711         LD      HL,(PROGND)     ; Get end of program
   0210 E3            [16]  712         EX      (SP),HL         ; Get length of input line
   0211 C1            [ 9]  713         POP     BC              ; End of program to BC
   0212 09            [ 7]  714         ADD     HL,BC           ; Find new end
   0213 E5            [11]  715         PUSH    HL              ; Save new end
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 14.
Hexadecimal [16-Bits]



   0214 CD 5C 01      [16]  716         CALL    MOVUP           ; Make space for line
   0217 E1            [ 9]  717         POP     HL              ; Restore new end
   0218 22 D6 10      [16]  718         LD      (PROGND),HL     ; Update end of program pointer
   021B EB            [ 3]  719         EX      DE,HL           ; Get line to move up in HL
   021C 74            [ 7]  720         LD      (HL),H          ; Save MSB
   021D D1            [ 9]  721         POP     DE              ; Get new line number
   021E 23            [ 4]  722         INC     HL              ; Skip pointer
   021F 23            [ 4]  723         INC     HL
   0220 73            [ 7]  724         LD      (HL),E          ; Save LSB of line number
   0221 23            [ 4]  725         INC     HL
   0222 72            [ 7]  726         LD      (HL),D          ; Save MSB of line number
   0223 23            [ 4]  727         INC     HL              ; To first byte in line
a  0224               [ 4]  728         LD      DE,BUFFER       ; Copy buffer to program
   0224 1A            [ 6]  729 MOVBUF: LD      A,(DE)          ; Get source
   0225 77            [ 7]  730         LD      (HL),A          ; Save destinations
   0226 23            [ 4]  731         INC     HL              ; Next source
   0227 13            [ 4]  732         INC     DE              ; Next destination
   0228 B7            [ 4]  733         OR      A               ; Done?
   0229 C2 24 02      [ 9]  734         JP      NZ,MOVBUF       ; No - Repeat
   022C CD 75 02      [16]  735 SETPTR: CALL    RUNFST          ; Set line pointers
   022F 23            [ 4]  736         INC     HL              ; To LSB of pointer
   0230 EB            [ 3]  737         EX      DE,HL           ; Address to DE
   0231 62            [ 4]  738 PTRLP:  LD      H,D             ; Address to HL
   0232 6B            [ 4]  739         LD      L,E
   0233 7E            [ 6]  740         LD      A,(HL)          ; Get LSB of pointer
   0234 23            [ 4]  741         INC     HL              ; To MSB of pointer
   0235 B6            [ 6]  742         OR      (HL)            ; Compare with MSB pointer
   0236 CA BB 01      [ 9]  743         JP      Z,GETCMD        ; Get command line if end
   0239 23            [ 4]  744         INC     HL              ; To LSB of line number
   023A 23            [ 4]  745         INC     HL              ; Skip line number
   023B 23            [ 4]  746         INC     HL              ; Point to first byte in line
   023C AF            [ 4]  747         XOR     A               ; Looking for 00 byte
   023D BE            [ 6]  748 FNDEND: CP      (HL)            ; Found end of line?
   023E 23            [ 4]  749         INC     HL              ; Move to next byte
   023F C2 3D 02      [ 9]  750         JP      NZ,FNDEND       ; No - Keep looking
   0242 EB            [ 3]  751         EX      DE,HL           ; Next line address to HL
   0243 73            [ 7]  752         LD      (HL),E          ; Save LSB of pointer
   0244 23            [ 4]  753         INC     HL
   0245 72            [ 7]  754         LD      (HL),D          ; Save MSB of pointer
   0246 C3 31 02      [ 9]  755         JP      PTRLP           ; Do next line
                            756 
   0249 2A 5E 10      [15]  757 SR0xCLN: LD      HL,(BASTXT)     ; Start of program text
   024C 44            [ 4]  758 SR0xCLP: LD      B,H             ; BC = Address to look at
   024D 4D            [ 4]  759         LD      C,L
   024E 7E            [ 6]  760         LD      A,(HL)          ; Get address of next line
   024F 23            [ 4]  761         INC     HL
   0250 B6            [ 6]  762         OR      (HL)            ; End of program found?
   0251 2B            [ 4]  763         DEC     HL
   0252 C8            [10]  764         RET     Z               ; Yes - Line not found
   0253 23            [ 4]  765         INC     HL
   0254 23            [ 4]  766         INC     HL
   0255 7E            [ 6]  767         LD      A,(HL)          ; Get LSB of line number
   0256 23            [ 4]  768         INC     HL
   0257 66            [ 6]  769         LD      H,(HL)          ; Get MSB of line number
   0258 6F            [ 4]  770         LD      L,A
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 15.
Hexadecimal [16-Bits]



   0259 CD D7 03      [16]  771         CALL    CP0xDEL          ; Compare with line in DE
   025C 60            [ 4]  772         LD      H,B             ; HL = Start of this line
   025D 69            [ 4]  773         LD      L,C
   025E 7E            [ 6]  774         LD      A,(HL)          ; Get LSB of next line address
   025F 23            [ 4]  775         INC     HL
   0260 66            [ 6]  776         LD      H,(HL)          ; Get MSB of next line address
   0261 6F            [ 4]  777         LD      L,A             ; Next line to HL
   0262 3F            [ 3]  778         CCF
   0263 C8            [10]  779         RET     Z               ; Lines found - Exit
   0264 3F            [ 3]  780         CCF
   0265 D0            [10]  781         RET     NC              ; Line not found,at line after
   0266 C3 4C 02      [ 9]  782         JP      SR0xCLP          ; Keep looking
                            783 
   0269 C0            [10]  784 NEW:    RET     NZ              ; Return if any more on line
   026A 2A 5E 10      [15]  785 CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
   026D AF            [ 4]  786         XOR     A               ; Set program area to empty
   026E 77            [ 7]  787         LD      (HL),A          ; Save LSB = 00
   026F 23            [ 4]  788         INC     HL
   0270 77            [ 7]  789         LD      (HL),A          ; Save MSB = 00
   0271 23            [ 4]  790         INC     HL
   0272 22 D6 10      [16]  791         LD      (PROGND),HL     ; Set program end
                            792 
   0275 2A 5E 10      [15]  793 RUNFST: LD      HL,(BASTXT)     ; Clear all variables
   0278 2B            [ 4]  794         DEC     HL
                            795 
   0279 22 CE 10      [16]  796 INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
   027C 2A AF 10      [15]  797         LD      HL,(LSTRAM)     ; Get end of RAM
   027F 22 C3 10      [16]  798         LD      (STRBOT),HL     ; Clear string space
   0282 AF            [ 4]  799         XOR     A
   0283 CD 55 05      [16]  800         CALL    RESTOR          ; Reset DATA pointers
   0286 2A D6 10      [15]  801         LD      HL,(PROGND)     ; Get end of program
   0289 22 D8 10      [16]  802         LD      (VAREND),HL     ; Clear variables
   028C 22 DA 10      [16]  803         LD      (ARREND),HL     ; Clear arrays
                            804 
   028F C1            [ 9]  805 CLREG:  POP     BC              ; Save return address
   0290 2A 5A 10      [15]  806         LD      HL,(STRSPC)     ; Get end of working RAN
   0293 F9            [ 4]  807         LD      SP,HL           ; Set stack
a  0294               [ 4]  808         LD      HL,TMSTPL       ; Temporary string pool
   0294 22 B1 10      [16]  809         LD      (TMSTPT),HL     ; Reset temporary string ptr
   0297 AF            [ 4]  810         XOR     A               ; A = 00
   0298 6F            [ 4]  811         LD      L,A             ; HL = 0000
   0299 67            [ 4]  812         LD      H,A
   029A 22 D4 10      [16]  813         LD      (CONTAD),HL     ; No CONTinue
   029D 32 CB 10      [13]  814         LD      (FORFLG),A      ; Clear FOR flag
   02A0 22 DE 10      [16]  815         LD      (FNRGNM),HL     ; Clear FN argument
   02A3 E5            [11]  816         PUSH    HL              ; HL = 0000
   02A4 C5            [11]  817         PUSH    BC              ; Put back return
   02A5 2A CE 10      [15]  818 DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
   02A8 C9            [ 9]  819         RET                     ; Return to execution driver
                            820 
a  02A9               [ 9]  821 PROMPT: LD      A,"?"           ; "?"
   02A9 CD E7 03      [16]  822         CALL    OUTC            ; Output character
a  02AC               [16]  823         LD      A," "           ; Space
   02AC CD E7 03      [16]  824         CALL    OUTC            ; Output character
   02AF C3 4E 10      [ 9]  825         JP      RINPUT          ; Get input line
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 16.
Hexadecimal [16-Bits]



                            826 
   02B2 AF            [ 4]  827 CRUN0xC: XOR     A               ; Tokenise line @ HL to BUFFER
   02B3 32 AE 10      [13]  828         LD      (DATFLG),A      ; Reset literal flag
a  02B6               [13]  829         LD      C,2+3           ; 2 byte number and 3 nulls
a  02B6               [13]  830         LD      DE,BUFFER       ; Start of input buffer
   02B6 7E            [ 6]  831 CRNCLP: LD      A,(HL)          ; Get byte
a  02B7               [ 6]  832         CP      " "             ; Is it a space?
   02B7 CA 13 03      [ 9]  833         JP      Z,MOVDIR        ; Yes - Copy direct
   02BA 47            [ 4]  834         LD      B,A             ; Save character
a  02BB               [ 4]  835         CP      '"'             ; Is it a quote?
   02BB CA 2D 03      [ 9]  836         JP      Z,CPYLIT        ; Yes - Copy literal string
   02BE B7            [ 4]  837         OR      A               ; Is it end of buffer?
   02BF CA 34 03      [ 9]  838         JP      Z,ENDBUF        ; Yes - End buffer
   02C2 3A AE 10      [12]  839         LD      A,(DATFLG)      ; Get data type
   02C5 B7            [ 4]  840         OR      A               ; Literal?
   02C6 7E            [ 6]  841         LD      A,(HL)          ; Get byte to copy
   02C7 C2 13 03      [ 9]  842         JP      NZ,MOVDIR       ; Literal - Copy direct
a  02CA               [ 9]  843         CP      "?"             ; Is it "?" short for PRINT
a  02CA               [ 9]  844         LD      A,ZPRINT        ; "PRINT" token
   02CA CA 13 03      [ 9]  845         JP      Z,MOVDIR        ; Yes - replace it
   02CD 7E            [ 6]  846         LD      A,(HL)          ; Get byte again
a  02CE               [ 6]  847         CP      "0"             ; Is it less than "0"
   02CE DA D4 02      [ 9]  848         JP      C,FNDWRD        ; Yes - Look for reserved words
a  02D1               [ 9]  849         CP      ";"+1           ; Is it "0123456789:;" ?
   02D1 DA 13 03      [ 9]  850         JP      C,MOVDIR        ; Yes - copy it direct
   02D4 D5            [11]  851 FNDWRD: PUSH    DE              ; Look for reserved words
a  02D5               [11]  852         LD      DE,WORDS-1      ; Point to table
   02D5 C5            [11]  853         PUSH    BC              ; Save count
a  02D6               [11]  854         LD      BC,RETNAD       ; Where to return to
   02D6 C5            [11]  855         PUSH    BC              ; Save return address
a  02D7               [11]  856         LD      B,ZEND-1        ; First token value -1
   02D7 7E            [ 6]  857         LD      A,(HL)          ; Get byte
a  02D8               [ 6]  858         CP      "a"             ; Less than "a" ?
   02D8 DA DF 02      [ 9]  859         JP      C,SEAR0xC        ; Yes - search for words
a  02DB               [ 9]  860         CP      "z"+1           ; Greater than "z" ?
   02DB D2 DF 02      [ 9]  861         JP      NC,SEAR0xC       ; Yes - search for words
q  02DE                     862         AND     01011111B       ; Force upper case
   02DE 77            [ 7]  863         LD      (HL),A          ; Replace byte
   02DF 4E            [ 6]  864 SEAR0xC: LD      C,(HL)          ; Search for a word
   02E0 EB            [ 3]  865         EX      DE,HL
   02E1 23            [ 4]  866 GETNXT: INC     HL              ; Get next reserved word
   02E2 B6            [ 6]  867         OR      (HL)            ; Start of word?
   02E3 F2 E1 02      [ 9]  868         JP      P,GETNXT        ; No - move on
   02E6 04            [ 4]  869         INC     B               ; Increment token value
   02E7 7E            [ 6]  870         LD      A, (HL)         ; Get byte from table
q  02E8                     871         AND     01111111B       ; Strip bit 7
   02E8 C8            [10]  872         RET     Z               ; Return if end of list
   02E9 B9            [ 4]  873         CP      C               ; Same character as in buffer?
   02EA C2 E1 02      [ 9]  874         JP      NZ,GETNXT       ; No - get next word
   02ED EB            [ 3]  875         EX      DE,HL
   02EE E5            [11]  876         PUSH    HL              ; Save start of word
                            877 
   02EF 13            [ 4]  878 NXTBYT: INC     DE              ; Look through rest of word
   02F0 1A            [ 6]  879         LD      A,(DE)          ; Get byte from table
   02F1 B7            [ 4]  880         OR      A               ; End of word ?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 17.
Hexadecimal [16-Bits]



   02F2 FA 0B 03      [ 9]  881         JP      M,MAT0xC         ; Yes - Match found
   02F5 4F            [ 4]  882         LD      C,A             ; Save it
   02F6 78            [ 4]  883         LD      A,B             ; Get token value
a  02F7               [ 4]  884         CP      ZGOTO           ; Is it "GOTO" token ?
   02F7 C2 FE 02      [ 9]  885         JP      NZ,NOSPC        ; No - Don't allow spaces
   02FA CD 4B 05      [16]  886         CALL    GET0xCR          ; Get next character
   02FD 2B            [ 4]  887         DEC     HL              ; Cancel increment from GET0xCR
   02FE 23            [ 4]  888 NOSPC:  INC     HL              ; Next byte
   02FF 7E            [ 6]  889         LD      A,(HL)          ; Get byte
a  0300               [ 6]  890         CP      "a"             ; Less than "a" ?
   0300 DA 03 03      [ 9]  891         JP      C,NO0xCNG        ; Yes - don't change
q  0303                     892         AND     01011111B       ; Make upper case
   0303 B9            [ 4]  893 NO0xCNG: CP      C               ; Same as in buffer ?
   0304 CA EF 02      [ 9]  894         JP      Z,NXTBYT        ; Yes - keep testing
   0307 E1            [ 9]  895         POP     HL              ; Get back start of word
   0308 C3 DF 02      [ 9]  896         JP      SEAR0xC          ; Look at next word
                            897 
   030B 48            [ 4]  898 MAT0xC:  LD      C,B             ; Word found - Save token value
   030C F1            [ 9]  899         POP     AF              ; Throw away return
   030D EB            [ 3]  900         EX      DE,HL
   030E C9            [ 9]  901         RET                     ; Return to "RETNAD"
   030F EB            [ 3]  902 RETNAD: EX      DE,HL           ; Get address in string
   0310 79            [ 4]  903         LD      A,C             ; Get token value
   0311 C1            [ 9]  904         POP     BC              ; Restore buffer length
   0312 D1            [ 9]  905         POP     DE              ; Get destination address
   0313 23            [ 4]  906 MOVDIR: INC     HL              ; Next source in buffer
   0314 12            [ 7]  907         LD      (DE),A          ; Put byte in buffer
   0315 13            [ 4]  908         INC     DE              ; Move up buffer
   0316 0C            [ 4]  909         INC     C               ; Increment length of buffer
a  0317               [ 4]  910         SUB     ":"             ; End of statement?
   0317 CA 1D 03      [ 9]  911         JP      Z,SETLIT        ; Jump if multi-statement line
a  031A               [ 9]  912         CP      ZDATA-0x3A       ; Is it DATA statement ?
   031A C2 20 03      [ 9]  913         JP      NZ,TSTREM       ; No - see if REM
   031D 32 AE 10      [13]  914 SETLIT: LD      (DATFLG),A      ; Set literal flag
a  0320               [13]  915 TSTREM: SUB     ZREM-0x3A        ; Is it REM?
   0320 C2 B6 02      [ 9]  916         JP      NZ,CRNCLP       ; No - Leave flag
   0323 47            [ 4]  917         LD      B,A             ; Copy rest of buffer
   0324 7E            [ 6]  918 NXT0xCR: LD      A,(HL)          ; Get byte
   0325 B7            [ 4]  919         OR      A               ; End of line ?
   0326 CA 34 03      [ 9]  920         JP      Z,ENDBUF        ; Yes - Terminate buffer
   0329 B8            [ 4]  921         CP      B               ; End of statement ?
   032A CA 13 03      [ 9]  922         JP      Z,MOVDIR        ; Yes - Get next one
   032D 23            [ 4]  923 CPYLIT: INC     HL              ; Move up source string
   032E 12            [ 7]  924         LD      (DE),A          ; Save in destination
   032F 0C            [ 4]  925         INC     C               ; Increment length
   0330 13            [ 4]  926         INC     DE              ; Move up destination
   0331 C3 24 03      [ 9]  927         JP      NXT0xCR          ; Repeat
                            928 
a  0334               [ 9]  929 ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
   0334 12            [ 7]  930         LD      (DE),A          ; Mark end of buffer (A = 00)
   0335 13            [ 4]  931         INC     DE
   0336 12            [ 7]  932         LD      (DE),A          ; A = 00
   0337 13            [ 4]  933         INC     DE
   0338 12            [ 7]  934         LD      (DE),A          ; A = 00
   0339 C9            [ 9]  935         RET
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 18.
Hexadecimal [16-Bits]



                            936 
   033A 3A 44 10      [12]  937 DODEL:  LD      A,(NULFLG)      ; Get null flag status
   033D B7            [ 4]  938         OR      A               ; Is it zero?
a  033E               [ 4]  939         LD      A,0             ; Zero A - Leave flags
   033E 32 44 10      [13]  940         LD      (NULFLG),A      ; Zero null flag
q  0341 C2 DE EC      [ 9]  941         JP      NZ,0xECDEL       ; Set - Echo it
   0344 05            [ 4]  942         DEC     B               ; Decrement length
   0345 CA 67 03      [ 9]  943         JP      Z,GETLIN        ; Get line again if empty
   0348 CD E7 03      [16]  944         CALL    OUTC            ; Output null character
q                           945         DB      0x3E             ; Skip "DEC B"
q                           946 0xECDEL: DEC     B               ; Count bytes in buffer
   034B 2B            [ 4]  947         DEC     HL              ; Back space buffer
   034C CA 5E 03      [ 9]  948         JP      Z,OTKLN         ; No buffer - Try again
   034F 7E            [ 6]  949         LD      A,(HL)          ; Get deleted byte
   0350 CD E7 03      [16]  950         CALL    OUTC            ; Echo it
   0353 C3 7E 03      [ 9]  951         JP      MORINP          ; Get more input
                            952 
   0356 05            [ 4]  953 DEL0xCR: DEC     B               ; Count bytes in buffer
   0357 2B            [ 4]  954         DEC     HL              ; Back space buffer
   0358 CD E7 03      [16]  955         CALL    OUTC            ; Output character in A
   035B C2 7E 03      [ 9]  956         JP      NZ,MORINP       ; Not end - Get more
   035E CD E7 03      [16]  957 OTKLN:  CALL    OUTC            ; Output character in A
   0361 CD 07 08      [16]  958 KILIN:  CALL    PRNTCR          ; Output CRLF
   0364 C3 7A 03      [ 9]  959         JP      TTYLIN          ; Get line again
                            960 
   0367 CD 44 17      [16]  961 GETLIN: CALL    MONTST          ; Is it NAS-SYS?
   036A CA 7A 03      [ 9]  962         JP      Z,TTYLIN        ; No - Character input
   036D 2A 75 0C      [15]  963         LD      HL,(CIN)        ; Point to NAS-SYS input table
   0370 7E            [ 6]  964         LD      A,(HL)          ; Get input mode
a  0371               [ 6]  965         CP      0x74             ; Is it "X" mode?
   0371 CA 7A 03      [ 9]  966         JP      Z,TTYLIN        ; Yes - Teletype line input
   0374 CD B0 17      [16]  967         CALL    INLINE          ; Get a line from NAS-SYS
   0377 C3 0A 08      [ 9]  968         JP      DONULL          ; POS(X)=0 and do nulls
                            969 
a  037A               [ 9]  970 TTYLIN: LD      HL,BUFFER       ; Get a line by character
a  037A               [ 9]  971         LD      B,1             ; Set buffer as empty
   037A AF            [ 4]  972         XOR     A
   037B 32 44 10      [13]  973         LD      (NULFLG),A      ; Clear null flag
   037E CD 16 04      [16]  974 MORINP: CALL    CLOTST          ; Get character and test ^O
   0381 4F            [ 4]  975         LD      C,A             ; Save character in C
a  0382               [ 4]  976         CP      DEL             ; Delete character?
   0382 CA 3A 03      [ 9]  977         JP      Z,DODEL         ; Yes - Process it
   0385 3A 44 10      [12]  978         LD      A,(NULFLG)      ; Get null flag
   0388 B7            [ 4]  979         OR      A               ; Test null flag status
   0389 CA 93 03      [ 9]  980         JP      Z,PROCES        ; Reset - Process character
a  038C               [ 9]  981         LD      A,0             ; Set a null
   038C CD E7 03      [16]  982         CALL    OUTC            ; Output null
   038F AF            [ 4]  983         XOR     A               ; Clear A
   0390 32 44 10      [13]  984         LD      (NULFLG),A      ; Reset null flag
   0393 79            [ 4]  985 PROCES: LD      A,C             ; Get character
a  0394               [ 4]  986         CP      CTRLG           ; Bell?
   0394 CA C0 03      [ 9]  987         JP      Z,PUTCTL        ; Yes - Save it
a  0397               [ 9]  988         CP      CTRLC           ; Is it control "C"?
   0397 CC 07 08      [16]  989         CALL    Z,PRNTCR        ; Yes - Output CRLF
   039A 37            [ 3]  990         SCF                     ; Flag break
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 19.
Hexadecimal [16-Bits]



   039B C8            [10]  991         RET     Z               ; Return if control "C"
a  039C               [10]  992         CP      CR              ; Is it enter?
   039C CA 07 08      [ 9]  993         JP      Z,ENDINP        ; Yes - Terminate input
a  039F               [ 9]  994         CP      CTRLU           ; Is it control "U"?
   039F CA 61 03      [ 9]  995         JP      Z,KILIN         ; Yes - Get another line
a  03A2               [ 9]  996         CP      "@"             ; Is it "kill line"?
   03A2 CA 5E 03      [ 9]  997         JP      Z,OTKLN         ; Yes - Kill line
a  03A5               [ 9]  998         CP      "_"             ; Is it delete?
   03A5 CA 56 03      [ 9]  999         JP      Z,DEL0xCR        ; Yes - Delete character
a  03A8               [ 9] 1000         CP      BKSP            ; Is it backspace?
   03A8 CA 56 03      [ 9] 1001         JP      Z,DEL0xCR        ; Yes - Delete character
a  03AB               [ 9] 1002         CP      CTRLR           ; Is it control "R"?
   03AB C2 BD 03      [ 9] 1003         JP      NZ,PUTBUF       ; No - Put in buffer
   03AE C5            [11] 1004         PUSH    BC              ; Save buffer length
   03AF D5            [11] 1005         PUSH    DE              ; Save DE
   03B0 E5            [11] 1006         PUSH    HL              ; Save buffer address
a  03B1               [11] 1007         LD      (HL),0          ; Mark end of buffer
   03B1 CD 7F 18      [16] 1008         CALL    OUTNCR          ; Output and do CRLF
a  03B4               [16] 1009         LD      HL,BUFFER       ; Point to buffer start
   03B4 CD 92 0D      [16] 1010         CALL    PRS             ; Output buffer
   03B7 E1            [ 9] 1011         POP     HL              ; Restore buffer address
   03B8 D1            [ 9] 1012         POP     DE              ; Restore DE
   03B9 C1            [ 9] 1013         POP     BC              ; Restore buffer length
   03BA C3 7E 03      [ 9] 1014         JP      MORINP          ; Get another character
                           1015 
a  03BD               [ 9] 1016 PUTBUF: CP      " "             ; Is it a control code?
   03BD DA 7E 03      [ 9] 1017         JP      C,MORINP        ; Yes - Ignore
   03C0 78            [ 4] 1018 PUTCTL: LD      A,B             ; Get number of bytes in buffer
a  03C1               [ 4] 1019         CP      72+1            ; Test for line overflow
a  03C1               [ 4] 1020         LD      A,CTRLG         ; Set a bell
   03C1 D2 D1 03      [ 9] 1021         JP      NC,OUTNBS       ; Ring bell if buffer full
   03C4 79            [ 4] 1022         LD      A,C             ; Get character
   03C5 71            [ 7] 1023         LD      (HL),C          ; Save in buffer
   03C6 32 CC 10      [13] 1024         LD      (LSTBIN),A      ; Save last input byte
   03C9 23            [ 4] 1025         INC     HL              ; Move up buffer
   03CA 04            [ 4] 1026         INC     B               ; Increment length
   03CB CD E7 03      [16] 1027 OUTIT:  CALL    OUTC            ; Output the character entered
   03CE C3 7E 03      [ 9] 1028         JP      MORINP          ; Get another character
                           1029 
   03D1 CD E7 03      [16] 1030 OUTNBS: CALL    OUTC            ; Output bell and back over it
a  03D4               [16] 1031         LD      A,BKSP          ; Set back space
   03D4 C3 CB 03      [ 9] 1032         JP      OUTIT           ; Output it and get more
                           1033 
   03D7 7C            [ 4] 1034 CP0xDEL: LD      A,H             ; Get H
   03D8 92            [ 4] 1035         SUB     D               ; Compare with D
   03D9 C0            [10] 1036         RET     NZ              ; Different - Exit
   03DA 7D            [ 4] 1037         LD      A,L             ; Get L
   03DB 93            [ 4] 1038         SUB     E               ; Compare with E
   03DC C9            [ 9] 1039         RET                     ; Return status
                           1040 
q                          1041 0xCKSYN: LD      A,(HL)          ; Check syntax of character
   03DD E3            [16] 1042         EX      (SP),HL         ; Address of test byte
   03DE BE            [ 6] 1043         CP      (HL)            ; Same as in code string?
   03DF 23            [ 4] 1044         INC     HL              ; Return address
   03E0 E3            [16] 1045         EX      (SP),HL         ; Put it back
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 20.
Hexadecimal [16-Bits]



   03E1 CA 4B 05      [ 9] 1046         JP      Z,GET0xCR        ; Yes - Get next character
   03E4 C3 86 01      [ 9] 1047         JP      SNERR           ; Different - ?SN Error
                           1048 
   03E7 F5            [11] 1049 OUTC:   PUSH    AF              ; Save character
   03E8 3A 45 10      [12] 1050         LD      A,(CTLOFG)      ; Get control "O" flag
   03EB B7            [ 4] 1051         OR      A               ; Is it set?
   03EC C2 C2 0D      [ 9] 1052         JP      NZ,POPAF        ; Yes - don't output
   03EF F1            [ 9] 1053         POP     AF              ; Restore character
   03F0 C5            [11] 1054         PUSH    BC              ; Save buffer length
   03F1 F5            [11] 1055         PUSH    AF              ; Save character
a  03F2               [11] 1056         CP      " "             ; Is it a control code?
   03F2 DA 09 04      [ 9] 1057         JP      C,DINPOS        ; Yes - Don't INC POS(X)
   03F5 3A 42 10      [12] 1058         LD      A,(LWIDTH)      ; Get line width
   03F8 47            [ 4] 1059         LD      B,A             ; To B
   03F9 3A AB 10      [12] 1060         LD      A,(CURPOS)      ; Get cursor position
   03FC 04            [ 4] 1061         INC     B               ; Width 255?
   03FD CA 05 04      [ 9] 1062         JP      Z,INCLEN        ; Yes - No width limit
   0400 05            [ 4] 1063         DEC     B               ; Restore width
   0401 B8            [ 4] 1064         CP      B               ; At end of line?
   0402 CC 07 08      [16] 1065         CALL    Z,PRNTCR        ; Yes - output CRLF
   0405 3C            [ 4] 1066 INCLEN: INC     A               ; Move on one character
   0406 32 AB 10      [13] 1067         LD      (CURPOS),A      ; Save new position
   0409 F1            [ 9] 1068 DINPOS: POP     AF              ; Restore character
   040A C1            [ 9] 1069         POP     BC              ; Restore buffer length
   040B F5            [11] 1070         PUSH    AF              ; << This sequence >>
   040C F1            [ 9] 1071         POP     AF              ; << is not needed >>
   040D F5            [11] 1072         PUSH    AF              ; Save character
   040E C5            [11] 1073         PUSH    BC              ; Save buffer length
   040F 4F            [ 4] 1074         LD      C,A             ; Character to C
   0410 CD FE 15      [16] 1075         CALL    CONMON          ; Send it
   0413 C1            [ 9] 1076         POP     BC              ; Restore buffer length
   0414 F1            [ 9] 1077         POP     AF              ; Restore character
   0415 C9            [ 9] 1078         RET
                           1079 
   0416 CD 20 16      [16] 1080 CLOTST: CALL    GETINP          ; Get input character
q  0419                    1081         AND     01111111B       ; Strip bit 7
a  0419               [16] 1082         CP      CTRLO           ; Is it control "O"?
   0419 C0            [10] 1083         RET     NZ              ; No don't flip flag
   041A 3A 45 10      [12] 1084         LD      A,(CTLOFG)      ; Get flag
   041D 2F            [ 3] 1085         CPL                     ; Flip it
   041E 32 45 10      [13] 1086         LD      (CTLOFG),A      ; Put it back
   0421 AF            [ 4] 1087         XOR     A               ; Null character
   0422 C9            [ 9] 1088         RET
                           1089 
   0423 CD 70 06      [16] 1090 LIST:   CALL    ATOH            ; ASCII number to DE
   0426 C0            [10] 1091         RET     NZ              ; Return if anything extra
   0427 C1            [ 9] 1092         POP     BC              ; Rubbish - Not needed
   0428 CD 49 02      [16] 1093         CALL    SR0xCLN          ; Search for line number in DE
   042B C5            [11] 1094         PUSH    BC              ; Save address of line
   042C CD 70 04      [16] 1095         CALL    SETLIN          ; Set up lines counter
   042F E1            [ 9] 1096 LISTLP: POP     HL              ; Restore address of line
   0430 4E            [ 6] 1097         LD      C,(HL)          ; Get LSB of next line
   0431 23            [ 4] 1098         INC     HL
   0432 46            [ 6] 1099         LD      B,(HL)          ; Get MSB of next line
   0433 23            [ 4] 1100         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 21.
Hexadecimal [16-Bits]



   0434 78            [ 4] 1101         LD      A,B             ; BC = 0 (End of program)?
   0435 B1            [ 4] 1102         OR      C
   0436 CA B1 01      [ 9] 1103         JP      Z,PRNTOK        ; Yes - Go to command mode
   0439 CD 7F 04      [16] 1104         CALL    COUNT           ; Count lines
   043C CD 70 05      [16] 1105         CALL    TSTBRK          ; Test for break key
   043F C5            [11] 1106         PUSH    BC              ; Save address of next line
   0440 CD 07 08      [16] 1107         CALL    PRNTCR          ; Output CRLF
   0443 5E            [ 6] 1108         LD      E,(HL)          ; Get LSB of line number
   0444 23            [ 4] 1109         INC     HL
   0445 56            [ 6] 1110         LD      D,(HL)          ; Get MSB of line number
   0446 23            [ 4] 1111         INC     HL
   0447 E5            [11] 1112         PUSH    HL              ; Save address of line start
   0448 EB            [ 3] 1113         EX      DE,HL           ; Line number to HL
   0449 CD FA 13      [16] 1114         CALL    PRNTHL          ; Output line number in decimal
a  044C               [16] 1115         LD      A," "           ; Space after line number
   044C E1            [ 9] 1116         POP     HL              ; Restore start of line address
   044D CD E7 03      [16] 1117 LSTLP2: CALL    OUTC            ; Output character in A
   0450 7E            [ 6] 1118 LSTLP3: LD      A,(HL)          ; Get next byte in line
   0451 B7            [ 4] 1119         OR      A               ; End of line?
   0452 23            [ 4] 1120         INC     HL              ; To next byte in line
   0453 CA 2F 04      [ 9] 1121         JP      Z,LISTLP        ; Yes - get next line
   0456 F2 4D 04      [ 9] 1122         JP      P,LSTLP2        ; No token - output it
a  0459               [ 9] 1123         SUB     ZEND-1          ; Find and output word
   0459 4F            [ 4] 1124         LD      C,A             ; Token offset+1 to C
a  045A               [ 4] 1125         LD      DE,WORDS        ; Reserved word list
   045A 1A            [ 6] 1126 FNDTOK: LD      A,(DE)          ; Get character in list
   045B 13            [ 4] 1127         INC     DE              ; Move on to next
   045C B7            [ 4] 1128         OR      A               ; Is it start of word?
   045D F2 5A 04      [ 9] 1129         JP      P,FNDTOK        ; No - Keep looking for word
   0460 0D            [ 4] 1130         DEC     C               ; Count words
   0461 C2 5A 04      [ 9] 1131         JP      NZ,FNDTOK       ; Not there - keep looking
q  0464                    1132 OUTWRD: AND     01111111B       ; Strip bit 7
   0464 CD E7 03      [16] 1133         CALL    OUTC            ; Output first character
   0467 1A            [ 6] 1134         LD      A,(DE)          ; Get next character
   0468 13            [ 4] 1135         INC     DE              ; Move on to next
   0469 B7            [ 4] 1136         OR      A               ; Is it end of word?
   046A F2 64 04      [ 9] 1137         JP      P,OUTWRD        ; No - output the rest
   046D C3 50 04      [ 9] 1138         JP      LSTLP3          ; Next byte in line
                           1139 
   0470 E5            [11] 1140 SETLIN: PUSH    HL              ; Set up LINES counter
   0471 2A 48 10      [15] 1141         LD      HL,(LINESN)     ; Get LINES number
   0474 22 46 10      [16] 1142         LD      (LINESC),HL     ; Save in LINES counter
   0477 E1            [ 9] 1143         POP     HL
   0478 C9            [ 9] 1144         RET
                           1145 
a  0479               [ 9] 1146 LDNMI1: LD      HL,BREAK        ; Break routine
   0479 22 7E 0C      [16] 1147         LD      (NMI),HL        ; NMI forces break
   047C C3 B1 01      [ 9] 1148         JP      PRNTOK          ; Go to command mode
                           1149 
q                          1150         DB      0x0FE            ; <<< NO REFERENCE TO HERE >>>
                           1151 
   047F E5            [11] 1152 COUNT:  PUSH    HL              ; Save code string address
   0480 D5            [11] 1153         PUSH    DE
   0481 2A 46 10      [15] 1154         LD      HL,(LINESC)     ; Get LINES counter
a  0484               [15] 1155         LD      DE,-1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 22.
Hexadecimal [16-Bits]



   0484 ED 5A         [10] 1156         ADC     HL,DE           ; Decrement
   0486 22 46 10      [16] 1157         LD      (LINESC),HL     ; Put it back
   0489 D1            [ 9] 1158         POP     DE
   048A E1            [ 9] 1159         POP     HL              ; Restore code string address
   048B F0            [10] 1160         RET     P               ; Return if more lines to go
   048C E5            [11] 1161         PUSH    HL              ; Save code string address
   048D 2A 48 10      [15] 1162         LD      HL,(LINESN)     ; Get LINES number
   0490 22 46 10      [16] 1163         LD      (LINESC),HL     ; Reset LINES counter
   0493 3A 4C 10      [12] 1164         LD      A,(NMIFLG)      ; Break by NMI?
   0496 B7            [ 4] 1165         OR      A
   0497 C2 AD 17      [ 9] 1166         JP      NZ,ARETN        ; Yes - "RETN"
   049A CD 20 16      [16] 1167         CALL    GETINP          ; Get input character
a  049D               [16] 1168         CP      CTRLC           ; Is it control "C"?
   049D CA A4 04      [ 9] 1169         JP      Z,RSLNBK        ; Yes - Reset LINES an break
   04A0 E1            [ 9] 1170         POP     HL              ; Restore code string address
   04A1 C3 7F 04      [ 9] 1171         JP      COUNT           ; Keep on counting
                           1172 
   04A4 2A 48 10      [15] 1173 RSLNBK: LD      HL,(LINESN)     ; Get LINES number
   04A7 22 46 10      [16] 1174         LD      (LINESC),HL     ; Reset LINES counter
   04AA C3 85 00      [ 9] 1175         JP      BRKRET          ; Go and output "Break"
                           1176 
a  04AD               [ 9] 1177 FOR:    LD      A,0x64           ; Flag "FOR" assignment
   04AD 32 CB 10      [13] 1178         LD      (FORFLG),A      ; Save "FOR" flag
   04B0 CD 29 07      [16] 1179         CALL    LET             ; Set up initial index
   04B3 C1            [ 9] 1180         POP     BC              ; Drop RETurn address
   04B4 E5            [11] 1181         PUSH    HL              ; Save code string address
   04B5 CD 1A 07      [16] 1182         CALL    DATA            ; Get next statement address
   04B8 22 C7 10      [16] 1183         LD      (LOOPST),HL     ; Save it for start of lo6p
a  04BB               [16] 1184         LD      HL,2            ; Offset for "FOR" block
   04BB 39            [ 7] 1185         ADD     HL,SP           ; Point to it
   04BC CD 42 01      [16] 1186 FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
   04BF D1            [ 9] 1187         POP     DE              ; Get code string address
   04C0 C2 D8 04      [ 9] 1188         JP      NZ,FORFND       ; No nesting found
   04C3 09            [ 7] 1189         ADD     HL,BC           ; Move into "FOR" block
   04C4 D5            [11] 1190         PUSH    DE              ; Save code string address
   04C5 2B            [ 4] 1191         DEC     HL
   04C6 56            [ 6] 1192         LD      D,(HL)          ; Get MSB of loop statement
   04C7 2B            [ 4] 1193         DEC     HL
   04C8 5E            [ 6] 1194         LD      E,(HL)          ; Get LSB of loop statement
   04C9 23            [ 4] 1195         INC     HL
   04CA 23            [ 4] 1196         INC     HL
   04CB E5            [11] 1197         PUSH    HL              ; Save block address
   04CC 2A C7 10      [15] 1198         LD      HL,(LOOPST)     ; Get address of loop statement
   04CF CD D7 03      [16] 1199         CALL    CP0xDEL          ; Compare the FOR loops
   04D2 E1            [ 9] 1200         POP     HL              ; Restore block address
   04D3 C2 BC 04      [ 9] 1201         JP      NZ,FORSLP       ; Different FORs - Find another
   04D6 D1            [ 9] 1202         POP     DE              ; Restore code string address
   04D7 F9            [ 4] 1203         LD      SP,HL           ; Remove all nested loops
                           1204 
   04D8 EB            [ 3] 1205 FORFND: EX      DE,HL           ; Code string address to HL
a  04D9               [ 3] 1206         LD      C,8
q  04D9 CD 0C 00      [16] 1207         CALL    0xCKSTK          ; Check for 8 levels of stack
   04DC E5            [11] 1208         PUSH    HL              ; Save code string address
   04DD 2A C7 10      [15] 1209         LD      HL,(LOOPST)     ; Get first statement of loop
   04E0 E3            [16] 1210         EX      (SP),HL         ; Save and restore code string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 23.
Hexadecimal [16-Bits]



   04E1 E5            [11] 1211         PUSH    HL              ; Re-save code string address
   04E2 2A 5C 10      [15] 1212         LD      HL,(LINEAT)     ; Get current line number
   04E5 E3            [16] 1213         EX      (SP),HL         ; Save and restore code string
   04E6 CD 75 09      [16] 1214         CALL    TSTNUM          ; Make sure it's a number
q  04E9 CD 0C 00      [16] 1215         CALL    0xCKSYN          ; Make sure "TO" is next
o  04EC                    1216         DB      ZTO             ; "TO" token
   04EC CD 72 09      [16] 1217         CALL    GETNUM          ; Get "TO" expression value
   04EF E5            [11] 1218         PUSH    HL              ; Save code string address
   04F0 CD DC 12      [16] 1219         CALL    BCDEFP          ; Move "TO" value to BCDE
   04F3 E1            [ 9] 1220         POP     HL              ; Restore code string address
   04F4 C5            [11] 1221         PUSH    BC              ; Save "TO" value in block
   04F5 D5            [11] 1222         PUSH    DE
a  04F6               [11] 1223         LD      BC,0x8100        ; BCDE - 1 (default STEP)
   04F6 51            [ 4] 1224         LD      D,C             ; C=0
   04F7 5A            [ 4] 1225         LD      E,D             ; D=0
   04F8 7E            [ 6] 1226         LD      A,(HL)          ; Get next byte in code string
a  04F9               [ 6] 1227         CP      ZSTEP           ; See if "STEP" is stated
a  04F9               [ 6] 1228         LD      A,1             ; Sign of step = 1
   04F9 C2 0A 05      [ 9] 1229         JP      NZ,SAVSTP       ; No STEP given - Default to 1
   04FC CD 4B 05      [16] 1230         CALL    GET0xCR          ; Jump over "STEP" token
   04FF CD 72 09      [16] 1231         CALL    GETNUM          ; Get step value
   0502 E5            [11] 1232         PUSH    HL              ; Save code string address
   0503 CD DC 12      [16] 1233         CALL    BCDEFP          ; Move STEP to BCDE
   0506 CD A2 12      [16] 1234         CALL    TSTSGN          ; Test sign of FPREG
   0509 E1            [ 9] 1235         POP     HL              ; Restore code string address
   050A C5            [11] 1236 SAVSTP: PUSH    BC              ; Save the STEP value in block
   050B D5            [11] 1237         PUSH    DE
   050C F5            [11] 1238         PUSH    AF              ; Save sign of STEP
   050D 33            [ 4] 1239         INC     SP              ; Don't save flags
   050E E5            [11] 1240         PUSH    HL              ; Save code string address
   050F 2A CE 10      [15] 1241         LD      HL,(BRKLIN)     ; Get address of index variable
   0512 E3            [16] 1242         EX      (SP),HL         ; Save and restore code string
a  0513               [16] 1243 PUTFID: LD      B,ZFOR          ; "FOR" block marker
   0513 C5            [11] 1244         PUSH    BC              ; Save it
   0514 33            [ 4] 1245         INC     SP              ; Don't save C
                           1246 
q  0515 CD 0C 00      [16] 1247 RUNCNT: CALL    0xCKBRK          ; Execution driver - Test break
   0518 B7            [ 4] 1248         OR      A               ; Break key hit?
   0519 C4 75 05      [16] 1249         CALL    NZ,STALL        ; Yes - Pause for a key
   051C 22 CE 10      [16] 1250         LD      (BRKLIN),HL     ; Save code address for break
   051F 7E            [ 6] 1251         LD      A,(HL)          ; Get next byte in code string
a  0520               [ 6] 1252         CP      ":"             ; Multi statement line?
   0520 CA 37 05      [ 9] 1253         JP      Z,EXCUTE        ; Yes - Execute it
   0523 B7            [ 4] 1254         OR      A               ; End of line?
   0524 C2 86 01      [ 9] 1255         JP      NZ,SNERR        ; No - Syntax error
   0527 23            [ 4] 1256         INC     HL              ; Point to address of next line
   0528 7E            [ 6] 1257         LD      A,(HL)          ; Get LSB of line pointer
   0529 23            [ 4] 1258         INC     HL
   052A B6            [ 6] 1259         OR      (HL)            ; Is it zero (End of prog)?
   052B CA 81 05      [ 9] 1260         JP      Z,ENDPRG        ; Yes - Terminate execution
   052E 23            [ 4] 1261         INC     HL              ; Point to line number
   052F 5E            [ 6] 1262         LD      E,(HL)          ; Get LSB of line number
   0530 23            [ 4] 1263         INC     HL
   0531 56            [ 6] 1264         LD      D,(HL)          ; Get MSB of line number
   0532 EB            [ 3] 1265         EX      DE,HL           ; Line number to HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 24.
Hexadecimal [16-Bits]



   0533 22 5C 10      [16] 1266         LD      (LINEAT),HL     ; Save as current line number
   0536 EB            [ 3] 1267         EX      DE,HL           ; Line number back to DE
   0537 CD 4B 05      [16] 1268 EXCUTE: CALL    GET0xCR          ; Get key word
a  053A               [16] 1269         LD      DE,RUNCNT       ; Where to RETurn to
   053A D5            [11] 1270         PUSH    DE              ; Save for RETurn
   053B C8            [10] 1271 IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
a  053C               [10] 1272 ONJMP:  SUB     ZEND            ; Is it a token?
   053C DA 29 07      [ 9] 1273         JP      C,LET           ; No - try to assign it
a  053F               [ 9] 1274         CP      ZNEW+1-ZEND     ; END to NEW ?
   053F D2 86 01      [ 9] 1275         JP      NC,SNERR        ; Not a key word - ?SN Error
   0542 07            [ 3] 1276         RLCA                    ; Double it
   0543 4F            [ 4] 1277         LD      C,A             ; BC = Offset into table
a  0544               [ 4] 1278         LD      B,0
   0544 EB            [ 3] 1279         EX      DE,HL           ; Save code string address
a  0545               [ 3] 1280         LD      HL,WORDTB       ; Keyword address table
   0545 09            [ 7] 1281         ADD     HL,BC           ; Point to routine address
   0546 4E            [ 6] 1282         LD      C,(HL)          ; Get LSB of routine address
   0547 23            [ 4] 1283         INC     HL
   0548 46            [ 6] 1284         LD      B,(HL)          ; Get MSB of routine address
   0549 C5            [11] 1285         PUSH    BC              ; Save routine address
   054A EB            [ 3] 1286         EX      DE,HL           ; Restore code string address
                           1287 
   054B 23            [ 4] 1288 GET0xCR: INC     HL              ; Point to next character
   054C 7E            [ 6] 1289         LD      A,(HL)          ; Get next code string byte
a  054D               [ 6] 1290         CP      ":"             ; Z if ":"
   054D D0            [10] 1291         RET     NC              ; NC if > "9"
a  054E               [10] 1292         CP      " "
   054E CA 4B 05      [ 9] 1293         JP      Z,GET0xCR        ; Skip over spaces
a  0551               [ 9] 1294         CP      "0"
   0551 3F            [ 3] 1295         CCF                     ; NC if < "0"
   0552 3C            [ 4] 1296         INC     A               ; Test for zero - Leave carry
   0553 3D            [ 4] 1297         DEC     A               ; Z if Null
   0554 C9            [ 9] 1298         RET
                           1299 
   0555 EB            [ 3] 1300 RESTOR: EX      DE,HL           ; Save code string address
   0556 2A 5E 10      [15] 1301         LD      HL,(BASTXT)     ; Point to start of program
   0559 CA 6A 05      [ 9] 1302         JP      Z,RESTNL        ; Just RESTORE - reset pointer
   055C EB            [ 3] 1303         EX      DE,HL           ; Restore code string address
   055D CD 70 06      [16] 1304         CALL    ATOH            ; Get line number to DE
   0560 E5            [11] 1305         PUSH    HL              ; Save code string address
   0561 CD 49 02      [16] 1306         CALL    SR0xCLN          ; Search for line number in DE
   0564 60            [ 4] 1307         LD      H,B             ; HL = Address of line
   0565 69            [ 4] 1308         LD      L,C
   0566 D1            [ 9] 1309         POP     DE              ; Restore code string address
   0567 D2 FC 06      [ 9] 1310         JP      NC,ULERR        ; ?UL Error if not found
   056A 2B            [ 4] 1311 RESTNL: DEC     HL              ; Byte before DATA statement
   056B 22 DC 10      [16] 1312 UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
   056E EB            [ 3] 1313         EX      DE,HL           ; Restore code string address
   056F C9            [ 9] 1314         RET
                           1315 
q  0570 CD 0C 00      [16] 1316 TSTBRK: CALL    0xCKBRK          ; Test for interrupts
   0573 B7            [ 4] 1317         OR      A
   0574 C8            [10] 1318         RET     Z               ; Return if no key pressed
   0575 CD 16 04      [16] 1319 STALL:  CALL    CLOTST          ; Get input and test for ^O
a  0578               [16] 1320         CP      CTRLS           ; Is it control "S"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 25.
Hexadecimal [16-Bits]



   0578 CC 16 04      [16] 1321         CALL    Z,CLOTST        ; Yes - Get another character
a  057B               [16] 1322         CP      CTRLC           ; Return if not control "C"
   057B C0            [10] 1323 STOP:   RET     NZ              ; Exit if anything else
q                          1324         DB      0x0F6            ; Flag "STOP"
   057C C0            [10] 1325 PEND:   RET     NZ              ; Exit if anything else
   057D 22 CE 10      [16] 1326         LD      (BRKLIN),HL     ; Save point of break
q                          1327         DB      0x21             ; Skip "OR 11111111B"
q  0580                    1328 INPBRK: OR      11111111B       ; Flag "Break" wanted
   0580 C1            [ 9] 1329         POP     BC              ; Return not needed and more
   0581 2A 5C 10      [15] 1330 ENDPRG: LD      HL,(LINEAT)     ; Get current line number
   0584 F5            [11] 1331         PUSH    AF              ; Save STOP / END status
   0585 7D            [ 4] 1332         LD      A,L             ; Is it direct break?
   0586 A4            [ 4] 1333         AND     H
   0587 3C            [ 4] 1334         INC     A               ; Line is -1 if direct break
   0588 CA 94 05      [ 9] 1335         JP      Z,NOLIN         ; Yes - No line number
   058B 22 D2 10      [16] 1336         LD      (ERRLIN),HL     ; Save line of break
   058E 2A CE 10      [15] 1337         LD      HL,(BRKLIN)     ; Get point of break
   0591 22 D4 10      [16] 1338         LD      (CONTAD),HL     ; Save point to CONTinue
   0594 AF            [ 4] 1339 NOLIN:  XOR     A
   0595 32 45 10      [13] 1340         LD      (CTLOFG),A      ; Enable output
   0598 CD FF 07      [16] 1341         CALL    STTLIN          ; Start a new line
   059B F1            [ 9] 1342         POP     AF              ; Restore STOP / END status
a  059C               [ 9] 1343         LD      HL,BRKMSG       ; "Break" message
   059C C2 9E 01      [ 9] 1344         JP      NZ,ERRIN        ; "in line" wanted?
   059F C3 B1 01      [ 9] 1345         JP      PRNTOK          ; Go to command mode
                           1346 
   05A2 2A D4 10      [15] 1347 CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
   05A5 7C            [ 4] 1348         LD      A,H             ; Is it zero?
   05A6 B5            [ 4] 1349         OR      L
a  05A7               [ 4] 1350         LD      E,CN            ; ?CN Error
   05A7 CA 86 01      [ 9] 1351         JP      Z,ERROR         ; Yes - output "?CN Error"
   05AA EB            [ 3] 1352         EX      DE,HL           ; Save code string address
   05AB 2A D2 10      [15] 1353         LD      HL,(ERRLIN)     ; Get line of last break
   05AE 22 5C 10      [16] 1354         LD      (LINEAT),HL     ; Set up current line number
   05B1 EB            [ 3] 1355         EX      DE,HL           ; Restore code string address
   05B2 C9            [ 9] 1356         RET                     ; CONTinue where left off
                           1357 
   05B3 CD C8 0F      [16] 1358 NULL:   CALL    GETINT          ; Get integer 0-255
   05B6 C0            [10] 1359         RET     NZ              ; Return if bad value
   05B7 32 41 10      [13] 1360         LD      (NULLS),A       ; Set nulls number
   05BA C9            [ 9] 1361         RET
                           1362 
a  05BB               [ 9] 1363 ARRLD1: LD      B,-1            ; Flag array load
   05BB CD 4B 05      [16] 1364 ARRSV1: CALL    GET0xCR          ; Skip "*"
   05BE 78            [ 4] 1365         LD      A,B             ; CLOAD* or CSAVE*
   05BF 32 CE 10      [13] 1366         LD      (BRKLIN),A      ; Save it
a  05C2               [13] 1367         LD      A,1             ; It's an array
   05C2 32 CB 10      [13] 1368         LD      (FORFLG),A      ; Flag array name
   05C5 CD 01 0B      [16] 1369         CALL    GETVAR          ; Get address of array name
   05C8 E5            [11] 1370         PUSH    HL              ; Save code string address
   05C9 32 CB 10      [13] 1371         LD      (FORFLG),A      ; Clear flag
   05CC 60            [ 4] 1372         LD      H,B             ; Address of array to HL
   05CD 69            [ 4] 1373         LD      L,C
   05CE 0B            [ 4] 1374         DEC     BC              ; Back space
   05CF 0B            [ 4] 1375         DEC     BC              ;  to point
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 26.
Hexadecimal [16-Bits]



   05D0 0B            [ 4] 1376         DEC     BC              ;  to the
   05D1 0B            [ 4] 1377         DEC     BC              ; array name
   05D2 3A CE 10      [12] 1378         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   05D5 B7            [ 4] 1379         OR      A
   05D6 F5            [11] 1380         PUSH    AF              ; Save CLOAD* / CSAVE* status
   05D7 EB            [ 3] 1381         EX      DE,HL           ; Array data length
   05D8 19            [ 7] 1382         ADD     HL,DE           ; End of data
   05D9 EB            [ 3] 1383         EX      DE,HL           ; To DE
   05DA 4E            [ 6] 1384         LD      C,(HL)          ; Get dimension bytes
a  05DB               [ 6] 1385         LD      B,0
   05DB 09            [ 7] 1386         ADD     HL,BC           ; 2 Bytes each dimension
   05DC 09            [ 7] 1387         ADD     HL,BC
   05DD 23            [ 4] 1388         INC     HL              ; Over number of dimensions
   05DE E5            [11] 1389         PUSH    HL              ; Address of array data
   05DF D5            [11] 1390         PUSH    DE              ; End of array data
   05E0 C5            [11] 1391         PUSH    BC              ; Number of dimensions
   05E1 3A CE 10      [12] 1392         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
a  05E4               [12] 1393         CP      -1
   05E4 CC FA 15      [16] 1394         CALL    Z,CASFF         ; CLOAD* - Cassette on
   05E7 3A CE 10      [12] 1395         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
a  05EA               [12] 1396         CP      -1
   05EA C4 EF 15      [16] 1397         CALL    NZ,CASFFW       ; CSAVE* - Cassette on and wait
   05ED 00            [ 3] 1398         NOP
   05EE 00            [ 3] 1399         NOP
   05EF 00            [ 3] 1400         NOP
a  05F0               [ 3] 1401         LD      HL,0
q  05F0                    1402         LD      (0xCKSUM),HL     ; Zero check sum
   05F0 C1            [ 9] 1403         POP     BC              ; Number of dimensions
   05F1 D1            [ 9] 1404         POP     DE              ; End of array data
   05F2 E1            [ 9] 1405         POP     HL              ; Address of array data
aq 05F3               [ 9] 1406         LD      B,11010010B     ; Header byte
   05F3 C3 65 18      [ 9] 1407         JP      JPLDSV          ; CSAVE-SN0xDDR , CLOAD-GETHDR
                           1408 
   05F6 78            [ 4] 1409 SN0xDDR: LD      A,B             ; Get header byte
   05F7 CD F5 0F      [16] 1410         CALL    WUART2          ; Send 2 bytes to UART
   05FA CD F5 0F      [16] 1411         CALL    WUART2          ; Send 2 bytes to UART
   05FD C3 0B 06      [ 9] 1412         JP      SNDARY          ; Send array data
                           1413 
a  0600               [ 9] 1414 GETHDR: LD      C,4             ; 4 Bytes to check
   0600 CD F2 0F      [16] 1415 HDRLP:  CALL    RUART           ; Read byte from UART
   0603 B8            [ 4] 1416         CP      B               ; Same as header?
   0604 C2 00 06      [ 9] 1417         JP      NZ,GETHDR       ; No - Wait for another
   0607 0D            [ 4] 1418         DEC     C               ; Count bytes
   0608 C2 00 06      [ 9] 1419         JP      NZ,HDRLP        ; More needed
   060B CD 75 09      [16] 1420 SNDARY: CALL    TSTNUM          ; Check it's a numerical array
   060E CD D7 03      [16] 1421 ARYLP:  CALL    CP0xDEL          ; All array data done
   0611 CA 25 06      [ 9] 1422         JP      Z,SUMOFF        ; Yes - Do check sum
   0614 F1            [ 9] 1423         POP     AF              ; CLOAD* or CSAVE* ?
   0615 F5            [11] 1424         PUSH    AF              ; Re-save flags
   0616 7E            [ 6] 1425         LD      A,(HL)          ; Get byte
   0617 F4 F8 0F      [16] 1426         CALL    P,WUART         ; CSAVE* - Write byte
   061A FC F2 0F      [16] 1427         CALL    M,RUART         ; CLOAD* - Read byte
   061D 77            [ 7] 1428         LD      (HL),A          ; Save byte in case of CLOAD*
   061E CD 2E 06      [16] 1429         CALL    ACCSUM          ; Accumulate check sum
   0621 23            [ 4] 1430         INC     HL              ; Next byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 27.
Hexadecimal [16-Bits]



   0622 C3 0E 06      [ 9] 1431         JP      ARYLP           ; Repeat
                           1432 
   0625 CD 33 06      [16] 1433 SUMOFF: CALL    DOSUM           ; Do check sum
   0628 CD FA 15      [16] 1434         CALL    CASFF           ; Cassette off
   062B F1            [ 9] 1435         POP     AF              ; Not needed any more
   062C E1            [ 9] 1436         POP     HL              ; Restore code string address
   062D C9            [ 9] 1437         RET
                           1438 
   062E E5            [11] 1439 ACCSUM: PUSH    HL              ; Save address in array
q  062F                    1440         LD      HL,(0xCKSUM)     ; Get check sum
a  062F               [11] 1441         LD      B,0             ; BC - Value of byte
   062F 4F            [ 4] 1442         LD      C,A
   0630 09            [ 7] 1443         ADD     HL,BC           ; Add byte to check sum
q  0631                    1444         LD      (0xCKSUM),HL     ; Re-save check sum
   0631 E1            [ 9] 1445         POP     HL              ; Restore address in array
   0632 C9            [ 9] 1446         RET
                           1447 
   0633 3A CE 10      [12] 1448 DOSUM:  LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   0636 B7            [ 4] 1449         OR      A
q  0637 FA 0C 00      [ 9] 1450         JP      M,0xCSUMS        ; CLOAD* - Check if sums match
q  063A                    1451         LD      A,(0xCKSUM)      ; Get LSB of check sum
   063A CD F8 0F      [16] 1452         CALL    WUART           ; Write to UART
q  063D                    1453         LD      A,(0xCKSUM+1)    ; Get MSB of check sum
   063D C3 F8 0F      [ 9] 1454         JP      WUART           ; Write to UART and return
                           1455 
q                          1456 0xCSUMS: CALL    RUART           ; Read LSB of check sum
   0640 F5            [11] 1457         PUSH    AF              ; Save it
   0641 CD F2 0F      [16] 1458         CALL    RUART           ; Read MSB of check sum
   0644 C1            [ 9] 1459         POP     BC              ; LSB to B
   0645 58            [ 4] 1460         LD      E,B             ; LSB to E
   0646 57            [ 4] 1461         LD      D,A             ; MSB to D
q  0647                    1462         LD      HL,(0xCKSUM)     ; Get accumulated check sum
   0647 CD D7 03      [16] 1463         CALL    CP0xDEL          ; Are they the same?
   064A C8            [10] 1464         RET     Z               ; Yes - End CLOAD*
   064B CD FA 15      [16] 1465         CALL    CASFF           ; Cassette off
   064E C3 92 10      [ 9] 1466         JP      OUTBAD          ; Different - Output "Bad"
                           1467 
q                          1468 0xCKLTR: LD      A,(HL)          ; Get byte
a  0651               [ 9] 1469         CP      "A"             ; < "A" ?
   0651 D8            [10] 1470         RET     C               ; Carry set if not letter
a  0652               [10] 1471         CP      "Z"+1           ; > "Z" ?
   0652 3F            [ 3] 1472         CCF
   0653 C9            [ 9] 1473         RET                     ; Carry set if not letter
                           1474 
   0654 CD 4B 05      [16] 1475 FPSINT: CALL    GET0xCR          ; Get next character
   0657 CD 72 09      [16] 1476 POSINT: CALL    GETNUM          ; Get integer 0 to 32767
   065A CD A2 12      [16] 1477 DEPINT: CALL    TSTSGN          ; Test sign of FPREG
   065D FA 6D 06      [ 9] 1478         JP      M,FCERR         ; Negative - ?FC Error
   0660 3A E7 10      [12] 1479 DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
a  0663               [12] 1480         CP      0x80+16          ; Exponent in range (16 bits)?
   0663 DA 27 13      [ 9] 1481         JP      C,FPINT         ; Yes - convert it
a  0666               [ 9] 1482         LD      BC,0x9080        ; BCDE = -32768
a  0666               [ 9] 1483         LD      DE,0000
   0666 E5            [11] 1484         PUSH    HL              ; Save code string address
   0667 CD 00 13      [16] 1485         CALL    CMPNUM          ; Compare FPREG with BCDE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 28.
Hexadecimal [16-Bits]



   066A E1            [ 9] 1486         POP     HL              ; Restore code string address
   066B 51            [ 4] 1487         LD      D,C             ; MSB to D
   066C C8            [10] 1488         RET     Z               ; Return if in range
a  066D               [10] 1489 FCERR:  LD      E,FC            ; ?FC Error
   066D C3 86 01      [ 9] 1490         JP      ERROR           ; Output error-
                           1491 
   0670 2B            [ 4] 1492 ATOH:   DEC     HL              ; ASCII number to DE binary
a  0671               [ 4] 1493 GETLN:  LD      DE,0            ; Get number to DE
   0671 CD 4B 05      [16] 1494 GTLNLP: CALL    GET0xCR          ; Get next character
   0674 D0            [10] 1495         RET     NC              ; Exit if not a digit
   0675 E5            [11] 1496         PUSH    HL              ; Save code string address
   0676 F5            [11] 1497         PUSH    AF              ; Save digit
a  0677               [11] 1498         LD      HL,65529/10     ; Largest number 65529
   0677 CD D7 03      [16] 1499         CALL    CP0xDEL          ; Number in range?
   067A DA 86 01      [ 9] 1500         JP      C,SNERR         ; No - ?SN Error
   067D 62            [ 4] 1501         LD      H,D             ; HL = Number
   067E 6B            [ 4] 1502         LD      L,E
   067F 19            [ 7] 1503         ADD     HL,DE           ; Times 2
   0680 29            [ 7] 1504         ADD     HL,HL           ; Times 4
   0681 19            [ 7] 1505         ADD     HL,DE           ; Times 5
   0682 29            [ 7] 1506         ADD     HL,HL           ; Times 10
   0683 F1            [ 9] 1507         POP     AF              ; Restore digit
a  0684               [ 9] 1508         SUB     "0"             ; Make it 0 to 9
   0684 5F            [ 4] 1509         LD      E,A             ; DE = Value of digit
a  0685               [ 4] 1510         LD      D,0
   0685 19            [ 7] 1511         ADD     HL,DE           ; Add to number
   0686 EB            [ 3] 1512         EX      DE,HL           ; Number to DE
   0687 E1            [ 9] 1513         POP     HL              ; Restore code string address
   0688 C3 71 06      [ 9] 1514         JP      GTLNLP          ; Go to next character
                           1515 
   068B CA 79 02      [ 9] 1516 CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
   068E CD 57 06      [16] 1517         CALL    POSINT          ; Get integer 0 to 32767 to DE
   0691 2B            [ 4] 1518         DEC     HL              ; Cancel increment
   0692 CD 4B 05      [16] 1519         CALL    GET0xCR          ; Get next character
   0695 E5            [11] 1520         PUSH    HL              ; Save code string address
   0696 2A AF 10      [15] 1521         LD      HL,(LSTRAM)     ; Get end of RAM
   0699 CA AD 06      [ 9] 1522         JP      Z,STORED        ; No value given - Use stored
   069C E1            [ 9] 1523         POP     HL              ; Restore code string address
q  069D CD 0C 00      [16] 1524         CALL    0xCKSYN          ; Check for comma
q                          1525         DB      ","
   06A0 D5            [11] 1526         PUSH    DE              ; Save number
   06A1 CD 57 06      [16] 1527         CALL    POSINT          ; Get integer 0 to 32767
   06A4 2B            [ 4] 1528         DEC     HL              ; Cancel increment
   06A5 CD 4B 05      [16] 1529         CALL    GET0xCR          ; Get next character
   06A8 C2 86 01      [ 9] 1530         JP      NZ,SNERR        ; ?SN Error if more on line
   06AB E3            [16] 1531         EX      (SP),HL         ; Save code string address
   06AC EB            [ 3] 1532         EX      DE,HL           ; Number to DE
   06AD 7D            [ 4] 1533 STORED: LD      A,L             ; Get LSB of new RAM top
   06AE 93            [ 4] 1534         SUB     E               ; Subtract LSB of string space
   06AF 5F            [ 4] 1535         LD      E,A             ; Save LSB
   06B0 7C            [ 4] 1536         LD      A,H             ; Get MSB of new RAM top
   06B1 9A            [ 4] 1537         SBC     A,D             ; Subtract MSB of string space
   06B2 57            [ 4] 1538         LD      D,A             ; Save MSB
   06B3 DA 7D 01      [ 9] 1539         JP      C,OMERR         ; ?OM Error if not enough mem
   06B6 E5            [11] 1540         PUSH    HL              ; Save RAM top
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 29.
Hexadecimal [16-Bits]



   06B7 2A D6 10      [15] 1541         LD      HL,(PROGND)     ; Get program end
a  06BA               [15] 1542         LD      BC,40           ; 40 Bytes minimum working RAM
   06BA 09            [ 7] 1543         ADD     HL,BC           ; Get lowest address
   06BB CD D7 03      [16] 1544         CALL    CP0xDEL          ; Enough memory?
   06BE D2 7D 01      [ 9] 1545         JP      NC,OMERR        ; No - ?OM Error
   06C1 EB            [ 3] 1546         EX      DE,HL           ; RAM top to HL
   06C2 22 5A 10      [16] 1547         LD      (STRSPC),HL     ; Set new string space
   06C5 E1            [ 9] 1548         POP     HL              ; End of memory to use
   06C6 22 AF 10      [16] 1549         LD      (LSTRAM),HL     ; Set new top of RAM
   06C9 E1            [ 9] 1550         POP     HL              ; Restore code string address
   06CA C3 79 02      [ 9] 1551         JP      INTVAR          ; Initialise variables
                           1552 
   06CD CA 75 02      [ 9] 1553 RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
   06D0 CD 79 02      [16] 1554         CALL    INTVAR          ; Initialise variables
a  06D3               [16] 1555         LD      BC,RUNCNT       ; Execution driver loop
   06D3 C3 E2 06      [ 9] 1556         JP      RUNLIN          ; RUN from line number
                           1557 
a  06D6               [ 9] 1558 GOSUB:  LD      C,3             ; 3 Levels of stack needed
q  06D6 CD 0C 00      [16] 1559         CALL    0xCKSTK          ; Check for 3 levels of stack
   06D9 C1            [ 9] 1560         POP     BC              ; Get return address
   06DA E5            [11] 1561         PUSH    HL              ; Save code string for RETURN
   06DB E5            [11] 1562         PUSH    HL              ; And for GOSUB routine
   06DC 2A 5C 10      [15] 1563         LD      HL,(LINEAT)     ; Get current line
   06DF E3            [16] 1564         EX      (SP),HL         ; Into stack - Code string out
a  06E0               [16] 1565         LD      A,ZGOSUB        ; "GOSUB" token
   06E0 F5            [11] 1566         PUSH    AF              ; Save token
   06E1 33            [ 4] 1567         INC     SP              ; Don't save flags
                           1568 
   06E2 C5            [11] 1569 RUNLIN: PUSH    BC              ; Save return address
   06E3 CD 70 06      [16] 1570 GOTO:   CALL    ATOH            ; ASCII number to DE binary
   06E6 CD 1A 07      [16] 1571         CALL    REM             ; Get end of line
   06E9 E5            [11] 1572         PUSH    HL              ; Save end of line
   06EA 2A 5C 10      [15] 1573         LD      HL,(LINEAT)     ; Get current line
   06ED CD D7 03      [16] 1574         CALL    CP0xDEL          ; Line after current?
   06F0 E1            [ 9] 1575         POP     HL              ; Restore end of line
   06F1 23            [ 4] 1576         INC     HL              ; Start of next line
   06F2 DC 4C 02      [16] 1577         CALL    C,SR0xCLP        ; Line is after current line
   06F5 D4 49 02      [16] 1578         CALL    NC,SR0xCLN       ; Line is before current line
   06F8 60            [ 4] 1579         LD      H,B             ; Set up code string address
   06F9 69            [ 4] 1580         LD      L,C
   06FA 2B            [ 4] 1581         DEC     HL              ; Incremented after
   06FB D8            [10] 1582         RET     C               ; Line found
a  06FC               [10] 1583 ULERR:  LD      E,UL            ; ?UL Error
   06FC C3 86 01      [ 9] 1584         JP      ERROR           ; Output error message
                           1585 
   06FF C0            [10] 1586 RETURN: RET     NZ              ; Return if not just RETURN
a  0700               [10] 1587         LD      D,-1            ; Flag "GOSUB" search
   0700 CD 41 01      [16] 1588         CALL    BAKSTK          ; Look "GOSUB" block
   0703 F9            [ 4] 1589         LD      SP,HL           ; Kill all FORs in subroutine
a  0704               [ 4] 1590         CP      ZGOSUB          ; Test for "GOSUB" token
a  0704               [ 4] 1591         LD      E,RG            ; ?RG Error
   0704 C2 86 01      [ 9] 1592         JP      NZ,ERROR        ; Error if no "GOSUB" found
   0707 E1            [ 9] 1593         POP     HL              ; Get RETURN line number
   0708 22 5C 10      [16] 1594         LD      (LINEAT),HL     ; Save as current
   070B 23            [ 4] 1595         INC     HL              ; Was it from direct statement?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 30.
Hexadecimal [16-Bits]



   070C 7C            [ 4] 1596         LD      A,H
   070D B5            [ 4] 1597         OR      L               ; Return to line
   070E C2 18 07      [ 9] 1598         JP      NZ,RETLIN       ; No - Return to line
   0711 3A CC 10      [12] 1599         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
   0714 B7            [ 4] 1600         OR      A               ; If so buffer is corrupted
   0715 C2 B0 01      [ 9] 1601         JP      NZ,POPNOK       ; Yes - Go to command mode
a  0718               [ 9] 1602 RETLIN: LD      HL,RUNCNT       ; Execution driver loop
   0718 E3            [16] 1603         EX      (SP),HL         ; Into stack - Code string out
q                          1604         DB      0x3E             ; Skip "POP HL"
   0719 E1            [ 9] 1605 NXTDTA: POP     HL              ; Restore code string address
                           1606 
q  071A                    1607 DATA:   DB      0x01,3AH         ; ":" End of statement
a  071A               [ 9] 1608 REM:    LD      C,0             ; 00  End of statement
a  071A               [ 9] 1609         LD      B,0
   071A 79            [ 4] 1610 NXTSTL: LD      A,C             ; Statement and byte
   071B 48            [ 4] 1611         LD      C,B
   071C 47            [ 4] 1612         LD      B,A             ; Statement end byte
   071D 7E            [ 6] 1613 NXTSTT: LD      A,(HL)          ; Get byte
   071E B7            [ 4] 1614         OR      A               ; End of line?
   071F C8            [10] 1615         RET     Z               ; Yes - Exit
   0720 B8            [ 4] 1616         CP      B               ; End of statement?
   0721 C8            [10] 1617         RET     Z               ; Yes - Exit
   0722 23            [ 4] 1618         INC     HL              ; Next byte
a  0723               [ 4] 1619         CP      '"'             ; Literal string?
   0723 CA 1A 07      [ 9] 1620         JP      Z,NXTSTL        ; Yes - Look for another '"'
   0726 C3 1D 07      [ 9] 1621         JP      NXTSTT          ; Keep looking
                           1622 
   0729 CD 01 0B      [16] 1623 LET:    CALL    GETVAR          ; Get variable name
q  072C CD 0C 00      [16] 1624         CALL    0xCKSYN          ; Make sure "=" follows
o  072F                    1625         DB      ZEQUAL          ; "=" token
   072F D5            [11] 1626         PUSH    DE              ; Save address of variable
   0730 3A AD 10      [12] 1627         LD      A,(TYPE)        ; Get data type
   0733 F5            [11] 1628         PUSH    AF              ; Save type
   0734 CD 85 09      [16] 1629         CALL    EVAL            ; Evaluate expression
   0737 F1            [ 9] 1630         POP     AF              ; Restore type
   0738 E3            [16] 1631         EX      (SP),HL         ; Save code - Get var addr
   0739 22 CE 10      [16] 1632         LD      (BRKLIN),HL     ; Save address of variable
   073C 1F            [ 3] 1633         RRA                     ; Adjust type
q  073D CD 0C 00      [16] 1634         CALL    0xCKTYP          ; Check types are the same
   0740 CA 77 07      [ 9] 1635         JP      Z,LETNUM        ; Numeric - Move value
   0743 E5            [11] 1636 LETSTR: PUSH    HL              ; Save address of string var
   0744 2A E4 10      [15] 1637         LD      HL,(FPREG)      ; Pointer to string entry
   0747 E5            [11] 1638         PUSH    HL              ; Save it on stack
   0748 23            [ 4] 1639         INC     HL              ; Skip over length
   0749 23            [ 4] 1640         INC     HL
   074A 5E            [ 6] 1641         LD      E,(HL)          ; LSB of string address
   074B 23            [ 4] 1642         INC     HL
   074C 56            [ 6] 1643         LD      D,(HL)          ; MSB of string address
   074D 2A 5E 10      [15] 1644         LD      HL,(BASTXT)     ; Point to start of program
   0750 CD D7 03      [16] 1645         CALL    CP0xDEL          ; Is string before program?
   0753 D2 66 07      [ 9] 1646         JP      NC,CRESTR       ; Yes - Create string entry
   0756 2A 5A 10      [15] 1647         LD      HL,(STRSPC)     ; Point to string space
   0759 CD D7 03      [16] 1648         CALL    CP0xDEL          ; Is string literal in program?
   075C D1            [ 9] 1649         POP     DE              ; Restore address of string
   075D D2 6E 07      [ 9] 1650         JP      NC,MVSTPT       ; Yes - Set up pointer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 31.
Hexadecimal [16-Bits]



a  0760               [ 9] 1651         LD      HL,TMPSTR       ; Temporary string pool
   0760 CD D7 03      [16] 1652         CALL    CP0xDEL          ; Is string in temporary pool?
   0763 D2 6E 07      [ 9] 1653         JP      NC,MVSTPT       ; No - Set up pointer
q                          1654         DB      0x3E             ; Skip "POP DE"
   0766 D1            [ 9] 1655 CRESTR: POP     DE              ; Restore address of string
   0767 CD D2 0E      [16] 1656         CALL    BAKTMP          ; Back to last tmp-str entry
   076A EB            [ 3] 1657         EX      DE,HL           ; Address of string entry
   076B CD 3C 0D      [16] 1658         CALL    SAVSTR          ; Save string in string area
   076E CD D2 0E      [16] 1659 MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
   0771 E1            [ 9] 1660         POP     HL              ; Get string pointer
   0772 CD E5 12      [16] 1661         CALL    DETHL4          ; Move string pointer to var
   0775 E1            [ 9] 1662         POP     HL              ; Restore code string address
   0776 C9            [ 9] 1663         RET
                           1664 
   0777 E5            [11] 1665 LETNUM: PUSH    HL              ; Save address of variable
   0778 CD E5 12      [16] 1666         CALL    FPTHL           ; Move value to variable
   077B D1            [ 9] 1667         POP     DE              ; Restore address of variable
   077C E1            [ 9] 1668         POP     HL              ; Restore code string address
   077D C9            [ 9] 1669         RET
                           1670 
   077E CD C8 0F      [16] 1671 ON:     CALL    GETINT          ; Get integer 0-255
   0781 7E            [ 6] 1672         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
   0782 47            [ 4] 1673         LD      B,A             ; Save in B
a  0783               [ 4] 1674         CP      ZGOSUB          ; "GOSUB" token?
   0783 CA 8A 07      [ 9] 1675         JP      Z,ONGO          ; Yes - Find line number
q  0786 CD 0C 00      [16] 1676         CALL    0xCKSYN          ; Make sure it's "GOTO"
o  0789                    1677         DB      ZGOTO           ; "GOTO" token
   0789 2B            [ 4] 1678         DEC     HL              ; Cancel increment
   078A 4B            [ 4] 1679 ONGO:   LD      C,E             ; Integer of branch value
   078B 0D            [ 4] 1680 ONGOLP: DEC     C               ; Count branches
   078C 78            [ 4] 1681         LD      A,B             ; Get "GOTO" or "GOSUB" token
   078D CA 3C 05      [ 9] 1682         JP      Z,ONJMP         ; Go to that line if right one
   0790 CD 71 06      [16] 1683         CALL    GETLN           ; Get line number to DE
a  0793               [16] 1684         CP      ","             ; Another line number?
   0793 C0            [10] 1685         RET     NZ              ; No - Drop through
   0794 C3 8B 07      [ 9] 1686         JP      ONGOLP          ; Yes - loop
                           1687 
   0797 CD 85 09      [16] 1688 IF:     CALL    EVAL            ; Evaluate expression
   079A 7E            [ 6] 1689         LD      A,(HL)          ; Get token
a  079B               [ 6] 1690         CP      ZGOTO           ; "GOTO" token?
   079B CA A2 07      [ 9] 1691         JP      Z,IFGO          ; Yes - Get line
q  079E CD 0C 00      [16] 1692         CALL    0xCKSYN          ; Make sure it's "THEN"
o  07A1                    1693         DB      ZTHEN           ; "THEN" token
   07A1 2B            [ 4] 1694         DEC     HL              ; Cancel increment
   07A2 CD 75 09      [16] 1695 IFGO:   CALL    TSTNUM          ; Make sure it's numeric
   07A5 CD A2 12      [16] 1696         CALL    TSTSGN          ; Test state of expression
   07A8 CA 1A 07      [ 9] 1697         JP      Z,REM           ; False - Drop through
   07AB CD 4B 05      [16] 1698         CALL    GET0xCR          ; Get next character
   07AE DA E3 06      [ 9] 1699         JP      C,GOTO          ; Number - GOTO that line
   07B1 C3 3B 05      [ 9] 1700         JP      IFJMP           ; Otherwise do statement
                           1701 
   07B4 2B            [ 4] 1702 MRPRNT: DEC     HL              ; DEC 'cos GET0xCR INCs
   07B5 CD 4B 05      [16] 1703         CALL    GET0xCR          ; Get next character
   07B8 CA 07 08      [ 9] 1704 PRINT:  JP      Z,PRNTCR        ; CRLF if just PRINT
   07BB C8            [10] 1705 PRNTLP: RET     Z               ; End of list - Exit
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 32.
Hexadecimal [16-Bits]



a  07BC               [10] 1706         CP      ZTAB            ; "TAB(" token?
   07BC CA 31 08      [ 9] 1707         JP      Z,DOTAB         ; Yes - Do TAB routine
a  07BF               [ 9] 1708         CP      ZSPC            ; "SPC(" token?
   07BF CA 31 08      [ 9] 1709         JP      Z,DOTAB         ; Yes - Do SPC routine
   07C2 E5            [11] 1710         PUSH    HL              ; Save code string address
a  07C3               [11] 1711         CP      ","             ; Comma?
   07C3 CA 1C 08      [ 9] 1712         JP      Z,DOCOM         ; Yes - Move to next zone
a  07C6               [ 9] 1713         CP      ";"             ; Semi-colon?
   07C6 CA 4F 08      [ 9] 1714         JP      Z,NEXITM        ; Do semi-colon routine
   07C9 C1            [ 9] 1715         POP     BC              ; Code string address to BC
   07CA CD 85 09      [16] 1716         CALL    EVAL            ; Evaluate expression
   07CD E5            [11] 1717         PUSH    HL              ; Save code string address
   07CE 3A AD 10      [12] 1718         LD      A,(TYPE)        ; Get variable type
   07D1 B7            [ 4] 1719         OR      A               ; Is it a string variable?
   07D2 C2 F8 07      [ 9] 1720         JP      NZ,PRNTST       ; Yes - Output string contents
   07D5 CD 00 14      [16] 1721         CALL    NUMASC          ; Convert number to text
   07D8 CD 5D 0D      [16] 1722         CALL    CRTST           ; Create temporary string
a  07DB               [16] 1723         LD      (HL)," "        ; Followed by a space
   07DB 2A E4 10      [15] 1724         LD      HL,(FPREG)      ; Get length of output
   07DE 34            [10] 1725         INC     (HL)            ; Plus 1 for the space
   07DF 2A E4 10      [15] 1726         LD      HL,(FPREG)      ; < Not needed >
   07E2 3A 42 10      [12] 1727         LD      A,(LWIDTH)      ; Get width of line
   07E5 47            [ 4] 1728         LD      B,A             ; To B
   07E6 04            [ 4] 1729         INC     B               ; Width 255 (No limit)?
   07E7 CA F4 07      [ 9] 1730         JP      Z,PRNTNB        ; Yes - Output number string
   07EA 04            [ 4] 1731         INC     B               ; Adjust it
   07EB 3A AB 10      [12] 1732         LD      A,(CURPOS)      ; Get cursor position
   07EE 86            [ 6] 1733         ADD     A,(HL)          ; Add length of string
   07EF 3D            [ 4] 1734         DEC     A               ; Adjust it
   07F0 B8            [ 4] 1735         CP      B               ; Will output fit on this line?
   07F1 D4 07 08      [16] 1736         CALL    NC,PRNTCR       ; No - CRLF first
   07F4 CD 95 0D      [16] 1737 PRNTNB: CALL    PRS1            ; Output string at (HL)
   07F7 AF            [ 4] 1738         XOR     A               ; Skip CALL by setting "Z" flag
   07F8 C4 95 0D      [16] 1739 PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
   07FB E1            [ 9] 1740         POP     HL              ; Restore code string address
   07FC C3 B4 07      [ 9] 1741         JP      MRPRNT          ; See if more to PRINT
                           1742 
   07FF 3A AB 10      [12] 1743 STTLIN: LD      A,(CURPOS)      ; Make sure on new line
   0802 B7            [ 4] 1744         OR      A               ; Already at start?
   0803 C8            [10] 1745         RET     Z               ; Yes - Do nothing
   0804 C3 07 08      [ 9] 1746         JP      PRNTCR          ; Start a new line
                           1747 
a  0807               [ 9] 1748 ENDINP: LD      (HL),0          ; Mark end of buffer
a  0807               [ 9] 1749         LD      HL,BUFFER-1     ; Point to buffer
a  0807               [ 9] 1750 PRNTCR: LD      A,CR            ; Load a CR
   0807 CD E7 03      [16] 1751         CALL    OUTC            ; Output character
   080A AF            [ 4] 1752 DONULL: XOR     A               ; Set to position 0
   080B 32 AB 10      [13] 1753         LD      (CURPOS),A      ; Store it
   080E 3A 41 10      [12] 1754         LD      A,(NULLS)       ; Get number of nulls
   0811 3D            [ 4] 1755 NULLP:  DEC     A               ; Count them
   0812 C8            [10] 1756         RET     Z               ; Return if done
   0813 F5            [11] 1757         PUSH    AF              ; Save count
   0814 AF            [ 4] 1758         XOR     A               ; Load a null
   0815 CD E7 03      [16] 1759         CALL    OUTC            ; Output it
   0818 F1            [ 9] 1760         POP     AF              ; Restore count
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 33.
Hexadecimal [16-Bits]



   0819 C3 11 08      [ 9] 1761         JP      NULLP           ; Keep counting
                           1762 
   081C 3A 43 10      [12] 1763 DOCOM:  LD      A,(COMMAN)      ; Get comma width
   081F 47            [ 4] 1764         LD      B,A             ; Save in B
   0820 3A AB 10      [12] 1765         LD      A,(CURPOS)      ; Get current position
   0823 B8            [ 4] 1766         CP      B               ; Within the limit?
   0824 D4 07 08      [16] 1767         CALL    NC,PRNTCR       ; No - output CRLF
   0827 D2 4F 08      [ 9] 1768         JP      NC,NEXITM       ; Get next item
a  082A               [ 9] 1769 ZONELP: SUB     14              ; Next zone of 14 characters
   082A D2 2A 08      [ 9] 1770         JP      NC,ZONELP       ; Repeat if more zones
   082D 2F            [ 3] 1771         CPL                     ; Number of spaces to output
   082E C3 46 08      [ 9] 1772         JP      ASPCS           ; Output them
                           1773 
   0831 F5            [11] 1774 DOTAB:  PUSH    AF              ; Save token
   0832 CD C5 0F      [16] 1775         CALL    FNDNUM          ; Evaluate expression
q  0835 CD 0C 00      [16] 1776         CALL    0xCKSYN          ; Make sure ")" follows
q                          1777         DB      ")"
   0838 2B            [ 4] 1778         DEC     HL              ; Back space on to ")"
   0839 F1            [ 9] 1779         POP     AF              ; Restore token
a  083A               [ 9] 1780         SUB     ZSPC            ; Was it "SPC(" ?
   083A E5            [11] 1781         PUSH    HL              ; Save code string address
   083B CA 41 08      [ 9] 1782         JP      Z,DOSPC         ; Yes - Do "E" spaces
   083E 3A AB 10      [12] 1783         LD      A,(CURPOS)      ; Get current position
   0841 2F            [ 3] 1784 DOSPC:  CPL                     ; Number of spaces to print to
   0842 83            [ 4] 1785         ADD     A,E             ; Total number to print
   0843 D2 4F 08      [ 9] 1786         JP      NC,NEXITM       ; TAB < Current POS(X)
   0846 3C            [ 4] 1787 ASPCS:  INC     A               ; Output A spaces
   0847 47            [ 4] 1788         LD      B,A             ; Save number to print
a  0848               [ 4] 1789         LD      A," "           ; Space
   0848 CD E7 03      [16] 1790 SPCLP:  CALL    OUTC            ; Output character in A
   084B 05            [ 4] 1791         DEC     B               ; Count them
   084C C2 48 08      [ 9] 1792         JP      NZ,SPCLP        ; Repeat if more
   084F E1            [ 9] 1793 NEXITM: POP     HL              ; Restore code string address
   0850 CD 4B 05      [16] 1794         CALL    GET0xCR          ; Get next character
   0853 C3 BB 07      [ 9] 1795         JP      PRNTLP          ; More to print
                           1796 
q  0856                    1797 REDO:   DB      "?Redo from start",CR,LF,0
                           1798 
   0856 3A CD 10      [12] 1799 BADINP: LD      A,(READFG)      ; READ or INPUT?
   0859 B7            [ 4] 1800         OR      A
   085A C2 80 01      [ 9] 1801         JP      NZ,DATSNR       ; READ - ?SN Error
   085D C1            [ 9] 1802         POP     BC              ; Throw away code string addr
a  085E               [ 9] 1803         LD      HL,REDO         ; "Redo from start" message
   085E CD 92 0D      [16] 1804         CALL    PRS             ; Output string
   0861 C3 A5 02      [ 9] 1805         JP      DOAGN           ; Do last INPUT again
                           1806 
   0864 CD 18 0D      [16] 1807 INPUT:  CALL    IDTEST          ; Test for illegal direct
   0867 7E            [ 6] 1808         LD      A,(HL)          ; Get character after "INPUT"
a  0868               [ 6] 1809         CP      '"'             ; Is there a prompt string?
a  0868               [ 6] 1810         LD      A,0             ; Clear A and leave flags
   0868 32 45 10      [13] 1811         LD      (CTLOFG),A      ; Enable output
   086B C2 78 08      [ 9] 1812         JP      NZ,NOPMPT       ; No prompt - get input
   086E CD 5E 0D      [16] 1813         CALL    QTSTR           ; Get string terminated by '"'
q  0871 CD 0C 00      [16] 1814         CALL    0xCKSYN          ; Check for ";" after prompt
q                          1815         DB      ";"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 34.
Hexadecimal [16-Bits]



   0874 E5            [11] 1816         PUSH    HL              ; Save code string address
   0875 CD 95 0D      [16] 1817         CALL    PRS1            ; Output prompt string
q                          1818         DB      0x3E             ; Skip "PUSH HL"
   0878 E5            [11] 1819 NOPMPT: PUSH    HL              ; Save code string address
   0879 CD A9 02      [16] 1820         CALL    PROMPT          ; Get input with "? " prompt
   087C C1            [ 9] 1821         POP     BC              ; Restore code string address
   087D DA 80 05      [ 9] 1822         JP      C,INPBRK        ; Break pressed - Exit
   0880 23            [ 4] 1823         INC     HL              ; Next byte
   0881 7E            [ 6] 1824         LD      A,(HL)          ; Get it
   0882 B7            [ 4] 1825         OR      A               ; End of line?
   0883 2B            [ 4] 1826         DEC     HL              ; Back again
   0884 C5            [11] 1827         PUSH    BC              ; Re-save code string address
   0885 CA 19 07      [ 9] 1828         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
a  0888               [ 9] 1829         LD      (HL),","        ; Store comma as separator
   0888 C3 8F 08      [ 9] 1830         JP      NXTITM          ; Get next item
                           1831 
   088B E5            [11] 1832 READ:   PUSH    HL              ; Save code string address
   088C 2A DC 10      [15] 1833         LD      HL,(NXTDAT)     ; Next DATA statement
q                          1834         DB      0x0F6            ; Flag "READ"
   088F AF            [ 4] 1835 NXTITM: XOR     A               ; Flag "INPUT"
   0890 32 CD 10      [13] 1836         LD      (READFG),A      ; Save "READ"/"INPUT" flag
   0893 E3            [16] 1837         EX      (SP),HL         ; Get code str' , Save pointer
   0894 C3 9A 08      [ 9] 1838         JP      GTVLUS          ; Get values
                           1839 
q  0897 CD 0C 00      [16] 1840 NEDMOR: CALL    0xCKSYN          ; Check for comma between items
q                          1841         DB      ","
   089A CD 01 0B      [16] 1842 GTVLUS: CALL    GETVAR          ; Get variable name
   089D E3            [16] 1843         EX      (SP),HL         ; Save code str" , Get pointer
   089E D5            [11] 1844         PUSH    DE              ; Save variable address
   089F 7E            [ 6] 1845         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
a  08A0               [ 6] 1846         CP      ","             ; Comma?
   08A0 CA BE 08      [ 9] 1847         JP      Z,ANTVLU        ; Yes - Get another value
   08A3 3A CD 10      [12] 1848         LD      A,(READFG)      ; Is it READ?
   08A6 B7            [ 4] 1849         OR      A
   08A7 C2 0C 09      [ 9] 1850         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
a  08AA               [ 9] 1851         LD      A,"?"           ; More INPUT needed
   08AA CD E7 03      [16] 1852         CALL    OUTC            ; Output character
   08AD CD A9 02      [16] 1853         CALL    PROMPT          ; Get INPUT with prompt
   08B0 D1            [ 9] 1854         POP     DE              ; Variable address
   08B1 C1            [ 9] 1855         POP     BC              ; Code string address
   08B2 DA 80 05      [ 9] 1856         JP      C,INPBRK        ; Break pressed
   08B5 23            [ 4] 1857         INC     HL              ; Point to next DATA byte
   08B6 7E            [ 6] 1858         LD      A,(HL)          ; Get byte
   08B7 B7            [ 4] 1859         OR      A               ; Is it zero (No input) ?
   08B8 2B            [ 4] 1860         DEC     HL              ; Back space INPUT pointer
   08B9 C5            [11] 1861         PUSH    BC              ; Save code string address
   08BA CA 19 07      [ 9] 1862         JP      Z,NXTDTA        ; Find end of buffer
   08BD D5            [11] 1863         PUSH    DE              ; Save variable address
   08BE 3A AD 10      [12] 1864 ANTVLU: LD      A,(TYPE)        ; Check data type
   08C1 B7            [ 4] 1865         OR      A               ; Is it numeric?
   08C2 CA DF 08      [ 9] 1866         JP      Z,INPBIN        ; Yes - Convert to binary
   08C5 CD 4B 05      [16] 1867         CALL    GET0xCR          ; Get next character
   08C8 57            [ 4] 1868         LD      D,A             ; Save input character
   08C9 47            [ 4] 1869         LD      B,A             ; Again
a  08CA               [ 4] 1870         CP      '"'             ; Start of literal sting?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 35.
Hexadecimal [16-Bits]



   08CA CA D6 08      [ 9] 1871         JP      Z,STRENT        ; Yes - Create string entry
   08CD 3A CD 10      [12] 1872         LD      A,(READFG)      ; "READ" or "INPUT" ?
   08D0 B7            [ 4] 1873         OR      A
   08D1 57            [ 4] 1874         LD      D,A             ; Save 00 if "INPUT"
   08D2 CA D5 08      [ 9] 1875         JP      Z,ITMSEP        ; "INPUT" - End with 00
a  08D5               [ 9] 1876         LD      D,":"           ; "DATA" - End with 00 or ":"
a  08D5               [ 9] 1877 ITMSEP: LD      B,","           ; Item separator
   08D5 2B            [ 4] 1878         DEC     HL              ; Back space for DTSTR
   08D6 CD 5F 0D      [16] 1879 STRENT: CALL    DTSTR           ; Get string terminated by D
   08D9 EB            [ 3] 1880         EX      DE,HL           ; String address to DE
a  08DA               [ 3] 1881         LD      HL,LTSTND       ; Where to go after LETSTR
   08DA E3            [16] 1882         EX      (SP),HL         ; Save HL , get input pointer
   08DB D5            [11] 1883         PUSH    DE              ; Save address of string
   08DC C3 43 07      [ 9] 1884         JP      LETSTR          ; Assign string to variable
                           1885 
   08DF CD 4B 05      [16] 1886 INPBIN: CALL    GET0xCR          ; Get next character
   08E2 CD 76 13      [16] 1887         CALL    ASCTFP          ; Convert ASCII to FP number
   08E5 E3            [16] 1888         EX      (SP),HL         ; Save input ptr, Get var addr
   08E6 CD E5 12      [16] 1889         CALL    FPTHL           ; Move FPREG to variable
   08E9 E1            [ 9] 1890         POP     HL              ; Restore input pointer
   08EA 2B            [ 4] 1891 LTSTND: DEC     HL              ; DEC 'cos GET0xCR INCs
   08EB CD 4B 05      [16] 1892         CALL    GET0xCR          ; Get next character
   08EE CA F4 08      [ 9] 1893         JP      Z,MORDT         ; End of line - More needed?
a  08F1               [ 9] 1894         CP      ","             ; Another value?
   08F1 C2 56 08      [ 9] 1895         JP      NZ,BADINP       ; No - Bad input
   08F4 E3            [16] 1896 MORDT:  EX      (SP),HL         ; Get code string address
   08F5 2B            [ 4] 1897         DEC     HL              ; DEC 'cos GET0xCR INCs
   08F6 CD 4B 05      [16] 1898         CALL    GET0xCR          ; Get next character
   08F9 C2 97 08      [ 9] 1899         JP      NZ,NEDMOR       ; More needed - Get it
   08FC D1            [ 9] 1900         POP     DE              ; Restore DATA pointer
   08FD 3A CD 10      [12] 1901         LD      A,(READFG)      ; "READ" or "INPUT" ?
   0900 B7            [ 4] 1902         OR      A
   0901 EB            [ 3] 1903         EX      DE,HL           ; DATA pointer to HL
   0902 C2 6B 05      [ 9] 1904         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
   0905 D5            [11] 1905         PUSH    DE              ; Save code string address
   0906 B6            [ 6] 1906         OR      (HL)            ; More input given?
a  0907               [ 6] 1907         LD      HL,EXTIG        ; "?Extra ignored" message
   0907 C4 92 0D      [16] 1908         CALL    NZ,PRS          ; Output string if extra given
   090A E1            [ 9] 1909         POP     HL              ; Restore code string address
   090B C9            [ 9] 1910         RET
                           1911 
q  090C                    1912 EXTIG:  DB      "?Extra ignored",CR,LF,0
                           1913 
   090C CD 1A 07      [16] 1914 FDTLP:  CALL    DATA            ; Get next statement
   090F B7            [ 4] 1915         OR      A               ; End of line?
   0910 C2 23 09      [ 9] 1916         JP      NZ,FANDT        ; No - See if DATA statement
   0913 23            [ 4] 1917         INC     HL
   0914 7E            [ 6] 1918         LD      A,(HL)          ; End of program?
   0915 23            [ 4] 1919         INC     HL
   0916 B6            [ 6] 1920         OR      (HL)            ; 00 00 Ends program
a  0917               [ 6] 1921         LD      E,OD            ; ?OD Error
   0917 CA 86 01      [ 9] 1922         JP      Z,ERROR         ; Yes - Out of DATA
   091A 23            [ 4] 1923         INC     HL
   091B 5E            [ 6] 1924         LD      E,(HL)          ; LSB of line number
   091C 23            [ 4] 1925         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 36.
Hexadecimal [16-Bits]



   091D 56            [ 6] 1926         LD      D,(HL)          ; MSB of line number
   091E EB            [ 3] 1927         EX      DE,HL
   091F 22 C9 10      [16] 1928         LD      (DATLIN),HL     ; Set line of current DATA item
   0922 EB            [ 3] 1929         EX      DE,HL
   0923 CD 4B 05      [16] 1930 FANDT:  CALL    GET0xCR          ; Get next character
a  0926               [16] 1931         CP      ZDATA           ; "DATA" token
   0926 C2 0C 09      [ 9] 1932         JP      NZ,FDTLP        ; No "DATA" - Keep looking
   0929 C3 BE 08      [ 9] 1933         JP      ANTVLU          ; Found - Convert input
                           1934 
a  092C               [ 9] 1935 NEXT:   LD      DE,0            ; In case no index given
   092C C4 01 0B      [16] 1936 NEXT1:  CALL    NZ,GETVAR       ; Get index address
   092F 22 CE 10      [16] 1937         LD      (BRKLIN),HL     ; Save code string address
   0932 CD 41 01      [16] 1938         CALL    BAKSTK          ; Look for "FOR" block
   0935 C2 86 01      [ 9] 1939         JP      NZ,NFERR        ; No "FOR" - ?NF Error
   0938 F9            [ 4] 1940         LD      SP,HL           ; Clear nested loops
   0939 D5            [11] 1941         PUSH    DE              ; Save index address
   093A 7E            [ 6] 1942         LD      A,(HL)          ; Get sign of STEP
   093B 23            [ 4] 1943         INC     HL
   093C F5            [11] 1944         PUSH    AF              ; Save sign of STEP
   093D D5            [11] 1945         PUSH    DE              ; Save index address
   093E CD CE 12      [16] 1946         CALL    PHLTFP          ; Move index value to FPREG
   0941 E3            [16] 1947         EX      (SP),HL         ; Save address of TO value
   0942 E5            [11] 1948         PUSH    HL              ; Save address of index
   0943 CD C3 10      [16] 1949         CALL    ADDPHL          ; Add STEP to index value
   0946 E1            [ 9] 1950         POP     HL              ; Restore address of index
   0947 CD E5 12      [16] 1951         CALL    FPTHL           ; Move value to index variable
   094A E1            [ 9] 1952         POP     HL              ; Restore address of TO value
   094B CD DC 12      [16] 1953         CALL    LOADFP          ; Move TO value to BCDE
   094E E5            [11] 1954         PUSH    HL              ; Save address of line of FOR
   094F CD 00 13      [16] 1955         CALL    CMPNUM          ; Compare index with TO value
   0952 E1            [ 9] 1956         POP     HL              ; Restore address of line num
   0953 C1            [ 9] 1957         POP     BC              ; Address of sign of STEP
   0954 90            [ 4] 1958         SUB     B               ; Compare with expected sign
   0955 CD DC 12      [16] 1959         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
   0958 CA 64 09      [ 9] 1960         JP      Z,KILFOR        ; Loop finished - Terminate it
   095B EB            [ 3] 1961         EX      DE,HL           ; Loop statement line number
   095C 22 5C 10      [16] 1962         LD      (LINEAT),HL     ; Set loop line number
   095F 69            [ 4] 1963         LD      L,C             ; Set code string to loop
   0960 60            [ 4] 1964         LD      H,B
   0961 C3 13 05      [ 9] 1965         JP      PUTFID          ; Put back "FOR" and continue
                           1966 
   0964 F9            [ 4] 1967 KILFOR: LD      SP,HL           ; Remove "FOR" block
   0965 2A CE 10      [15] 1968         LD      HL,(BRKLIN)     ; Code string after "NEXT"
   0968 7E            [ 6] 1969         LD      A,(HL)          ; Get next byte in code string
a  0969               [ 6] 1970         CP      ","             ; More NEXTs ?
   0969 C2 15 05      [ 9] 1971         JP      NZ,RUNCNT       ; No - Do next statement
   096C CD 4B 05      [16] 1972         CALL    GET0xCR          ; Position to index name
   096F CD 2C 09      [16] 1973         CALL    NEXT1           ; Re-enter NEXT routine
                           1974 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           1975 
   0972 CD 85 09      [16] 1976 GETNUM: CALL    EVAL            ; Get a numeric expression
q  0975                    1977 TSTNUM: DB      0x0F6            ; Clear carry (numeric)
   0975 37            [ 3] 1978 TSTSTR: SCF                     ; Set carry (string)
q                          1979 0xCKTYP: LD      A,(TYPE)        ; Check types match
   0976 8F            [ 4] 1980         ADC     A,A             ; Expected + actual
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 37.
Hexadecimal [16-Bits]



   0977 B7            [ 4] 1981         OR      A               ; Clear carry , set parity
   0978 E8            [10] 1982         RET     PE              ; Even parity - Types match
   0979 C3 86 01      [ 9] 1983         JP      TMERR           ; Different types - Error
                           1984 
                           1985 ; <<< NO REFERENCE TO HERE >>>
                           1986 
q  097C CD 0C 00      [16] 1987         CALL    0xCKSYN          ; Make sure "=" follows
o  097F                    1988         DB      ZEQUAL          ; "="
   097F C3 85 09      [ 9] 1989         JP      EVAL            ; Evaluate expression
                           1990 
q  0982 CD 0C 00      [16] 1991 OPNPAR: CALL    0xCKSYN          ; Make sure "(" follows
q                          1992         DB      "("
   0985 2B            [ 4] 1993 EVAL:   DEC     HL              ; Evaluate expression & save
a  0986               [ 4] 1994         LD      D,0             ; Precedence value
   0986 D5            [11] 1995 EVAL1:  PUSH    DE              ; Save precedence
a  0987               [11] 1996         LD      C,1
q  0987 CD 0C 00      [16] 1997         CALL    0xCKSTK          ; Check for 1 level of stack
   098A CD E4 09      [16] 1998         CALL    OPRND           ; Get next expression value
   098D 22 D0 10      [16] 1999 EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
   0990 2A D0 10      [15] 2000 EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
   0993 C1            [ 9] 2001         POP     BC              ; Precedence value and operator
   0994 78            [ 4] 2002         LD      A,B             ; Get precedence value
a  0995               [ 4] 2003         CP      0x78             ; "AND" or "OR" ?
   0995 D4 75 09      [16] 2004         CALL    NC,TSTNUM       ; No - Make sure it's a number
   0998 7E            [ 6] 2005         LD      A,(HL)          ; Get next operator / function
a  0999               [ 6] 2006         LD      D,0             ; Clear Last relation
a  0999               [ 6] 2007 RLTLP:  SUB     ZGTR            ; ">" Token
   0999 DA AF 09      [ 9] 2008         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
a  099C               [ 9] 2009         CP      ZLTH+1-ZGTR     ; < = >
   099C D2 AF 09      [ 9] 2010         JP      NC,FOPRND       ; Function - Call it
a  099F               [ 9] 2011         CP      ZEQUAL-ZGTR     ; "="
   099F 17            [ 3] 2012         RLA                     ; <- Test for legal
   09A0 AA            [ 4] 2013         XOR     D               ; <- combinations of < = >
   09A1 BA            [ 4] 2014         CP      D               ; <- by combining last token
   09A2 57            [ 4] 2015         LD      D,A             ; <- with current one
   09A3 DA 86 01      [ 9] 2016         JP      C,SNERR         ; Error if "<<" "==" or ">>"
   09A6 22 C5 10      [16] 2017         LD      (CUROPR),HL     ; Save address of current token
   09A9 CD 4B 05      [16] 2018         CALL    GET0xCR          ; Get next character
   09AC C3 99 09      [ 9] 2019         JP      RLTLP           ; Treat the two as one
                           2020 
   09AF 7A            [ 4] 2021 FOPRND: LD      A,D             ; < = > found ?
   09B0 B7            [ 4] 2022         OR      A
   09B1 C2 8F 0A      [ 9] 2023         JP      NZ,TSTRED       ; Yes - Test for reduction
   09B4 7E            [ 6] 2024         LD      A,(HL)          ; Get operator token
   09B5 22 C5 10      [16] 2025         LD      (CUROPR),HL     ; Save operator address
a  09B8               [16] 2026         SUB     ZPLUS           ; Operator or function?
   09B8 D8            [10] 2027         RET     C               ; Neither - Exit
a  09B9               [10] 2028         CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
   09B9 D0            [10] 2029         RET     NC              ; No - Exit
   09BA 5F            [ 4] 2030         LD      E,A             ; Coded operator
   09BB 3A AD 10      [12] 2031         LD      A,(TYPE)        ; Get data type
   09BE 3D            [ 4] 2032         DEC     A               ; FF = numeric , 00 = string
   09BF B3            [ 4] 2033         OR      E               ; Combine with coded operator
   09C0 7B            [ 4] 2034         LD      A,E             ; Get coded operator
   09C1 CA 6C 0E      [ 9] 2035         JP      Z,CONCAT        ; String concatenation
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 38.
Hexadecimal [16-Bits]



   09C4 07            [ 3] 2036         RLCA                    ; Times 2
   09C5 83            [ 4] 2037         ADD     A,E             ; Times 3
   09C6 5F            [ 4] 2038         LD      E,A             ; To DE (D is 0)
a  09C7               [ 4] 2039         LD      HL,PRITAB       ; Precedence table
   09C7 19            [ 7] 2040         ADD     HL,DE           ; To the operator concerned
   09C8 78            [ 4] 2041         LD      A,B             ; Last operator precedence
   09C9 56            [ 6] 2042         LD      D,(HL)          ; Get evaluation precedence
   09CA BA            [ 4] 2043         CP      D               ; Compare with eval precedence
   09CB D0            [10] 2044         RET     NC              ; Exit if higher precedence
   09CC 23            [ 4] 2045         INC     HL              ; Point to routine address
   09CD CD 75 09      [16] 2046         CALL    TSTNUM          ; Make sure it's a number
                           2047 
   09D0 C5            [11] 2048 STKTHS: PUSH    BC              ; Save last precedence & token
a  09D1               [11] 2049         LD      BC,EVAL3        ; Where to go on prec' break
   09D1 C5            [11] 2050         PUSH    BC              ; Save on stack for return
   09D2 43            [ 4] 2051         LD      B,E             ; Save operator
   09D3 4A            [ 4] 2052         LD      C,D             ; Save precedence
   09D4 CD C1 12      [16] 2053         CALL    STAKFP          ; Move value to stack
   09D7 58            [ 4] 2054         LD      E,B             ; Restore operator
   09D8 51            [ 4] 2055         LD      D,C             ; Restore precedence
   09D9 4E            [ 6] 2056         LD      C,(HL)          ; Get LSB of routine address
   09DA 23            [ 4] 2057         INC     HL
   09DB 46            [ 6] 2058         LD      B,(HL)          ; Get MSB of routine address
   09DC 23            [ 4] 2059         INC     HL
   09DD C5            [11] 2060         PUSH    BC              ; Save routine address
   09DE 2A C5 10      [15] 2061         LD      HL,(CUROPR)     ; Address of current operator
   09E1 C3 86 09      [ 9] 2062         JP      EVAL1           ; Loop until prec' break
                           2063 
   09E4 AF            [ 4] 2064 OPRND:  XOR     A               ; Get operand routine
   09E5 32 AD 10      [13] 2065         LD      (TYPE),A        ; Set numeric expected
   09E8 CD 4B 05      [16] 2066         CALL    GET0xCR          ; Get next character
a  09EB               [16] 2067         LD      E,MO            ; ?MO Error
   09EB CA 86 01      [ 9] 2068         JP      Z,ERROR         ; No operand - Error
   09EE DA 76 13      [ 9] 2069         JP      C,ASCTFP        ; Number - Get value
q  09F1 CD 0C 00      [16] 2070         CALL    0xCKLTR          ; See if a letter
   09F4 D2 22 0A      [ 9] 2071         JP      NC,CONVAR       ; Letter - Find variable
a  09F7               [ 9] 2072         CP      ZPLUS           ; "+" Token ?
   09F7 CA E4 09      [ 9] 2073         JP      Z,OPRND         ; Yes - Look for operand
a  09FA               [ 9] 2074         CP      "."             ; "." ?
   09FA CA 76 13      [ 9] 2075         JP      Z,ASCTFP        ; Yes - Create FP number
a  09FD               [ 9] 2076         CP      ZMINUS          ; "-" Token ?
   09FD CA 13 0A      [ 9] 2077         JP      Z,MINUS         ; Yes - Do minus
a  0A00               [ 9] 2078         CP      '"'             ; Literal string ?
   0A00 CA 5E 0D      [ 9] 2079         JP      Z,QTSTR         ; Get string terminated by '"'
a  0A03               [ 9] 2080         CP      ZNOT            ; "NOT" Token ?
   0A03 CA E3 0A      [ 9] 2081         JP      Z,EVNOT         ; Yes - Eval NOT expression
a  0A06               [ 9] 2082         CP      ZFN             ; "FN" Token ?
   0A06 CA D3 0C      [ 9] 2083         JP      Z,DOFN          ; Yes - Do FN routine
a  0A09               [ 9] 2084         SUB     ZSGN            ; Is it a function?
   0A09 D2 33 0A      [ 9] 2085         JP      NC,FNOFST       ; Yes - Evaluate function
   0A0C CD 82 09      [16] 2086 EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
q  0A0F CD 0C 00      [16] 2087         CALL    0xCKSYN          ; Make sure ")" follows
q                          2088         DB      ")"
   0A12 C9            [ 9] 2089         RET
                           2090 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 39.
Hexadecimal [16-Bits]



a  0A13               [ 9] 2091 MINUS:  LD      D,0x7D           ; "-" precedence
   0A13 CD 86 09      [16] 2092         CALL    EVAL1           ; Evaluate until prec' break
   0A16 2A D0 10      [15] 2093         LD      HL,(NXTOPR)     ; Get next operator address
   0A19 E5            [11] 2094         PUSH    HL              ; Save next operator address
   0A1A CD BE 12      [16] 2095         CALL    INVSGN          ; Negate value
   0A1D CD 75 09      [16] 2096 RETNUM: CALL    TSTNUM          ; Make sure it's a number
   0A20 E1            [ 9] 2097         POP     HL              ; Restore next operator address
   0A21 C9            [ 9] 2098         RET
                           2099 
   0A22 CD 01 0B      [16] 2100 CONVAR: CALL    GETVAR          ; Get variable address to DE
   0A25 E5            [11] 2101 FRMEVL: PUSH    HL              ; Save code string address
   0A26 EB            [ 3] 2102         EX      DE,HL           ; Variable address to HL
   0A27 22 E4 10      [16] 2103         LD      (FPREG),HL      ; Save address of variable
   0A2A 3A AD 10      [12] 2104         LD      A,(TYPE)        ; Get type
   0A2D B7            [ 4] 2105         OR      A               ; Numeric?
   0A2E CC CE 12      [16] 2106         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
   0A31 E1            [ 9] 2107         POP     HL              ; Restore code string address
   0A32 C9            [ 9] 2108         RET
                           2109 
a  0A33               [ 9] 2110 FNOFST: LD      B,0             ; Get address of function
   0A33 07            [ 3] 2111         RLCA                    ; Double function offset
   0A34 4F            [ 4] 2112         LD      C,A             ; BC = Offset in function table
   0A35 C5            [11] 2113         PUSH    BC              ; Save adjusted token value
   0A36 CD 4B 05      [16] 2114         CALL    GET0xCR          ; Get next character
   0A39 79            [ 4] 2115         LD      A,C             ; Get adjusted token value
a  0A3A               [ 4] 2116         CP      2*(ZPOINT-ZSGN) ; Adjusted "POINT" token?
   0A3A CA 21 18      [ 9] 2117         JP      Z,POINTB        ; Yes - Do "POINT" (not POINTB)
a  0A3D               [ 9] 2118         CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
   0A3D DA 58 0A      [ 9] 2119         JP      C,FNVAL         ; No - Do function
   0A40 CD 82 09      [16] 2120         CALL    OPNPAR          ; Evaluate expression  (X,...
q  0A43 CD 0C 00      [16] 2121         CALL    0xCKSYN          ; Make sure "," follows
q                          2122         DB      ","
   0A46 CD 75 09      [16] 2123         CALL    TSTSTR          ; Make sure it's a string
   0A49 EB            [ 3] 2124         EX      DE,HL           ; Save code string address
   0A4A 2A E4 10      [15] 2125         LD      HL,(FPREG)      ; Get address of string
   0A4D E3            [16] 2126         EX      (SP),HL         ; Save address of string
   0A4E E5            [11] 2127         PUSH    HL              ; Save adjusted token value
   0A4F EB            [ 3] 2128         EX      DE,HL           ; Restore code string address
   0A50 CD C8 0F      [16] 2129         CALL    GETINT          ; Get integer 0-255
   0A53 EB            [ 3] 2130         EX      DE,HL           ; Save code string address
   0A54 E3            [16] 2131         EX      (SP),HL         ; Save integer,HL = adj' token
   0A55 C3 5D 0A      [ 9] 2132         JP      GOFUNC          ; Jump to string function
                           2133 
   0A58 CD 0C 0A      [16] 2134 FNVAL:  CALL    EVLPAR          ; Evaluate expression
   0A5B E3            [16] 2135         EX      (SP),HL         ; HL = Adjusted token value
a  0A5C               [16] 2136         LD      DE,RETNUM       ; Return number from function
   0A5C D5            [11] 2137         PUSH    DE              ; Save on stack
a  0A5D               [11] 2138 GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
   0A5D 09            [ 7] 2139         ADD     HL,BC           ; Point to right address
   0A5E 4E            [ 6] 2140         LD      C,(HL)          ; Get LSB of address
   0A5F 23            [ 4] 2141         INC     HL              ;
   0A60 66            [ 6] 2142         LD      H,(HL)          ; Get MSB of address
   0A61 69            [ 4] 2143         LD      L,C             ; Address to HL
   0A62 E9            [ 3] 2144         JP      (HL)            ; Jump to function
                           2145 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 40.
Hexadecimal [16-Bits]



   0A63 15            [ 4] 2146 SGNEXP: DEC     D               ; Dee to flag negative exponent
a  0A64               [ 4] 2147         CP      ZMINUS          ; "-" token ?
   0A64 C8            [10] 2148         RET     Z               ; Yes - Return
a  0A65               [10] 2149         CP      "-"             ; "-" ASCII ?
   0A65 C8            [10] 2150         RET     Z               ; Yes - Return
   0A66 14            [ 4] 2151         INC     D               ; Inc to flag positive exponent
a  0A67               [ 4] 2152         CP      "+"             ; "+" ASCII ?
   0A67 C8            [10] 2153         RET     Z               ; Yes - Return
a  0A68               [10] 2154         CP      ZPLUS           ; "+" token ?
   0A68 C8            [10] 2155         RET     Z               ; Yes - Return
   0A69 2B            [ 4] 2156         DEC     HL              ; DEC 'cos GET0xCR INCs
   0A6A C9            [ 9] 2157         RET                     ; Return "NZ"
                           2158 
q  0A6B                    2159 POR:    DB      0x0F6            ; Flag "OR"
   0A6B AF            [ 4] 2160 PAND:   XOR     A               ; Flag "AND"
   0A6C F5            [11] 2161         PUSH    AF              ; Save "AND" / "OR" flag
   0A6D CD 75 09      [16] 2162         CALL    TSTNUM          ; Make sure it's a number
   0A70 CD 60 06      [16] 2163         CALL    DEINT           ; Get integer -32768 to 32767
   0A73 F1            [ 9] 2164         POP     AF              ; Restore "AND" / "OR" flag
   0A74 EB            [ 3] 2165         EX      DE,HL           ; <- Get last
   0A75 C1            [ 9] 2166         POP     BC              ; <-  value
   0A76 E3            [16] 2167         EX      (SP),HL         ; <-  from
   0A77 EB            [ 3] 2168         EX      DE,HL           ; <-  stack
   0A78 CD D1 12      [16] 2169         CALL    FPBCDE          ; Move last value to FPREG
   0A7B F5            [11] 2170         PUSH    AF              ; Save "AND" / "OR" flag
   0A7C CD 60 06      [16] 2171         CALL    DEINT           ; Get integer -32768 to 32767
   0A7F F1            [ 9] 2172         POP     AF              ; Restore "AND" / "OR" flag
   0A80 C1            [ 9] 2173         POP     BC              ; Get value
   0A81 79            [ 4] 2174         LD      A,C             ; Get LSB
a  0A82               [ 4] 2175         LD      HL,ACPASS       ; Address of save AC as current
   0A82 C2 8A 0A      [ 9] 2176         JP      NZ,POR1         ; Jump if OR
   0A85 A3            [ 4] 2177         AND     E               ; "AND" LSBs
   0A86 4F            [ 4] 2178         LD      C,A             ; Save LSB
   0A87 78            [ 4] 2179         LD      A,B             ; Get MBS
   0A88 A2            [ 4] 2180         AND     D               ; "AND" MSBs
   0A89 E9            [ 3] 2181         JP      (HL)            ; Save AC as current (ACPASS)
                           2182 
   0A8A B3            [ 4] 2183 POR1:   OR      E               ; "OR" LSBs
   0A8B 4F            [ 4] 2184         LD      C,A             ; Save LSB
   0A8C 78            [ 4] 2185         LD      A,B             ; Get MSB
   0A8D B2            [ 4] 2186         OR      D               ; "OR" MSBs
   0A8E E9            [ 3] 2187         JP      (HL)            ; Save AC as current (ACPASS)
                           2188 
a  0A8F               [ 3] 2189 TSTRED: LD      HL,CMPLOG       ; Logical compare routine
   0A8F 3A AD 10      [12] 2190         LD      A,(TYPE)        ; Get data type
   0A92 1F            [ 3] 2191         RRA                     ; Carry set = string
   0A93 7A            [ 4] 2192         LD      A,D             ; Get last precedence value
   0A94 17            [ 3] 2193         RLA                     ; Times 2 plus carry
   0A95 5F            [ 4] 2194         LD      E,A             ; To E
a  0A96               [ 4] 2195         LD      D,0x64           ; Relational precedence
   0A96 78            [ 4] 2196         LD      A,B             ; Get current precedence
   0A97 BA            [ 4] 2197         CP      D               ; Compare with last
   0A98 D0            [10] 2198         RET     NC              ; Eval if last was rel' or log'
   0A99 C3 D0 09      [ 9] 2199         JP      STKTHS          ; Stack this one and get next
                           2200 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 41.
Hexadecimal [16-Bits]



   0A9C 9E 0A              2201 CMPLOG: .dw      CMPLG1          ; Compare two values / strings
   0A9E 79            [ 4] 2202 CMPLG1: LD      A,C             ; Get data type
   0A9F B7            [ 4] 2203         OR      A
   0AA0 1F            [ 3] 2204         RRA
   0AA1 C1            [ 9] 2205         POP     BC              ; Get last expression to BCDE
   0AA2 D1            [ 9] 2206         POP     DE
   0AA3 F5            [11] 2207         PUSH    AF              ; Save status
q  0AA4 CD 0C 00      [16] 2208         CALL    0xCKTYP          ; Check that types match
a  0AA7               [16] 2209         LD      HL,CMPRES       ; Result to comparison
   0AA7 E5            [11] 2210         PUSH    HL              ; Save for RETurn
   0AA8 CA 00 13      [ 9] 2211         JP      Z,CMPNUM        ; Compare values if numeric
   0AAB AF            [ 4] 2212         XOR     A               ; Compare two strings
   0AAC 32 AD 10      [13] 2213         LD      (TYPE),A        ; Set type to numeric
   0AAF D5            [11] 2214         PUSH    DE              ; Save string name
   0AB0 CD B4 0E      [16] 2215         CALL    GSTRCU          ; Get current string
   0AB3 7E            [ 6] 2216         LD      A,(HL)          ; Get length of string
   0AB4 23            [ 4] 2217         INC     HL
   0AB5 23            [ 4] 2218         INC     HL
   0AB6 4E            [ 6] 2219         LD      C,(HL)          ; Get LSB of address
   0AB7 23            [ 4] 2220         INC     HL
   0AB8 46            [ 6] 2221         LD      B,(HL)          ; Get MSB of address
   0AB9 D1            [ 9] 2222         POP     DE              ; Restore string name
   0ABA C5            [11] 2223         PUSH    BC              ; Save address of string
   0ABB F5            [11] 2224         PUSH    AF              ; Save length of string
   0ABC CD B8 0E      [16] 2225         CALL    GSTRDE          ; Get second string
   0ABF CD DC 12      [16] 2226         CALL    LOADFP          ; Get address of second string
   0AC2 F1            [ 9] 2227         POP     AF              ; Restore length of string 1
   0AC3 57            [ 4] 2228         LD      D,A             ; Length to D
   0AC4 E1            [ 9] 2229         POP     HL              ; Restore address of string 1
   0AC5 7B            [ 4] 2230 CMPSTR: LD      A,E             ; Bytes of string 2 to do
   0AC6 B2            [ 4] 2231         OR      D               ; Bytes of string 1 to do
   0AC7 C8            [10] 2232         RET     Z               ; Exit if all bytes compared
   0AC8 7A            [ 4] 2233         LD      A,D             ; Get bytes of string 1 to do
a  0AC9               [ 4] 2234         SUB     1
   0AC9 D8            [10] 2235         RET     C               ; Exit if end of string 1
   0ACA AF            [ 4] 2236         XOR     A
   0ACB BB            [ 4] 2237         CP      E               ; Bytes of string 2 to do
   0ACC 3C            [ 4] 2238         INC     A
   0ACD D0            [10] 2239         RET     NC              ; Exit if end of string 2
   0ACE 15            [ 4] 2240         DEC     D               ; Count bytes in string 1
   0ACF 1D            [ 4] 2241         DEC     E               ; Count bytes in string 2
   0AD0 0A            [ 6] 2242         LD      A,(BC)          ; Byte in string 2
   0AD1 BE            [ 6] 2243         CP      (HL)            ; Compare to byte in string 1
   0AD2 23            [ 4] 2244         INC     HL              ; Move up string 1
   0AD3 03            [ 4] 2245         INC     BC              ; Move up string 2
   0AD4 CA C5 0A      [ 9] 2246         JP      Z,CMPSTR        ; Same - Try next bytes
   0AD7 3F            [ 3] 2247         CCF                     ; Flag difference (">" or "<")
   0AD8 C3 AC 12      [ 9] 2248         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                           2249 
   0ADB 3C            [ 4] 2250 CMPRES: INC     A               ; Increment current value
   0ADC 8F            [ 4] 2251         ADC     A,A             ; Double plus carry
   0ADD C1            [ 9] 2252         POP     BC              ; Get other value
   0ADE A0            [ 4] 2253         AND     B               ; Combine them
a  0ADF               [ 4] 2254         ADD     A,-1            ; Carry set if different
   0ADF 9F            [ 4] 2255         SBC     A,A             ; 00 - Equal , FF - Different
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 42.
Hexadecimal [16-Bits]



   0AE0 C3 B3 12      [ 9] 2256         JP      FLGREL          ; Set current value & continue
                           2257 
a  0AE3               [ 9] 2258 EVNOT:  LD      D,0x5A           ; Precedence value for "NOT"
   0AE3 CD 86 09      [16] 2259         CALL    EVAL1           ; Eval until precedence break
   0AE6 CD 75 09      [16] 2260         CALL    TSTNUM          ; Make sure it's a number
   0AE9 CD 60 06      [16] 2261         CALL    DEINT           ; Get integer -32768 - 32767
   0AEC 7B            [ 4] 2262         LD      A,E             ; Get LSB
   0AED 2F            [ 3] 2263         CPL                     ; Invert LSB
   0AEE 4F            [ 4] 2264         LD      C,A             ; Save "NOT" of LSB
   0AEF 7A            [ 4] 2265         LD      A,D             ; Get MSB
   0AF0 2F            [ 3] 2266         CPL                     ; Invert MSB
   0AF1 CD 9E 0C      [16] 2267         CALL    ACPASS          ; Save AC as current
   0AF4 C1            [ 9] 2268         POP     BC              ; Clean up stack
   0AF5 C3 90 09      [ 9] 2269         JP      EVAL3           ; Continue evaluation
                           2270 
   0AF8 2B            [ 4] 2271 DIMRET: DEC     HL              ; DEC 'cos GET0xCR INCs
   0AF9 CD 4B 05      [16] 2272         CALL    GET0xCR          ; Get next character
   0AFC C8            [10] 2273         RET     Z               ; End of DIM statement
q  0AFD CD 0C 00      [16] 2274         CALL    0xCKSYN          ; Make sure "," follows
q                          2275         DB      ","
a  0B00               [16] 2276 DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
   0B00 C5            [11] 2277         PUSH    BC              ; Save on stack
q                          2278         DB      0x0F6            ; Flag "Create" variable
   0B01 AF            [ 4] 2279 GETVAR: XOR     A               ; Find variable address,to DE
   0B02 32 AC 10      [13] 2280         LD      (LCRFLG),A      ; Set locate / create flag
   0B05 46            [ 6] 2281         LD      B,(HL)          ; Get First byte of name
q  0B06 CD 0C 00      [16] 2282 GTFNAM: CALL    0xCKLTR          ; See if a letter
   0B09 DA 86 01      [ 9] 2283         JP      C,SNERR         ; ?SN Error if not a letter
   0B0C AF            [ 4] 2284         XOR     A
   0B0D 4F            [ 4] 2285         LD      C,A             ; Clear second byte of name
   0B0E 32 AD 10      [13] 2286         LD      (TYPE),A        ; Set type to numeric
   0B11 CD 4B 05      [16] 2287         CALL    GET0xCR          ; Get next character
   0B14 DA 1D 0B      [ 9] 2288         JP      C,SVNAM2        ; Numeric - Save in name
q  0B17 CD 0C 00      [16] 2289         CALL    0xCKLTR          ; See if a letter
q  0B1A DA CA 00      [ 9] 2290         JP      C,0xCARTY        ; Not a letter - Check type
   0B1D 4F            [ 4] 2291 SVNAM2: LD      C,A             ; Save second byte of name
   0B1E CD 4B 05      [16] 2292 ENDNAM: CALL    GET0xCR          ; Get next character
   0B21 DA 1E 0B      [ 9] 2293         JP      C,ENDNAM        ; Numeric - Get another
q  0B24 CD 0C 00      [16] 2294         CALL    0xCKLTR          ; See if a letter
   0B27 D2 1E 0B      [ 9] 2295         JP      NC,ENDNAM       ; Letter - Get another
q                          2296 0xCARTY: SUB     "$"             ; String variable?
   0B2A C2 37 0B      [ 9] 2297         JP      NZ,NOTSTR       ; No - Numeric variable
   0B2D 3C            [ 4] 2298         INC     A               ; A = 1 (string type)
   0B2E 32 AD 10      [13] 2299         LD      (TYPE),A        ; Set type to string
   0B31 0F            [ 3] 2300         RRCA                    ; A = 0x80 , Flag for string
   0B32 81            [ 4] 2301         ADD     A,C             ; 2nd byte of name has bit 7 on
   0B33 4F            [ 4] 2302         LD      C,A             ; Resave second byte on name
   0B34 CD 4B 05      [16] 2303         CALL    GET0xCR          ; Get next character
   0B37 3A CB 10      [12] 2304 NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
   0B3A 3D            [ 4] 2305         DEC     A
   0B3B CA CE 0B      [ 9] 2306         JP      Z,ARLDSV        ; Yes - Get array name
   0B3E F2 45 0B      [ 9] 2307         JP      P,NSCFOR        ; No array with "FOR" or "FN"
   0B41 7E            [ 6] 2308         LD      A,(HL)          ; Get byte again
a  0B42               [ 6] 2309         SUB     "("             ; Subscripted variable?
   0B42 CA AC 0B      [ 9] 2310         JP      Z,SBSCPT        ; Yes - Sort out subscript
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 43.
Hexadecimal [16-Bits]



                           2311 
   0B45 AF            [ 4] 2312 NSCFOR: XOR     A               ; Simple variable
   0B46 32 CB 10      [13] 2313         LD      (FORFLG),A      ; Clear "FOR" flag
   0B49 E5            [11] 2314         PUSH    HL              ; Save code string address
   0B4A 50            [ 4] 2315         LD      D,B             ; DE = Variable name to find
   0B4B 59            [ 4] 2316         LD      E,C
   0B4C 2A DE 10      [15] 2317         LD      HL,(FNRGNM)     ; FN argument name
   0B4F CD D7 03      [16] 2318         CALL    CP0xDEL          ; Is it the FN argument?
a  0B52               [16] 2319         LD      DE,FNARG        ; Point to argument value
   0B52 CA FB 11      [ 9] 2320         JP      Z,POPHRT        ; Yes - Return FN argument value
   0B55 2A D8 10      [15] 2321         LD      HL,(VAREND)     ; End of variables
   0B58 EB            [ 3] 2322         EX      DE,HL           ; Address of end of search
   0B59 2A D6 10      [15] 2323         LD      HL,(PROGND)     ; Start of variables address
   0B5C CD D7 03      [16] 2324 FNDVAR: CALL    CP0xDEL          ; End of variable list table?
   0B5F CA 75 0B      [ 9] 2325         JP      Z,CFEVAL        ; Yes - Called from EVAL?
   0B62 79            [ 4] 2326         LD      A,C             ; Get second byte of name
   0B63 96            [ 6] 2327         SUB     (HL)            ; Compare with name in list
   0B64 23            [ 4] 2328         INC     HL              ; Move on to first byte
   0B65 C2 6A 0B      [ 9] 2329         JP      NZ,FNTHR        ; Different - Find another
   0B68 78            [ 4] 2330         LD      A,B             ; Get first byte of name
   0B69 96            [ 6] 2331         SUB     (HL)            ; Compare with name in list
   0B6A 23            [ 4] 2332 FNTHR:  INC     HL              ; Move on to LSB of value
   0B6B CA A1 0B      [ 9] 2333         JP      Z,RETADR        ; Found - Return address
   0B6E 23            [ 4] 2334         INC     HL              ; <- Skip
   0B6F 23            [ 4] 2335         INC     HL              ; <- over
   0B70 23            [ 4] 2336         INC     HL              ; <- F.P.
   0B71 23            [ 4] 2337         INC     HL              ; <- value
   0B72 C3 5C 0B      [ 9] 2338         JP      FNDVAR          ; Keep looking
                           2339 
   0B75 E1            [ 9] 2340 CFEVAL: POP     HL              ; Restore code string address
   0B76 E3            [16] 2341         EX      (SP),HL         ; Get return address
   0B77 D5            [11] 2342         PUSH    DE              ; Save address of variable
a  0B78               [11] 2343         LD      DE,FRMEVL       ; Return address in EVAL
   0B78 CD D7 03      [16] 2344         CALL    CP0xDEL          ; Called from EVAL ?
   0B7B D1            [ 9] 2345         POP     DE              ; Restore address of variable
   0B7C CA A4 0B      [ 9] 2346         JP      Z,RETNUL        ; Yes - Return null variable
   0B7F E3            [16] 2347         EX      (SP),HL         ; Put back return
   0B80 E5            [11] 2348         PUSH    HL              ; Save code string address
   0B81 C5            [11] 2349         PUSH    BC              ; Save variable name
a  0B82               [11] 2350         LD      BC,6            ; 2 byte name plus 4 byte data
   0B82 2A DA 10      [15] 2351         LD      HL,(ARREND)     ; End of arrays
   0B85 E5            [11] 2352         PUSH    HL              ; Save end of arrays
   0B86 09            [ 7] 2353         ADD     HL,BC           ; Move up 6 bytes
   0B87 C1            [ 9] 2354         POP     BC              ; Source address in BC
   0B88 E5            [11] 2355         PUSH    HL              ; Save new end address
   0B89 CD 5C 01      [16] 2356         CALL    MOVUP           ; Move arrays up
   0B8C E1            [ 9] 2357         POP     HL              ; Restore new end address
   0B8D 22 DA 10      [16] 2358         LD      (ARREND),HL     ; Set new end address
   0B90 60            [ 4] 2359         LD      H,B             ; End of variables to HL
   0B91 69            [ 4] 2360         LD      L,C
   0B92 22 D8 10      [16] 2361         LD      (VAREND),HL     ; Set new end address
                           2362 
   0B95 2B            [ 4] 2363 ZEROLP: DEC     HL              ; Back through to zero variable
a  0B96               [ 4] 2364         LD      (HL),0          ; Zero byte in variable
   0B96 CD D7 03      [16] 2365         CALL    CP0xDEL          ; Done them all?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 44.
Hexadecimal [16-Bits]



   0B99 C2 95 0B      [ 9] 2366         JP      NZ,ZEROLP       ; No - Keep on going
   0B9C D1            [ 9] 2367         POP     DE              ; Get variable name
   0B9D 73            [ 7] 2368         LD      (HL),E          ; Store second character
   0B9E 23            [ 4] 2369         INC     HL
   0B9F 72            [ 7] 2370         LD      (HL),D          ; Store first character
   0BA0 23            [ 4] 2371         INC     HL
   0BA1 EB            [ 3] 2372 RETADR: EX      DE,HL           ; Address of variable in DE
   0BA2 E1            [ 9] 2373         POP     HL              ; Restore code string address
   0BA3 C9            [ 9] 2374         RET
                           2375 
   0BA4 32 E7 10      [13] 2376 RETNUL: LD      (FPEXP),A       ; Set result to zero
a  0BA7               [13] 2377         LD      HL,ZERBYT       ; Also set a null string
   0BA7 22 E4 10      [16] 2378         LD      (FPREG),HL      ; Save for EVAL
   0BAA E1            [ 9] 2379         POP     HL              ; Restore code string address
   0BAB C9            [ 9] 2380         RET
                           2381 
   0BAC E5            [11] 2382 SBSCPT: PUSH    HL              ; Save code string address
   0BAD 2A AC 10      [15] 2383         LD      HL,(LCRFLG)     ; Locate/Create and Type
   0BB0 E3            [16] 2384         EX      (SP),HL         ; Save and get code string
   0BB1 57            [ 4] 2385         LD      D,A             ; Zero number of dimensions
   0BB2 D5            [11] 2386 SCPTLP: PUSH    DE              ; Save number of dimensions
   0BB3 C5            [11] 2387         PUSH    BC              ; Save array name
   0BB4 CD 54 06      [16] 2388         CALL    FPSINT          ; Get subscript (0-32767)
   0BB7 C1            [ 9] 2389         POP     BC              ; Restore array name
   0BB8 F1            [ 9] 2390         POP     AF              ; Get number of dimensions
   0BB9 EB            [ 3] 2391         EX      DE,HL
   0BBA E3            [16] 2392         EX      (SP),HL         ; Save subscript value
   0BBB E5            [11] 2393         PUSH    HL              ; Save LCRFLG and TYPE
   0BBC EB            [ 3] 2394         EX      DE,HL
   0BBD 3C            [ 4] 2395         INC     A               ; Count dimensions
   0BBE 57            [ 4] 2396         LD      D,A             ; Save in D
   0BBF 7E            [ 6] 2397         LD      A,(HL)          ; Get next byte in code string
a  0BC0               [ 6] 2398         CP      ","             ; Comma (more to come)?
   0BC0 CA B2 0B      [ 9] 2399         JP      Z,SCPTLP        ; Yes - More subscripts
q  0BC3 CD 0C 00      [16] 2400         CALL    0xCKSYN          ; Make sure ")" follows
q                          2401         DB      ")"
   0BC6 22 D0 10      [16] 2402         LD      (NXTOPR),HL     ; Save code string address
   0BC9 E1            [ 9] 2403         POP     HL              ; Get LCRFLG and TYPE
   0BCA 22 AC 10      [16] 2404         LD      (LCRFLG),HL     ; Restore Locate/create & type
a  0BCD               [16] 2405         LD      E,0             ; Flag not CSAVE* or CLOAD*
   0BCD D5            [11] 2406         PUSH    DE              ; Save number of dimensions (D)
q                          2407         DB      0x11             ; Skip "PUSH HL" and "PUSH AF'
                           2408 
   0BCE E5            [11] 2409 ARLDSV: PUSH    HL              ; Save code string address
   0BCF F5            [11] 2410         PUSH    AF              ; A = 00 , Flags set = Z,N
   0BD0 2A D8 10      [15] 2411         LD      HL,(VAREND)     ; Start of arrays
q                          2412         DB      0x3E             ; Skip "ADD HL,DE"
   0BD3 19            [ 7] 2413 FNDARY: ADD     HL,DE           ; Move to next array start
   0BD4 EB            [ 3] 2414         EX      DE,HL
   0BD5 2A DA 10      [15] 2415         LD      HL,(ARREND)     ; End of arrays
   0BD8 EB            [ 3] 2416         EX      DE,HL           ; Current array pointer
   0BD9 CD D7 03      [16] 2417         CALL    CP0xDEL          ; End of arrays found?
   0BDC CA 03 0C      [ 9] 2418         JP      Z,CREARY        ; Yes - Create array
   0BDF 7E            [ 6] 2419         LD      A,(HL)          ; Get second byte of name
   0BE0 B9            [ 4] 2420         CP      C               ; Compare with name given
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 45.
Hexadecimal [16-Bits]



   0BE1 23            [ 4] 2421         INC     HL              ; Move on
   0BE2 C2 E7 0B      [ 9] 2422         JP      NZ,NXTARY       ; Different - Find next array
   0BE5 7E            [ 6] 2423         LD      A,(HL)          ; Get first byte of name
   0BE6 B8            [ 4] 2424         CP      B               ; Compare with name given
   0BE7 23            [ 4] 2425 NXTARY: INC     HL              ; Move on
   0BE8 5E            [ 6] 2426         LD      E,(HL)          ; Get LSB of next array address
   0BE9 23            [ 4] 2427         INC     HL
   0BEA 56            [ 6] 2428         LD      D,(HL)          ; Get MSB of next array address
   0BEB 23            [ 4] 2429         INC     HL
   0BEC C2 D3 0B      [ 9] 2430         JP      NZ,FNDARY       ; Not found - Keep looking
   0BEF 3A AC 10      [12] 2431         LD      A,(LCRFLG)      ; Found Locate or Create it?
   0BF2 B7            [ 4] 2432         OR      A
   0BF3 C2 86 01      [ 9] 2433         JP      NZ,DDERR        ; Create - ?DD Error
   0BF6 F1            [ 9] 2434         POP     AF              ; Locate - Get number of dim'ns
   0BF7 44            [ 4] 2435         LD      B,H             ; BC Points to array dim'ns
   0BF8 4D            [ 4] 2436         LD      C,L
   0BF9 CA FB 11      [ 9] 2437         JP      Z,POPHRT        ; Jump if array load/save
   0BFC 96            [ 6] 2438         SUB     (HL)            ; Same number of dimensions?
   0BFD CA 59 0C      [ 9] 2439         JP      Z,FINDEL        ; Yes - Find element
a  0C00               [ 9] 2440 BSERR:  LD      E,BS            ; ?BS Error
   0C00 C3 86 01      [ 9] 2441         JP      ERROR           ; Output error
                           2442 
a  0C03               [ 9] 2443 CREARY: LD      DE,4            ; 4 Bytes per entry
   0C03 F1            [ 9] 2444         POP     AF              ; Array to save or 0 dim'ns?
   0C04 CA 6D 06      [ 9] 2445         JP      Z,FCERR         ; Yes - ?FC Error
   0C07 71            [ 7] 2446         LD      (HL),C          ; Save second byte of name
   0C08 23            [ 4] 2447         INC     HL
   0C09 70            [ 7] 2448         LD      (HL),B          ; Save first byte of name
   0C0A 23            [ 4] 2449         INC     HL
   0C0B 4F            [ 4] 2450         LD      C,A             ; Number of dimensions to C
q  0C0C CD 0C 00      [16] 2451         CALL    0xCKSTK          ; Check if enough memory
   0C0F 23            [ 4] 2452         INC     HL              ; Point to number of dimensions
   0C10 23            [ 4] 2453         INC     HL
   0C11 22 C5 10      [16] 2454         LD      (CUROPR),HL     ; Save address of pointer
   0C14 71            [ 7] 2455         LD      (HL),C          ; Set number of dimensions
   0C15 23            [ 4] 2456         INC     HL
   0C16 3A AC 10      [12] 2457         LD      A,(LCRFLG)      ; Locate of Create?
   0C19 17            [ 3] 2458         RLA                     ; Carry set = Create
   0C1A 79            [ 4] 2459         LD      A,C             ; Get number of dimensions
a  0C1B               [ 4] 2460 CRARLP: LD      BC,10+1         ; Default dimension size 10
   0C1B D2 20 0C      [ 9] 2461         JP      NC,DEFSIZ       ; Locate - Set default size
   0C1E C1            [ 9] 2462         POP     BC              ; Get specified dimension size
   0C1F 03            [ 4] 2463         INC     BC              ; Include zero element
   0C20 71            [ 7] 2464 DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
   0C21 23            [ 4] 2465         INC     HL
   0C22 70            [ 7] 2466         LD      (HL),B          ; Save MSB of dimension size
   0C23 23            [ 4] 2467         INC     HL
   0C24 F5            [11] 2468         PUSH    AF              ; Save num' of dim'ns an status
   0C25 E5            [11] 2469         PUSH    HL              ; Save address of dim'n size
   0C26 CD 60 13      [16] 2470         CALL    MLDEBC          ; Multiply DE by BC to find
   0C29 EB            [ 3] 2471         EX      DE,HL           ; amount of mem needed (to DE)
   0C2A E1            [ 9] 2472         POP     HL              ; Restore address of dimension
   0C2B F1            [ 9] 2473         POP     AF              ; Restore number of dimensions
   0C2C 3D            [ 4] 2474         DEC     A               ; Count them
   0C2D C2 1B 0C      [ 9] 2475         JP      NZ,CRARLP       ; Do next dimension if more
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 46.
Hexadecimal [16-Bits]



   0C30 F5            [11] 2476         PUSH    AF              ; Save locate/create flag
   0C31 42            [ 4] 2477         LD      B,D             ; MSB of memory needed
   0C32 4B            [ 4] 2478         LD      C,E             ; LSB of memory needed
   0C33 EB            [ 3] 2479         EX      DE,HL
   0C34 19            [ 7] 2480         ADD     HL,DE           ; Add bytes to array start
   0C35 DA 7D 01      [ 9] 2481         JP      C,OMERR         ; Too big - Error
   0C38 CD 72 01      [16] 2482         CALL    ENFMEM          ; See if enough memory
   0C3B 22 DA 10      [16] 2483         LD      (ARREND),HL     ; Save new end of array
                           2484 
   0C3E 2B            [ 4] 2485 ZERARY: DEC     HL              ; Back through array data
a  0C3F               [ 4] 2486         LD      (HL),0          ; Set array element to zero
   0C3F CD D7 03      [16] 2487         CALL    CP0xDEL          ; All elements zeroed?
   0C42 C2 3E 0C      [ 9] 2488         JP      NZ,ZERARY       ; No - Keep on going
   0C45 03            [ 4] 2489         INC     BC              ; Number of bytes + 1
   0C46 57            [ 4] 2490         LD      D,A             ; A=0
   0C47 2A C5 10      [15] 2491         LD      HL,(CUROPR)     ; Get address of array
   0C4A 5E            [ 6] 2492         LD      E,(HL)          ; Number of dimensions
   0C4B EB            [ 3] 2493         EX      DE,HL           ; To HL
   0C4C 29            [ 7] 2494         ADD     HL,HL           ; Two bytes per dimension size
   0C4D 09            [ 7] 2495         ADD     HL,BC           ; Add number of bytes
   0C4E EB            [ 3] 2496         EX      DE,HL           ; Bytes needed to DE
   0C4F 2B            [ 4] 2497         DEC     HL
   0C50 2B            [ 4] 2498         DEC     HL
   0C51 73            [ 7] 2499         LD      (HL),E          ; Save LSB of bytes needed
   0C52 23            [ 4] 2500         INC     HL
   0C53 72            [ 7] 2501         LD      (HL),D          ; Save MSB of bytes needed
   0C54 23            [ 4] 2502         INC     HL
   0C55 F1            [ 9] 2503         POP     AF              ; Locate / Create?
   0C56 DA 7C 0C      [ 9] 2504         JP      C,ENDDIM        ; A is 0 , End if create
   0C59 47            [ 4] 2505 FINDEL: LD      B,A             ; Find array element
   0C5A 4F            [ 4] 2506         LD      C,A
   0C5B 7E            [ 6] 2507         LD      A,(HL)          ; Number of dimensions
   0C5C 23            [ 4] 2508         INC     HL
q                          2509         DB      0x16             ; Skip "POP HL"
   0C5D E1            [ 9] 2510 FNDELP: POP     HL              ; Address of next dim' size
   0C5E 5E            [ 6] 2511         LD      E,(HL)          ; Get LSB of dim'n size
   0C5F 23            [ 4] 2512         INC     HL
   0C60 56            [ 6] 2513         LD      D,(HL)          ; Get MSB of dim'n size
   0C61 23            [ 4] 2514         INC     HL
   0C62 E3            [16] 2515         EX      (SP),HL         ; Save address - Get index
   0C63 F5            [11] 2516         PUSH    AF              ; Save number of dim'ns
   0C64 CD D7 03      [16] 2517         CALL    CP0xDEL          ; Dimension too large?
   0C67 D2 00 0C      [ 9] 2518         JP      NC,BSERR        ; Yes - ?BS Error
   0C6A E5            [11] 2519         PUSH    HL              ; Save index
   0C6B CD 60 13      [16] 2520         CALL    MLDEBC          ; Multiply previous by size
   0C6E D1            [ 9] 2521         POP     DE              ; Index supplied to DE
   0C6F 19            [ 7] 2522         ADD     HL,DE           ; Add index to pointer
   0C70 F1            [ 9] 2523         POP     AF              ; Number of dimensions
   0C71 3D            [ 4] 2524         DEC     A               ; Count them
   0C72 44            [ 4] 2525         LD      B,H             ; MSB of pointer
   0C73 4D            [ 4] 2526         LD      C,L             ; LSB of pointer
   0C74 C2 5D 0C      [ 9] 2527         JP      NZ,FNDELP       ; More - Keep going
   0C77 29            [ 7] 2528         ADD     HL,HL           ; 4 Bytes per element
   0C78 29            [ 7] 2529         ADD     HL,HL
   0C79 C1            [ 9] 2530         POP     BC              ; Start of array
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 47.
Hexadecimal [16-Bits]



   0C7A 09            [ 7] 2531         ADD     HL,BC           ; Point to element
   0C7B EB            [ 3] 2532         EX      DE,HL           ; Address of element to DE
   0C7C 2A D0 10      [15] 2533 ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
   0C7F C9            [ 9] 2534         RET
                           2535 
   0C80 2A DA 10      [15] 2536 FRE:    LD      HL,(ARREND)     ; Start of free memory
   0C83 EB            [ 3] 2537         EX      DE,HL           ; To DE
a  0C84               [ 3] 2538         LD      HL,0            ; End of free memory
   0C84 39            [ 7] 2539         ADD     HL,SP           ; Current stack value
   0C85 3A AD 10      [12] 2540         LD      A,(TYPE)        ; Dummy argument type
   0C88 B7            [ 4] 2541         OR      A
   0C89 CA 99 0C      [ 9] 2542         JP      Z,FRENUM        ; Numeric - Free variable space
   0C8C CD B4 0E      [16] 2543         CALL    GSTRCU          ; Current string to pool
   0C8F CD CB 0D      [16] 2544         CALL    GARBGE          ; Garbage collection
   0C92 2A 5A 10      [15] 2545         LD      HL,(STRSPC)     ; Bottom of string space in use
   0C95 EB            [ 3] 2546         EX      DE,HL           ; To DE
   0C96 2A C3 10      [15] 2547         LD      HL,(STRBOT)     ; Bottom of string space
   0C99 7D            [ 4] 2548 FRENUM: LD      A,L             ; Get LSB of end
   0C9A 93            [ 4] 2549         SUB     E               ; Subtract LSB of beginning
   0C9B 4F            [ 4] 2550         LD      C,A             ; Save difference if C
   0C9C 7C            [ 4] 2551         LD      A,H             ; Get MSB of end
   0C9D 9A            [ 4] 2552         SBC     A,D             ; Subtract MSB of beginning
   0C9E 41            [ 4] 2553 ACPASS: LD      B,C             ; Return integer AC
   0C9F 50            [ 4] 2554 ABPASS: LD      D,B             ; Return integer AB
a  0CA0               [ 4] 2555         LD      E,0
a  0CA0               [ 4] 2556         LD      HL,TYPE         ; Point to type
   0CA0 73            [ 7] 2557         LD      (HL),E          ; Set type to numeric
a  0CA1               [ 7] 2558         LD      B,0x80+16        ; 16 bit integer
   0CA1 C3 B3 12      [ 9] 2559         JP      RETINT          ; Return the integr
                           2560 
   0CA4 3A AB 10      [12] 2561 POS:    LD      A,(CURPOS)      ; Get cursor position
   0CA7 47            [ 4] 2562 PASSA:  LD      B,A             ; Put A into AB
   0CA8 AF            [ 4] 2563         XOR     A               ; Zero A
   0CA9 C3 9F 0C      [ 9] 2564         JP      ABPASS          ; Return integer AB
                           2565 
q  0CAC CD CE 00      [16] 2566 DEF:    CALL    0xCEKFN          ; Get "FN" and name
   0CAF CD 18 0D      [16] 2567         CALL    IDTEST          ; Test for illegal direct
a  0CB2               [16] 2568         LD      BC,DATA         ; To get next statement
   0CB2 C5            [11] 2569         PUSH    BC              ; Save address for RETurn
   0CB3 D5            [11] 2570         PUSH    DE              ; Save address of function ptr
q  0CB4 CD 0C 00      [16] 2571         CALL    0xCKSYN          ; Make sure "(" follows
q                          2572         DB      "("
   0CB7 CD 01 0B      [16] 2573         CALL    GETVAR          ; Get argument variable name
   0CBA E5            [11] 2574         PUSH    HL              ; Save code string address
   0CBB EB            [ 3] 2575         EX      DE,HL           ; Argument address to HL
   0CBC 2B            [ 4] 2576         DEC     HL
   0CBD 56            [ 6] 2577         LD      D,(HL)          ; Get first byte of arg name
   0CBE 2B            [ 4] 2578         DEC     HL
   0CBF 5E            [ 6] 2579         LD      E,(HL)          ; Get second byte of arg name
   0CC0 E1            [ 9] 2580         POP     HL              ; Restore code string address
   0CC1 CD 75 09      [16] 2581         CALL    TSTNUM          ; Make sure numeric argument
q  0CC4 CD 0C 00      [16] 2582         CALL    0xCKSYN          ; Make sure ")" follows
q                          2583         DB      ")"
q  0CC7 CD 0C 00      [16] 2584         CALL    0xCKSYN          ; Make sure "=" follows
o  0CCA                    2585         DB      ZEQUAL          ; "=" token
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 48.
Hexadecimal [16-Bits]



   0CCA 44            [ 4] 2586         LD      B,H             ; Code string address to BC
   0CCB 4D            [ 4] 2587         LD      C,L
   0CCC E3            [16] 2588         EX      (SP),HL         ; Save code str , Get FN ptr
   0CCD 71            [ 7] 2589         LD      (HL),C          ; Save LSB of FN code string
   0CCE 23            [ 4] 2590         INC     HL
   0CCF 70            [ 7] 2591         LD      (HL),B          ; Save MSB of FN code string
   0CD0 C3 57 0D      [ 9] 2592         JP      SVSTAD          ; Save address and do function
                           2593 
q  0CD3 CD CE 00      [16] 2594 DOFN:   CALL    0xCEKFN          ; Make sure FN follows
   0CD6 D5            [11] 2595         PUSH    DE              ; Save function pointer address
   0CD7 CD 0C 0A      [16] 2596         CALL    EVLPAR          ; Evaluate expression in "()"
   0CDA CD 75 09      [16] 2597         CALL    TSTNUM          ; Make sure numeric result
   0CDD E3            [16] 2598         EX      (SP),HL         ; Save code str , Get FN ptr
   0CDE 5E            [ 6] 2599         LD      E,(HL)          ; Get LSB of FN code string
   0CDF 23            [ 4] 2600         INC     HL
   0CE0 56            [ 6] 2601         LD      D,(HL)          ; Get MSB of FN code string
   0CE1 23            [ 4] 2602         INC     HL
   0CE2 7A            [ 4] 2603         LD      A,D             ; And function DEFined?
   0CE3 B3            [ 4] 2604         OR      E
   0CE4 CA 86 01      [ 9] 2605         JP      Z,UFERR         ; No - ?UF Error
   0CE7 7E            [ 6] 2606         LD      A,(HL)          ; Get LSB of argument address
   0CE8 23            [ 4] 2607         INC     HL
   0CE9 66            [ 6] 2608         LD      H,(HL)          ; Get MSB of argument address
   0CEA 6F            [ 4] 2609         LD      L,A             ; HL = Arg variable address
   0CEB E5            [11] 2610         PUSH    HL              ; Save it
   0CEC 2A DE 10      [15] 2611         LD      HL,(FNRGNM)     ; Get old argument name
   0CEF E3            [16] 2612         EX      (SP),HL ;       ; Save old , Get new
   0CF0 22 DE 10      [16] 2613         LD      (FNRGNM),HL     ; Set new argument name
   0CF3 2A E2 10      [15] 2614         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
   0CF6 E5            [11] 2615         PUSH    HL              ; Save it
   0CF7 2A E0 10      [15] 2616         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
   0CFA E5            [11] 2617         PUSH    HL              ; Save it
a  0CFB               [11] 2618         LD      HL,FNARG        ; HL = Value of argument
   0CFB D5            [11] 2619         PUSH    DE              ; Save FN code string address
   0CFC CD E5 12      [16] 2620         CALL    FPTHL           ; Move FPREG to argument
   0CFF E1            [ 9] 2621         POP     HL              ; Get FN code string address
   0D00 CD 72 09      [16] 2622         CALL    GETNUM          ; Get value from function
   0D03 2B            [ 4] 2623         DEC     HL              ; DEC 'cos GET0xCR INCs
   0D04 CD 4B 05      [16] 2624         CALL    GET0xCR          ; Get next character
   0D07 C2 86 01      [ 9] 2625         JP      NZ,SNERR        ; Bad character in FN - Error
   0D0A E1            [ 9] 2626         POP     HL              ; Get MSB,EXP of old arg
   0D0B 22 E0 10      [16] 2627         LD      (FNARG),HL      ; Restore it
   0D0E E1            [ 9] 2628         POP     HL              ; Get LSB,NLSB of old arg
   0D0F 22 E2 10      [16] 2629         LD      (FNARG+2),HL    ; Restore it
   0D12 E1            [ 9] 2630         POP     HL              ; Get name of old arg
   0D13 22 DE 10      [16] 2631         LD      (FNRGNM),HL     ; Restore it
   0D16 E1            [ 9] 2632         POP     HL              ; Restore code string address
   0D17 C9            [ 9] 2633         RET
                           2634 
   0D18 E5            [11] 2635 IDTEST: PUSH    HL              ; Save code string address
   0D19 2A 5C 10      [15] 2636         LD      HL,(LINEAT)     ; Get current line number
   0D1C 23            [ 4] 2637         INC     HL              ; -1 means direct statement
   0D1D 7C            [ 4] 2638         LD      A,H
   0D1E B5            [ 4] 2639         OR      L
   0D1F E1            [ 9] 2640         POP     HL              ; Restore code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 49.
Hexadecimal [16-Bits]



   0D20 C0            [10] 2641         RET     NZ              ; Return if in program
a  0D21               [10] 2642         LD      E,ID            ; ?ID Error
   0D21 C3 86 01      [ 9] 2643         JP      ERROR
                           2644 
q                          2645 0xCEKFN: CALL    CHKSYN          ; Make sure FN follows
o  0D24                    2646         DB      ZFN             ; "FN" token
a  0D24               [ 9] 2647         LD      A,0x80
   0D24 32 CB 10      [13] 2648         LD      (FORFLG),A      ; Flag FN name to find
   0D27 B6            [ 6] 2649         OR      (HL)            ; FN name has bit 7 set
   0D28 47            [ 4] 2650         LD      B,A             ; in first byte of name
   0D29 CD 06 0B      [16] 2651         CALL    GTFNAM          ; Get FN name
   0D2C C3 75 09      [ 9] 2652         JP      TSTNUM          ; Make sure numeric function
                           2653 
   0D2F CD 75 09      [16] 2654 STR:    CALL    TSTNUM          ; Make sure it's a number
   0D32 CD 00 14      [16] 2655         CALL    NUMASC          ; Turn number into text
   0D35 CD 5D 0D      [16] 2656         CALL    CRTST           ; Create string entry for it
   0D38 CD B4 0E      [16] 2657         CALL    GSTRCU          ; Current string to pool
a  0D3B               [16] 2658         LD      BC,TOPOOL       ; Save in string pool
   0D3B C5            [11] 2659         PUSH    BC              ; Save address on stack
                           2660 
   0D3C 7E            [ 6] 2661 SAVSTR: LD      A,(HL)          ; Get string length
   0D3D 23            [ 4] 2662         INC     HL
   0D3E 23            [ 4] 2663         INC     HL
   0D3F E5            [11] 2664         PUSH    HL              ; Save pointer to string
   0D40 CD A9 0D      [16] 2665         CALL    TESTR           ; See if enough string space
   0D43 E1            [ 9] 2666         POP     HL              ; Restore pointer to string
   0D44 4E            [ 6] 2667         LD      C,(HL)          ; Get LSB of address
   0D45 23            [ 4] 2668         INC     HL
   0D46 46            [ 6] 2669         LD      B,(HL)          ; Get MSB of address
   0D47 CD 54 0D      [16] 2670         CALL    CRTMST          ; Create string entry
   0D4A E5            [11] 2671         PUSH    HL              ; Save pointer to MSB of addr
   0D4B 6F            [ 4] 2672         LD      L,A             ; Length of string
   0D4C CD A7 0E      [16] 2673         CALL    TOSTRA          ; Move to string area
   0D4F D1            [ 9] 2674         POP     DE              ; Restore pointer to MSB
   0D50 C9            [ 9] 2675         RET
                           2676 
   0D51 CD A9 0D      [16] 2677 MKTMST: CALL    TESTR           ; See if enough string space
a  0D54               [16] 2678 CRTMST: LD      HL,TMPSTR       ; Temporary string
   0D54 E5            [11] 2679         PUSH    HL              ; Save it
   0D55 77            [ 7] 2680         LD      (HL),A          ; Save length of string
   0D56 23            [ 4] 2681         INC     HL
   0D57 23            [ 4] 2682 SVSTAD: INC     HL
   0D58 73            [ 7] 2683         LD      (HL),E          ; Save LSB of address
   0D59 23            [ 4] 2684         INC     HL
   0D5A 72            [ 7] 2685         LD      (HL),D          ; Save MSB of address
   0D5B E1            [ 9] 2686         POP     HL              ; Restore pointer
   0D5C C9            [ 9] 2687         RET
                           2688 
   0D5D 2B            [ 4] 2689 CRTST:  DEC     HL              ; DEC - INCed after
a  0D5E               [ 4] 2690 QTSTR:  LD      B,'"'           ; Terminating quote
   0D5E 50            [ 4] 2691         LD      D,B             ; Quote to D
   0D5F E5            [11] 2692 DTSTR:  PUSH    HL              ; Save start
a  0D60               [11] 2693         LD      C,-1            ; Set counter to -1
   0D60 23            [ 4] 2694 QTSTLP: INC     HL              ; Move on
   0D61 7E            [ 6] 2695         LD      A,(HL)          ; Get byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 50.
Hexadecimal [16-Bits]



   0D62 0C            [ 4] 2696         INC     C               ; Count bytes
   0D63 B7            [ 4] 2697         OR      A               ; End of line?
   0D64 CA 6F 0D      [ 9] 2698         JP      Z,CRTSTE        ; Yes - Create string entry
   0D67 BA            [ 4] 2699         CP      D               ; Terminator D found?
   0D68 CA 6F 0D      [ 9] 2700         JP      Z,CRTSTE        ; Yes - Create string entry
   0D6B B8            [ 4] 2701         CP      B               ; Terminator B found?
   0D6C C2 60 0D      [ 9] 2702         JP      NZ,QTSTLP       ; No - Keep looking
a  0D6F               [ 9] 2703 CRTSTE: CP      '"'             ; End with '"'?
   0D6F CC 4B 05      [16] 2704         CALL    Z,GET0xCR        ; Yes - Get next character
   0D72 E3            [16] 2705         EX      (SP),HL         ; Starting quote
   0D73 23            [ 4] 2706         INC     HL              ; First byte of string
   0D74 EB            [ 3] 2707         EX      DE,HL           ; To DE
   0D75 79            [ 4] 2708         LD      A,C             ; Get length
   0D76 CD 54 0D      [16] 2709         CALL    CRTMST          ; Create string entry
a  0D79               [16] 2710 TSTOPL: LD      DE,TMPSTR       ; Temporary string
   0D79 2A B1 10      [15] 2711         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   0D7C 22 E4 10      [16] 2712         LD      (FPREG),HL      ; Save address of string ptr
a  0D7F               [16] 2713         LD      A,1
   0D7F 32 AD 10      [13] 2714         LD      (TYPE),A        ; Set type to string
   0D82 CD E5 12      [16] 2715         CALL    DETHL4          ; Move string to pool
   0D85 CD D7 03      [16] 2716         CALL    CP0xDEL          ; Out of string pool?
   0D88 22 B1 10      [16] 2717         LD      (TMSTPT),HL     ; Save new pointer
   0D8B E1            [ 9] 2718         POP     HL              ; Restore code string address
   0D8C 7E            [ 6] 2719         LD      A,(HL)          ; Get next code byte
   0D8D C0            [10] 2720         RET     NZ              ; Return if pool OK
a  0D8E               [10] 2721         LD      E,ST            ; ?ST Error
   0D8E C3 86 01      [ 9] 2722         JP      ERROR           ; String pool overflow
                           2723 
   0D91 23            [ 4] 2724 PRNUMS: INC     HL              ; Skip leading space
   0D92 CD 5D 0D      [16] 2725 PRS:    CALL    CRTST           ; Create string entry for it
   0D95 CD B4 0E      [16] 2726 PRS1:   CALL    GSTRCU          ; Current string to pool
   0D98 CD DC 12      [16] 2727         CALL    LOADFP          ; Move string block to BCDE
   0D9B 1C            [ 4] 2728         INC     E               ; Length + 1
   0D9C 1D            [ 4] 2729 PRSLP:  DEC     E               ; Count characters
   0D9D C8            [10] 2730         RET     Z               ; End of string
   0D9E 0A            [ 6] 2731         LD      A,(BC)          ; Get byte to output
   0D9F CD E7 03      [16] 2732         CALL    OUTC            ; Output character in A
a  0DA2               [16] 2733         CP      CR              ; Return?
   0DA2 CC 0A 08      [16] 2734         CALL    Z,DONULL        ; Yes - Do nulls
   0DA5 03            [ 4] 2735         INC     BC              ; Next byte in string
   0DA6 C3 9C 0D      [ 9] 2736         JP      PRSLP           ; More characters to output
                           2737 
   0DA9 B7            [ 4] 2738 TESTR:  OR      A               ; Test if enough room
q                          2739         DB      0x0E             ; No garbage collection done
   0DAA F1            [ 9] 2740 GRBDON: POP     AF              ; Garbage collection done
   0DAB F5            [11] 2741         PUSH    AF              ; Save status
   0DAC 2A 5A 10      [15] 2742         LD      HL,(STRSPC)     ; Bottom of string space in use
   0DAF EB            [ 3] 2743         EX      DE,HL           ; To DE
   0DB0 2A C3 10      [15] 2744         LD      HL,(STRBOT)     ; Bottom of string area
   0DB3 2F            [ 3] 2745         CPL                     ; Negate length (Top down)
   0DB4 4F            [ 4] 2746         LD      C,A             ; -Length to BC
a  0DB5               [ 4] 2747         LD      B,-1            ; BC = -ve length of string
   0DB5 09            [ 7] 2748         ADD     HL,BC           ; Add to bottom of space in use
   0DB6 23            [ 4] 2749         INC     HL              ; Plus one for 2's complement
   0DB7 CD D7 03      [16] 2750         CALL    CP0xDEL          ; Below string RAM area?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 51.
Hexadecimal [16-Bits]



   0DBA DA C4 0D      [ 9] 2751         JP      C,TESTOS        ; Tidy up if not done else err
   0DBD 22 C3 10      [16] 2752         LD      (STRBOT),HL     ; Save new bottom of area
   0DC0 23            [ 4] 2753         INC     HL              ; Point to first byte of string
   0DC1 EB            [ 3] 2754         EX      DE,HL           ; Address to DE
   0DC2 F1            [ 9] 2755 POPAF:  POP     AF              ; Throw away status push
   0DC3 C9            [ 9] 2756         RET
                           2757 
   0DC4 F1            [ 9] 2758 TESTOS: POP     AF              ; Garbage collect been done?
a  0DC5               [ 9] 2759         LD      E,OS            ; ?OS Error
   0DC5 CA 86 01      [ 9] 2760         JP      Z,ERROR         ; Yes - Not enough string apace
   0DC8 BF            [ 4] 2761         CP      A               ; Flag garbage collect done
   0DC9 F5            [11] 2762         PUSH    AF              ; Save status
a  0DCA               [11] 2763         LD      BC,GRBDON       ; Garbage collection done
   0DCA C5            [11] 2764         PUSH    BC              ; Save for RETurn
   0DCB 2A AF 10      [15] 2765 GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
   0DCE 22 C3 10      [16] 2766 GARBLP: LD      (STRBOT),HL     ; Reset string pointer
a  0DD1               [16] 2767         LD      HL,0
   0DD1 E5            [11] 2768         PUSH    HL              ; Flag no string found
   0DD2 2A 5A 10      [15] 2769         LD      HL,(STRSPC)     ; Get bottom of string space
   0DD5 E5            [11] 2770         PUSH    HL              ; Save bottom of string space
a  0DD6               [11] 2771         LD      HL,TMSTPL       ; Temporary string pool
   0DD6 EB            [ 3] 2772 GRBLP:  EX      DE,HL
   0DD7 2A B1 10      [15] 2773         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   0DDA EB            [ 3] 2774         EX      DE,HL
   0DDB CD D7 03      [16] 2775         CALL    CP0xDEL          ; Temporary string pool done?
a  0DDE               [16] 2776         LD      BC,GRBLP        ; Loop until string pool done
   0DDE C2 22 0E      [ 9] 2777         JP      NZ,STPOOL       ; No - See if in string area
   0DE1 2A D6 10      [15] 2778         LD      HL,(PROGND)     ; Start of simple variables
   0DE4 EB            [ 3] 2779 SMPVAR: EX      DE,HL
   0DE5 2A D8 10      [15] 2780         LD      HL,(VAREND)     ; End of simple variables
   0DE8 EB            [ 3] 2781         EX      DE,HL
   0DE9 CD D7 03      [16] 2782         CALL    CP0xDEL          ; All simple strings done?
   0DEC CA FA 0D      [ 9] 2783         JP      Z,ARRLP         ; Yes - Do string arrays
   0DEF 7E            [ 6] 2784         LD      A,(HL)          ; Get type of variable
   0DF0 23            [ 4] 2785         INC     HL
   0DF1 23            [ 4] 2786         INC     HL
   0DF2 B7            [ 4] 2787         OR      A               ; "S" flag set if string
   0DF3 CD 23 0E      [16] 2788         CALL    STRADD          ; See if string in string area
   0DF6 C3 E4 0D      [ 9] 2789         JP      SMPVAR          ; Loop until simple ones done
                           2790 
   0DF9 C1            [ 9] 2791 GNXARY: POP     BC              ; Scrap address of this array
   0DFA EB            [ 3] 2792 ARRLP:  EX      DE,HL
   0DFB 2A DA 10      [15] 2793         LD      HL,(ARREND)     ; End of string arrays
   0DFE EB            [ 3] 2794         EX      DE,HL
   0DFF CD D7 03      [16] 2795         CALL    CP0xDEL          ; All string arrays done?
   0E02 CA 49 0E      [ 9] 2796         JP      Z,SCNEND        ; Yes - Move string if found
   0E05 CD DC 12      [16] 2797         CALL    LOADFP          ; Get array name to BCDE
   0E08 7B            [ 4] 2798         LD      A,E             ; Get type of array     
   0E09 E5            [11] 2799         PUSH    HL              ; Save address of num of dim'ns
   0E0A 09            [ 7] 2800         ADD     HL,BC           ; Start of next array
   0E0B B7            [ 4] 2801         OR      A               ; Test type of array
   0E0C F2 F9 0D      [ 9] 2802         JP      P,GNXARY        ; Numeric array - Ignore it
   0E0F 22 C5 10      [16] 2803         LD      (CUROPR),HL     ; Save address of next array
   0E12 E1            [ 9] 2804         POP     HL              ; Get address of num of dim'ns
   0E13 4E            [ 6] 2805         LD      C,(HL)          ; BC = Number of dimensions
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 52.
Hexadecimal [16-Bits]



a  0E14               [ 6] 2806         LD      B,0
   0E14 09            [ 7] 2807         ADD     HL,BC           ; Two bytes per dimension size
   0E15 09            [ 7] 2808         ADD     HL,BC
   0E16 23            [ 4] 2809         INC     HL              ; Plus one for number of dim'ns
   0E17 EB            [ 3] 2810 GRBARY: EX      DE,HL
   0E18 2A C5 10      [15] 2811         LD      HL,(CUROPR)     ; Get address of next array
   0E1B EB            [ 3] 2812         EX      DE,HL
   0E1C CD D7 03      [16] 2813         CALL    CP0xDEL          ; Is this array finished?
   0E1F CA FA 0D      [ 9] 2814         JP      Z,ARRLP         ; Yes - Get next one
a  0E22               [ 9] 2815         LD      BC,GRBARY       ; Loop until array all done
   0E22 C5            [11] 2816 STPOOL: PUSH    BC              ; Save return address
a  0E23               [11] 2817         OR      0x80             ; Flag string type
   0E23 7E            [ 6] 2818 STRADD: LD      A,(HL)          ; Get string length
   0E24 23            [ 4] 2819         INC     HL
   0E25 23            [ 4] 2820         INC     HL
   0E26 5E            [ 6] 2821         LD      E,(HL)          ; Get LSB of string address
   0E27 23            [ 4] 2822         INC     HL
   0E28 56            [ 6] 2823         LD      D,(HL)          ; Get MSB of string address
   0E29 23            [ 4] 2824         INC     HL
   0E2A F0            [10] 2825         RET     P               ; Not a string - Return
   0E2B B7            [ 4] 2826         OR      A               ; Set flags on string length
   0E2C C8            [10] 2827         RET     Z               ; Null string - Return
   0E2D 44            [ 4] 2828         LD      B,H             ; Save variable pointer
   0E2E 4D            [ 4] 2829         LD      C,L
   0E2F 2A C3 10      [15] 2830         LD      HL,(STRBOT)     ; Bottom of new area
   0E32 CD D7 03      [16] 2831         CALL    CP0xDEL          ; String been done?
   0E35 60            [ 4] 2832         LD      H,B             ; Restore variable pointer
   0E36 69            [ 4] 2833         LD      L,C
   0E37 D8            [10] 2834         RET     C               ; String done - Ignore
   0E38 E1            [ 9] 2835         POP     HL              ; Return address
   0E39 E3            [16] 2836         EX      (SP),HL         ; Lowest available string area
   0E3A CD D7 03      [16] 2837         CALL    CP0xDEL          ; String within string area?
   0E3D E3            [16] 2838         EX      (SP),HL         ; Lowest available string area
   0E3E E5            [11] 2839         PUSH    HL              ; Re-save return address
   0E3F 60            [ 4] 2840         LD      H,B             ; Restore variable pointer
   0E40 69            [ 4] 2841         LD      L,C
   0E41 D0            [10] 2842         RET     NC              ; Outside string area - Ignore
   0E42 C1            [ 9] 2843         POP     BC              ; Get return , Throw 2 away
   0E43 F1            [ 9] 2844         POP     AF              ; 
   0E44 F1            [ 9] 2845         POP     AF              ; 
   0E45 E5            [11] 2846         PUSH    HL              ; Save variable pointer
   0E46 D5            [11] 2847         PUSH    DE              ; Save address of current
   0E47 C5            [11] 2848         PUSH    BC              ; Put back return address
   0E48 C9            [ 9] 2849         RET                     ; Go to it
                           2850 
   0E49 D1            [ 9] 2851 SCNEND: POP     DE              ; Addresses of strings
   0E4A E1            [ 9] 2852         POP     HL              ; 
   0E4B 7D            [ 4] 2853         LD      A,L             ; HL = 0 if no more to do
   0E4C B4            [ 4] 2854         OR      H
   0E4D C8            [10] 2855         RET     Z               ; No more to do - Return
   0E4E 2B            [ 4] 2856         DEC     HL
   0E4F 46            [ 6] 2857         LD      B,(HL)          ; MSB of address of string
   0E50 2B            [ 4] 2858         DEC     HL
   0E51 4E            [ 6] 2859         LD      C,(HL)          ; LSB of address of string
   0E52 E5            [11] 2860         PUSH    HL              ; Save variable address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 53.
Hexadecimal [16-Bits]



   0E53 2B            [ 4] 2861         DEC     HL
   0E54 2B            [ 4] 2862         DEC     HL
   0E55 6E            [ 6] 2863         LD      L,(HL)          ; HL = Length of string
a  0E56               [ 6] 2864         LD      H,0
   0E56 09            [ 7] 2865         ADD     HL,BC           ; Address of end of string+1
   0E57 50            [ 4] 2866         LD      D,B             ; String address to DE
   0E58 59            [ 4] 2867         LD      E,C
   0E59 2B            [ 4] 2868         DEC     HL              ; Last byte in string
   0E5A 44            [ 4] 2869         LD      B,H             ; Address to BC
   0E5B 4D            [ 4] 2870         LD      C,L
   0E5C 2A C3 10      [15] 2871         LD      HL,(STRBOT)     ; Current bottom of string area
   0E5F CD 5F 01      [16] 2872         CALL    MOVSTR          ; Move string to new address
   0E62 E1            [ 9] 2873         POP     HL              ; Restore variable address
   0E63 71            [ 7] 2874         LD      (HL),C          ; Save new LSB of address
   0E64 23            [ 4] 2875         INC     HL
   0E65 70            [ 7] 2876         LD      (HL),B          ; Save new MSB of address
   0E66 69            [ 4] 2877         LD      L,C             ; Next string area+1 to HL
   0E67 60            [ 4] 2878         LD      H,B
   0E68 2B            [ 4] 2879         DEC     HL              ; Next string area address
   0E69 C3 CE 0D      [ 9] 2880         JP      GARBLP          ; Look for more strings
                           2881 
   0E6C C5            [11] 2882 CONCAT: PUSH    BC              ; Save prec' opr & code string
   0E6D E5            [11] 2883         PUSH    HL              ; 
   0E6E 2A E4 10      [15] 2884         LD      HL,(FPREG)      ; Get first string
   0E71 E3            [16] 2885         EX      (SP),HL         ; Save first string
   0E72 CD E4 09      [16] 2886         CALL    OPRND           ; Get second string
   0E75 E3            [16] 2887         EX      (SP),HL         ; Restore first string
   0E76 CD 75 09      [16] 2888         CALL    TSTSTR          ; Make sure it's a string
   0E79 7E            [ 6] 2889         LD      A,(HL)          ; Get length of second string
   0E7A E5            [11] 2890         PUSH    HL              ; Save first string
   0E7B 2A E4 10      [15] 2891         LD      HL,(FPREG)      ; Get second string
   0E7E E5            [11] 2892         PUSH    HL              ; Save second string
   0E7F 86            [ 6] 2893         ADD     A,(HL)          ; Add length of second string
a  0E80               [ 6] 2894         LD      E,LS            ; ?LS Error
   0E80 DA 86 01      [ 9] 2895         JP      C,ERROR         ; String too long - Error
   0E83 CD 51 0D      [16] 2896         CALL    MKTMST          ; Make temporary string
   0E86 D1            [ 9] 2897         POP     DE              ; Get second string to DE
   0E87 CD B8 0E      [16] 2898         CALL    GSTRDE          ; Move to string pool if needed
   0E8A E3            [16] 2899         EX      (SP),HL         ; Get first string
   0E8B CD B7 0E      [16] 2900         CALL    GSTRHL          ; Move to string pool if needed
   0E8E E5            [11] 2901         PUSH    HL              ; Save first string
   0E8F 2A C1 10      [15] 2902         LD      HL,(TMPSTR+2)   ; Temporary string address
   0E92 EB            [ 3] 2903         EX      DE,HL           ; To DE
   0E93 CD 9E 0E      [16] 2904         CALL    SSTSA           ; First string to string area
   0E96 CD 9E 0E      [16] 2905         CALL    SSTSA           ; Second string to string area
a  0E99               [16] 2906         LD      HL,EVAL2        ; Return to evaluation loop
   0E99 E3            [16] 2907         EX      (SP),HL         ; Save return,get code string
   0E9A E5            [11] 2908         PUSH    HL              ; Save code string address
   0E9B C3 79 0D      [ 9] 2909         JP      TSTOPL          ; To temporary string to pool
                           2910 
   0E9E E1            [ 9] 2911 SSTSA:  POP     HL              ; Return address
   0E9F E3            [16] 2912         EX      (SP),HL         ; Get string block,save return
   0EA0 7E            [ 6] 2913         LD      A,(HL)          ; Get length of string
   0EA1 23            [ 4] 2914         INC     HL
   0EA2 23            [ 4] 2915         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 54.
Hexadecimal [16-Bits]



   0EA3 4E            [ 6] 2916         LD      C,(HL)          ; Get LSB of string address
   0EA4 23            [ 4] 2917         INC     HL
   0EA5 46            [ 6] 2918         LD      B,(HL)          ; Get MSB of string address
   0EA6 6F            [ 4] 2919         LD      L,A             ; Length to L
   0EA7 2C            [ 4] 2920 TOSTRA: INC     L               ; INC - DECed after
   0EA8 2D            [ 4] 2921 TSALP:  DEC     L               ; Count bytes moved
   0EA9 C8            [10] 2922         RET     Z               ; End of string - Return
   0EAA 0A            [ 6] 2923         LD      A,(BC)          ; Get source
   0EAB 12            [ 7] 2924         LD      (DE),A          ; Save destination
   0EAC 03            [ 4] 2925         INC     BC              ; Next source
   0EAD 13            [ 4] 2926         INC     DE              ; Next destination
   0EAE C3 A8 0E      [ 9] 2927         JP      TSALP           ; Loop until string moved
                           2928 
   0EB1 CD 75 09      [16] 2929 GETSTR: CALL    TSTSTR          ; Make sure it's a string
   0EB4 2A E4 10      [15] 2930 GSTRCU: LD      HL,(FPREG)      ; Get current string
   0EB7 EB            [ 3] 2931 GSTRHL: EX      DE,HL           ; Save DE
   0EB8 CD D2 0E      [16] 2932 GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
   0EBB EB            [ 3] 2933         EX      DE,HL           ; Restore DE
   0EBC C0            [10] 2934         RET     NZ              ; No - Return
   0EBD D5            [11] 2935         PUSH    DE              ; Save string
   0EBE 50            [ 4] 2936         LD      D,B             ; String block address to DE
   0EBF 59            [ 4] 2937         LD      E,C
   0EC0 1B            [ 4] 2938         DEC     DE              ; Point to length
   0EC1 4E            [ 6] 2939         LD      C,(HL)          ; Get string length
   0EC2 2A C3 10      [15] 2940         LD      HL,(STRBOT)     ; Current bottom of string area
   0EC5 CD D7 03      [16] 2941         CALL    CP0xDEL          ; Last one in string area?
   0EC8 C2 D0 0E      [ 9] 2942         JP      NZ,POPHL        ; No - Return
   0ECB 47            [ 4] 2943         LD      B,A             ; Clear B (A=0)
   0ECC 09            [ 7] 2944         ADD     HL,BC           ; Remove string from str' area
   0ECD 22 C3 10      [16] 2945         LD      (STRBOT),HL     ; Save new bottom of str' area
   0ED0 E1            [ 9] 2946 POPHL:  POP     HL              ; Restore string
   0ED1 C9            [ 9] 2947         RET
                           2948 
   0ED2 2A B1 10      [15] 2949 BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
   0ED5 2B            [ 4] 2950         DEC     HL              ; Back
   0ED6 46            [ 6] 2951         LD      B,(HL)          ; Get MSB of address
   0ED7 2B            [ 4] 2952         DEC     HL              ; Back
   0ED8 4E            [ 6] 2953         LD      C,(HL)          ; Get LSB of address
   0ED9 2B            [ 4] 2954         DEC     HL              ; Back
   0EDA 2B            [ 4] 2955         DEC     HL              ; Back
   0EDB CD D7 03      [16] 2956         CALL    CP0xDEL          ; String last in string pool?
   0EDE C0            [10] 2957         RET     NZ              ; Yes - Leave it
   0EDF 22 B1 10      [16] 2958         LD      (TMSTPT),HL     ; Save new string pool top
   0EE2 C9            [ 9] 2959         RET
                           2960 
a  0EE3               [ 9] 2961 LEN:    LD      BC,PASSA        ; To return integer A
   0EE3 C5            [11] 2962         PUSH    BC              ; Save address
   0EE4 CD B1 0E      [16] 2963 GETLEN: CALL    GETSTR          ; Get string and its length
   0EE7 AF            [ 4] 2964         XOR     A
   0EE8 57            [ 4] 2965         LD      D,A             ; Clear D
   0EE9 32 AD 10      [13] 2966         LD      (TYPE),A        ; Set type to numeric
   0EEC 7E            [ 6] 2967         LD      A,(HL)          ; Get length of string
   0EED B7            [ 4] 2968         OR      A               ; Set status flags
   0EEE C9            [ 9] 2969         RET
                           2970 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 55.
Hexadecimal [16-Bits]



a  0EEF               [ 9] 2971 ASC:    LD      BC,PASSA        ; To return integer A
   0EEF C5            [11] 2972         PUSH    BC              ; Save address
   0EF0 CD E4 0E      [16] 2973 GTFLNM: CALL    GETLEN          ; Get length of string
   0EF3 CA 6D 06      [ 9] 2974         JP      Z,FCERR         ; Null string - Error
   0EF6 23            [ 4] 2975         INC     HL
   0EF7 23            [ 4] 2976         INC     HL
   0EF8 5E            [ 6] 2977         LD      E,(HL)          ; Get LSB of address
   0EF9 23            [ 4] 2978         INC     HL
   0EFA 56            [ 6] 2979         LD      D,(HL)          ; Get MSB of address
   0EFB 1A            [ 6] 2980         LD      A,(DE)          ; Get first byte of string
   0EFC C9            [ 9] 2981         RET
                           2982 
q                          2983 0xCR:    LD      A,1             ; One character string
   0EFD CD 51 0D      [16] 2984         CALL    MKTMST          ; Make a temporary string
   0F00 CD CB 0F      [16] 2985         CALL    MAKINT          ; Make it integer A
   0F03 2A C1 10      [15] 2986         LD      HL,(TMPSTR+2)   ; Get address of string
   0F06 73            [ 7] 2987         LD      (HL),E          ; Save character
   0F07 C1            [ 9] 2988 TOPOOL: POP     BC              ; Clean up stack
   0F08 C3 79 0D      [ 9] 2989         JP      TSTOPL          ; Temporary string to pool
                           2990 
   0F0B CD 80 0F      [16] 2991 LEFT:   CALL    LFRGNM          ; Get number and ending ")"
   0F0E AF            [ 4] 2992         XOR     A               ; Start at first byte in string
   0F0F E3            [16] 2993 RIGHT1: EX      (SP),HL         ; Save code string,Get string
   0F10 4F            [ 4] 2994         LD      C,A             ; Starting position in string
   0F11 E5            [11] 2995 MID1:   PUSH    HL              ; Save string block address
   0F12 7E            [ 6] 2996         LD      A,(HL)          ; Get length of string
   0F13 B8            [ 4] 2997         CP      B               ; Compare with number given
   0F14 DA 18 0F      [ 9] 2998         JP      C,ALLFOL        ; All following bytes required
   0F17 78            [ 4] 2999         LD      A,B             ; Get new length
q                          3000         DB      0x11             ; Skip "LD C,0"
a  0F18               [ 4] 3001 ALLFOL: LD      C,0             ; First byte of string
   0F18 C5            [11] 3002         PUSH    BC              ; Save position in string
   0F19 CD A9 0D      [16] 3003         CALL    TESTR           ; See if enough string space
   0F1C C1            [ 9] 3004         POP     BC              ; Get position in string
   0F1D E1            [ 9] 3005         POP     HL              ; Restore string block address
   0F1E E5            [11] 3006         PUSH    HL              ; And re-save it
   0F1F 23            [ 4] 3007         INC     HL
   0F20 23            [ 4] 3008         INC     HL
   0F21 46            [ 6] 3009         LD      B,(HL)          ; Get LSB of address
   0F22 23            [ 4] 3010         INC     HL
   0F23 66            [ 6] 3011         LD      H,(HL)          ; Get MSB of address
   0F24 68            [ 4] 3012         LD      L,B             ; HL = address of string
a  0F25               [ 4] 3013         LD      B,0             ; BC = starting address
   0F25 09            [ 7] 3014         ADD     HL,BC           ; Point to that byte
   0F26 44            [ 4] 3015         LD      B,H             ; BC = source string
   0F27 4D            [ 4] 3016         LD      C,L
   0F28 CD 54 0D      [16] 3017         CALL    CRTMST          ; Create a string entry
   0F2B 6F            [ 4] 3018         LD      L,A             ; Length of new string
   0F2C CD A7 0E      [16] 3019         CALL    TOSTRA          ; Move string to string area
   0F2F D1            [ 9] 3020         POP     DE              ; Clear stack
   0F30 CD B8 0E      [16] 3021         CALL    GSTRDE          ; Move to string pool if needed
   0F33 C3 79 0D      [ 9] 3022         JP      TSTOPL          ; Temporary string to pool
                           3023 
   0F36 CD 80 0F      [16] 3024 RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
   0F39 D1            [ 9] 3025         POP     DE              ; Get string length
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 56.
Hexadecimal [16-Bits]



   0F3A D5            [11] 3026         PUSH    DE              ; And re-save
   0F3B 1A            [ 6] 3027         LD      A,(DE)          ; Get length
   0F3C 90            [ 4] 3028         SUB     B               ; Move back N bytes
   0F3D C3 0F 0F      [ 9] 3029         JP      RIGHT1          ; Go and get sub-string
                           3030 
   0F40 EB            [ 3] 3031 MID:    EX      DE,HL           ; Get code string address
   0F41 7E            [ 6] 3032         LD      A,(HL)          ; Get next byte "," or ")"
   0F42 CD 84 0F      [16] 3033         CALL    MIDNUM          ; Get number supplied
   0F45 04            [ 4] 3034         INC     B               ; Is it character zero?
   0F46 05            [ 4] 3035         DEC     B
   0F47 CA 6D 06      [ 9] 3036         JP      Z,FCERR         ; Yes - Error
   0F4A C5            [11] 3037         PUSH    BC              ; Save starting position
a  0F4B               [11] 3038         LD      E,255           ; All of string
a  0F4B               [11] 3039         CP      ")"             ; Any length given?
   0F4B CA 54 0F      [ 9] 3040         JP      Z,RSTSTR        ; No - Rest of string
q  0F4E CD 0C 00      [16] 3041         CALL    0xCKSYN          ; Make sure "," follows
q                          3042         DB      ","
   0F51 CD C8 0F      [16] 3043         CALL    GETINT          ; Get integer 0-255
q  0F54 CD 0C 00      [16] 3044 RSTSTR: CALL    0xCKSYN          ; Make sure ")" follows
q                          3045         DB      ")"
   0F57 F1            [ 9] 3046         POP     AF              ; Restore starting position
   0F58 E3            [16] 3047         EX      (SP),HL         ; Get string,8ave code string
a  0F59               [16] 3048         LD      BC,MID1         ; Continuation of MID$ routine
   0F59 C5            [11] 3049         PUSH    BC              ; Save for return
   0F5A 3D            [ 4] 3050         DEC     A               ; Starting position-1
   0F5B BE            [ 6] 3051         CP      (HL)            ; Compare with length
a  0F5C               [ 6] 3052         LD      B,0             ; Zero bytes length
   0F5C D0            [10] 3053         RET     NC              ; Null string if start past end
   0F5D 4F            [ 4] 3054         LD      C,A             ; Save starting position-1
   0F5E 7E            [ 6] 3055         LD      A,(HL)          ; Get length of string
   0F5F 91            [ 4] 3056         SUB     C               ; Subtract start
   0F60 BB            [ 4] 3057         CP      E               ; Enough string for it?
   0F61 47            [ 4] 3058         LD      B,A             ; Save maximum length available
   0F62 D8            [10] 3059         RET     C               ; Truncate string if needed
   0F63 43            [ 4] 3060         LD      B,E             ; Set specified length
   0F64 C9            [ 9] 3061         RET                     ; Go and create string
                           3062 
   0F65 CD E4 0E      [16] 3063 VAL:    CALL    GETLEN          ; Get length of string
   0F68 CA 2C 11      [ 9] 3064         JP      Z,RESZER        ; Result zero
   0F6B 5F            [ 4] 3065         LD      E,A             ; Save length
   0F6C 23            [ 4] 3066         INC     HL
   0F6D 23            [ 4] 3067         INC     HL
   0F6E 7E            [ 6] 3068         LD      A,(HL)          ; Get LSB of address
   0F6F 23            [ 4] 3069         INC     HL
   0F70 66            [ 6] 3070         LD      H,(HL)          ; Get MSB of address
   0F71 6F            [ 4] 3071         LD      L,A             ; HL = String address
   0F72 E5            [11] 3072         PUSH    HL              ; Save string address
   0F73 19            [ 7] 3073         ADD     HL,DE
   0F74 46            [ 6] 3074         LD      B,(HL)          ; Get end of string+1 byte
   0F75 72            [ 7] 3075         LD      (HL),D          ; Zero it to terminate
   0F76 E3            [16] 3076         EX      (SP),HL         ; Save string end,get start
   0F77 C5            [11] 3077         PUSH    BC              ; Save end+1 byte
   0F78 7E            [ 6] 3078         LD      A,(HL)          ; Get starting byte
   0F79 CD 76 13      [16] 3079         CALL    ASCTFP          ; Convert ASCII string to FP
   0F7C C1            [ 9] 3080         POP     BC              ; Restore end+1 byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 57.
Hexadecimal [16-Bits]



   0F7D E1            [ 9] 3081         POP     HL              ; Restore end+1 address
   0F7E 70            [ 7] 3082         LD      (HL),B          ; Put back original byte
   0F7F C9            [ 9] 3083         RET
                           3084 
   0F80 EB            [ 3] 3085 LFRGNM: EX      DE,HL           ; Code string address to HL
q  0F81 CD 0C 00      [16] 3086         CALL    0xCKSYN          ; Make sure ")" follows
q                          3087         DB      ")"
   0F84 C1            [ 9] 3088 MIDNUM: POP     BC              ; Get return address
   0F85 D1            [ 9] 3089         POP     DE              ; Get number supplied
   0F86 C5            [11] 3090         PUSH    BC              ; Re-save return address
   0F87 43            [ 4] 3091         LD      B,E             ; Number to B
   0F88 C9            [ 9] 3092         RET
                           3093 
   0F89 CD CB 0F      [16] 3094 INP:    CALL    MAKINT          ; Make it integer A
   0F8C 32 3F 10      [13] 3095         LD      (INPORT),A      ; Set input port
   0F8F CD 3E 10      [16] 3096         CALL    INPSUB          ; Get input from port
   0F92 C3 A7 0C      [ 9] 3097         JP      PASSA           ; Return integer A
                           3098 
   0F95 CD B6 0F      [16] 3099 POUT:   CALL    SETIO           ; Set up port number
   0F98 C3 06 10      [ 9] 3100         JP      OUTSUB          ; Output data and return
                           3101 
   0F9B CD B6 0F      [16] 3102 WAIT:   CALL    SETIO           ; Set up port number
   0F9E F5            [11] 3103         PUSH    AF              ; Save AND mask
a  0F9F               [11] 3104         LD      E,0             ; Assume zero if none given
   0F9F 2B            [ 4] 3105         DEC     HL              ; DEC 'cos GET0xCR INCs
   0FA0 CD 4B 05      [16] 3106         CALL    GET0xCR          ; Get next character
   0FA3 CA AC 0F      [ 9] 3107         JP      Z,NOXOR         ; No XOR byte given
q  0FA6 CD 0C 00      [16] 3108         CALL    0xCKSYN          ; Make sure "," follows
q                          3109         DB      ","
   0FA9 CD C8 0F      [16] 3110         CALL    GETINT          ; Get integer 0-255 to XOR with
   0FAC C1            [ 9] 3111 NOXOR:  POP     BC              ; Restore AND mask
   0FAD CD 3E 10      [16] 3112 WAITLP: CALL    INPSUB          ; Get input
   0FB0 AB            [ 4] 3113         XOR     E               ; Flip selected bits
   0FB1 A0            [ 4] 3114         AND     B               ; Result non-zero?
   0FB2 CA AD 0F      [ 9] 3115         JP      Z,WAITLP        ; No = keep waiting
   0FB5 C9            [ 9] 3116         RET
                           3117 
   0FB6 CD C8 0F      [16] 3118 SETIO:  CALL    GETINT          ; Get integer 0-255
   0FB9 32 3F 10      [13] 3119         LD      (INPORT),A      ; Set input port
   0FBC 32 07 10      [13] 3120         LD      (OTPORT),A      ; Set output port
q  0FBF CD 0C 00      [16] 3121         CALL    0xCKSYN          ; Make sure "," follows
q                          3122         DB      ","
   0FC2 C3 C8 0F      [ 9] 3123         JP      GETINT          ; Get integer 0-255 and return
                           3124 
   0FC5 CD 4B 05      [16] 3125 FNDNUM: CALL    GET0xCR          ; Get next character
   0FC8 CD 72 09      [16] 3126 GETINT: CALL    GETNUM          ; Get a number from 0 to 255
   0FCB CD 5A 06      [16] 3127 MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
   0FCE 7A            [ 4] 3128         LD      A,D             ; Get MSB of number
   0FCF B7            [ 4] 3129         OR      A               ; Zero?
   0FD0 C2 6D 06      [ 9] 3130         JP      NZ,FCERR        ; No - Error
   0FD3 2B            [ 4] 3131         DEC     HL              ; DEC 'cos GET0xCR INCs
   0FD4 CD 4B 05      [16] 3132         CALL    GET0xCR          ; Get next character
   0FD7 7B            [ 4] 3133         LD      A,E             ; Get number to A
   0FD8 C9            [ 9] 3134         RET
                           3135 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 58.
Hexadecimal [16-Bits]



                           3136 ; << NO  REFERENCE  TO  THIS  SECTION  OF  CODE >>
                           3137 ; << Set up another program area (can be in ROM) >>
                           3138 
   0FD9 2A 5E 10      [15] 3139         LD      HL,(BASTXT)     ; Get start of program text
   0FDC 22 D6 10      [16] 3140         LD      (PROGND),HL     ; Set more variable space
a  0FDF               [16] 3141         LD      HL,0x8000        ; Address of new program
   0FDF 5E            [ 6] 3142         LD      E,(HL)          ; Get LSB of new RAM end
   0FE0 23            [ 4] 3143         INC     HL
   0FE1 56            [ 6] 3144         LD      D,(HL)          ; Get MSB of new RAM end
   0FE2 23            [ 4] 3145         INC     HL
   0FE3 23            [ 4] 3146         INC     HL              ; Null at start of program
   0FE4 22 5E 10      [16] 3147         LD      (BASTXT),HL     ; New program text area 0x8003
   0FE7 EB            [ 3] 3148         EX      DE,HL           ; New RAM end to HL
   0FE8 22 AF 10      [16] 3149         LD      (LSTRAM),HL     ; Set new RAM end
   0FEB 22 5A 10      [16] 3150         LD      (STRSPC),HL     ; Clear string space
a  0FEE               [16] 3151         LD      BC,RUNCNT       ; Execution driver loop
   0FEE C5            [11] 3152         PUSH    BC              ; Save for return
   0FEF C3 75 02      [ 9] 3153         JP      RUNFST          ; Clear variables and continue
                           3154 
   0FF2 C3 5A 16      [ 9] 3155 RUART:  JP      GUART           ; Get a byte from UART
                           3156 
   0FF5 CD F8 0F      [16] 3157 WUART2: CALL    WUART           ; Send 2 Bytes to UART
   0FF8 F5            [11] 3158 WUART:  PUSH    AF              ; Save byte
   0FF9 C5            [11] 3159         PUSH    BC              ; Save BC
   0FFA 4F            [ 4] 3160         LD      C,A             ; Byte to C
   0FFB CD 6C 16      [16] 3161         CALL    SUART           ; Send byte to UART
   0FFE C1            [ 9] 3162         POP     BC              ; Restore BC
   0FFF F1            [ 9] 3163         POP     AF              ; Restore byte
   1000 C9            [ 9] 3164         RET
                           3165 
a  1001               [ 9] 3166 CSAVE:  LD      B,1             ; Flag "CSAVE"
a  1001               [ 9] 3167         CP      ZTIMES          ; "*" token? ("CSAVE*")
   1001 CA BB 05      [ 9] 3168         JP      Z,ARRSV1        ; Yes - Array save
   1004 CD 85 09      [16] 3169         CALL    EVAL            ; Evaluate expression
   1007 E5            [11] 3170         PUSH    HL              ; Save code string address
   1008 CD F0 0E      [16] 3171         CALL    GTFLNM          ; Get file name
   100B D5            [11] 3172         PUSH    DE              ; Save file name
   100C CD EF 15      [16] 3173         CALL    CASFFW          ; Turn on motor and wait
   100F D1            [ 9] 3174         POP     DE              ; Restore file name
aq 1010               [ 9] 3175         LD      A,11010011B     ; Header byte
   1010 CD F8 0F      [16] 3176         CALL    WUART           ; Send byte to UART
   1013 CD F5 0F      [16] 3177         CALL    WUART2          ; Send byte twice more
   1016 1A            [ 6] 3178         LD      A,(DE)          ; Get file name
   1017 CD F8 0F      [16] 3179         CALL    WUART           ; Send it to UART
   101A 00            [ 3] 3180         NOP
   101B 00            [ 3] 3181         NOP
   101C 00            [ 3] 3182         NOP
a  101D               [ 3] 3183         LD      HL,PROGND       ; Start of program information
   101D 22 0C 0C      [16] 3184         LD      (ARG1),HL       ; Save for monitor save routine
   1020 2A D6 10      [15] 3185         LD      HL,(PROGND)     ; End of program information
   1023 22 0E 0C      [16] 3186         LD      (ARG2),HL       ; Save for monitor save routine
   1026 CD 48 17      [16] 3187         CALL    SAVE            ; Save program to tape
   1029 CD FD 15      [16] 3188         CALL    ARET            ; Not much there!
   102C E1            [ 9] 3189         POP     HL              ; Restore code string address
   102D C9            [ 9] 3190         RET
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 59.
Hexadecimal [16-Bits]



                           3191 
   102E 7E            [ 6] 3192 CLOAD:  LD      A,(HL)          ; Get byte after "CLOAD"
a  102F               [ 6] 3193         CP      ZTIMES          ; "*" token? ("CLOAD*")
   102F CA BB 05      [ 9] 3194         JP      Z,ARRLD1        ; Yes - Array load
   1032 CD 60 18      [16] 3195         CALL    SMOTOR          ; Start motor and get "?"
a  1035               [16] 3196         SUB     ZPRINT          ; "?" ("PRINT" token) Verify?
   1035 CA 39 10      [ 9] 3197         JP      Z,FLGVER        ; Yes - Flag "verify"
   1038 AF            [ 4] 3198         XOR     A               ; Flag "load"
q                          3199         DB      0x01             ; Skip "CPL" and "INC HL"
   1039 2F            [ 3] 3200 FLGVER: CPL                     ; Flag "verify"
   103A 23            [ 4] 3201         INC     HL              ; Skip over "?"
   103B F5            [11] 3202         PUSH    AF              ; Save verify flag
   103C 2B            [ 4] 3203         DEC     HL              ; DEC 'cos GET0xCR INCs
   103D CD 4B 05      [16] 3204         CALL    GET0xCR          ; Get next character
a  1040               [16] 3205         LD      A,0             ; Any file will do
   1040 CA 4A 10      [ 9] 3206         JP      Z,ANYNAM        ; No name given - Any will do
   1043 CD 85 09      [16] 3207         CALL    EVAL            ; Evaluate expression
   1046 CD F0 0E      [16] 3208         CALL    GTFLNM          ; Get file name
   1049 1A            [ 6] 3209         LD      A,(DE)          ; Get first byte of name
   104A 6F            [ 4] 3210 ANYNAM: LD      L,A             ; Save name to find
   104B F1            [ 9] 3211         POP     AF              ; Get verify flag
   104C F5            [11] 3212         PUSH    AF              ; And re-save
   104D B7            [ 4] 3213         OR      A               ; Verify of load?
   104E 67            [ 4] 3214         LD      H,A
   104F 22 E4 10      [16] 3215         LD      (FPREG),HL      ; Save nam of file to find
   1052 CC 6A 02      [16] 3216         CALL    Z,CLRPTR        ; Load - Clear pointers
   1055 2A E4 10      [15] 3217         LD      HL,(FPREG)      ; Get name of program to find
   1058 EB            [ 3] 3218         EX      DE,HL           ; Name to DE
a  1059               [ 3] 3219 CLOAD1: LD      B,3             ; 3 Header bytes
   1059 CD F2 0F      [16] 3220 CLOAD2: CALL    RUART           ; Get a byte from UART
q  105C                    3221         SUB     11010011B       ; Header byte?
   105C C2 59 10      [ 9] 3222         JP      NZ,CLOAD1       ; Look for header
   105F 05            [ 4] 3223         DEC     B               ; Count header bytes
   1060 C2 59 10      [ 9] 3224         JP      NZ,CLOAD2       ; More to find?
   1063 CD F2 0F      [16] 3225         CALL    RUART           ; Get name of file
   1066 CD 98 10      [16] 3226         CALL    FILFND          ; Display "file X found"
   1069 1C            [ 4] 3227         INC     E               ; Any file name given?
   106A 1D            [ 4] 3228         DEC     E
   106B CA 72 10      [ 9] 3229         JP      Z,THSFIL        ; No - This file will do
   106E BB            [ 4] 3230         CP      E               ; Has file been found?
   106F C2 59 10      [ 9] 3231         JP      NZ,CLOAD1       ; No - Look for another
   1072 00            [ 3] 3232 THSFIL: NOP
   1073 00            [ 3] 3233         NOP
   1074 00            [ 3] 3234         NOP
   1075 F1            [ 9] 3235         POP     AF              ; Get verify flag
   1076 B7            [ 4] 3236         OR      A               ; Load or verify?
   1077 C2 86 10      [ 9] 3237         JP      NZ,CLOADV       ; Verify program
   107A CD 5D 17      [16] 3238         CALL    MONLD           ; Use monitor to load program
   107D 2A D6 10      [15] 3239         LD      HL,(PROGND)     ; Get end of program
   1080 CD 72 01      [16] 3240         CALL    ENFMEM          ; See if enough memory
   1083 C3 89 10      [ 9] 3241         JP      CLOADE          ; "Ok" and set up pointers
                           3242 
   1086 CD 7D 17      [16] 3243 CLOADV: CALL    MONVE           ; Use monitor to verify program
a  1089               [16] 3244 CLOADE: LD      HL,OKMSG        ; "Ok" message
   1089 CD 92 0D      [16] 3245         CALL    PRS             ; Output string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 60.
Hexadecimal [16-Bits]



   108C CD FD 15      [16] 3246         CALL    ARET            ; Not a lot there!
   108F C3 2C 02      [ 9] 3247         JP      SETPTR          ; Set up line pointers
                           3248 
a  1092               [ 9] 3249 OUTBAD: LD      HL,BAD          ; "Bad" message
   1092 CD 92 0D      [16] 3250         CALL    PRS             ; Output string
   1095 C3 9E 01      [ 9] 3251         JP      ERRIN           ; In line message
                           3252 
   1098 C5            [11] 3253 FILFND: PUSH    BC              ; <- Save
   1099 E5            [11] 3254         PUSH    HL              ; <- all
   109A D5            [11] 3255         PUSH    DE              ; <- the
   109B F5            [11] 3256         PUSH    AF              ; <- registers
a  109C               [11] 3257         LD      HL,FILE         ; "File" message
   109C CD 92 0D      [16] 3258         CALL    PRS             ; Output string
   109F F1            [ 9] 3259         POP     AF              ; Get file name
   10A0 F5            [11] 3260         PUSH    AF              ; And re-save
   10A1 CD FE 15      [16] 3261         CALL    CONMON          ; Output file name to screen
a  10A4               [16] 3262         LD      HL,FOUND        ; "Found" message
   10A4 CD 92 0D      [16] 3263         CALL    PRS             ; Output string
   10A7 F1            [ 9] 3264         POP     AF              ; <- Restore
   10A8 D1            [ 9] 3265         POP     DE              ; <- all
   10A9 E1            [ 9] 3266         POP     HL              ; <- the
   10AA C1            [ 9] 3267         POP     BC              ; <- registers
   10AB C9            [ 9] 3268         RET
                           3269 
q  10AC                    3270 FILE:   DB      "File ",0
q  10AC                    3271 FOUND:  DB      " Found",CR,LF,0
q  10AC                    3272 BAD:    DB      "Bad",0,0,0
                           3273 
   10AC CD 60 06      [16] 3274 PEEK:   CALL    DEINT           ; Get memory address
   10AF 1A            [ 6] 3275         LD      A,(DE)          ; Get byte in memory
   10B0 C3 A7 0C      [ 9] 3276         JP      PASSA           ; Return integer A
                           3277 
   10B3 CD 72 09      [16] 3278 POKE:   CALL    GETNUM          ; Get memory address
   10B6 CD 60 06      [16] 3279         CALL    DEINT           ; Get integer -32768 to 3276
   10B9 D5            [11] 3280         PUSH    DE              ; Save memory address
q  10BA CD 0C 00      [16] 3281         CALL    0xCKSYN          ; Make sure "," follows
q                          3282         DB      ","
   10BD CD C8 0F      [16] 3283         CALL    GETINT          ; Get integer 0-255
   10C0 D1            [ 9] 3284         POP     DE              ; Restore memory address
   10C1 12            [ 7] 3285         LD      (DE),A          ; Load it into memory
   10C2 C9            [ 9] 3286         RET
                           3287 
a  10C3               [ 9] 3288 ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
   10C3 CD DC 12      [16] 3289 ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
   10C6 C3 D1 10      [ 9] 3290         JP      FPADD           ; Add BCDE to FPREG
                           3291 
   10C9 CD DC 12      [16] 3292 SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
q                          3293         DB      0x21             ; Skip "POP BC" and "POP DE"
   10CC C1            [ 9] 3294 PSUB:   POP     BC              ; Get FP number from stack
   10CD D1            [ 9] 3295         POP     DE
   10CE CD BE 12      [16] 3296 SUBCDE: CALL    INVSGN          ; Negate FPREG
   10D1 78            [ 4] 3297 FPADD:  LD      A,B             ; Get FP exponent
   10D2 B7            [ 4] 3298         OR      A               ; Is number zero?
   10D3 C8            [10] 3299         RET     Z               ; Yes - Nothing to add
   10D4 3A E7 10      [12] 3300         LD      A,(FPEXP)       ; Get FPREG exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 61.
Hexadecimal [16-Bits]



   10D7 B7            [ 4] 3301         OR      A               ; Is this number zero?
   10D8 CA D1 12      [ 9] 3302         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
   10DB 90            [ 4] 3303         SUB     B               ; BCDE number larger?
   10DC D2 EB 10      [ 9] 3304         JP      NC,NOSWAP       ; No - Don't swap them
   10DF 2F            [ 3] 3305         CPL                     ; Two's complement
   10E0 3C            [ 4] 3306         INC     A               ;  FP exponent
   10E1 EB            [ 3] 3307         EX      DE,HL
   10E2 CD C1 12      [16] 3308         CALL    STAKFP          ; Put FPREG on stack
   10E5 EB            [ 3] 3309         EX      DE,HL
   10E6 CD D1 12      [16] 3310         CALL    FPBCDE          ; Move BCDE to FPREG
   10E9 C1            [ 9] 3311         POP     BC              ; Restore number from stack
   10EA D1            [ 9] 3312         POP     DE
a  10EB               [ 9] 3313 NOSWAP: CP      24+1            ; Second number insignificant?
   10EB D0            [10] 3314         RET     NC              ; Yes - First number is result
   10EC F5            [11] 3315         PUSH    AF              ; Save number of bits to scale
   10ED CD EE 12      [16] 3316         CALL    SIGNS           ; Set MSBs & sign of result
   10F0 67            [ 4] 3317         LD      H,A             ; Save sign of result
   10F1 F1            [ 9] 3318         POP     AF              ; Restore scaling factor
   10F2 CD 7E 11      [16] 3319         CALL    SCALE           ; Scale BCDE to same exponent
   10F5 B4            [ 4] 3320         OR      H               ; Result to be positive?
a  10F6               [ 4] 3321         LD      HL,FPREG        ; Point to FPREG
   10F6 F2 0A 11      [ 9] 3322         JP      P,MINCDE        ; No - Subtract FPREG from CDE
   10F9 CD 61 11      [16] 3323         CALL    PLUCDE          ; Add FPREG to CDE
   10FC D2 49 11      [ 9] 3324         JP      NC,RONDUP       ; No overflow - Round it up
   10FF 23            [ 4] 3325         INC     HL              ; Point to exponent
   1100 34            [10] 3326         INC     (HL)            ; Increment it
   1101 CA 86 01      [ 9] 3327         JP      Z,OVERR         ; Number overflowed - Error
a  1104               [ 9] 3328         LD      L,1             ; 1 bit to shift right
   1104 CD 8C 11      [16] 3329         CALL    SHRT1           ; Shift result right
   1107 C3 49 11      [ 9] 3330         JP      RONDUP          ; Round it up
                           3331 
   110A AF            [ 4] 3332 MINCDE: XOR     A               ; Clear A and carry
   110B 90            [ 4] 3333         SUB     B               ; Negate exponent
   110C 47            [ 4] 3334         LD      B,A             ; Re-save exponent
   110D 7E            [ 6] 3335         LD      A,(HL)          ; Get LSB of FPREG
   110E 9B            [ 4] 3336         SBC     A, E            ; Subtract LSB of BCDE
   110F 5F            [ 4] 3337         LD      E,A             ; Save LSB of BCDE
   1110 23            [ 4] 3338         INC     HL
   1111 7E            [ 6] 3339         LD      A,(HL)          ; Get NMSB of FPREG
   1112 9A            [ 4] 3340         SBC     A,D             ; Subtract NMSB of BCDE
   1113 57            [ 4] 3341         LD      D,A             ; Save NMSB of BCDE
   1114 23            [ 4] 3342         INC     HL
   1115 7E            [ 6] 3343         LD      A,(HL)          ; Get MSB of FPREG
   1116 99            [ 4] 3344         SBC     A,C             ; Subtract MSB of BCDE
   1117 4F            [ 4] 3345         LD      C,A             ; Save MSB of BCDE
   1118 DC 6D 11      [16] 3346 CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                           3347 
   111B 68            [ 4] 3348 BNORM:  LD      L,B             ; L = Exponent
   111C 63            [ 4] 3349         LD      H,E             ; H = LSB
   111D AF            [ 4] 3350         XOR     A
   111E 47            [ 4] 3351 BNRMLP: LD      B,A             ; Save bit count
   111F 79            [ 4] 3352         LD      A,C             ; Get MSB
   1120 B7            [ 4] 3353         OR      A               ; Is it zero?
   1121 C2 39 11      [ 9] 3354         JP      NZ,PNORM        ; No - Do it bit at a time
   1124 4A            [ 4] 3355         LD      C,D             ; MSB = NMSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 62.
Hexadecimal [16-Bits]



   1125 54            [ 4] 3356         LD      D,H             ; NMSB= LSB
   1126 65            [ 4] 3357         LD      H,L             ; LSB = VLSB
   1127 6F            [ 4] 3358         LD      L,A             ; VLSB= 0
   1128 78            [ 4] 3359         LD      A,B             ; Get exponent
a  1129               [ 4] 3360         SUB     8               ; Count 8 bits
a  1129               [ 4] 3361         CP      -24-8           ; Was number zero?
   1129 C2 1E 11      [ 9] 3362         JP      NZ,BNRMLP       ; No - Keep normalising
   112C AF            [ 4] 3363 RESZER: XOR     A               ; Result is zero
   112D 32 E7 10      [13] 3364 SAVEXP: LD      (FPEXP),A       ; Save result as zero
   1130 C9            [ 9] 3365         RET
                           3366 
   1131 05            [ 4] 3367 NORMAL: DEC     B               ; Count bits
   1132 29            [ 7] 3368         ADD     HL,HL           ; Shift HL left
   1133 7A            [ 4] 3369         LD      A,D             ; Get NMSB
   1134 17            [ 3] 3370         RLA                     ; Shift left with last bit
   1135 57            [ 4] 3371         LD      D,A             ; Save NMSB
   1136 79            [ 4] 3372         LD      A,C             ; Get MSB
   1137 8F            [ 4] 3373         ADC     A,A             ; Shift left with last bit
   1138 4F            [ 4] 3374         LD      C,A             ; Save MSB
   1139 F2 31 11      [ 9] 3375 PNORM:  JP      P,NORMAL        ; Not done - Keep going
   113C 78            [ 4] 3376         LD      A,B             ; Number of bits shifted
   113D 5C            [ 4] 3377         LD      E,H             ; Save HL in EB
   113E 45            [ 4] 3378         LD      B,L
   113F B7            [ 4] 3379         OR      A               ; Any shifting done?
   1140 CA 49 11      [ 9] 3380         JP      Z,RONDUP        ; No - Round it up
a  1143               [ 9] 3381         LD      HL,FPEXP        ; Point to exponent
   1143 86            [ 6] 3382         ADD     A,(HL)          ; Add shifted bits
   1144 77            [ 7] 3383         LD      (HL),A          ; Re-save exponent
   1145 D2 2C 11      [ 9] 3384         JP      NC,RESZER       ; Underflow - Result is zero
   1148 C8            [10] 3385         RET     Z               ; Result is zero
   1149 78            [ 4] 3386 RONDUP: LD      A,B             ; Get VLSB of number
a  114A               [ 4] 3387 RONDB:  LD      HL,FPEXP        ; Point to exponent
   114A B7            [ 4] 3388         OR      A               ; Any rounding?
   114B FC 56 11      [16] 3389         CALL    M,FPROND        ; Yes - Round number up
   114E 46            [ 6] 3390         LD      B,(HL)          ; B = Exponent
   114F 23            [ 4] 3391         INC     HL
   1150 7E            [ 6] 3392         LD      A,(HL)          ; Get sign of result
q  1151                    3393         AND     10000000B       ; Only bit 7 needed
   1151 A9            [ 4] 3394         XOR     C               ; Set correct sign
   1152 4F            [ 4] 3395         LD      C,A             ; Save correct sign in number
   1153 C3 D1 12      [ 9] 3396         JP      FPBCDE          ; Move BCDE to FPREG
                           3397 
   1156 1C            [ 4] 3398 FPROND: INC     E               ; Round LSB
   1157 C0            [10] 3399         RET     NZ              ; Return if ok
   1158 14            [ 4] 3400         INC     D               ; Round NMSB
   1159 C0            [10] 3401         RET     NZ              ; Return if ok
   115A 0C            [ 4] 3402         INC     C               ; Round MSB
   115B C0            [10] 3403         RET     NZ              ; Return if ok
a  115C               [10] 3404         LD      C,0x80           ; Set normal value
   115C 34            [10] 3405         INC     (HL)            ; Increment exponent
   115D C0            [10] 3406         RET     NZ              ; Return if ok
   115E C3 86 01      [ 9] 3407         JP      OVERR           ; Overflow error
                           3408 
   1161 7E            [ 6] 3409 PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
   1162 83            [ 4] 3410         ADD     A,E             ; Add LSB of BCDE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 63.
Hexadecimal [16-Bits]



   1163 5F            [ 4] 3411         LD      E,A             ; Save LSB of BCDE
   1164 23            [ 4] 3412         INC     HL
   1165 7E            [ 6] 3413         LD      A,(HL)          ; Get NMSB of FPREG
   1166 8A            [ 4] 3414         ADC     A,D             ; Add NMSB of BCDE
   1167 57            [ 4] 3415         LD      D,A             ; Save NMSB of BCDE
   1168 23            [ 4] 3416         INC     HL
   1169 7E            [ 6] 3417         LD      A,(HL)          ; Get MSB of FPREG
   116A 89            [ 4] 3418         ADC     A,C             ; Add MSB of BCDE
   116B 4F            [ 4] 3419         LD      C,A             ; Save MSB of BCDE
   116C C9            [ 9] 3420         RET
                           3421 
a  116D               [ 9] 3422 COMPL:  LD      HL,SGNRES       ; Sign of result
   116D 7E            [ 6] 3423         LD      A,(HL)          ; Get sign of result
   116E 2F            [ 3] 3424         CPL                     ; Negate it
   116F 77            [ 7] 3425         LD      (HL),A          ; Put it back
   1170 AF            [ 4] 3426         XOR     A
   1171 6F            [ 4] 3427         LD      L,A             ; Set L to zero
   1172 90            [ 4] 3428         SUB     B               ; Negate exponent,set carry
   1173 47            [ 4] 3429         LD      B,A             ; Re-save exponent
   1174 7D            [ 4] 3430         LD      A,L             ; Load zero
   1175 9B            [ 4] 3431         SBC     A,E             ; Negate LSB
   1176 5F            [ 4] 3432         LD      E,A             ; Re-save LSB
   1177 7D            [ 4] 3433         LD      A,L             ; Load zero
   1178 9A            [ 4] 3434         SBC     A,D             ; Negate NMSB
   1179 57            [ 4] 3435         LD      D,A             ; Re-save NMSB
   117A 7D            [ 4] 3436         LD      A,L             ; Load zero
   117B 99            [ 4] 3437         SBC     A,C             ; Negate MSB
   117C 4F            [ 4] 3438         LD      C,A             ; Re-save MSB
   117D C9            [ 9] 3439         RET
                           3440 
a  117E               [ 9] 3441 SCALE:  LD      B,0             ; Clear underflow
a  117E               [ 9] 3442 SCALLP: SUB     8               ; 8 bits (a whole byte)?
   117E DA 87 11      [ 9] 3443         JP      C,SHRITE        ; No - Shift right A bits
   1181 43            [ 4] 3444         LD      B,E             ; <- Shift
   1182 5A            [ 4] 3445         LD      E,D             ; <- right
   1183 51            [ 4] 3446         LD      D,C             ; <- eight
a  1184               [ 4] 3447         LD      C,0             ; <- bits
   1184 C3 7E 11      [ 9] 3448         JP      SCALLP          ; More bits to shift
                           3449 
a  1187               [ 9] 3450 SHRITE: ADD     A,8+1           ; Adjust count
   1187 6F            [ 4] 3451         LD      L,A             ; Save bits to shift
   1188 AF            [ 4] 3452 SHRLP:  XOR     A               ; Flag for all done
   1189 2D            [ 4] 3453         DEC     L               ; All shifting done?
   118A C8            [10] 3454         RET     Z               ; Yes - Return
   118B 79            [ 4] 3455         LD      A,C             ; Get MSB
   118C 1F            [ 3] 3456 SHRT1:  RRA                     ; Shift it right
   118D 4F            [ 4] 3457         LD      C,A             ; Re-save
   118E 7A            [ 4] 3458         LD      A,D             ; Get NMSB
   118F 1F            [ 3] 3459         RRA                     ; Shift right with last bit
   1190 57            [ 4] 3460         LD      D,A             ; Re-save it
   1191 7B            [ 4] 3461         LD      A,E             ; Get LSB
   1192 1F            [ 3] 3462         RRA                     ; Shift right with last bit
   1193 5F            [ 4] 3463         LD      E,A             ; Re-save it
   1194 78            [ 4] 3464         LD      A,B             ; Get underflow
   1195 1F            [ 3] 3465         RRA                     ; Shift right with last bit
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 64.
Hexadecimal [16-Bits]



   1196 47            [ 4] 3466         LD      B,A             ; Re-save underflow
   1197 C3 88 11      [ 9] 3467         JP      SHRLP           ; More bits to do
                           3468 
q  119A                    3469 UNITY:  DB       0x000,000H,000H,081H    ; 1.00000
                           3470 
q  119A                    3471 LOGTAB: DB      3                       ; Table used by LOG
q                          3472         DB      0x0AA,056H,019H,080H     ; 0.59898
q                          3473         DB      0x0F1,022H,076H,080H     ; 0.96147
q                          3474         DB      0x045,0AAH,038H,082H     ; 2.88539
                           3475 
   119A CD A2 12      [16] 3476 LOG:    CALL    TSTSGN          ; Test sign of value
   119D B7            [ 4] 3477         OR      A
   119E EA 6D 06      [ 9] 3478         JP      PE,FCERR        ; ?FC Error if <= zero
a  11A1               [ 9] 3479         LD      HL,FPEXP        ; Point to exponent
   11A1 7E            [ 6] 3480         LD      A,(HL)          ; Get exponent
a  11A2               [ 6] 3481         LD      BC,0x8035        ; BCDE = SQR(1/2)
a  11A2               [ 6] 3482         LD      DE,0x04F3
   11A2 90            [ 4] 3483         SUB     B               ; Scale value to be < 1
   11A3 F5            [11] 3484         PUSH    AF              ; Save scale factor
   11A4 70            [ 7] 3485         LD      (HL),B          ; Save new exponent
   11A5 D5            [11] 3486         PUSH    DE              ; Save SQR(1/2)
   11A6 C5            [11] 3487         PUSH    BC
   11A7 CD D1 10      [16] 3488         CALL    FPADD           ; Add SQR(1/2) to value
   11AA C1            [ 9] 3489         POP     BC              ; Restore SQR(1/2)
   11AB D1            [ 9] 3490         POP     DE
   11AC 04            [ 4] 3491         INC     B               ; Make it SQR(2)
   11AD CD 0A 12      [16] 3492         CALL    DVBCDE          ; Divide by SQR(2)
a  11B0               [16] 3493         LD      HL,UNITY        ; Point to 1.
   11B0 CD C9 10      [16] 3494         CALL    SUBPHL          ; Subtract FPREG from 1
a  11B3               [16] 3495         LD      HL,LOGTAB       ; Coefficient table
   11B3 CD 18 15      [16] 3496         CALL    SUMSER          ; Evaluate sum of series
a  11B6               [16] 3497         LD      BC,0x8080        ; BCDE = -0.5
a  11B6               [16] 3498         LD      DE,0x0000
   11B6 CD D1 10      [16] 3499         CALL    FPADD           ; Subtract 0.5 from FPREG
   11B9 F1            [ 9] 3500         POP     AF              ; Restore scale factor
   11BA CD E0 13      [16] 3501         CALL    RSCALE          ; Re-scale number
a  11BD               [16] 3502 MULLN2: LD      BC,0x8031        ; BCDE = Ln(2)
a  11BD               [16] 3503         LD      DE,0x7218
q                          3504         DB      0x21             ; Skip "POP BC" and "POP DE"
                           3505 
   11BD C1            [ 9] 3506 MULT:   POP     BC              ; Get number from stack
   11BE D1            [ 9] 3507         POP     DE
   11BF CD A2 12      [16] 3508 FPMULT: CALL    TSTSGN          ; Test sign of FPREG
   11C2 C8            [10] 3509         RET     Z               ; Return zero if zero
a  11C3               [10] 3510         LD      L,0             ; Flag add exponents
   11C3 CD 6A 12      [16] 3511         CALL    ADDEXP          ; Add exponents
   11C6 79            [ 4] 3512         LD      A,C             ; Get MSB of multiplier
   11C7 32 F6 10      [13] 3513         LD      (MULVAL),A      ; Save MSB of multiplier
   11CA EB            [ 3] 3514         EX      DE,HL
   11CB 22 F7 10      [16] 3515         LD      (MULVAL+1),HL   ; Save rest of multiplier
a  11CE               [16] 3516         LD      BC,0            ; Partial product (BCDE) = zero
   11CE 50            [ 4] 3517         LD      D,B
   11CF 58            [ 4] 3518         LD      E,B
a  11D0               [ 4] 3519         LD      HL,BNORM        ; Address of normalise
   11D0 E5            [11] 3520         PUSH    HL              ; Save for return
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 65.
Hexadecimal [16-Bits]



a  11D1               [11] 3521         LD      HL,MULT8        ; Address of 8 bit multiply
   11D1 E5            [11] 3522         PUSH    HL              ; Save for NMSB,MSB
   11D2 E5            [11] 3523         PUSH    HL              ; 
a  11D3               [11] 3524         LD      HL,FPREG        ; Point to number
   11D3 7E            [ 6] 3525 MULT8:  LD      A,(HL)          ; Get LSB of number
   11D4 23            [ 4] 3526         INC     HL              ; Point to NMSB
   11D5 B7            [ 4] 3527         OR      A               ; Test LSB
   11D6 CA FD 11      [ 9] 3528         JP      Z,BYTSFT        ; Zero - shift to next byte
   11D9 E5            [11] 3529         PUSH    HL              ; Save address of number
a  11DA               [11] 3530         LD      L,8             ; 8 bits to multiply by
   11DA 1F            [ 3] 3531 MUL8LP: RRA                     ; Shift LSB right
   11DB 67            [ 4] 3532         LD      H,A             ; Save LSB
   11DC 79            [ 4] 3533         LD      A,C             ; Get MSB
   11DD D2 EB 11      [ 9] 3534         JP      NC,NOMADD       ; Bit was zero - Don't add
   11E0 E5            [11] 3535         PUSH    HL              ; Save LSB and count
   11E1 2A F7 10      [15] 3536         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
   11E4 19            [ 7] 3537         ADD     HL,DE           ; Add NMSB and LSB
   11E5 EB            [ 3] 3538         EX      DE,HL           ; Leave sum in DE
   11E6 E1            [ 9] 3539         POP     HL              ; Restore MSB and count
   11E7 3A F6 10      [12] 3540         LD      A,(MULVAL)      ; Get MSB of multiplier
   11EA 89            [ 4] 3541         ADC     A,C             ; Add MSB
   11EB 1F            [ 3] 3542 NOMADD: RRA                     ; Shift MSB right
   11EC 4F            [ 4] 3543         LD      C,A             ; Re-save MSB
   11ED 7A            [ 4] 3544         LD      A,D             ; Get NMSB
   11EE 1F            [ 3] 3545         RRA                     ; Shift NMSB right
   11EF 57            [ 4] 3546         LD      D,A             ; Re-save NMSB
   11F0 7B            [ 4] 3547         LD      A,E             ; Get LSB
   11F1 1F            [ 3] 3548         RRA                     ; Shift LSB right
   11F2 5F            [ 4] 3549         LD      E,A             ; Re-save LSB
   11F3 78            [ 4] 3550         LD      A,B             ; Get VLSB
   11F4 1F            [ 3] 3551         RRA                     ; Shift VLSB right
   11F5 47            [ 4] 3552         LD      B,A             ; Re-save VLSB
   11F6 2D            [ 4] 3553         DEC     L               ; Count bits multiplied
   11F7 7C            [ 4] 3554         LD      A,H             ; Get LSB of multiplier
   11F8 C2 DA 11      [ 9] 3555         JP      NZ,MUL8LP       ; More - Do it
   11FB E1            [ 9] 3556 POPHRT: POP     HL              ; Restore address of number
   11FC C9            [ 9] 3557         RET
                           3558 
   11FD 43            [ 4] 3559 BYTSFT: LD      B,E             ; Shift partial product left
   11FE 5A            [ 4] 3560         LD      E,D
   11FF 51            [ 4] 3561         LD      D,C
   1200 4F            [ 4] 3562         LD      C,A
   1201 C9            [ 9] 3563         RET
                           3564 
   1202 CD C1 12      [16] 3565 DIV10:  CALL    STAKFP          ; Save FPREG on stack
a  1205               [16] 3566         LD      BC,0x8420        ; BCDE = 10.
a  1205               [16] 3567         LD      DE,0x0000
   1205 CD D1 12      [16] 3568         CALL    FPBCDE          ; Move 10 to FPREG
                           3569 
   1208 C1            [ 9] 3570 DIV:    POP     BC              ; Get number from stack
   1209 D1            [ 9] 3571         POP     DE
   120A CD A2 12      [16] 3572 DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
   120D CA 86 01      [ 9] 3573         JP      Z,DZERR         ; Error if division by zero
a  1210               [ 9] 3574         LD      L,-1            ; Flag subtract exponents
   1210 CD 6A 12      [16] 3575         CALL    ADDEXP          ; Subtract exponents
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 66.
Hexadecimal [16-Bits]



   1213 34            [10] 3576         INC     (HL)            ; Add 2 to exponent to adjust
   1214 34            [10] 3577         INC     (HL)
   1215 2B            [ 4] 3578         DEC     HL              ; Point to MSB
   1216 7E            [ 6] 3579         LD      A,(HL)          ; Get MSB of dividend
   1217 32 12 10      [13] 3580         LD      (DIV3),A        ; Save for subtraction
   121A 2B            [ 4] 3581         DEC     HL
   121B 7E            [ 6] 3582         LD      A,(HL)          ; Get NMSB of dividend
   121C 32 0E 10      [13] 3583         LD      (DIV2),A        ; Save for subtraction
   121F 2B            [ 4] 3584         DEC     HL
   1220 7E            [ 6] 3585         LD      A,(HL)          ; Get MSB of dividend
   1221 32 0A 10      [13] 3586         LD      (DIV1),A        ; Save for subtraction
   1224 41            [ 4] 3587         LD      B,C             ; Get MSB
   1225 EB            [ 3] 3588         EX      DE,HL           ; NMSB,LSB to HL
   1226 AF            [ 4] 3589         XOR     A
   1227 4F            [ 4] 3590         LD      C,A             ; Clear MSB of quotient
   1228 57            [ 4] 3591         LD      D,A             ; Clear NMSB of quotient
   1229 5F            [ 4] 3592         LD      E,A             ; Clear LSB of quotient
   122A 32 15 10      [13] 3593         LD      (DIV4),A        ; Clear overflow count
   122D E5            [11] 3594 DIVLP:  PUSH    HL              ; Save divisor
   122E C5            [11] 3595         PUSH    BC
   122F 7D            [ 4] 3596         LD      A,L             ; Get LSB of number
   1230 CD 09 10      [16] 3597         CALL    DIVSUP          ; Subt' divisor from dividend
a  1233               [16] 3598         SBC     A,0             ; Count for overflows
   1233 3F            [ 3] 3599         CCF
   1234 D2 3D 12      [ 9] 3600         JP      NC,RESDIV       ; Restore divisor if borrow
   1237 32 15 10      [13] 3601         LD      (DIV4),A        ; Re-save overflow count
   123A F1            [ 9] 3602         POP     AF              ; Scrap divisor
   123B F1            [ 9] 3603         POP     AF
   123C 37            [ 3] 3604         SCF                     ; Set carry to
q                          3605         DB      0x0D2            ; Skip "POP BC" and "POP HL"
                           3606 
   123D C1            [ 9] 3607 RESDIV: POP     BC              ; Restore divisor
   123E E1            [ 9] 3608         POP     HL
   123F 79            [ 4] 3609         LD      A,C             ; Get MSB of quotient
   1240 3C            [ 4] 3610         INC     A
   1241 3D            [ 4] 3611         DEC     A
   1242 1F            [ 3] 3612         RRA                     ; Bit 0 to bit 7
   1243 FA 4A 11      [ 9] 3613         JP      M,RONDB         ; Done - Normalise result
   1246 17            [ 3] 3614         RLA                     ; Restore carry
   1247 7B            [ 4] 3615         LD      A,E             ; Get LSB of quotient
   1248 17            [ 3] 3616         RLA                     ; Double it
   1249 5F            [ 4] 3617         LD      E,A             ; Put it back
   124A 7A            [ 4] 3618         LD      A,D             ; Get NMSB of quotient
   124B 17            [ 3] 3619         RLA                     ; Double it
   124C 57            [ 4] 3620         LD      D,A             ; Put it back
   124D 79            [ 4] 3621         LD      A,C             ; Get MSB of quotient
   124E 17            [ 3] 3622         RLA                     ; Double it
   124F 4F            [ 4] 3623         LD      C,A             ; Put it back
   1250 29            [ 7] 3624         ADD     HL,HL           ; Double NMSB,LSB of divisor
   1251 78            [ 4] 3625         LD      A,B             ; Get MSB of divisor
   1252 17            [ 3] 3626         RLA                     ; Double it
   1253 47            [ 4] 3627         LD      B,A             ; Put it back
   1254 3A 15 10      [12] 3628         LD      A,(DIV4)        ; Get VLSB of quotient
   1257 17            [ 3] 3629         RLA                     ; Double it
   1258 32 15 10      [13] 3630         LD      (DIV4),A        ; Put it back
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 67.
Hexadecimal [16-Bits]



   125B 79            [ 4] 3631         LD      A,C             ; Get MSB of quotient
   125C B2            [ 4] 3632         OR      D               ; Merge NMSB
   125D B3            [ 4] 3633         OR      E               ; Merge LSB
   125E C2 2D 12      [ 9] 3634         JP      NZ,DIVLP        ; Not done - Keep dividing
   1261 E5            [11] 3635         PUSH    HL              ; Save divisor
a  1262               [11] 3636         LD      HL,FPEXP        ; Point to exponent
   1262 35            [10] 3637         DEC     (HL)            ; Divide by 2
   1263 E1            [ 9] 3638         POP     HL              ; Restore divisor
   1264 C2 2D 12      [ 9] 3639         JP      NZ,DIVLP        ; Ok - Keep going
   1267 C3 86 01      [ 9] 3640         JP      OVERR           ; Overflow error
                           3641 
   126A 78            [ 4] 3642 ADDEXP: LD      A,B             ; Get exponent of dividend
   126B B7            [ 4] 3643         OR      A               ; Test it
   126C CA 89 12      [ 9] 3644         JP      Z,OVTST3        ; Zero - Result zero
   126F 7D            [ 4] 3645         LD      A,L             ; Get add/subtract flag
a  1270               [ 4] 3646         LD      HL,FPEXP        ; Point to exponent
   1270 AE            [ 6] 3647         XOR     (HL)            ; Add or subtract it
   1271 80            [ 4] 3648         ADD     A,B             ; Add the other exponent
   1272 47            [ 4] 3649         LD      B,A             ; Save new exponent
   1273 1F            [ 3] 3650         RRA                     ; Test exponent for overflow
   1274 A8            [ 4] 3651         XOR     B
   1275 78            [ 4] 3652         LD      A,B             ; Get exponent
   1276 F2 88 12      [ 9] 3653         JP      P,OVTST2        ; Positive - Test for overflow
a  1279               [ 9] 3654         ADD     A,0x80           ; Add excess 128
   1279 77            [ 7] 3655         LD      (HL),A          ; Save new exponent
   127A CA FB 11      [ 9] 3656         JP      Z,POPHRT        ; Zero - Result zero
   127D CD EE 12      [16] 3657         CALL    SIGNS           ; Set MSBs and sign of result
   1280 77            [ 7] 3658         LD      (HL),A          ; Save new exponent
   1281 2B            [ 4] 3659         DEC     HL              ; Point to MSB
   1282 C9            [ 9] 3660         RET
                           3661 
   1283 CD A2 12      [16] 3662 OVTST1: CALL    TSTSGN          ; Test sign of FPREG
   1286 2F            [ 3] 3663         CPL                     ; Invert sign
   1287 E1            [ 9] 3664         POP     HL              ; Clean up stack
   1288 B7            [ 4] 3665 OVTST2: OR      A               ; Test if new exponent zero
   1289 E1            [ 9] 3666 OVTST3: POP     HL              ; Clear off return address
   128A F2 2C 11      [ 9] 3667         JP      P,RESZER        ; Result zero
   128D C3 86 01      [ 9] 3668         JP      OVERR           ; Overflow error
                           3669 
   1290 CD DC 12      [16] 3670 MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
   1293 78            [ 4] 3671         LD      A,B             ; Get exponent
   1294 B7            [ 4] 3672         OR      A               ; Is it zero?
   1295 C8            [10] 3673         RET     Z               ; Yes - Result is zero
a  1296               [10] 3674         ADD     A,2             ; Multiply by 4
   1296 DA 86 01      [ 9] 3675         JP      C,OVERR         ; Overflow - ?OV Error
   1299 47            [ 4] 3676         LD      B,A             ; Re-save exponent
   129A CD D1 10      [16] 3677         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
a  129D               [16] 3678         LD      HL,FPEXP        ; Point to exponent
   129D 34            [10] 3679         INC     (HL)            ; Double number (Times 10)
   129E C0            [10] 3680         RET     NZ              ; Ok - Return
   129F C3 86 01      [ 9] 3681         JP      OVERR           ; Overflow error
                           3682 
   12A2 3A E7 10      [12] 3683 TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
   12A5 B7            [ 4] 3684         OR      A
   12A6 C8            [10] 3685         RET     Z               ; RETurn if number is zero
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 68.
Hexadecimal [16-Bits]



   12A7 3A E6 10      [12] 3686         LD      A,(FPREG+2)     ; Get MSB of FPREG
q                          3687         DB      0x0FE            ; Test sign
   12AA 2F            [ 3] 3688 RETREL: CPL                     ; Invert sign
   12AB 17            [ 3] 3689         RLA                     ; Sign bit to carry
   12AC 9F            [ 4] 3690 FLGDIF: SBC     A,A             ; Carry to all bits of A
   12AD C0            [10] 3691         RET     NZ              ; Return -1 if negative
   12AE 3C            [ 4] 3692         INC     A               ; Bump to +1
   12AF C9            [ 9] 3693         RET                     ; Positive - Return +1
                           3694 
   12B0 CD A2 12      [16] 3695 SGN:    CALL    TSTSGN          ; Test sign of FPREG
a  12B3               [16] 3696 FLGREL: LD      B,0x80+8         ; 8 bit integer in exponent
a  12B3               [16] 3697         LD      DE,0            ; Zero NMSB and LSB
a  12B3               [16] 3698 RETINT: LD      HL,FPEXP        ; Point to exponent
   12B3 4F            [ 4] 3699         LD      C,A             ; CDE = MSB,NMSB and LSB
   12B4 70            [ 7] 3700         LD      (HL),B          ; Save exponent
a  12B5               [ 7] 3701         LD      B,0             ; CDE = integer to normalise
   12B5 23            [ 4] 3702         INC     HL              ; Point to sign of result
a  12B6               [ 4] 3703         LD      (HL),0x80        ; Set sign of result
   12B6 17            [ 3] 3704         RLA                     ; Carry = sign of integer
   12B7 C3 18 11      [ 9] 3705         JP      CONPOS          ; Set sign of result
                           3706 
   12BA CD A2 12      [16] 3707 ABS:    CALL    TSTSGN          ; Test sign of FPREG
   12BD F0            [10] 3708         RET     P               ; Return if positive
a  12BE               [10] 3709 INVSGN: LD      HL,FPREG+2      ; Point to MSB
   12BE 7E            [ 6] 3710         LD      A,(HL)          ; Get sign of mantissa
a  12BF               [ 6] 3711         XOR     0x80             ; Invert sign of mantissa
   12BF 77            [ 7] 3712         LD      (HL),A          ; Re-save sign of mantissa
   12C0 C9            [ 9] 3713         RET
                           3714 
   12C1 EB            [ 3] 3715 STAKFP: EX      DE,HL           ; Save code string address
   12C2 2A E4 10      [15] 3716         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
   12C5 E3            [16] 3717         EX      (SP),HL         ; Stack them,get return
   12C6 E5            [11] 3718         PUSH    HL              ; Re-save return
   12C7 2A E6 10      [15] 3719         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
   12CA E3            [16] 3720         EX      (SP),HL         ; Stack them,get return
   12CB E5            [11] 3721         PUSH    HL              ; Re-save return
   12CC EB            [ 3] 3722         EX      DE,HL           ; Restore code string address
   12CD C9            [ 9] 3723         RET
                           3724 
   12CE CD DC 12      [16] 3725 PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
   12D1 EB            [ 3] 3726 FPBCDE: EX      DE,HL           ; Save code string address
   12D2 22 E4 10      [16] 3727         LD      (FPREG),HL      ; Save LSB,NLSB of number
   12D5 60            [ 4] 3728         LD      H,B             ; Exponent of number
   12D6 69            [ 4] 3729         LD      L,C             ; MSB of number
   12D7 22 E6 10      [16] 3730         LD      (FPREG+2),HL    ; Save MSB and exponent
   12DA EB            [ 3] 3731         EX      DE,HL           ; Restore code string address
   12DB C9            [ 9] 3732         RET
                           3733 
a  12DC               [ 9] 3734 BCDEFP: LD      HL,FPREG        ; Point to FPREG
   12DC 5E            [ 6] 3735 LOADFP: LD      E,(HL)          ; Get LSB of number
   12DD 23            [ 4] 3736         INC     HL
   12DE 56            [ 6] 3737         LD      D,(HL)          ; Get NMSB of number
   12DF 23            [ 4] 3738         INC     HL
   12E0 4E            [ 6] 3739         LD      C,(HL)          ; Get MSB of number
   12E1 23            [ 4] 3740         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 69.
Hexadecimal [16-Bits]



   12E2 46            [ 6] 3741         LD      B,(HL)          ; Get exponent of number
   12E3 23            [ 4] 3742 IN0xCL:  INC     HL              ; Used for conditional "INC HL"
   12E4 C9            [ 9] 3743         RET
                           3744 
a  12E5               [ 9] 3745 FPTHL:  LD      DE,FPREG        ; Point to FPREG
a  12E5               [ 9] 3746 DETHL4: LD      B,4             ; 4 bytes to move
   12E5 1A            [ 6] 3747 DETHLB: LD      A,(DE)          ; Get source
   12E6 77            [ 7] 3748         LD      (HL),A          ; Save destination
   12E7 13            [ 4] 3749         INC     DE              ; Next source
   12E8 23            [ 4] 3750         INC     HL              ; Next destination
   12E9 05            [ 4] 3751         DEC     B               ; Count bytes
   12EA C2 E5 12      [ 9] 3752         JP      NZ,DETHLB       ; Loop if more
   12ED C9            [ 9] 3753         RET
                           3754 
a  12EE               [ 9] 3755 SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
   12EE 7E            [ 6] 3756         LD      A,(HL)          ; Get MSB
   12EF 07            [ 3] 3757         RLCA                    ; Old sign to carry
   12F0 37            [ 3] 3758         SCF                     ; Set MSBit
   12F1 1F            [ 3] 3759         RRA                     ; Set MSBit of MSB
   12F2 77            [ 7] 3760         LD      (HL),A          ; Save new MSB
   12F3 3F            [ 3] 3761         CCF                     ; Complement sign
   12F4 1F            [ 3] 3762         RRA                     ; Old sign to carry
   12F5 23            [ 4] 3763         INC     HL
   12F6 23            [ 4] 3764         INC     HL
   12F7 77            [ 7] 3765         LD      (HL),A          ; Set sign of result
   12F8 79            [ 4] 3766         LD      A,C             ; Get MSB
   12F9 07            [ 3] 3767         RLCA                    ; Old sign to carry
   12FA 37            [ 3] 3768         SCF                     ; Set MSBit
   12FB 1F            [ 3] 3769         RRA                     ; Set MSBit of MSB
   12FC 4F            [ 4] 3770         LD      C,A             ; Save MSB
   12FD 1F            [ 3] 3771         RRA
   12FE AE            [ 6] 3772         XOR     (HL)            ; New sign of result
   12FF C9            [ 9] 3773         RET
                           3774 
   1300 78            [ 4] 3775 CMPNUM: LD      A,B             ; Get exponent of number
   1301 B7            [ 4] 3776         OR      A
   1302 CA A2 12      [ 9] 3777         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
a  1305               [ 9] 3778         LD      HL,RETREL       ; Return relation routine
   1305 E5            [11] 3779         PUSH    HL              ; Save for return
   1306 CD A2 12      [16] 3780         CALL    TSTSGN          ; Test sign of FPREG
   1309 79            [ 4] 3781         LD      A,C             ; Get MSB of number
   130A C8            [10] 3782         RET     Z               ; FPREG zero - Number's MSB
a  130B               [10] 3783         LD      HL,FPREG+2      ; MSB of FPREG
   130B AE            [ 6] 3784         XOR     (HL)            ; Combine signs
   130C 79            [ 4] 3785         LD      A,C             ; Get MSB of number
   130D F8            [10] 3786         RET     M               ; Exit if signs different
   130E CD 14 13      [16] 3787         CALL    CMPFP           ; Compare FP numbers
   1311 1F            [ 3] 3788         RRA                     ; Get carry to sign
   1312 A9            [ 4] 3789         XOR     C               ; Combine with MSB of number
   1313 C9            [ 9] 3790         RET
                           3791 
   1314 23            [ 4] 3792 CMPFP:  INC     HL              ; Point to exponent
   1315 78            [ 4] 3793         LD      A,B             ; Get exponent
   1316 BE            [ 6] 3794         CP      (HL)            ; Compare exponents
   1317 C0            [10] 3795         RET     NZ              ; Different
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 70.
Hexadecimal [16-Bits]



   1318 2B            [ 4] 3796         DEC     HL              ; Point to MBS
   1319 79            [ 4] 3797         LD      A,C             ; Get MSB
   131A BE            [ 6] 3798         CP      (HL)            ; Compare MSBs
   131B C0            [10] 3799         RET     NZ              ; Different
   131C 2B            [ 4] 3800         DEC     HL              ; Point to NMSB
   131D 7A            [ 4] 3801         LD      A,D             ; Get NMSB
   131E BE            [ 6] 3802         CP      (HL)            ; Compare NMSBs
   131F C0            [10] 3803         RET     NZ              ; Different
   1320 2B            [ 4] 3804         DEC     HL              ; Point to LSB
   1321 7B            [ 4] 3805         LD      A,E             ; Get LSB
   1322 96            [ 6] 3806         SUB     (HL)            ; Compare LSBs
   1323 C0            [10] 3807         RET     NZ              ; Different
   1324 E1            [ 9] 3808         POP     HL              ; Drop RETurn
   1325 E1            [ 9] 3809         POP     HL              ; Drop another RETurn
   1326 C9            [ 9] 3810         RET
                           3811 
   1327 47            [ 4] 3812 FPINT:  LD      B,A             ; <- Move
   1328 4F            [ 4] 3813         LD      C,A             ; <- exponent
   1329 57            [ 4] 3814         LD      D,A             ; <- to all
   132A 5F            [ 4] 3815         LD      E,A             ; <- bits
   132B B7            [ 4] 3816         OR      A               ; Test exponent
   132C C8            [10] 3817         RET     Z               ; Zero - Return zero
   132D E5            [11] 3818         PUSH    HL              ; Save pointer to number
   132E CD DC 12      [16] 3819         CALL    BCDEFP          ; Move FPREG to BCDE
   1331 CD EE 12      [16] 3820         CALL    SIGNS           ; Set MSBs & sign of result
   1334 AE            [ 6] 3821         XOR     (HL)            ; Combine with sign of FPREG
   1335 67            [ 4] 3822         LD      H,A             ; Save combined signs
   1336 FC 47 13      [16] 3823         CALL    M,DCBCDE        ; Negative - Decrement BCDE
a  1339               [16] 3824         LD      A,0x80+24        ; 24 bits
   1339 90            [ 4] 3825         SUB     B               ; Bits to shift
   133A CD 7E 11      [16] 3826         CALL    SCALE           ; Shift BCDE
   133D 7C            [ 4] 3827         LD      A,H             ; Get combined sign
   133E 17            [ 3] 3828         RLA                     ; Sign to carry
   133F DC 56 11      [16] 3829         CALL    C,FPROND        ; Negative - Round number up
a  1342               [16] 3830         LD      B,0             ; Zero exponent
   1342 DC 6D 11      [16] 3831         CALL    C,COMPL         ; If negative make positive
   1345 E1            [ 9] 3832         POP     HL              ; Restore pointer to number
   1346 C9            [ 9] 3833         RET
                           3834 
   1347 1B            [ 4] 3835 DCBCDE: DEC     DE              ; Decrement BCDE
   1348 7A            [ 4] 3836         LD      A,D             ; Test LSBs
   1349 A3            [ 4] 3837         AND     E
   134A 3C            [ 4] 3838         INC     A
   134B C0            [10] 3839         RET     NZ              ; Exit if LSBs not FFFF
   134C 0B            [ 4] 3840         DEC     BC              ; Decrement MSBs
   134D C9            [ 9] 3841         RET
                           3842 
a  134E               [ 9] 3843 INT:    LD      HL,FPEXP        ; Point to exponent
   134E 7E            [ 6] 3844         LD      A,(HL)          ; Get exponent
a  134F               [ 6] 3845         CP      0x80+24          ; Integer accuracy only?
   134F 3A E4 10      [12] 3846         LD      A,(FPREG)       ; Get LSB
   1352 D0            [10] 3847         RET     NC              ; Yes - Already integer
   1353 7E            [ 6] 3848         LD      A,(HL)          ; Get exponent
   1354 CD 27 13      [16] 3849         CALL    FPINT           ; F.P to integer
a  1357               [16] 3850         LD      (HL),0x80+24     ; Save 24 bit integer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 71.
Hexadecimal [16-Bits]



   1357 7B            [ 4] 3851         LD      A,E             ; Get LSB of number
   1358 F5            [11] 3852         PUSH    AF              ; Save LSB
   1359 79            [ 4] 3853         LD      A,C             ; Get MSB of number
   135A 17            [ 3] 3854         RLA                     ; Sign to carry
   135B CD 18 11      [16] 3855         CALL    CONPOS          ; Set sign of result
   135E F1            [ 9] 3856         POP     AF              ; Restore LSB of number
   135F C9            [ 9] 3857         RET
                           3858 
a  1360               [ 9] 3859 MLDEBC: LD      HL,0            ; Clear partial product
   1360 78            [ 4] 3860         LD      A,B             ; Test multiplier
   1361 B1            [ 4] 3861         OR      C
   1362 C8            [10] 3862         RET     Z               ; Return zero if zero
a  1363               [10] 3863         LD      A,16            ; 16 bits
   1363 29            [ 7] 3864 MLDBLP: ADD     HL,HL           ; Shift P.P left
   1364 DA 00 0C      [ 9] 3865         JP      C,BSERR         ; ?BS Error if overflow
   1367 EB            [ 3] 3866         EX      DE,HL
   1368 29            [ 7] 3867         ADD     HL,HL           ; Shift multiplier left
   1369 EB            [ 3] 3868         EX      DE,HL
   136A D2 71 13      [ 9] 3869         JP      NC,NOMLAD       ; Bit was zero - No add
   136D 09            [ 7] 3870         ADD     HL,BC           ; Add multiplicand
   136E DA 00 0C      [ 9] 3871         JP      C,BSERR         ; ?BS Error if overflow
   1371 3D            [ 4] 3872 NOMLAD: DEC     A               ; Count bits
   1372 C2 63 13      [ 9] 3873         JP      NZ,MLDBLP       ; More
   1375 C9            [ 9] 3874         RET
                           3875 
a  1376               [ 9] 3876 ASCTFP: CP      "-"             ; Negative?
   1376 F5            [11] 3877         PUSH    AF              ; Save it and flags
   1377 CA 7E 13      [ 9] 3878         JP      Z,CNVNUM        ; Yes - Convert number
a  137A               [ 9] 3879         CP      "+"             ; Positive?
   137A CA 7E 13      [ 9] 3880         JP      Z,CNVNUM        ; Yes - Convert number
   137D 2B            [ 4] 3881         DEC     HL              ; DEC 'cos GET0xCR INCs
   137E CD 2C 11      [16] 3882 CNVNUM: CALL    RESZER          ; Set result to zero
   1381 47            [ 4] 3883         LD      B,A             ; Digits after point counter
   1382 57            [ 4] 3884         LD      D,A             ; Sign of exponent
   1383 5F            [ 4] 3885         LD      E,A             ; Exponent of ten
   1384 2F            [ 3] 3886         CPL
   1385 4F            [ 4] 3887         LD      C,A             ; Before or after point flag
   1386 CD 4B 05      [16] 3888 MANLP:  CALL    GET0xCR          ; Get next character
   1389 DA CB 13      [ 9] 3889         JP      C,ADDIG         ; Digit - Add to number
a  138C               [ 9] 3890         CP      "."
   138C CA A6 13      [ 9] 3891         JP      Z,DPOINT        ; "." - Flag point
a  138F               [ 9] 3892         CP      "E"
   138F C2 AA 13      [ 9] 3893         JP      NZ,CONEXP       ; Not "E" - Scale number
   1392 CD 4B 05      [16] 3894         CALL    GET0xCR          ; Get next character
   1395 CD 63 0A      [16] 3895         CALL    SGNEXP          ; Get sign of exponent
   1398 CD 4B 05      [16] 3896 EXPLP:  CALL    GET0xCR          ; Get next character
   139B DA EB 13      [ 9] 3897         JP      C,EDIGIT        ; Digit - Add to exponent
   139E 14            [ 4] 3898         INC     D               ; Is sign negative?
   139F C2 AA 13      [ 9] 3899         JP      NZ,CONEXP       ; No - Scale number
   13A2 AF            [ 4] 3900         XOR     A
   13A3 93            [ 4] 3901         SUB     E               ; Negate exponent
   13A4 5F            [ 4] 3902         LD      E,A             ; And re-save it
   13A5 0C            [ 4] 3903         INC     C               ; Flag end of number
   13A6 0C            [ 4] 3904 DPOINT: INC     C               ; Flag point passed
   13A7 CA 86 13      [ 9] 3905         JP      Z,MANLP         ; Zero - Get another digit
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 72.
Hexadecimal [16-Bits]



   13AA E5            [11] 3906 CONEXP: PUSH    HL              ; Save code string address
   13AB 7B            [ 4] 3907         LD      A,E             ; Get exponent
   13AC 90            [ 4] 3908         SUB     B               ; Subtract digits after point
   13AD F4 C3 13      [16] 3909 SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
   13B0 F2 B9 13      [ 9] 3910         JP      P,ENDCON        ; Positive - All done
   13B3 F5            [11] 3911         PUSH    AF              ; Save number of times to /10
   13B4 CD 02 12      [16] 3912         CALL    DIV10           ; Divide by 10
   13B7 F1            [ 9] 3913         POP     AF              ; Restore count
   13B8 3C            [ 4] 3914         INC     A               ; Count divides
                           3915 
   13B9 C2 AD 13      [ 9] 3916 ENDCON: JP      NZ,SCALMI       ; More to do
   13BC D1            [ 9] 3917         POP     DE              ; Restore code string address
   13BD F1            [ 9] 3918         POP     AF              ; Restore sign of number
   13BE CC BE 12      [16] 3919         CALL    Z,INVSGN        ; Negative - Negate number
   13C1 EB            [ 3] 3920         EX      DE,HL           ; Code string address to HL
   13C2 C9            [ 9] 3921         RET
                           3922 
   13C3 C8            [10] 3923 SCALPL: RET     Z               ; Exit if no scaling needed
   13C4 F5            [11] 3924 MULTEN: PUSH    AF              ; Save count
   13C5 CD 90 12      [16] 3925         CALL    MLSP10          ; Multiply number by 10
   13C8 F1            [ 9] 3926         POP     AF              ; Restore count
   13C9 3D            [ 4] 3927         DEC     A               ; Count multiplies
   13CA C9            [ 9] 3928         RET
                           3929 
   13CB D5            [11] 3930 ADDIG:  PUSH    DE              ; Save sign of exponent
   13CC 57            [ 4] 3931         LD      D,A             ; Save digit
   13CD 78            [ 4] 3932         LD      A,B             ; Get digits after point
   13CE 89            [ 4] 3933         ADC     A,C             ; Add one if after point
   13CF 47            [ 4] 3934         LD      B,A             ; Re-save counter
   13D0 C5            [11] 3935         PUSH    BC              ; Save point flags
   13D1 E5            [11] 3936         PUSH    HL              ; Save code string address
   13D2 D5            [11] 3937         PUSH    DE              ; Save digit
   13D3 CD 90 12      [16] 3938         CALL    MLSP10          ; Multiply number by 10
   13D6 F1            [ 9] 3939         POP     AF              ; Restore digit
a  13D7               [ 9] 3940         SUB     "0"             ; Make it absolute
   13D7 CD E0 13      [16] 3941         CALL    RSCALE          ; Re-scale number
   13DA E1            [ 9] 3942         POP     HL              ; Restore code string address
   13DB C1            [ 9] 3943         POP     BC              ; Restore point flags
   13DC D1            [ 9] 3944         POP     DE              ; Restore sign of exponent
   13DD C3 86 13      [ 9] 3945         JP      MANLP           ; Get another digit
                           3946 
   13E0 CD C1 12      [16] 3947 RSCALE: CALL    STAKFP          ; Put number on stack
   13E3 CD B3 12      [16] 3948         CALL    FLGREL          ; Digit to add to FPREG
   13E6 C1            [ 9] 3949 PADD:   POP     BC              ; Restore number
   13E7 D1            [ 9] 3950         POP     DE
   13E8 C3 D1 10      [ 9] 3951         JP      FPADD           ; Add BCDE to FPREG and return
                           3952 
   13EB 7B            [ 4] 3953 EDIGIT: LD      A,E             ; Get digit
   13EC 07            [ 3] 3954         RLCA                    ; Times 2
   13ED 07            [ 3] 3955         RLCA                    ; Times 4
   13EE 83            [ 4] 3956         ADD     A,E             ; Times 5
   13EF 07            [ 3] 3957         RLCA                    ; Times 10
   13F0 86            [ 6] 3958         ADD     A,(HL)          ; Add next digit
a  13F1               [ 6] 3959         SUB     "0"             ; Make it absolute
   13F1 5F            [ 4] 3960         LD      E,A             ; Save new digit
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 73.
Hexadecimal [16-Bits]



   13F2 C3 98 13      [ 9] 3961         JP      EXPLP           ; Look for another digit
                           3962 
   13F5 E5            [11] 3963 LINEIN: PUSH    HL              ; Save code string address
a  13F6               [11] 3964         LD      HL,INMSG        ; Output " in "
   13F6 CD 92 0D      [16] 3965         CALL    PRS             ; Output string at HL
   13F9 E1            [ 9] 3966         POP     HL              ; Restore code string address
   13FA EB            [ 3] 3967 PRNTHL: EX      DE,HL           ; Code string address to DE
   13FB AF            [ 4] 3968         XOR     A
a  13FC               [ 4] 3969         LD      B,0x80+24        ; 24 bits
   13FC CD B3 12      [16] 3970         CALL    RETINT          ; Return the integer
a  13FF               [16] 3971         LD      HL,PRNUMS       ; Print number string
   13FF E5            [11] 3972         PUSH    HL              ; Save for return
a  1400               [11] 3973 NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
   1400 E5            [11] 3974         PUSH    HL              ; Save for return
   1401 CD A2 12      [16] 3975         CALL    TSTSGN          ; Test sign of FPREG
a  1404               [16] 3976         LD      (HL)," "        ; Space at start
   1404 F2 07 14      [ 9] 3977         JP      P,SPCFST        ; Positive - Space to start
a  1407               [ 9] 3978         LD      (HL),"-"        ; "-" sign at start
   1407 23            [ 4] 3979 SPCFST: INC     HL              ; First byte of number
a  1408               [ 4] 3980         LD      (HL),"0"        ; "0" if zero
   1408 CA 93 14      [ 9] 3981         JP      Z,JSTZER        ; Return "0" if zero
   140B E5            [11] 3982         PUSH    HL              ; Save buffer address
   140C FC BE 12      [16] 3983         CALL    M,INVSGN        ; Negate FPREG if negative
   140F AF            [ 4] 3984         XOR     A               ; Zero A
   1410 F5            [11] 3985         PUSH    AF              ; Save it
   1411 CD 99 14      [16] 3986         CALL    RNGTST          ; Test number is in range
a  1414               [16] 3987 SIXDIG: LD      BC,0x9143        ; BCDE - 99999.9
a  1414               [16] 3988         LD      DE,0x4FF8
   1414 CD 00 13      [16] 3989         CALL    CMPNUM          ; Compare numbers
   1417 B7            [ 4] 3990         OR      A
   1418 E2 2C 14      [ 9] 3991         JP      PO,INRNG        ; > 99999.9 - Sort it out
   141B F1            [ 9] 3992         POP     AF              ; Restore count
   141C CD C4 13      [16] 3993         CALL    MULTEN          ; Multiply by ten
   141F F5            [11] 3994         PUSH    AF              ; Re-save count
   1420 C3 14 14      [ 9] 3995         JP      SIXDIG          ; Test it again
                           3996 
   1423 CD 02 12      [16] 3997 GTSIXD: CALL    DIV10           ; Divide by 10
   1426 F1            [ 9] 3998         POP     AF              ; Get count
   1427 3C            [ 4] 3999         INC     A               ; Count divides
   1428 F5            [11] 4000         PUSH    AF              ; Re-save count
   1429 CD 99 14      [16] 4001         CALL    RNGTST          ; Test number is in range
   142C CD C3 10      [16] 4002 INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
   142F 3C            [ 4] 4003         INC     A
   1430 CD 27 13      [16] 4004         CALL    FPINT           ; F.P to integer
   1433 CD D1 12      [16] 4005         CALL    FPBCDE          ; Move BCDE to FPREG
a  1436               [16] 4006         LD      BC,0x0306        ; 1E+06 to 1E-03 range
   1436 F1            [ 9] 4007         POP     AF              ; Restore count
   1437 81            [ 4] 4008         ADD     A,C             ; 6 digits before point
   1438 3C            [ 4] 4009         INC     A               ; Add one
   1439 FA 41 14      [ 9] 4010         JP      M,MAKNUM        ; Do it in "E" form if < 1E-02
a  143C               [ 9] 4011         CP      6+1+1           ; More than 999999 ?
   143C D2 41 14      [ 9] 4012         JP      NC,MAKNUM       ; Yes - Do it in "E" form
   143F 3C            [ 4] 4013         INC     A               ; Adjust for exponent
   1440 47            [ 4] 4014         LD      B,A             ; Exponent of number
a  1441               [ 4] 4015         LD      A,2             ; Make it zero after
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 74.
Hexadecimal [16-Bits]



                           4016 
   1441 3D            [ 4] 4017 MAKNUM: DEC     A               ; Adjust for digits to do
   1442 3D            [ 4] 4018         DEC     A
   1443 E1            [ 9] 4019         POP     HL              ; Restore buffer address
   1444 F5            [11] 4020         PUSH    AF              ; Save count
a  1445               [11] 4021         LD      DE,POWERS       ; Powers of ten
   1445 05            [ 4] 4022         DEC     B               ; Count digits before point
   1446 C2 4B 14      [ 9] 4023         JP      NZ,DIGTXT       ; Not zero - Do number
a  1449               [ 9] 4024         LD      (HL),"."        ; Save point
   1449 23            [ 4] 4025         INC     HL              ; Move on
a  144A               [ 4] 4026         LD      (HL),"0"        ; Save zero
   144A 23            [ 4] 4027         INC     HL              ; Move on
   144B 05            [ 4] 4028 DIGTXT: DEC     B               ; Count digits before point
a  144C               [ 4] 4029         LD      (HL),"."        ; Save point in case
   144C CC E3 12      [16] 4030         CALL    Z,IN0xCL         ; Last digit - move on
   144F C5            [11] 4031         PUSH    BC              ; Save digits before point
   1450 E5            [11] 4032         PUSH    HL              ; Save buffer address
   1451 D5            [11] 4033         PUSH    DE              ; Save powers of ten
   1452 CD DC 12      [16] 4034         CALL    BCDEFP          ; Move FPREG to BCDE
   1455 E1            [ 9] 4035         POP     HL              ; Powers of ten table
a  1456               [ 9] 4036         LD      B, "0"-1        ; ASCII "0" - 1
   1456 04            [ 4] 4037 TRYAGN: INC     B               ; Count subtractions
   1457 7B            [ 4] 4038         LD      A,E             ; Get LSB
   1458 96            [ 6] 4039         SUB     (HL)            ; Subtract LSB
   1459 5F            [ 4] 4040         LD      E,A             ; Save LSB
   145A 23            [ 4] 4041         INC     HL
   145B 7A            [ 4] 4042         LD      A,D             ; Get NMSB
   145C 9E            [ 6] 4043         SBC     A,(HL)          ; Subtract NMSB
   145D 57            [ 4] 4044         LD      D,A             ; Save NMSB
   145E 23            [ 4] 4045         INC     HL
   145F 79            [ 4] 4046         LD      A,C             ; Get MSB
   1460 9E            [ 6] 4047         SBC     A,(HL)          ; Subtract MSB
   1461 4F            [ 4] 4048         LD      C,A             ; Save MSB
   1462 2B            [ 4] 4049         DEC     HL              ; Point back to start
   1463 2B            [ 4] 4050         DEC     HL
   1464 D2 56 14      [ 9] 4051         JP      NC,TRYAGN       ; No overflow - Try again
   1467 CD 61 11      [16] 4052         CALL    PLUCDE          ; Restore number
   146A 23            [ 4] 4053         INC     HL              ; Start of next number
   146B CD D1 12      [16] 4054         CALL    FPBCDE          ; Move BCDE to FPREG
   146E EB            [ 3] 4055         EX      DE,HL           ; Save point in table
   146F E1            [ 9] 4056         POP     HL              ; Restore buffer address
   1470 70            [ 7] 4057         LD      (HL),B          ; Save digit in buffer
   1471 23            [ 4] 4058         INC     HL              ; And move on
   1472 C1            [ 9] 4059         POP     BC              ; Restore digit count
   1473 0D            [ 4] 4060         DEC     C               ; Count digits
   1474 C2 4B 14      [ 9] 4061         JP      NZ,DIGTXT       ; More - Do them
   1477 05            [ 4] 4062         DEC     B               ; Any decimal part?
   1478 CA 83 14      [ 9] 4063         JP      Z,DOEBIT        ; No - Do "E" bit
   147B 2B            [ 4] 4064 SUPTLZ: DEC     HL              ; Move back through buffer
   147C 7E            [ 6] 4065         LD      A,(HL)          ; Get character
a  147D               [ 6] 4066         CP      "0"             ; "0" character?
   147D CA 7B 14      [ 9] 4067         JP      Z,SUPTLZ        ; Yes - Look back for more
a  1480               [ 9] 4068         CP      "."             ; A decimal point?
   1480 C4 E3 12      [16] 4069         CALL    NZ,IN0xCL        ; Move back over digit
                           4070 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 75.
Hexadecimal [16-Bits]



   1483 F1            [ 9] 4071 DOEBIT: POP     AF              ; Get "E" flag
   1484 CA 96 14      [ 9] 4072         JP      Z,NOENED        ; No "E" needed - End buffer
a  1487               [ 9] 4073         LD      (HL),"E"        ; Put "E" in buffer
   1487 23            [ 4] 4074         INC     HL              ; And move on
a  1488               [ 4] 4075         LD      (HL),"+"        ; Put '+' in buffer
   1488 F2 8D 14      [ 9] 4076         JP      P,OUTEXP        ; Positive - Output exponent
a  148B               [ 9] 4077         LD      (HL),"-"        ; Put "-" in buffer
   148B 2F            [ 3] 4078         CPL                     ; Negate exponent
   148C 3C            [ 4] 4079         INC     A
a  148D               [ 4] 4080 OUTEXP: LD      B,"0"-1         ; ASCII "0" - 1
   148D 04            [ 4] 4081 EXPTEN: INC     B               ; Count subtractions
a  148E               [ 4] 4082         SUB     10              ; Tens digit
   148E D2 8D 14      [ 9] 4083         JP      NC,EXPTEN       ; More to do
a  1491               [ 9] 4084         ADD     A,"0"+10        ; Restore and make ASCII
   1491 23            [ 4] 4085         INC     HL              ; Move on
   1492 70            [ 7] 4086         LD      (HL),B          ; Save MSB of exponent
   1493 23            [ 4] 4087 JSTZER: INC     HL              ;
   1494 77            [ 7] 4088         LD      (HL),A          ; Save LSB of exponent
   1495 23            [ 4] 4089         INC     HL
   1496 71            [ 7] 4090 NOENED: LD      (HL),C          ; Mark end of buffer
   1497 E1            [ 9] 4091         POP     HL              ; Restore code string address
   1498 C9            [ 9] 4092         RET
                           4093 
a  1499               [ 9] 4094 RNGTST: LD      BC,0x9474        ; BCDE = 999999.
a  1499               [ 9] 4095         LD      DE,0x23F7
   1499 CD 00 13      [16] 4096         CALL    CMPNUM          ; Compare numbers
   149C B7            [ 4] 4097         OR      A
   149D E1            [ 9] 4098         POP     HL              ; Return address to HL
   149E E2 23 14      [ 9] 4099         JP      PO,GTSIXD       ; Too big - Divide by ten
   14A1 E9            [ 3] 4100         JP      (HL)            ; Otherwise return to caller
                           4101 
q  14A2                    4102 HALF:   DB      0x00,00H,00H,80H ; 0.5
                           4103 
q  14A2                    4104 POWERS: DB      0x0A0,086H,001H  ; 100000
q                          4105         DB      0x010,027H,000H  ;  10000
q                          4106         DB      0x0E8,003H,000H  ;   1000
q                          4107         DB      0x064,000H,000H  ;    100
q                          4108         DB      0x00A,000H,000H  ;     10
q                          4109         DB      0x001,000H,000H  ;      1
                           4110 
a  14A2               [ 3] 4111 NEGAFT: LD  HL,INVSGN           ; Negate result
   14A2 E3            [16] 4112         EX      (SP),HL         ; To be done after caller
   14A3 E9            [ 3] 4113         JP      (HL)            ; Return to caller
                           4114 
   14A4 CD C1 12      [16] 4115 SQR:    CALL    STAKFP          ; Put value on stack
a  14A7               [16] 4116         LD      HL,HALF         ; Set power to 1/2
   14A7 CD CE 12      [16] 4117         CALL    PHLTFP          ; Move 1/2 to FPREG
                           4118 
   14AA C1            [ 9] 4119 POWER:  POP     BC              ; Get base
   14AB D1            [ 9] 4120         POP     DE
   14AC CD A2 12      [16] 4121         CALL    TSTSGN          ; Test sign of power
   14AF 78            [ 4] 4122         LD      A,B             ; Get exponent of base
   14B0 CA ED 14      [ 9] 4123         JP      Z,EXP           ; Make result 1 if zero
   14B3 F2 BA 14      [ 9] 4124         JP      P,POWER1        ; Positive base - Ok
   14B6 B7            [ 4] 4125         OR      A               ; Zero to negative power?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 76.
Hexadecimal [16-Bits]



   14B7 CA 86 01      [ 9] 4126         JP      Z,DZERR         ; Yes - ?/0 Error
   14BA B7            [ 4] 4127 POWER1: OR      A               ; Base zero?
   14BB CA 2D 11      [ 9] 4128         JP      Z,SAVEXP        ; Yes - Return zero
   14BE D5            [11] 4129         PUSH    DE              ; Save base
   14BF C5            [11] 4130         PUSH    BC
   14C0 79            [ 4] 4131         LD      A,C             ; Get MSB of base
q  14C1                    4132         OR      01111111B       ; Get sign status
   14C1 CD DC 12      [16] 4133         CALL    BCDEFP          ; Move power to BCDE
   14C4 F2 D5 14      [ 9] 4134         JP      P,POWER2        ; Positive base - Ok
   14C7 D5            [11] 4135         PUSH    DE              ; Save power
   14C8 C5            [11] 4136         PUSH    BC
   14C9 CD 4E 13      [16] 4137         CALL    INT             ; Get integer of power
   14CC C1            [ 9] 4138         POP     BC              ; Restore power
   14CD D1            [ 9] 4139         POP     DE
   14CE F5            [11] 4140         PUSH    AF              ; MSB of base
   14CF CD 00 13      [16] 4141         CALL    CMPNUM          ; Power an integer?
   14D2 E1            [ 9] 4142         POP     HL              ; Restore MSB of base
   14D3 7C            [ 4] 4143         LD      A,H             ; but don't affect flags
   14D4 1F            [ 3] 4144         RRA                     ; Exponent odd or even?
   14D5 E1            [ 9] 4145 POWER2: POP     HL              ; Restore MSB and exponent
   14D6 22 E6 10      [16] 4146         LD      (FPREG+2),HL    ; Save base in FPREG
   14D9 E1            [ 9] 4147         POP     HL              ; LSBs of base
   14DA 22 E4 10      [16] 4148         LD      (FPREG),HL      ; Save in FPREG
   14DD DC A2 14      [16] 4149         CALL    C,NEGAFT        ; Odd power - Negate result
   14E0 CC BE 12      [16] 4150         CALL    Z,INVSGN        ; Negative base - Negate it
   14E3 D5            [11] 4151         PUSH    DE              ; Save power
   14E4 C5            [11] 4152         PUSH    BC
   14E5 CD 9A 11      [16] 4153         CALL    LOG             ; Get LOG of base
   14E8 C1            [ 9] 4154         POP     BC              ; Restore power
   14E9 D1            [ 9] 4155         POP     DE
   14EA CD BF 11      [16] 4156         CALL    FPMULT          ; Multiply LOG by power
                           4157 
   14ED CD C1 12      [16] 4158 EXP:    CALL    STAKFP          ; Put value on stack
a  14F0               [16] 4159         LD      BC,0x08138       ; BCDE = 1/Ln(2)
a  14F0               [16] 4160         LD      DE,0x0AA3B
   14F0 CD BF 11      [16] 4161         CALL    FPMULT          ; Multiply value by 1/LN(2)
   14F3 3A E7 10      [12] 4162         LD      A,(FPEXP)       ; Get exponent
a  14F6               [12] 4163         CP      0x80+8           ; Is it in range?
   14F6 D2 83 12      [ 9] 4164         JP      NC,OVTST1       ; No - Test for overflow
   14F9 CD 4E 13      [16] 4165         CALL    INT             ; Get INT of FPREG
a  14FC               [16] 4166         ADD     A,0x80           ; For excess 128
a  14FC               [16] 4167         ADD     A,2             ; Exponent > 126?
   14FC DA 83 12      [ 9] 4168         JP      C,OVTST1        ; Yes - Test for overflow
   14FF F5            [11] 4169         PUSH    AF              ; Save scaling factor
a  1500               [11] 4170         LD      HL,UNITY        ; Point to 1.
   1500 CD C3 10      [16] 4171         CALL    ADDPHL          ; Add 1 to FPREG
   1503 CD BD 11      [16] 4172         CALL    MULLN2          ; Multiply by LN(2)
   1506 F1            [ 9] 4173         POP     AF              ; Restore scaling factor
   1507 C1            [ 9] 4174         POP     BC              ; Restore exponent
   1508 D1            [ 9] 4175         POP     DE
   1509 F5            [11] 4176         PUSH    AF              ; Save scaling factor
   150A CD CE 10      [16] 4177         CALL    SUBCDE          ; Subtract exponent from FPREG
   150D CD BE 12      [16] 4178         CALL    INVSGN          ; Negate result
a  1510               [16] 4179         LD      HL,EXPTAB       ; Coefficient table
   1510 CD 24 15      [16] 4180         CALL    SMSER1          ; Sum the series
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 77.
Hexadecimal [16-Bits]



a  1513               [16] 4181         LD      DE,0            ; Zero LSBs
   1513 C1            [ 9] 4182         POP     BC              ; Scaling factor
   1514 4A            [ 4] 4183         LD      C,D             ; Zero MSB
   1515 C3 BF 11      [ 9] 4184         JP      FPMULT          ; Scale result to correct value
                           4185 
q  1518                    4186 EXPTAB: DB      8                       ; Table used by EXP
q                          4187         DB      0x040,02EH,094H,074H     ; -1/7! (-1/5040)
q                          4188         DB      0x070,04FH,02EH,077H     ;  1/6! ( 1/720)
q                          4189         DB      0x06E,002H,088H,07AH     ; -1/5! (-1/120)
q                          4190         DB      0x0E6,0A0H,02AH,07CH     ;  1/4! ( 1/24)
q                          4191         DB      0x050,0AAH,0AAH,07EH     ; -1/3! (-1/6)
q                          4192         DB      0x0FF,0FFH,07FH,07FH     ;  1/2! ( 1/2)
q                          4193         DB      0x000,000H,080H,081H     ; -1/1! (-1/1)
q                          4194         DB      0x000,000H,000H,081H     ;  1/0! ( 1/1)
                           4195 
   1518 CD C1 12      [16] 4196 SUMSER: CALL    STAKFP          ; Put FPREG on stack
a  151B               [16] 4197         LD      DE,MULT         ; Multiply by "X"
   151B D5            [11] 4198         PUSH    DE              ; To be done after
   151C E5            [11] 4199         PUSH    HL              ; Save address of table
   151D CD DC 12      [16] 4200         CALL    BCDEFP          ; Move FPREG to BCDE
   1520 CD BF 11      [16] 4201         CALL    FPMULT          ; Square the value
   1523 E1            [ 9] 4202         POP     HL              ; Restore address of table
   1524 CD C1 12      [16] 4203 SMSER1: CALL    STAKFP          ; Put value on stack
   1527 7E            [ 6] 4204         LD      A,(HL)          ; Get number of coefficients
   1528 23            [ 4] 4205         INC     HL              ; Point to start of table
   1529 CD CE 12      [16] 4206         CALL    PHLTFP          ; Move coefficient to FPREG
q                          4207         DB      0x06             ; Skip "POP AF"
   152C F1            [ 9] 4208 SUMLP:  POP     AF              ; Restore count
   152D C1            [ 9] 4209         POP     BC              ; Restore number
   152E D1            [ 9] 4210         POP     DE
   152F 3D            [ 4] 4211         DEC     A               ; Cont coefficients
   1530 C8            [10] 4212         RET     Z               ; All done
   1531 D5            [11] 4213         PUSH    DE              ; Save number
   1532 C5            [11] 4214         PUSH    BC
   1533 F5            [11] 4215         PUSH    AF              ; Save count
   1534 E5            [11] 4216         PUSH    HL              ; Save address in table
   1535 CD BF 11      [16] 4217         CALL    FPMULT          ; Multiply FPREG by BCDE
   1538 E1            [ 9] 4218         POP     HL              ; Restore address in table
   1539 CD DC 12      [16] 4219         CALL    LOADFP          ; Number at HL to BCDE
   153C E5            [11] 4220         PUSH    HL              ; Save address in table
   153D CD D1 10      [16] 4221         CALL    FPADD           ; Add coefficient to FPREG
   1540 E1            [ 9] 4222         POP     HL              ; Restore address in table
   1541 C3 2C 15      [ 9] 4223         JP      SUMLP           ; More coefficients
                           4224 
   1544 CD A2 12      [16] 4225 RND:    CALL    TSTSGN          ; Test sign of FPREG
a  1547               [16] 4226         LD      HL,SEED+2       ; Random number seed
   1547 FA 81 15      [ 9] 4227         JP      M,RESEED        ; Negative - Re-seed
a  154A               [ 9] 4228         LD      HL,LSTRND       ; Last random number
   154A CD CE 12      [16] 4229         CALL    PHLTFP          ; Move last RND to FPREG
a  154D               [16] 4230         LD      HL,SEED+2       ; Random number seed
   154D C8            [10] 4231         RET     Z               ; Return if RND(0)
   154E 86            [ 6] 4232         ADD     A,(HL)          ; Add (SEED)+2)
q  154F                    4233         AND     00000111B       ; 0 to 7
a  154F               [ 6] 4234         LD      B,0
   154F 77            [ 7] 4235         LD      (HL),A          ; Re-save seed
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 78.
Hexadecimal [16-Bits]



   1550 23            [ 4] 4236         INC     HL              ; Move to coefficient table
   1551 87            [ 4] 4237         ADD     A,A             ; 4 bytes
   1552 87            [ 4] 4238         ADD     A,A             ; per entry
   1553 4F            [ 4] 4239         LD      C,A             ; BC = Offset into table
   1554 09            [ 7] 4240         ADD     HL,BC           ; Point to coefficient
   1555 CD DC 12      [16] 4241         CALL    LOADFP          ; Coefficient to BCDE
   1558 CD BF 11      [16] 4242         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
   155B 3A 18 10      [12] 4243         LD      A,(SEED+1)      ; Get (SEED+1)
   155E 3C            [ 4] 4244         INC     A               ; Add 1
q  155F                    4245         AND     00000011B       ; 0 to 3
a  155F               [ 4] 4246         LD      B,0
a  155F               [ 4] 4247         CP      1               ; Is it zero?
   155F 88            [ 4] 4248         ADC     A,B             ; Yes - Make it 1
   1560 32 18 10      [13] 4249         LD      (SEED+1),A      ; Re-save seed
a  1563               [13] 4250         LD      HL,RNDTAB-4     ; Addition table
   1563 87            [ 4] 4251         ADD     A,A             ; 4 bytes
   1564 87            [ 4] 4252         ADD     A,A             ; per entry
   1565 4F            [ 4] 4253         LD      C,A             ; BC = Offset into table
   1566 09            [ 7] 4254         ADD     HL,BC           ; Point to value
   1567 CD C3 10      [16] 4255         CALL    ADDPHL          ; Add value to FPREG
   156A CD DC 12      [16] 4256 RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
   156D 7B            [ 4] 4257         LD      A,E             ; Get LSB
   156E 59            [ 4] 4258         LD      E,C             ; LSB = MSB
q  156F                    4259         XOR     01001111B       ; Fiddle around
   156F 4F            [ 4] 4260         LD      C,A             ; New MSB
a  1570               [ 4] 4261         LD      (HL),0x80        ; Set exponent
   1570 2B            [ 4] 4262         DEC     HL              ; Point to MSB
   1571 46            [ 6] 4263         LD      B,(HL)          ; Get MSB
a  1572               [ 6] 4264         LD      (HL),0x80        ; Make value -0.5
a  1572               [ 6] 4265         LD      HL,SEED         ; Random number seed
   1572 34            [10] 4266         INC     (HL)            ; Count seed
   1573 7E            [ 6] 4267         LD      A,(HL)          ; Get seed
a  1574               [ 6] 4268         SUB     171             ; Do it modulo 171
   1574 C2 7B 15      [ 9] 4269         JP      NZ,RND2         ; Non-zero - Ok
   1577 77            [ 7] 4270         LD      (HL),A          ; Zero seed
   1578 0C            [ 4] 4271         INC     C               ; Fillde about
   1579 15            [ 4] 4272         DEC     D               ; with the
   157A 1C            [ 4] 4273         INC     E               ; number
   157B CD 1B 11      [16] 4274 RND2:   CALL    BNORM           ; Normalise number
a  157E               [16] 4275         LD      HL,LSTRND       ; Save random number
   157E C3 E5 12      [ 9] 4276         JP      FPTHL           ; Move FPREG to last and return
                           4277 
   1581 77            [ 7] 4278 RESEED: LD      (HL),A          ; Re-seed random numbers
   1582 2B            [ 4] 4279         DEC     HL
   1583 77            [ 7] 4280         LD      (HL),A
   1584 2B            [ 4] 4281         DEC     HL
   1585 77            [ 7] 4282         LD      (HL),A
   1586 C3 6A 15      [ 9] 4283         JP      RND1            ; Return RND seed
                           4284 
q  1589                    4285 RNDTAB: DB      0x068,0B1H,046H,068H     ; Table used by RND
q                          4286         DB      0x099,0E9H,092H,069H
q                          4287         DB      0x010,0D1H,075H,068H
                           4288 
a  1589               [ 9] 4289 COS:    LD      HL,HALFPI       ; Point to PI/2
   1589 CD C3 10      [16] 4290         CALL    ADDPHL          ; Add it to PPREG
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 79.
Hexadecimal [16-Bits]



   158C CD C1 12      [16] 4291 SIN:    CALL    STAKFP          ; Put angle on stack
a  158F               [16] 4292         LD      BC,0x8349        ; BCDE = 2 PI
a  158F               [16] 4293         LD      DE,0x0FDB
   158F CD D1 12      [16] 4294         CALL    FPBCDE          ; Move 2 PI to FPREG
   1592 C1            [ 9] 4295         POP     BC              ; Restore angle
   1593 D1            [ 9] 4296         POP     DE
   1594 CD 0A 12      [16] 4297         CALL    DVBCDE          ; Divide angle by 2 PI
   1597 CD C1 12      [16] 4298         CALL    STAKFP          ; Put it on stack
   159A CD 4E 13      [16] 4299         CALL    INT             ; Get INT of result
   159D C1            [ 9] 4300         POP     BC              ; Restore number
   159E D1            [ 9] 4301         POP     DE
   159F CD CE 10      [16] 4302         CALL    SUBCDE          ; Make it 0 <= value < 1
a  15A2               [16] 4303         LD      HL,QUARTR       ; Point to 0.25
   15A2 CD C9 10      [16] 4304         CALL    SUBPHL          ; Subtract value from 0.25
   15A5 CD A2 12      [16] 4305         CALL    TSTSGN          ; Test sign of value
   15A8 37            [ 3] 4306         SCF                     ; Flag positive
   15A9 F2 B3 15      [ 9] 4307         JP      P,SIN1          ; Positive - Ok
   15AC CD C3 10      [16] 4308         CALL    ROUND           ; Add 0.5 to value
   15AF CD A2 12      [16] 4309         CALL    TSTSGN          ; Test sign of value
   15B2 B7            [ 4] 4310         OR      A               ; Flag negative
   15B3 F5            [11] 4311 SIN1:   PUSH    AF              ; Save sign
   15B4 F4 BE 12      [16] 4312         CALL    P,INVSGN        ; Negate value if positive
a  15B7               [16] 4313         LD      HL,QUARTR       ; Point to 0.25
   15B7 CD C3 10      [16] 4314         CALL    ADDPHL          ; Add 0.25 to value
   15BA F1            [ 9] 4315         POP     AF              ; Restore sign
   15BB D4 BE 12      [16] 4316         CALL    NC,INVSGN       ; Negative - Make positive
a  15BE               [16] 4317         LD      HL,SINTAB       ; Coefficient table
   15BE C3 18 15      [ 9] 4318         JP      SUMSER          ; Evaluate sum of series
                           4319 
q  15C1                    4320 HALFPI: DB      0x0DB,00FH,049H,081H     ; 1.5708 (PI/2)
                           4321 
q  15C1                    4322 QUARTR: DB      0x000,000H,000H,07FH     ; 0.25
                           4323 
q  15C1                    4324 SINTAB: DB      5                       ; Table used by SIN
q                          4325         DB      0x0BA,0D7H,01EH,086H     ; 39.711
q                          4326         DB      0x064,026H,099H,087H     ;-76.575
q                          4327         DB      0x058,034H,023H,087H     ; 81.602
q                          4328         DB      0x0E0,05DH,0A5H,086H     ;-41.342
q                          4329         DB      0x0DA,00FH,049H,083H     ;  6.2832
                           4330 
   15C1 CD C1 12      [16] 4331 TAN:    CALL    STAKFP          ; Put angle on stack
   15C4 CD 8C 15      [16] 4332         CALL    SIN             ; Get SIN of angle
   15C7 C1            [ 9] 4333         POP     BC              ; Restore angle
   15C8 E1            [ 9] 4334         POP     HL
   15C9 CD C1 12      [16] 4335         CALL    STAKFP          ; Save SIN of angle
   15CC EB            [ 3] 4336         EX      DE,HL           ; BCDE = Angle
   15CD CD D1 12      [16] 4337         CALL    FPBCDE          ; Angle to FPREG
   15D0 CD 89 15      [16] 4338         CALL    COS             ; Get COS of angle
   15D3 C3 08 12      [ 9] 4339         JP      DIV             ; TAN = SIN / COS
                           4340 
   15D6 CD A2 12      [16] 4341 ATN:    CALL    TSTSGN          ; Test sign of value
   15D9 FC A2 14      [16] 4342         CALL    M,NEGAFT        ; Negate result after if -ve
   15DC FC BE 12      [16] 4343         CALL    M,INVSGN        ; Negate value if -ve
   15DF 3A E7 10      [12] 4344         LD      A,(FPEXP)       ; Get exponent
a  15E2               [12] 4345         CP      0x81             ; Number less than 1?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 80.
Hexadecimal [16-Bits]



   15E2 DA EB 15      [ 9] 4346         JP      C,ATN1          ; Yes - Get arc tangnt
a  15E5               [ 9] 4347         LD      BC,0x8100        ; BCDE = 1
   15E5 51            [ 4] 4348         LD      D,C
   15E6 59            [ 4] 4349         LD      E,C
   15E7 CD 0A 12      [16] 4350         CALL    DVBCDE          ; Get reciprocal of number
a  15EA               [16] 4351         LD      HL,SUBPHL       ; Sub angle from PI/2
   15EA E5            [11] 4352         PUSH    HL              ; Save for angle > 1
a  15EB               [11] 4353 ATN1:   LD      HL,ATNTAB       ; Coefficient table
   15EB CD 18 15      [16] 4354         CALL    SUMSER          ; Evaluate sum of series
a  15EE               [16] 4355         LD      HL,HALFPI       ; PI/2 - angle in case > 1
   15EE C9            [ 9] 4356         RET                     ; Number > 1 - Sub from PI/2
                           4357 
q  15EF                    4358 ATNTAB: DB      9                       ; Table used by ATN
q                          4359         DB      0x04A,0D7H,03BH,078H     ; 1/17
q                          4360         DB      0x002,06EH,084H,07BH     ;-1/15
q                          4361         DB      0x0FE,0C1H,02FH,07CH     ; 1/13
q                          4362         DB      0x074,031H,09AH,07DH     ;-1/11
q                          4363         DB      0x084,03DH,05AH,07DH     ; 1/9
q                          4364         DB      0x0C8,07FH,091H,07EH     ;-1/7
q                          4365         DB      0x0E4,0BBH,04CH,07EH     ; 1/5
q                          4366         DB      0x06C,0AAH,0AAH,07FH     ;-1/3
q                          4367         DB      0x000,000H,000H,081H     ; 1/1
                           4368 
   15EF CD 15 17      [16] 4369 CASFFW: CALL    FLPLED          ; Turn on cassette
a  15F2               [16] 4370         LD      B,0             ; Set 1 second delay
   15F2 CD 90 16      [16] 4371 DELAYB: CALL    DELAY           ; Wait a bit
   15F5 05            [ 4] 4372         DEC     B               ; Count
   15F6 C2 F2 15      [ 9] 4373         JP      NZ,DELAYB       ; More delay needed
   15F9 C9            [ 9] 4374         RET
                           4375 
   15FA C3 15 17      [ 9] 4376 CASFF:  JP      FLPLED          ; Flip tape LED
                           4377 
   15FD C9            [ 9] 4378 ARET:   RET                     ; A RETurn instruction
                           4379 
   15FE E5            [11] 4380 CONMON: PUSH    HL              ; Output character to screen
   15FF C5            [11] 4381         PUSH    BC              ; 
   1600 D5            [11] 4382         PUSH    DE              ; 
   1601 F5            [11] 4383         PUSH    AF              ; 
   1602 CD 44 17      [16] 4384         CALL    MONTST          ; See if NAS-SYS
   1605 C2 16 16      [ 9] 4385         JP      NZ,NASOUT       ; NAS-SYS - Output ASCII
   1608 F1            [ 9] 4386         POP     AF              ; Get character
   1609 F5            [11] 4387         PUSH    AF              ; And re-save
a  160A               [11] 4388         CP      LF              ; ASCII Line feed?
   160A CA 1B 16      [ 9] 4389         JP      Z,IG0xCR         ; Yes - Ignore it
a  160D               [ 9] 4390         CP      BKSP            ; ASCII back space?
   160D C2 10 16      [ 9] 4391         JP      NZ,CONOT1       ; No - Test for CR
a  1610               [ 9] 4392         LD      A,TBS           ; NASBUG back space
a  1610               [ 9] 4393 CONOT1: CP      CR              ; ASCII CR?
   1610 C2 18 16      [ 9] 4394         JP      NZ,OUT0xCR       ; No - Output character
a  1613               [ 9] 4395         LD      A,TCR           ; NASBUG CR
   1613 C3 18 16      [ 9] 4396         JP      OUT0xCR          ; Output it
                           4397 
   1616 F1            [ 9] 4398 NASOUT: POP     AF              ; Get character
   1617 F5            [11] 4399         PUSH    AF              ; And re-save
   1618 CD 21 17      [16] 4400 OUT0xCR: CALL    MONOUT          ; Output it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 81.
Hexadecimal [16-Bits]



   161B F1            [ 9] 4401 IG0xCR:  POP     AF              ; Restore character
   161C D1            [ 9] 4402         POP     DE              ;
   161D C1            [ 9] 4403         POP     BC              ;
   161E E1            [ 9] 4404         POP     HL              ;
   161F C9            [ 9] 4405         RET
                           4406 
   1620 E5            [11] 4407 GETINP: PUSH    HL              ; Get an input character
   1621 C5            [11] 4408         PUSH    BC              ;
   1622 D5            [11] 4409         PUSH    DE              ;
   1623 CD 44 17      [16] 4410         CALL    MONTST          ; See if NAS-SYS
   1626 CA 2E 16      [ 9] 4411         JP      Z,GETTIN        ; "T" monitor - Get input
   1629 DF 7B              4412         .dw      _BLNK
   162B C3 34 16      [ 9] 4413         JP      CONVIN          ; Convert to ASCII
                           4414 
   162E CD 4D 0C      [16] 4415 GETTIN: CALL    TIN             ; "T" input a character
   1631 D2 2E 16      [ 9] 4416         JP      NC,GETTIN       ; No input - wait
a  1634               [ 9] 4417 CONVIN: CP      TBS             ; NASBUG back space?
   1634 C2 37 16      [ 9] 4418         JP      NZ,CNVIN1       ; No - Test for break
a  1637               [ 9] 4419         LD      A,BKSP          ; ASCII back space
a  1637               [ 9] 4420 CNVIN1: CP      TBRK            ; NASBUG break?
   1637 C2 3A 16      [ 9] 4421         JP      NZ,CNVIN2       ; No - Test for control Z
a  163A               [ 9] 4422         LD      A,CTRLC         ; Control C
a  163A               [ 9] 4423 CNVIN2: CP      CTRLZ           ; ^Z?
   163A C2 3D 16      [ 9] 4424         JP      NZ,CNVIN3       ; No - Test for escape
a  163D               [ 9] 4425         LD      A,DEL           ; Delete
a  163D               [ 9] 4426 CNVIN3: CP      ESC             ; "ESC" ?
   163D C2 40 16      [ 9] 4427         JP      NZ,CNVIN4       ; No - Test for CR
a  1640               [ 9] 4428         LD      A,CTRLC         ; Control C
a  1640               [ 9] 4429 CNVIN4: CP      TCR             ; NASBUG CR?
   1640 C2 43 16      [ 9] 4430         JP      NZ,CNVIN5       ; No - Return character
a  1643               [ 9] 4431         LD      A,CR            ; ASCII CR
   1643 D1            [ 9] 4432 CNVIN5: POP     DE
   1644 C1            [ 9] 4433         POP     BC
   1645 E1            [ 9] 4434         POP     HL
   1646 C9            [ 9] 4435         RET
                           4436 
q                          4437 0xCKBRK: XOR     A               ; Check for break
   1647 CD 74 16      [16] 4438         CALL    SFTENT          ; Test for shift/enter
   164A CA 56 16      [ 9] 4439         JP      Z,TBRK2         ; Yes - Test for second break
   164D 3A 4D 10      [12] 4440         LD      A,(BRKFLG)      ; Get break flag
   1650 B7            [ 4] 4441         OR      A               ; Break flag set?
   1651 C2 56 16      [ 9] 4442         JP      NZ,TBRK2        ; Yes - Test for second break
   1654 AF            [ 4] 4443         XOR     A               ; Flag no break
   1655 C9            [ 9] 4444         RET
                           4445 
   1656 CD 2E 17      [16] 4446 TBRK2:  CALL    BREAK2          ; Second break?
a  1659               [16] 4447         LD      A,-1            ; Flag break
   1659 C9            [ 9] 4448         RET
                           4449 
   165A DB 02         [ 9] 4450 GUART:  IN      A,(UARTS)       ; Get UART status
   165C 17            [ 3] 4451         RLA                     ; Any data ready?
   165D D2 5A 16      [ 9] 4452         JP      NC,GUART        ; No - wait until there is
   1660 DB 01         [ 9] 4453         IN      A,(UARTD)       ; Get data from UART
   1662 C9            [ 9] 4454         RET
                           4455 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 82.
Hexadecimal [16-Bits]



   1663 D3 01         [10] 4456 UARTOT: OUT     (UARTD),A       ; Send data to UART
   1665 DB 02         [ 9] 4457 URTOLP: IN      A,(UARTS)       ; Get status
   1667 87            [ 4] 4458         ADD     A,A             ; Byte sent?
   1668 F8            [10] 4459         RET     M               ; Yes - Return
   1669 C3 65 16      [ 9] 4460         JP      URTOLP          ; Keep waiting
                           4461 
   166C F5            [11] 4462 SUART:  PUSH    AF              ; Save A
   166D CD 63 16      [16] 4463         CALL    UARTOT          ; Send it to UART
   1670 F1            [ 9] 4464         POP     AF              ; Restore A
   1671 C9            [ 9] 4465         RET
                           4466 
   1672 00            [ 3] 4467         NOP
   1673 00            [ 3] 4468         NOP
                           4469 
   1674 E5            [11] 4470 SFTENT: PUSH    HL              ; Test for Shift Enter from KBD
aq 1675               [11] 4471         LD      A,00000010B     ; Reset KBD counter mask
a  1675               [11] 4472         LD      HL,PORT0        ; Get old contents
   1675 AE            [ 6] 4473         XOR     (HL)            ; Toggle bit
   1676 D3 00         [10] 4474         OUT     (0),A           ; Reset KBD counter
q  1678                    4475         XOR     00000001B       ; Toggle bit
   1678 D3 00         [10] 4476         OUT     (0),A           ; Next row
q  167A                    4477         XOR     00000010B
   167A D3 00         [10] 4478         OUT     (0),A           ; Clear "clear" strobe
   167C 7E            [ 6] 4479         LD      A,(HL)          ; Get old value
   167D D3 00         [10] 4480         OUT     (0),A           ; Original contents
   167F 19            [ 7] 4481         ADD     HL,DE           ; ?? WHAT ??
   1680 E1            [ 9] 4482         POP     HL              ; Restore HL
   1681 DB 00         [ 9] 4483         IN      A,(0)           ; Read in row
q  1683                    4484         AND     00010010B       ; Mask SHIFT and ENTER
   1683 C9            [ 9] 4485         RET
                           4486 
   1684 CD 44 17      [16] 4487 CLS:    CALL    MONTST          ; See if NAS-SYS
   1687 CA 8D 16      [ 9] 4488         JP      Z,TCLS          ; "T" CLS
a  168A               [ 9] 4489         LD      A,CS            ; ASCII Clear screen
   168A C3 FE 15      [ 9] 4490         JP      CONMON          ; Output character
                           4491 
a  168D               [ 9] 4492 TCLS:   LD      A,TCS           ; NASBUG Clear screen
   168D C3 FE 15      [ 9] 4493         JP      CONMON          ; Output character
                           4494 
   1690 AF            [ 4] 4495 DELAY:  XOR     A               ; Delay routine
   1691 F5            [11] 4496 DELAY1: PUSH    AF              ; PUSHes and POPs delay
   1692 F1            [ 9] 4497         POP     AF
   1693 F5            [11] 4498         PUSH    AF
   1694 F1            [ 9] 4499         POP     AF
   1695 3D            [ 4] 4500         DEC     A               ; Count delays
   1696 C2 91 16      [ 9] 4501         JP      NZ,DELAY1       ; More delay
   1699 C9            [ 9] 4502         RET
                           4503 
   169A CD C8 0F      [16] 4504 WIDTH:  CALL    GETINT          ; Get integer 0-255
   169D 7B            [ 4] 4505         LD      A,E             ; Width to A
   169E 32 42 10      [13] 4506         LD      (LWIDTH),A      ; Set width
   16A1 C9            [ 9] 4507         RET
                           4508 
   16A2 CD 72 09      [16] 4509 LINES:  CALL    GETNUM          ; Get a number
   16A5 CD 60 06      [16] 4510         CALL    DEINT           ; Get integer -32768 to 32767
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 83.
Hexadecimal [16-Bits]



   16A8 ED 53 46 10   [19] 4511         LD      (LINESC),DE     ; Set lines counter
   16AC ED 53 48 10   [19] 4512         LD      (LINESN),DE     ; Set lines number
   16B0 C9            [ 9] 4513         RET
                           4514 
   16B1 CD 60 06      [16] 4515 DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
   16B4 D5            [11] 4516         PUSH    DE              ; Save number
   16B5 E1            [ 9] 4517         POP     HL              ; Number to HL
   16B6 46            [ 6] 4518         LD      B,(HL)          ; Get LSB of contents
   16B7 23            [ 4] 4519         INC     HL
   16B8 7E            [ 6] 4520         LD      A,(HL)          ; Get MSB of contents
   16B9 C3 9F 0C      [ 9] 4521         JP      ABPASS          ; Return integer AB
                           4522 
   16BC CD 72 09      [16] 4523 DOKE:   CALL    GETNUM          ; Get a number
   16BF CD 60 06      [16] 4524         CALL    DEINT           ; Get integer -32768 to 32767
   16C2 D5            [11] 4525         PUSH    DE              ; Save address
q  16C3 CD 0C 00      [16] 4526         CALL    0xCKSYN          ; Make sure "," follows
q                          4527         DB      ","
   16C6 CD 72 09      [16] 4528         CALL    GETNUM          ; Get a number
   16C9 CD 60 06      [16] 4529         CALL    DEINT           ; Get integer -32768 to 32767
   16CC E3            [16] 4530         EX      (SP),HL         ; Save value,get address
   16CD 73            [ 7] 4531         LD      (HL),E          ; Save LSB of value
   16CE 23            [ 4] 4532         INC     HL
   16CF 72            [ 7] 4533         LD      (HL),D          ; Save MSB of value
   16D0 E1            [ 9] 4534         POP     HL              ; Restore code string address
   16D1 C9            [ 9] 4535         RET
                           4536 
   16D2 F3            [ 3] 4537 JJUMP1: DI                      ; Disable interrupts
a  16D3               [ 3] 4538         LD      IX,-1           ; Flag cold start
   16D3 C3 0E 00      [ 9] 4539         JP      CSTART          ; Go and initialise
                           4540 
   16D6 CD C8 0F      [16] 4541 SCREEN: CALL    GETINT          ; Get integer 0 to 255
   16D9 F5            [11] 4542         PUSH    AF              ; Save column
q  16DA CD 0C 00      [16] 4543         CALL    0xCKSYN          ; Make sure "," follows
q                          4544         DB      ","
   16DD CD C8 0F      [16] 4545         CALL    GETINT          ; Get integer 0 to 255
   16E0 C1            [ 9] 4546         POP     BC              ; Column to B
   16E1 E5            [11] 4547         PUSH    HL              ; Save code string address
   16E2 C5            [11] 4548         PUSH    BC              ; Save column
   16E3 CD FC 16      [16] 4549         CALL    SCRADR          ; Calculate screen address
   16E6 E5            [11] 4550         PUSH    HL              ; Save screen address
   16E7 CD 44 17      [16] 4551         CALL    MONTST          ; See if NAS-SYS
   16EA CA F3 16      [ 9] 4552         JP      Z,TMNCUR        ; "T" monitor - "T" cursor
   16ED E1            [ 9] 4553         POP     HL              ; Restore screen address
   16EE 22 29 0C      [16] 4554         LD      (CURSOR),HL     ; Set new cursor position
   16F1 E1            [ 9] 4555         POP     HL              ; Rstore code string address
   16F2 C9            [ 9] 4556         RET
                           4557 
   16F3 2A 18 0C      [15] 4558 TMNCUR: LD      HL,(TCUR)       ; Get address or cursor
a  16F6               [15] 4559         LD      (HL)," "        ; Remove cursor
   16F6 E1            [ 9] 4560         POP     HL              ; Get new cursor address
   16F7 22 18 0C      [16] 4561         LD      (TCUR),HL       ; Set new cursor
a  16FA               [16] 4562         LD      (HL),"_"        ; Put it on screen
   16FA E1            [ 9] 4563         POP     HL              ; Restore code string address
   16FB C9            [ 9] 4564         RET
                           4565 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 84.
Hexadecimal [16-Bits]



a  16FC               [ 9] 4566 SCRADR: LD      HL,VDU+10-65    ; SCREEN VDU address (0,0)
a  16FC               [ 9] 4567         LD      B,0
   16FC 4F            [ 4] 4568         LD      C,A             ; Line to BC
   16FD B7            [ 4] 4569         OR      A               ; Test it
   16FE CA 6D 06      [ 9] 4570         JP      Z,FCERR         ; Zero - ?FC Error
a  1701               [ 9] 4571         CP      16+1            ; 16 lines
   1701 F2 6D 06      [ 9] 4572         JP      P,FCERR         ; > 16 - ?FC Error
   1704 D1            [ 9] 4573         POP     DE              ; RETurn address
   1705 F1            [ 9] 4574         POP     AF              ; Get column
   1706 D5            [11] 4575         PUSH    DE              ; Re-save RETurn
a  1707               [11] 4576         LD      D,0
   1707 5F            [ 4] 4577         LD      E,A             ; Column to DE
   1708 B7            [ 4] 4578         OR      A               ; Test it
   1709 CA 6D 06      [ 9] 4579         JP      Z,FCERR         ; Zero - ?FC Error
a  170C               [ 9] 4580         CP      48+1            ; 48 characters per line
   170C F2 6D 06      [ 9] 4581         JP      P,FCERR         ; > 48 - ?FC Error
   170F 19            [ 7] 4582         ADD     HL,DE           ; Add column to address
a  1710               [ 7] 4583         LD      D,0
   1710 59            [ 4] 4584         LD      E,C             ; Line to DE
a  1711               [ 4] 4585         LD      B,64            ; 64 Bytes per line
   1711 19            [ 7] 4586 ADD64X: ADD     HL,DE           ; Add line
   1712 10 FD         [ 9] 4587         DJNZ    ADD64X          ; SIXTY FOUR TIMES!!!
   1714 C9            [ 9] 4588         RET
                           4589 
   1715 CD 44 17      [16] 4590 FLPLED: CALL    MONTST          ; See if NAS-SYS
   1718 CA 1E 17      [ 9] 4591         JP      Z,TMFLP         ; "T" MFLP
   171B DF 5F              4592         .dw      _MFLP
   171D C9            [ 9] 4593         RET
                           4594 
   171E C3 51 00      [ 9] 4595 TMFLP:  JP      MFLP            ; Flip drive LED
                           4596 
   1721 F5            [11] 4597 MONOUT: PUSH    AF              ; Save character
   1722 CD 44 17      [16] 4598         CALL    MONTST          ; See if NAS-SYS
   1725 CA 2A 17      [ 9] 4599         JP      Z,TMNOUT        ; "T" output
   1728 F1            [ 9] 4600         POP     AF              ; Restore character
o  1729                    4601         DB      _ROUT           ; Output it
   1729 C9            [ 9] 4602         RET
                           4603 
   172A F1            [ 9] 4604 TMNOUT: POP     AF              ; Restore character
   172B C3 4A 0C      [ 9] 4605         JP      TOUT            ; "T" output
                           4606 
   172E 3A 4D 10      [12] 4607 BREAK2: LD      A,(BRKFLG)      ; Break flag set?
   1731 C2 40 17      [ 9] 4608         JP      NZ,RETCTC       ; Yes - Return ^C
   1734 CD 44 17      [16] 4609         CALL    MONTST          ; See if NAS-SYS
   1737 CA 3D 17      [ 9] 4610         JP      Z,T0xCINP        ; Get "T" character input
   173A DF 62              4611         .dw      _RIN            ; Scan for a character
   173C C9            [ 9] 4612         RET
                           4613 
   173D C3 4D 0C      [ 9] 4614 T0xCINP: JP      TIN             ; "T" input a character
                           4615 
a  1740               [ 9] 4616 RETCTC: LD      A,0             ; Clear Break flag
   1740 32 4D 10      [13] 4617         LD      (BRKFLG),A
a  1743               [13] 4618         LD      A,CTRLC         ; Return ^C
   1743 C9            [ 9] 4619         RET
                           4620 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 85.
Hexadecimal [16-Bits]



   1744 3A 01 00      [12] 4621 MONTST: LD      A,(MONSTT+1)    ; "T" monitor or NAS-SYS?
a  1747               [12] 4622         CP      0x33             ; 31 00 10 / 31 33 0C
   1747 C9            [ 9] 4623         RET
                           4624 
   1748 CD 15 17      [16] 4625 SAVE:   CALL    FLPLED          ; Flip tape LED
   174B CD 44 17      [16] 4626         CALL    MONTST          ; See if NAS-SYS
   174E CA 54 17      [ 9] 4627         JP      Z,TSAVE         ; "T" save
   1751 DF 57              4628         .dw      _WRIT           ; Save program
   1753 C9            [ 9] 4629         RET
                           4630 
   1754 3A 8D 00      [12] 4631 TSAVE:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
   1757 CA 00 04      [ 9] 4632         JP      Z,T4WR          ; T4 Write
   175A C3 D1 03      [ 9] 4633         JP      T2DUMP          ; T2 Dump
                           4634 
   175D CD 15 17      [16] 4635 MONLD:  CALL    FLPLED          ; Flip tape LED
   1760 CD 44 17      [16] 4636         CALL    MONTST          ; See if NAS-SYS
   1763 CA 6C 17      [ 9] 4637         JP      Z,TLOAD         ; "T" load
a  1766               [ 9] 4638         LD      A,"R"           ; Set READ
   1766 32 2B 0C      [13] 4639         LD      (ARGN),A
   1769 DF 52              4640         .dw      _READ           ; Load program
   176B C9            [ 9] 4641         RET
                           4642 
   176C 3A 8D 00      [12] 4643 TLOAD:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
   176F CA 0C 07      [ 9] 4644         JP      Z,T4READ        ; T4 Read
   1772 C3 D1 03      [ 9] 4645         JP      T2DUMP          ; T2 Dump ??????????
                           4646 
   1775 CD 44 17      [16] 4647 MONITR: CALL    MONTST          ; See if NAS-SYS
   1778 CA 00 00      [ 9] 4648         JP      Z,MONSTT        ; Jump to zero if "T"
   177B DF 5B              4649         .dw      _MRET           ; Return to NAS-SYS
                           4650 
   177D CD 15 17      [16] 4651 MONVE:  CALL    FLPLED          ; Flip tape LED
   1780 CD 44 17      [16] 4652         CALL    MONTST          ; See if NAS-SYS
   1783 CA 6D 06      [ 9] 4653         JP      Z,FCERR         ; Verify not available on "T"
a  1786               [ 9] 4654         LD      A,"V"           ; Set VERIFY
   1786 32 2B 0C      [13] 4655         LD      (ARGN),A
   1789 DF 56              4656         .dw      _VRFY           ; Verify tape
   178B C9            [ 9] 4657         RET
                           4658 
a  178C               [ 9] 4659 INITST: LD      A,0             ; Clear break flag
   178C 32 4D 10      [13] 4660         LD      (BRKFLG),A
   178F CD 44 17      [16] 4661         CALL    MONTST          ; See if NAS-SYS
   1792 CA 12 00      [ 9] 4662         JP      Z,INIT          ; "T" - No NMI vector
a  1795               [ 9] 4663         LD      HL,BREAK        ; Set NMI gives break
   1795 22 7E 0C      [16] 4664         LD      (NMI),HL
   1798 DD E5         [14] 4665         PUSH    IX              ; Get start up condition
   179A F1            [ 9] 4666         POP     AF              ; "Z" set if cold , Else clear
   179B B7            [ 4] 4667         OR      A               ; "Cold" or "Cool" start?
   179C C2 12 00      [ 9] 4668         JP      NZ,INIT         ; "Cool" don't init NAS-SYS
a  179F               [ 9] 4669         LD      B,15            ; Delay for keyboard clear
   179F CD F2 15      [16] 4670         CALL    DELAYB          ; Allow time for key release
   17A2 CD 0D 00      [16] 4671         CALL    STMON           ; Initialise NAS-SYS
   17A5 C3 12 00      [ 9] 4672         JP      INIT            ; Initialise BASIC
                           4673 
   17A8 F5            [11] 4674 BREAK:  PUSH    AF              ; Save character
a  17A9               [11] 4675         LD      A,-1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 86.
Hexadecimal [16-Bits]



   17A9 32 4D 10      [13] 4676         LD      (BRKFLG),A      ; Flag break
   17AC F1            [ 9] 4677         POP     AF              ; Restore character
   17AD ED 45         [12] 4678 ARETN:  RETN                    ; Return from NMI
                           4679 
   17AF 00            [ 3] 4680         NOP
                           4681 
   17B0 DF 63              4682 INLINE: .dw      _INLN           ; Get an input line
   17B2 D5            [11] 4683         PUSH    DE              ; Save cursor address
   17B3 D5            [11] 4684         PUSH    DE              ; Cursor address to HL
   17B4 E1            [ 9] 4685         POP     HL
a  17B5               [ 9] 4686         LD      DE,48-1         ; Length of line-1
   17B5 19            [ 7] 4687         ADD     HL,DE           ; Point to end of line
   17B6 7E            [ 6] 4688 ENDLIN: LD      A,(HL)          ; Get end of line
a  17B7               [ 6] 4689         CP      " "             ; Space?
   17B7 C2 C3 17      [ 9] 4690         JP      NZ,LINTBF       ; No - Copy to buffer
   17BA 1D            [ 4] 4691         DEC     E               ; Back 1 character
a  17BB               [ 4] 4692         LD      A,0             ; Wasteful test on E
   17BB B3            [ 4] 4693         OR      E
   17BC CA C3 17      [ 9] 4694         JP      Z,LINTBF        ; Start of line - Copy it
   17BF 2B            [ 4] 4695         DEC     HL              ; Back 1 character
   17C0 C3 B6 17      [ 9] 4696         JP      ENDLIN          ; Keep looking for end
                           4697 
   17C3 D5            [11] 4698 LINTBF: PUSH    DE              ; Line length to BC
   17C4 C1            [ 9] 4699         POP     BC
   17C5 03            [ 4] 4700         INC     BC              ; Length +1
a  17C6               [ 4] 4701         LD      DE,BUFFER       ; Input buffer
   17C6 E1            [ 9] 4702         POP     HL              ; Line start
   17C7 C5            [11] 4703         PUSH    BC              ; Save length
   17C8 ED B0         [14] 4704         LDIR                    ; Move line to buffer
a  17CA               [14] 4705         LD      A,0
   17CA 12            [ 7] 4706         LD      (DE),A          ; Mark end of buffer with 00
   17CB C1            [ 9] 4707         POP     BC              ; Restore buffer length
   17CC 41            [ 4] 4708         LD      B,C             ; Length returned in B
a  17CD               [ 4] 4709         LD      HL,BUFFER-1     ; Point to start of buffer-1
   17CD C9            [ 9] 4710         RET
                           4711 
q  17CE CD 0C 00      [16] 4712 GETXYA: CALL    0xCKSYN          ; Make sure "(" follows
q                          4713         DB      "("
   17D1 CD 72 09      [16] 4714         CALL    GETNUM          ; Get a number
   17D4 CD 60 06      [16] 4715         CALL    DEINT           ; Get integer -32768 to 32767
   17D7 D5            [11] 4716         PUSH    DE              ; Save "X"
q  17D8 CD 0C 00      [16] 4717         CALL    0xCKSYN          ; Make sure "," follows
q                          4718         DB      ","
   17DB CD 72 09      [16] 4719         CALL    GETNUM          ; Get a number
q  17DE CD 0C 00      [16] 4720         CALL    0xCKSYN          ; Make sure ")" follows
q                          4721         DB      ")"
   17E1 CD 60 06      [16] 4722         CALL    DEINT           ; Get integer -32768 to 32767
   17E4 E5            [11] 4723         PUSH    HL              ; Save code string address
   17E5 FD E1         [12] 4724         POP     IY              ; In IY
   17E7 CD 35 18      [16] 4725         CALL    XYPOS           ; Address and bit mask
   17EA F5            [11] 4726         PUSH    AF              ; Save mask
   17EB CD 55 18      [16] 4727         CALL    ADJCOL          ; Adjust column
   17EE CD FC 16      [16] 4728         CALL    SCRADR          ; Get VDU address
   17F1 F1            [ 9] 4729         POP     AF              ; Restore bit mask
aq 17F2               [ 9] 4730         LD      B,11000000B     ; Block graphics base
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 87.
Hexadecimal [16-Bits]



   17F2 B0            [ 4] 4731         OR      B               ; Set bits 7 & 6
   17F3 C9            [ 9] 4732         RET
                           4733 
   17F4 CD CE 17      [16] 4734 SETB:   CALL    GETXYA          ; Get co-ords and VDU address
   17F7 F5            [11] 4735         PUSH    AF              ; Save bit mask
   17F8 7E            [ 6] 4736         LD      A,(HL)          ; Get character from screen
q  17F9                    4737         CP      11000000B       ; Is it a block graphic?
   17F9 D2 02 18      [ 9] 4738         JP      NC,SETOR        ; Yes - OR new bit
   17FC F1            [ 9] 4739         POP     AF              ; Restore bit mask
   17FD 77            [ 7] 4740 PUTBIT: LD      (HL),A          ; Put character on screen
   17FE FD E5         [14] 4741 RESCSA: PUSH    IY              ; Restore code string address
   1800 E1            [ 9] 4742         POP     HL              ; From IY
   1801 C9            [ 9] 4743         RET
                           4744 
   1802 C1            [ 9] 4745 SETOR:  POP     BC              ; Restore bit mask
   1803 B0            [ 4] 4746         OR      B               ; Merge the bits
   1804 C3 FD 17      [ 9] 4747         JP      PUTBIT          ; Save on screen
                           4748 
   1807 CD CE 17      [16] 4749 RESETB: CALL    GETXYA          ; Get co-ords and VDU address
   180A F5            [11] 4750         PUSH    AF              ; Save bit mask
   180B 7E            [ 6] 4751         LD      A,(HL)          ; Get byte from screen
q  180C                    4752         CP      11000000B       ; Is it a block graphic?
   180C DA 1D 18      [ 9] 4753         JP      C,NORES         ; No - Leave it
aq 180F               [ 9] 4754         LD      B,00111111B     ; Six bits per block
   180F A0            [ 4] 4755         AND     B               ; Clear bits 7 & 6
   1810 C1            [ 9] 4756         POP     BC              ; Get bit mask
   1811 A0            [ 4] 4757         AND     B               ; Test for common bit
   1812 CA FE 17      [ 9] 4758         JP      Z,RESCSA        ; None - Leave it
   1815 7E            [ 6] 4759         LD      A,(HL)          ; Get byte from screen
q  1816                    4760         AND     00111111B       ; Isolate bit
   1816 A8            [ 4] 4761         XOR     B               ; Clear that bit
q  1817                    4762         CP      11000000B       ; Is it a graphic blank?
   1817 C2 FD 17      [ 9] 4763         JP      NZ,PUTBIT       ; No - Save character
a  181A               [ 9] 4764         LD      A," "           ; Put a space there
   181A C3 FD 17      [ 9] 4765         JP      PUTBIT          ; Save the space
                           4766 
   181D C1            [ 9] 4767 NORES:  POP     BC              ; Drop bit mask
   181E C3 FE 17      [ 9] 4768         JP      RESCSA          ; Restore code string address
                           4769 
   1821 CD CE 17      [16] 4770 POINTB: CALL    GETXYA          ; Get co-ords and VDU address
   1824 46            [ 6] 4771         LD      B,(HL)          ; Get character from screen
   1825 CD 7A 18      [16] 4772         CALL    TSTBIT          ; Test if bit is set
   1828 C2 32 18      [ 9] 4773         JP      NZ,POINT0       ; Different - Return zero
a  182B               [ 9] 4774         LD      A,0
a  182B               [ 9] 4775         LD      B,1             ; Integer AB = 1
   182B E1            [ 9] 4776 POINTX: POP     HL              ; Drop return
   182C FD E5         [14] 4777         PUSH    IY              ; PUSH code string address
a  182E               [14] 4778         LD      DE,RETNUM       ; To return a number
   182E D5            [11] 4779         PUSH    DE              ; Save for return
   182F C3 9F 0C      [ 9] 4780         JP      ABPASS          ; Return integer AB
                           4781 
a  1832               [ 9] 4782 POINT0: LD      B,0             ; Set zero
   1832 C3 2B 18      [ 9] 4783         JP      POINTX          ; Return value
                           4784 
   1835 C1            [ 9] 4785 XYPOS:  POP     BC              ; Get return address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 88.
Hexadecimal [16-Bits]



   1836 E1            [ 9] 4786         POP     HL              ; Get column
   1837 E5            [11] 4787         PUSH    HL              ; And re-save
   1838 C5            [11] 4788         PUSH    BC              ; Put back return address
   1839 7D            [ 4] 4789         LD      A,L             ; Get column
aq 183A               [ 4] 4790         LD      B,00000001B     ; 2 bits per character
   183A A0            [ 4] 4791         AND     B               ; Odd or even bit
   183B F5            [11] 4792         PUSH    AF              ; Save it
   183C D5            [11] 4793         PUSH    DE              ; Get row
   183D E1            [ 9] 4794         POP     HL              ; to HL
a  183E               [ 9] 4795         LD      DE,0            ; Zero line count
a  183E               [ 9] 4796         LD      BC,3            ; 3 blocks per line
   183E 23            [ 4] 4797         INC     HL
   183F ED 42         [10] 4798 DIV3LP: SBC     HL,BC           ; Subtract 3
   1841 13            [ 4] 4799         INC     DE              ; Count the subtractions
   1842 CA 48 18      [ 9] 4800         JP      Z,DIV3EX        ; Exactly - Exit
   1845 F2 3F 18      [ 9] 4801         JP      P,DIV3LP        ; More to do
                           4802 
   1848 09            [ 7] 4803 DIV3EX: ADD     HL,BC           ; Restore number
   1849 F1            [ 9] 4804         POP     AF              ; Restore column and odd/even
   184A B7            [ 4] 4805         OR      A               ; Set flags (NZ or Z)
   184B 7D            [ 4] 4806         LD      A,L             ; Get remainder from /3
   184C CA 4F 18      [ 9] 4807         JP      Z,NOREMD        ; No remainder
a  184F               [ 9] 4808         ADD     A,3             ; Adjust remainder
   184F 47            [ 4] 4809 NOREMD: LD      B,A             ; Bit number+1 to B
aq 1850               [ 4] 4810         LD      A,00000001B     ; Bit to rotate
   1850 07            [ 3] 4811 SHFTBT: RLCA                    ; Shift bit left
   1851 10 FD         [ 9] 4812         DJNZ    SHFTBT          ; Count shifts
   1853 1F            [ 3] 4813         RRA                     ; Restore correct place
   1854 C9            [ 9] 4814         RET
                           4815 
   1855 C1            [ 9] 4816 ADJCOL: POP     BC              ; Restore return address
   1856 F1            [ 9] 4817         POP     AF              ; Get bit mask
   1857 E1            [ 9] 4818         POP     HL              ; Get column
   1858 F5            [11] 4819         PUSH    AF              ; Re-save but mask
   1859 7D            [ 4] 4820         LD      A,L             ; Get column
   185A 1F            [ 3] 4821         RRA                     ; Divide by 2
a  185B               [ 3] 4822         ADD     A,1             ; Start at column 1
q  185B                    4823         AND     00111111B       ; 0 to 63
   185B 67            [ 4] 4824         LD      H,A             ; Save column in H
   185C E5            [11] 4825         PUSH    HL              ; Re-save column
   185D C5            [11] 4826         PUSH    BC              ; Put back return
   185E 7B            [ 4] 4827         LD      A,E             ; Get row
   185F C9            [ 9] 4828         RET
                           4829 
   1860 CD FA 15      [16] 4830 SMOTOR: CALL    CASFF           ; Flip tape drive
   1863 7E            [ 6] 4831         LD      A,(HL)          ; Get byte
   1864 C9            [ 9] 4832         RET
                           4833 
   1865 3A CE 10      [12] 4834 JPLDSV: LD      A,(BRKLIN)      ; CLOAD or CSAVE?
a  1868               [12] 4835         CP      -1
   1868 C2 F6 05      [ 9] 4836         JP      NZ,SN0xDDR       ; CSAVE - Send header
   186B C3 00 06      [ 9] 4837         JP      GETHDR          ; CLOAD - Get header
                           4838 
   186E CD 07 08      [16] 4839 CRLIN1: CALL    PRNTCR          ; Output CRLF
   1871 C3 67 03      [ 9] 4840         JP      GETLIN          ; Get an input line
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 89.
Hexadecimal [16-Bits]



                           4841 
   1874 CD 07 08      [16] 4842 CRLIN:  CALL    PRNTCR          ; Output CRLF
   1877 C3 67 03      [ 9] 4843         JP      GETLIN          ; Get an input line
                           4844 
   187A F5            [11] 4845 TSTBIT: PUSH    AF              ; Save bit mask
   187B A0            [ 4] 4846         AND     B               ; Get common bits
   187C C1            [ 9] 4847         POP     BC              ; Restore bit mask
   187D B8            [ 4] 4848         CP      B               ; Same bit set?
a  187E               [ 4] 4849         LD      A,0             ; Return 0 in A
   187E C9            [ 9] 4850         RET
                           4851 
   187F CD E7 03      [16] 4852 OUTNCR: CALL    OUTC            ; Output character in A
   1882 C3 07 08      [ 9] 4853         JP      PRNTCR          ; Output CRLF
                           4854 
   1885 C3 D2 16      [ 9] 4855 JJUMP:  JP      JJUMP1          ; "Cool" start
                           4856 
   1888 C3 85 00      [ 9] 4857 ZJUMP:  JP      BRKRET          ; Warm start
q                          4858         END
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 90.
Hexadecimal [16-Bits]

Symbol Table

    $          **** X   |     .__.$$$.=  2710 L   |     .__.ABS.=  0000 G
    .__.CPU.=  0001 L   |     .__.H$L.=  0000 L   |   1 ABPASS     0C9F R
  1 ABS        12BA R   |   1 ACCSUM     062E R   |   1 ACPASS     0C9E R
  1 ADD64X     1711 R   |   1 ADDEXP     126A R   |   1 ADDIG      13CB R
  1 ADDPHL     10C3 R   |   1 ADJCOL     1855 R   |   1 ALLFOL     0F18 R
  1 ANTVLU     08BE R   |   1 ANYNAM     104A R   |   1 ARET       15FD R
  1 ARETN      17AD R   |     ARG1    =  0C0C     |     ARG2    =  0C0E 
    ARGN    =  0C2B     |   1 ARLDSV     0BCE R   |     ARREND  =  10DA 
  1 ARRLD1     05BB R   |   1 ARRLP      0DFA R   |   1 ARRSV1     05BB R
  1 ARYLP      060E R   |   1 ASC        0EEF R   |   1 ASCTFP     1376 R
  1 ASPCS      0846 R   |   1 ATN        15D6 R   |   1 ATN1       15EB R
  1 ATNTAB     15EF R   |   1 ATOH       0670 R   |   1 BAD        10AC R
  1 BADINP     0856 R   |   1 BAKSTK     0141 R   |   1 BAKTMP     0ED2 R
    BASTXT  =  105E     |   1 BCDEFP     12DC R   |   1 BFREE      008B R
    BKSP    =  0008     |   1 BNORM      111B R   |   1 BNRMLP     111E R
  1 BREAK      17A8 R   |   1 BREAK2     172E R   |     BRKFLG  =  104D 
    BRKLIN  =  10CE     |   1 BRKMSG     0141 R   |   1 BRKRET     0085 R
    BS      =  0010     |   1 BSERR      0C00 R   |     BUFFER  =  1061 
  1 BYTSFT     11FD R   |   1 CASFF      15FA R   |   1 CASFFW     15EF R
  1 CFEVAL     0B75 R   |     CIN     =  0C75     |   1 CLEAR      068B R
  1 CLOAD      102E R   |   1 CLOAD1     1059 R   |   1 CLOAD2     1059 R
  1 CLOADE     1089 R   |   1 CLOADV     1086 R   |   1 CLOTST     0416 R
  1 CLREG      028F R   |   1 CLRPTR     026A R   |   1 CLS        1684 R
  1 CMPFP      1314 R   |   1 CMPLG1     0A9E R   |   1 CMPLOG     0A9C R
  1 CMPNUM     1300 R   |   1 CMPRES     0ADB R   |   1 CMPSTR     0AC5 R
    CN      =  0020     |   1 CNVIN1     1637 R   |   1 CNVIN2     163A R
  1 CNVIN3     163D R   |   1 CNVIN4     1640 R   |   1 CNVIN5     1643 R
  1 CNVNUM     137E R   |     COMMAN  =  1043     |   1 COMPL      116D R
  1 CONCAT     0E6C R   |   1 CONEXP     13AA R   |   1 CONMON     15FE R
  1 CONOT1     1610 R   |   1 CONPOS     1118 R   |   1 CONT       05A2 R
    CONTAD  =  10D4     |   1 CONVAR     0A22 R   |   1 CONVIN     1634 R
  1 COPY       0012 R   |   1 COS        1589 R   |   1 COUNT      047F R
  1 CP0xDEL    03D7 R   |   1 CPYLIT     032D R   |     CR      =  000D 
  1 CRARLP     0C1B R   |   1 CREARY     0C03 R   |   1 CRESTR     0766 R
  1 CRLIN      1874 R   |   1 CRLIN1     186E R   |   1 CRNCLP     02B6 R
  1 CRTMST     0D54 R   |   1 CRTST      0D5D R   |   1 CRTSTE     0D6F R
  1 CRUN0xC    02B2 R   |     CS      =  000C     |   1 CSAVE      1001 R
  1 CSTART     000E R   |     CTLOFG  =  1045     |     CTRLC   =  0003 
    CTRLG   =  0007     |     CTRLO   =  000F     |     CTRLR   =  0012 
    CTRLS   =  0013     |     CTRLU   =  0015     |     CTRLZ   =  001A 
    CUROPR  =  10C5     |     CURPOS  =  10AB     |     CURSOR  =  0C29 
  1 DATA       071A R   |     DATFLG  =  10AE     |     DATLIN  =  10C9 
  1 DATSNR     0180 R   |   1 DCBCDE     1347 R   |     DD      =  0012 
  1 DDERR      0186 R   |   1 DEEK       16B1 R   |   1 DEF        0CAC R
  1 DEFSIZ     0C20 R   |   1 DEINT      0660 R   |     DEL     =  007F 
  1 DEL0xCR    0356 R   |   1 DELAY      1690 R   |   1 DELAY1     1691 R
  1 DELAYB     15F2 R   |   1 DEPINT     065A R   |   1 DETHL4     12E5 R
  1 DETHLB     12E5 R   |   1 DIGTXT     144B R   |   1 DIM        0B00 R
  1 DIMRET     0AF8 R   |   1 DINPOS     0409 R   |   1 DIV        1208 R
    DIV1    =  100A     |   1 DIV10      1202 R   |     DIV2    =  100E 
    DIV3    =  1012     |   1 DIV3EX     1848 R   |   1 DIV3LP     183F R
    DIV4    =  1015     |   1 DIVLP      122D R   |     DIVSUP  =  1009 
  1 DOAGN      02A5 R   |   1 DOCOM      081C R   |   1 DODEL      033A R
  1 DOEBIT     1483 R   |   1 DOFN       0CD3 R   |   1 DOKE       16BC R
  1 DONULL     080A R   |   1 DOSPC      0841 R   |   1 DOSUM      0633 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 91.
Hexadecimal [16-Bits]

Symbol Table

  1 DOTAB      0831 R   |   1 DPOINT     13A6 R   |   1 DTSTR      0D5F R
  1 DVBCDE     120A R   |     DZ      =  0014     |   1 DZERR      0186 R
  1 EDIGIT     13EB R   |   1 ENDBUF     0334 R   |   1 ENDCON     13B9 R
  1 ENDDIM     0C7C R   |   1 ENDINP     0807 R   |   1 ENDLIN     17B6 R
  1 ENDNAM     0B1E R   |   1 ENDPRG     0581 R   |   1 ENFMEM     0172 R
  1 ERRIN      019E R   |     ERRLIN  =  10D2     |   1 ERRMSG     0141 R
  1 ERROR      0186 R   |   1 ERRORS     0117 R   |     ESC     =  001B 
  1 EVAL       0985 R   |   1 EVAL1      0986 R   |   1 EVAL2      098D R
  1 EVAL3      0990 R   |   1 EVLPAR     0A0C R   |   1 EVNOT      0AE3 R
  1 EXCUTE     0537 R   |   1 EXP        14ED R   |   1 EXPLP      1398 R
  1 EXPTAB     1518 R   |   1 EXPTEN     148D R   |   1 EXTIG      090C R
  1 FANDT      0923 R   |     FC      =  0008     |   1 FCERR      066D R
  1 FDTLP      090C R   |   1 FILE       10AC R   |   1 FILFND     1098 R
  1 FINDEL     0C59 R   |   1 FLGDIF     12AC R   |   1 FLGREL     12B3 R
  1 FLGVER     1039 R   |   1 FLPLED     1715 R   |     FNARG   =  10E0 
  1 FNCTAB     008B R   |   1 FNDARY     0BD3 R   |   1 FNDELP     0C5D R
  1 FNDEND     023D R   |   1 FNDNUM     0FC5 R   |   1 FNDTOK     045A R
  1 FNDVAR     0B5C R   |   1 FNDWRD     02D4 R   |   1 FNOFST     0A33 R
    FNRGNM  =  10DE     |   1 FNTHR      0B6A R   |   1 FNVAL      0A58 R
  1 FOPRND     09AF R   |   1 FOR        04AD R   |     FORFLG  =  10CB 
  1 FORFND     04D8 R   |   1 FORSLP     04BC R   |   1 FOUND      10AC R
  1 FPADD      10D1 R   |   1 FPBCDE     12D1 R   |     FPEXP   =  10E7 
  1 FPINT      1327 R   |   1 FPMULT     11BF R   |     FPREG   =  10E4 
  1 FPROND     1156 R   |   1 FPSINT     0654 R   |   1 FPTHL      12E5 R
  1 FRE        0C80 R   |   1 FRENUM     0C99 R   |   1 FRMEVL     0A25 R
  1 GARBGE     0DCB R   |   1 GARBLP     0DCE R   |   1 GET0xCR    054B R
  1 GETCMD     01BB R   |   1 GETHDR     0600 R   |   1 GETINP     1620 R
  1 GETINT     0FC8 R   |   1 GETLEN     0EE4 R   |   1 GETLIN     0367 R
  1 GETLN      0671 R   |   1 GETNUM     0972 R   |   1 GETNXT     02E1 R
  1 GETSTR     0EB1 R   |   1 GETTIN     162E R   |   1 GETVAR     0B01 R
  1 GETXYA     17CE R   |   1 GNXARY     0DF9 R   |   1 GOFUNC     0A5D R
  1 GOSUB      06D6 R   |   1 GOTO       06E3 R   |   1 GRBARY     0E17 R
  1 GRBDON     0DAA R   |   1 GRBLP      0DD6 R   |   1 GSTRCU     0EB4 R
  1 GSTRDE     0EB8 R   |   1 GSTRHL     0EB7 R   |   1 GTFLNM     0EF0 R
  1 GTFNAM     0B06 R   |   1 GTLNLP     0671 R   |   1 GTSIXD     1423 R
  1 GTVLUS     089A R   |   1 GUART      165A R   |   1 HALF       14A2 R
  1 HALFPI     15C1 R   |   1 HDRLP      0600 R   |     HIGH       **** X
    ID      =  0016     |   1 IDTEST     0D18 R   |   1 IF         0797 R
  1 IFGO       07A2 R   |   1 IFJMP      053B R   |   1 IG0xCR     161B R
  1 IN0xCL     12E3 R   |   1 INCLEN     0405 R   |   1 INDFND     0156 R
  1 INEWLN     0208 R   |   1 INIT       0012 R   |   1 INITAB     0117 R
  1 INITBE     0141 R   |   1 INITST     178C R   |   1 INLINE     17B0 R
  1 INMSG      0141 R   |   1 INP        0F89 R   |   1 INPBIN     08DF R
  1 INPBRK     0580 R   |     INPORT  =  103F     |     INPSUB  =  103E 
  1 INPUT      0864 R   |   1 INRNG      142C R   |   1 INT        134E R
  1 INTVAR     0279 R   |   1 INVSGN     12BE R   |   1 ITMSEP     08D5 R
  1 JJUMP      1885 R   |   1 JJUMP1     16D2 R   |   1 JPLDSV     1865 R
  1 JSTZER     1493 R   |   1 KILFOR     0964 R   |   1 KILIN      0361 R
    LCRFLG  =  10AC     |   1 LDNMI1     0479 R   |   1 LEFT       0F0B R
  1 LEN        0EE3 R   |   1 LET        0729 R   |   1 LETNUM     0777 R
  1 LETSTR     0743 R   |     LF      =  000A     |   1 LFRGNM     0F80 R
    LINEAT  =  105C     |   1 LINEIN     13F5 R   |   1 LINES      16A2 R
    LINESC  =  1046     |     LINESN  =  1048     |   1 LINFND     01F1 R
  1 LINTBF     17C3 R   |   1 LIST       0423 R   |   1 LISTLP     042F R
  1 LOADFP     12DC R   |   1 LOG        119A R   |   1 LOGTAB     119A R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 92.
Hexadecimal [16-Bits]

Symbol Table

  1 LOKFOR     0142 R   |     LOOPST  =  10C7     |     LOW        **** X
    LS      =  001C     |     LSTBIN  =  10CC     |   1 LSTLP2     044D R
  1 LSTLP3     0450 R   |     LSTRAM  =  10AF     |     LSTRND  =  103A 
  1 LTSTND     08EA R   |     LWIDTH  =  1042     |   1 MAKINT     0FCB R
  1 MAKNUM     1441 R   |   1 MANLP      1386 R   |   1 MAT0xC     030B R
  1 MEMMSG     008B R   |     MFLP    =  0051     |   1 MID        0F40 R
  1 MID1       0F11 R   |   1 MIDNUM     0F84 R   |   1 MINCDE     110A R
  1 MINUS      0A13 R   |   1 MKTMST     0D51 R   |   1 MLDBLP     1363 R
  1 MLDEBC     1360 R   |   1 MLOOP      0034 R   |   1 MLSP10     1290 R
    MO      =  0024     |   1 MONITR     1775 R   |   1 MONLD      175D R
  1 MONOUT     1721 R   |     MONSTT  =  0000     |   1 MONTST     1744 R
    MONTYP  =  008D     |   1 MONVE      177D R   |   1 MORDT      08F4 R
  1 MORINP     037E R   |   1 MOVBUF     0224 R   |   1 MOVDIR     0313 R
  1 MOVLP      0162 R   |   1 MOVSTR     015F R   |   1 MOVUP      015C R
  1 MRPRNT     07B4 R   |   1 MSIZE      0027 R   |   1 MUL8LP     11DA R
  1 MULLN2     11BD R   |   1 MULT       11BD R   |   1 MULT8      11D3 R
  1 MULTEN     13C4 R   |     MULVAL  =  10F6     |   1 MVSTPT     076E R
  1 NASOUT     1616 R   |   1 NEDMOR     0897 R   |   1 NEGAFT     14A2 R
  1 NEW        0269 R   |   1 NEXITM     084F R   |   1 NEXT       092C R
  1 NEXT1      092C R   |     NF      =  0000     |   1 NFERR      0186 R
    NMI     =  0C7E     |     NMIFLG  =  104C     |   1 NO0xCNG    0303 R
  1 NOENED     1496 R   |   1 NOLIN      0594 R   |   1 NOMADD     11EB R
  1 NOMLAD     1371 R   |   1 NOPMPT     0878 R   |   1 NOREMD     184F R
  1 NORES      181D R   |   1 NORMAL     1131 R   |   1 NOSPC      02FE R
  1 NOSWAP     10EB R   |   1 NOTSTR     0B37 R   |   1 NOXOR      0FAC R
  1 NSCFOR     0B45 R   |     NULFLG  =  1044     |   1 NULL       05B3 R
  1 NULLP      0811 R   |     NULLS   =  1041     |   1 NUMASC     1400 R
  1 NXT0xCR    0324 R   |   1 NXTARY     0BE7 R   |   1 NXTBYT     02EF R
    NXTDAT  =  10DC     |   1 NXTDTA     0719 R   |   1 NXTITM     088F R
    NXTOPR  =  10D0     |   1 NXTSTL     071A R   |   1 NXTSTT     071D R
    OD      =  0006     |   1 OKMSG      0141 R   |     OM      =  000C 
  1 OMERR      017D R   |   1 ON         077E R   |   1 ONGO       078A R
  1 ONGOLP     078B R   |   1 ONJMP      053C R   |   1 OPNPAR     0982 R
  1 OPRND      09E4 R   |     OS      =  001A     |   1 OTKLN      035E R
    OTPORT  =  1007     |   1 OUT0xCR    1618 R   |   1 OUTBAD     1092 R
  1 OUTC       03E7 R   |   1 OUTEXP     148D R   |   1 OUTIT      03CB R
  1 OUTNBS     03D1 R   |   1 OUTNCR     187F R   |     OUTSUB  =  1006 
  1 OUTWRD     0464 R   |     OV      =  000A     |   1 OVERR      0186 R
  1 OVTST1     1283 R   |   1 OVTST2     1288 R   |   1 OVTST3     1289 R
  1 PADD       13E6 R   |   1 PAND       0A6B R   |   1 PASSA      0CA7 R
    PBUFF   =  10E9     |   1 PEEK       10AC R   |   1 PEND       057C R
  1 PHLTFP     12CE R   |   1 PLUCDE     1161 R   |   1 PNORM      1139 R
    POINT   =  1051     |   1 POINT0     1832 R   |   1 POINTB     1821 R
  1 POINTX     182B R   |   1 POKE       10B3 R   |   1 POPAF      0DC2 R
  1 POPHL      0ED0 R   |   1 POPHRT     11FB R   |   1 POPNOK     01B0 R
  1 POR        0A6B R   |   1 POR1       0A8A R   |     PORT0   =  0C00 
  1 POS        0CA4 R   |   1 POSINT     0657 R   |   1 POUT       0F95 R
  1 POWER      14AA R   |   1 POWER1     14BA R   |   1 POWER2     14D5 R
  1 POWERS     14A2 R   |   1 PRINT      07B8 R   |   1 PRITAB     0109 R
  1 PRNTCR     0807 R   |   1 PRNTHL     13FA R   |   1 PRNTLP     07BB R
  1 PRNTNB     07F4 R   |   1 PRNTOK     01B1 R   |   1 PRNTST     07F8 R
  1 PRNUMS     0D91 R   |   1 PROCES     0393 R   |     PROGND  =  10D6 
    PROGST  =  10F9     |   1 PROMPT     02A9 R   |   1 PRS        0D92 R
  1 PRS1       0D95 R   |   1 PRSLP      0D9C R   |     PSET    =  1054 
  1 PSUB       10CC R   |   1 PTRLP      0231 R   |   1 PUTBIT     17FD R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 93.
Hexadecimal [16-Bits]

Symbol Table

  1 PUTBUF     03BD R   |   1 PUTCTL     03C0 R   |   1 PUTFID     0513 R
  1 QTSTLP     0D60 R   |   1 QTSTR      0D5E R   |   1 QUARTR     15C1 R
  1 READ       088B R   |     READFG  =  10CD     |   1 REDO       0856 R
  1 REM        071A R   |   1 RESCSA     17FE R   |   1 RESDIV     123D R
  1 RESEED     1581 R   |     RESET   =  1057     |   1 RESETB     1807 R
  1 RESTNL     056A R   |   1 RESTOR     0555 R   |   1 RESZER     112C R
  1 RETADR     0BA1 R   |   1 RETCTC     1740 R   |   1 RETINT     12B3 R
  1 RETLIN     0718 R   |   1 RETNAD     030F R   |   1 RETNUL     0BA4 R
  1 RETNUM     0A1D R   |   1 RETREL     12AA R   |   1 RETURN     06FF R
    RG      =  0004     |   1 RIGHT      0F36 R   |   1 RIGHT1     0F0F R
    RINPUT  =  104E     |   1 RLTLP      0999 R   |   1 RND        1544 R
  1 RND1       156A R   |   1 RND2       157B R   |   1 RNDTAB     1589 R
  1 RNGTST     1499 R   |   1 RONDB      114A R   |   1 RONDUP     1149 R
  1 ROUND      10C3 R   |   1 RSCALE     13E0 R   |   1 RSLNBK     04A4 R
  1 RSTSTR     0F54 R   |   1 RUART      0FF2 R   |   1 RUN        06CD R
  1 RUNCNT     0515 R   |   1 RUNFST     0275 R   |   1 RUNLIN     06E2 R
  1 SAVE       1748 R   |   1 SAVEXP     112D R   |   1 SAVSTP     050A R
  1 SAVSTR     0D3C R   |   1 SBSCPT     0BAC R   |   1 SCALE      117E R
  1 SCALLP     117E R   |   1 SCALMI     13AD R   |   1 SCALPL     13C3 R
  1 SCNEND     0E49 R   |   1 SCPTLP     0BB2 R   |   1 SCRADR     16FC R
  1 SCREEN     16D6 R   |   1 SEAR0xC    02DF R   |     SEED    =  1017 
  1 SETB       17F4 R   |   1 SETIO      0FB6 R   |   1 SETLIN     0470 R
  1 SETLIT     031D R   |   1 SETOR      1802 R   |   1 SETPTR     022C R
  1 SETTOP     0056 R   |   1 SFTENT     1674 R   |   1 SFTPRG     01F9 R
  1 SGN        12B0 R   |   1 SGNEXP     0A63 R   |     SGNRES  =  10E8 
  1 SHFTBT     1850 R   |   1 SHRITE     1187 R   |   1 SHRLP      1188 R
  1 SHRT1      118C R   |   1 SIGNON     008B R   |   1 SIGNS      12EE R
  1 SIN        158C R   |   1 SIN1       15B3 R   |   1 SINTAB     15C1 R
  1 SIXDIG     1414 R   |   1 SMOTOR     1860 R   |   1 SMPVAR     0DE4 R
  1 SMSER1     1524 R   |     SN      =  0002     |   1 SN0xDDR    05F6 R
  1 SNDARY     060B R   |   1 SNERR      0186 R   |   1 SPCFST     1407 R
  1 SPCLP      0848 R   |   1 SQR        14A4 R   |   1 SR0xCLN    0249 R
  1 SR0xCLP    024C R   |   1 SSTSA      0E9E R   |     ST      =  001E 
    STACK   =  1066     |   1 STAKFP     12C1 R   |   1 STALL      0575 R
  1 START      0000 R   |   1 STARTB     0003 R   |   1 STKTHS     09D0 R
    STLOOK  =  115D     |     STMON   =  000D     |   1 STOP       057B R
  1 STORED     06AD R   |   1 STPOOL     0E22 R   |   1 STR        0D2F R
  1 STRADD     0E23 R   |     STRBOT  =  10C3     |   1 STRENT     08D6 R
    STRSPC  =  105A     |   1 STTLIN     07FF R   |   1 SUART      166C R
  1 SUBCDE     10CE R   |   1 SUBPHL     10C9 R   |   1 SUMLP      152C R
  1 SUMOFF     0625 R   |   1 SUMSER     1518 R   |   1 SUPTLZ     147B R
  1 SVNAM2     0B1D R   |   1 SVSTAD     0D57 R   |   1 T0xCINP    173D R
    T2DUMP  =  03D1     |     T4READ  =  070C     |     T4WR    =  0400 
  1 TAN        15C1 R   |     TBRK    =  001C     |   1 TBRK2      1656 R
    TBS     =  001D     |   1 TCLS       168D R   |     TCR     =  001F 
    TCS     =  001E     |     TCUR    =  0C18     |   1 TESTOS     0DC4 R
  1 TESTR      0DA9 R   |   1 THSFIL     1072 R   |     TIN     =  0C4D 
  1 TLOAD      176C R   |     TM      =  0018     |   1 TMERR      0186 R
  1 TMFLP      171E R   |   1 TMNCUR     16F3 R   |   1 TMNOUT     172A R
    TMPSTR  =  10BF     |     TMSTPL  =  10B3     |     TMSTPT  =  10B1 
  1 TOPOOL     0F07 R   |   1 TOSTRA     0EA7 R   |     TOUT    =  0C4A 
  1 TRYAGN     1456 R   |   1 TSALP      0EA8 R   |   1 TSAVE      1754 R
  1 TSTBIT     187A R   |   1 TSTBRK     0570 R   |   1 TSTMEM     0046 R
  1 TSTNUM     0975 R   |   1 TSTOPL     0D79 R   |   1 TSTRED     0A8F R
  1 TSTREM     0320 R   |   1 TSTSGN     12A2 R   |   1 TSTSTR     0975 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 94.
Hexadecimal [16-Bits]

Symbol Table

  1 TTYLIN     037A R   |     TYPE    =  10AD     |     UARTD   =  0001 
  1 UARTOT     1663 R   |     UARTS   =  0002     |     UF      =  0022 
  1 UFERR      0186 R   |     UL      =  000E     |   1 ULERR      06FC R
  1 UNITY      119A R   |   1 UPDATA     056B R   |   1 URTOLP     1665 R
    USR     =  1003     |   1 VAL        0F65 R   |     VAREND  =  10D8 
    VDU     =  0800     |   1 WAIT       0F9B R   |   1 WAITLP     0FAD R
  1 WARMST     0085 R   |   1 WIDTH      169A R   |   1 WORDS      00BF R
  1 WORDTB     00BF R   |     WRKSPC  =  1000     |   1 WUART      0FF8 R
  1 WUART2     0FF5 R   |   1 XYPOS      1835 R   |     ZDATA   =  0083 
    ZDIV    =  00AF     |     ZEND    =  0080     |     ZEQUAL  =  00B4 
  1 ZERARY     0C3E R   |     ZERBYT  =  FFFFFFFF     |   1 ZEROLP     0B95 R
    ZFN     =  00A7     |     ZFOR    =  0081     |     ZGOSUB  =  008C 
    ZGOTO   =  0088     |     ZGTR    =  00B3     |   1 ZJUMP      1888 R
    ZLEFT   =  00CD     |     ZLTH    =  00B5     |     ZMINUS  =  00AD 
    ZNEW    =  00A4     |     ZNOT    =  00AA     |   1 ZONELP     082A R
    ZOR     =  00B2     |     ZPLUS   =  00AC     |     ZPOINT  =  00C7 
    ZPRINT  =  009E     |     ZREM    =  008E     |     ZSGN    =  00B6 
    ZSPC    =  00A8     |     ZSTEP   =  00AB     |     ZTAB    =  00A5 
    ZTHEN   =  00A9     |     ZTIMES  =  00AE     |     ZTO     =  00A6 
    _BLNK   =  7BDF     |     _INLN   =  63DF     |     _MFLP   =  5FDF 
    _MRET   =  5BDF     |     _READ   =  52DF     |     _RIN    =  62DF 
    _ROUT   =  00F7     |     _VRFY   =  56DF     |     _WRIT   =  57DF 

ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 95.
Hexadecimal [16-Bits]

Area Table

   0 _CODE      size    0   flags    0
   1 CODE       size 188B   flags    8

