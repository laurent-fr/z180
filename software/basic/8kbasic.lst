ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 1.
Hexadecimal [16-Bits]



                              1 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                              2 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                              3 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                              4 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                              5 ; the original ROM code (checksum 0xA934). PA
                              6 
                              7 .z180
                              8 
                              9 .area CODE (ABS)
                             10 
                             11 
                             12 ; MONITOR EQUATES (RESTART INSTRUCTIONS)
                             13 
                     00F7    14 _ROUT   .equ     0xF7            ; ROUT - Output char in A
                     7BDF    15 _BLNK   .equ     0x7BDF          ; SCAL BLINK - Get input char in A
                     63DF    16 _INLN   .equ     0x63DF          ; SCAL INLIN - Get input line
                     5FDF    17 _MFLP   .equ     0x5FDF          ; SCAL MFLP - Toggle tape drv LED
                     5BDF    18 _MRET   .equ     0x5BDF          ; SCAL MRET - Return to monitor
                     52DF    19 _READ   .equ     0x52DF          ; SCAL READ
                     62DF    20 _RIN    .equ     0x62DF          ; SCAL RIN - Scan for input char
                     56DF    21 _VRFY   .equ     0x56DF          ; SCAL VERIFY
                     57DF    22 _WRIT   .equ     0x57DF          ; SCAL WRITE
                             23 
                             24 ; GENERAL .equATES
                             25 
                     0001    26 UARTD   .equ     0x01             ; UART data port
                     0002    27 UARTS   .equ     0x02             ; UART status port
                     0003    28 CTRLC   .equ     0x03             ; Control "C"
                     0007    29 CTRLG   .equ     0x07             ; Control "G"
                     0008    30 BKSP    .equ     0x08             ; Back space
                     000A    31 LF      .equ     0x0A             ; Line feed
                     000C    32 CS      .equ     0x0C             ; Clear screen
                     000D    33 CR      .equ     0x0D             ; Carriage return
                     000F    34 CTRLO   .equ     0x0F             ; Control "O"
                     0012    35 CTRLR   .equ     0x12             ; Control "R"
                     0013    36 CTRLS   .equ     0x13             ; Control "S"
                     0015    37 CTRLU   .equ     0x15             ; Control "U"
                     001A    38 CTRLZ   .equ     0x1A             ; Control "Z"
                     001B    39 ESC     .equ     0x1B             ; Escape
                     001C    40 TBRK    .equ     0x1C             ; "T" monitor break
                     001D    41 TBS     .equ     0x1D             ; "T" monitor back space
                     001E    42 TCS     .equ     0x1E             ; "T" monitor clear screen
                     001F    43 TCR     .equ     0x1F             ; "T" monitor carriage return
                     007F    44 DEL     .equ     0x7F             ; Delete
                             45 
                             46 ; MONITOR LOCATIONS
                             47 
                     0000    48 MONSTT  .equ     0x0000           ; Start of monitor
                     000D    49 STMON   .equ     0x000D           ; NAS-SYS initialisation
                     0051    50 MFLP    .equ     0x0051           ; Flip tape LED ("T")
                     008D    51 MONTYP  .equ     0x008D           ; Type of "T" monitor
                     03D1    52 T2DUMP  .equ     0x03D1           ; "T2" Dump routine
                     0400    53 T4WR    .equ     0x0400           ; "T4" Write routine
                     070C    54 T4READ  .equ     0x070C           ; "T4" Read routine
                     0800    55 VDU     .equ     0x0800           ; NASCOM Video RAM base
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 2.
Hexadecimal [16-Bits]



                             56 
                             57 ; MONITOR WORK SPACE LOCATIONS
                             58 
                     0C00    59 PORT0   .equ     0x0C00           ; Copy of output port 0
                     0C0C    60 ARG1    .equ     0x0C0C           ; Argument 1
                     0C0E    61 ARG2    .equ     0x0C0E           ; Argument 2
                     0C18    62 TCUR    .equ     0x0C18           ; "T" monitor cursor
                     0C29    63 CURSOR  .equ     0x0C29           ; NAS-SYS Cursor
                     0C2B    64 ARGN    .equ     0x0C2B           ; Number of ARGS
                     0C4A    65 TOUT    .equ     0x0C4A           ; "T" Output reflection
                     0C4D    66 TIN     .equ     0x0C4D           ; "T" Input reflection
                     0C75    67 CIN     .equ     0x0C75           ; NAS-SYS Input table
                     0C7E    68 NMI     .equ     0x0C7E           ; NAS-SYS NMI Jump
                             69 
                             70 ; BASIC WORK SPACE LOCATIONS
                             71 
                     1000    72 WRKSPC  .equ     0x1000           ; BASIC Work space
                     1003    73 USR     .equ     0x1003           ; "USR (x)" jump
                     1006    74 OUTSUB  .equ     0x1006           ; "OUT p,n"
                     1007    75 OTPORT  .equ     0x1007           ; Port (p)
                     1009    76 DIVSUP  .equ     0x1009           ; Division support routine
                     100A    77 DIV1    .equ     0x100A           ; <- Values
                     100E    78 DIV2    .equ     0x100E           ; <-   to
                     1012    79 DIV3    .equ     0x1012           ; <-   be
                     1015    80 DIV4    .equ     0x1015           ; <-inserted
                     1017    81 SEED    .equ     0x1017           ; Random number seed
                     103A    82 LSTRND  .equ     0x103A           ; Last random number
                     103E    83 INPSUB  .equ     0x103E           ; #INP (x)" Routine
                     103F    84 INPORT  .equ     0x103F           ; PORT (x)
                     1041    85 NULLS   .equ     0x1041           ; Number of nulls
                     1042    86 LWIDTH  .equ     0x1042           ; Terminal width
                     1043    87 COMMAN  .equ     0x1043           ; Width for commas
                     1044    88 NULFLG  .equ     0x1044           ; Null after input byte flag
                     1045    89 CTLOFG  .equ     0x1045           ; Control "O" flag
                     1046    90 LINESC  .equ     0x1046           ; Lines counter
                     1048    91 LINESN  .equ     0x1048           ; Lines number
                     104A    92 CHKSUM  .equ     0x104A           ; Array load/save check sum
                     104C    93 NMIFLG  .equ     0x104C           ; Flag for NMI break routine
                     104D    94 BRKFLG  .equ     0x104D           ; Break flag
                     104E    95 RINPUT  .equ     0x104E           ; Input reflection
                     1051    96 POINT   .equ     0x1051           ; "POINT" reflection (unused)
                     1054    97 PSET    .equ     0x1054           ; "SET"   reflection
                     1057    98 RESET   .equ     0x1057           ; "RESET" reflection
                     105A    99 STRSPC  .equ     0x105A           ; Bottom of string space
                     105C   100 LINEAT  .equ     0x105C           ; Current line number
                     105E   101 BASTXT  .equ     0x105E           ; Pointer to start of program
                     1061   102 BUFFER  .equ     0x1061           ; Input buffer
                     1066   103 STACK   .equ     0x1066           ; Initial stack
                     10AB   104 CURPOS  .equ     0x10AB           ; Character position on line
                     10AC   105 LCRFLG  .equ     0x10AC           ; Locate/Create flag
                     10AD   106 TYPE    .equ     0x10AD           ; Data type flag
                     10AE   107 DATFLG  .equ     0x10AE           ; Literal statement flag
                     10AF   108 LSTRAM  .equ     0x10AF           ; Last available RAM
                     10B1   109 TMSTPT  .equ     0x10B1           ; Temporary string pointer
                     10B3   110 TMSTPL  .equ     0x10B3           ; Temporary string pool
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 3.
Hexadecimal [16-Bits]



                     10BF   111 TMPSTR  .equ     0x10BF           ; Temporary string
                     10C3   112 STRBOT  .equ     0x10C3           ; Bottom of string space
                     10C5   113 CUROPR  .equ     0x10C5           ; Current operator in EVAL
                     10C7   114 LOOPST  .equ     0x10C7           ; First statement of loop
                     10C9   115 DATLIN  .equ     0x10C9           ; Line of current DATA item
                     10CB   116 FORFLG  .equ     0x10CB           ; "FOR" loop flag
                     10CC   117 LSTBIN  .equ     0x10CC           ; Last byte entered
                     10CD   118 READFG  .equ     0x10CD           ; Read/Input flag
                     10CE   119 BRKLIN  .equ     0x10CE           ; Line of break
                     10D0   120 NXTOPR  .equ     0x10D0           ; Next operator in EVAL
                     10D2   121 ERRLIN  .equ     0x10D2           ; Line of error
                     10D4   122 CONTAD  .equ     0x10D4           ; Where to CONTinue
                     10D6   123 PROGND  .equ     0x10D6           ; End of program
                     10D8   124 VAREND  .equ     0x10D8           ; End of variables
                     10DA   125 ARREND  .equ     0x10DA           ; End of arrays
                     10DC   126 NXTDAT  .equ     0x10DC           ; Next data item
                     10DE   127 FNRGNM  .equ     0x10DE           ; Name of FN argument
                     10E0   128 FNARG   .equ     0x10E0           ; FN argument value
                     10E4   129 FPREG   .equ     0x10E4           ; Floating point register
                     10E7   130 FPEXP   .equ     FPREG+3         ; Floating point exponent
                     10E8   131 SGNRES  .equ     0x10E8           ; Sign of result
                     10E9   132 PBUFF   .equ     0x10E9           ; Number print buffer
                     10F6   133 MULVAL  .equ     0x10F6           ; Multiplier
                     10F9   134 PROGST  .equ     0x10F9           ; Start of program text area
                     115D   135 STLOOK  .equ     0x115D           ; Start of memory test
                            136 
                            137 ; BASIC ERROR CODE VALUES
                            138 
                     0000   139 NF      .equ     0x00             ; NEXT without FOR
                     0002   140 SN      .equ     0x02             ; Syntax error
                     0004   141 RG      .equ     0x04             ; RETURN without GOSUB
                     0006   142 OD      .equ     0x06             ; Out of DATA
                     0008   143 FC      .equ     0x08             ; Function call error
                     000A   144 OV      .equ     0x0A             ; Overflow
                     000C   145 OM      .equ     0x0C             ; Out of memory
                     000E   146 UL      .equ     0x0E             ; Undefined line number
                     0010   147 BS      .equ     0x10             ; Bad subscript
                     0012   148 DD      .equ     0x12             ; Re-DIMensioned array
                     0014   149 DZ      .equ     0x14             ; Division by zero (/0)
                     0016   150 ID      .equ     0x16             ; Illegal direct
                     0018   151 TM      .equ     0x18             ; Type miss-match
                     001A   152 OS      .equ     0x1A             ; Out of string space
                     001C   153 LS      .equ     0x1C             ; String too long
                     001E   154 ST      .equ     0x1E             ; String formula too complex
                     0020   155 CN      .equ     0x20             ; Can't CONTinue
                     0022   156 UF      .equ     0x22             ; UnDEFined FN function
                     0024   157 MO      .equ     0x24             ; Missing operand
                            158 
   E000                     159         .org     0xE000
                            160 
   E000 C3 03 E0      [ 9]  161 START:  JP      STARTB          ; Jump for restart jump
   E003 F3            [ 3]  162 STARTB: DI                      ; No interrupts
   E004 DD 21 00 00   [12]  163         LD      IX,#0            ; Flag cold start
   E008 C3 12 E0      [ 9]  164         JP      CSTART          ; Jump to initialise
                            165 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 4.
Hexadecimal [16-Bits]



   E00B 88 E9               166         .dw      DEINT           ; Get integer -32768 to 32767
   E00D 8E F0               167         .dw      ABPASS          ; Return integer in AB
                            168 
   E00F C3 3C E7      [ 9]  169         JP      LDNMI1          ; << NO REFERENCE TO HERE >>
                            170 
   E012 21 00 10      [ 9]  171 CSTART: LD      HL,#WRKSPC       ; Start of workspace RAM
   E015 F9            [ 4]  172         LD      SP,HL           ; Set up a temporary stack
   E016 C3 EC FB      [ 9]  173         JP      INITST          ; Go to initialise
                            174 
   E019 11 DF E2      [ 9]  175 INIT:   LD      DE,#INITAB       ; Initialise workspace
   E01C 06 63         [ 6]  176         LD      B,#INITBE-#INITAB+#3; Bytes to copy
   E01E 21 00 10      [ 9]  177         LD      HL,#WRKSPC       ; Into workspace RAM
   E021 1A            [ 6]  178 COPY:   LD      A,(DE)          ; Get source
   E022 77            [ 7]  179         LD      (HL),A          ; To destination
   E023 23            [ 4]  180         INC     HL              ; Next destination
   E024 13            [ 4]  181         INC     DE              ; Next source
   E025 05            [ 4]  182         DEC     B               ; Count bytes
   E026 C2 21 E0      [ 9]  183         JP      NZ,#COPY         ; More to move
   E029 F9            [ 4]  184         LD      SP,HL           ; Temporary stack
   E02A CD DF E4      [16]  185         CALL    CLREG           ; Clear registers and stack
   E02D CD 5B EB      [16]  186         CALL    PRNTCR          ; Output CRLF
   E030 32 AA 10      [13]  187         LD      (BUFFER+72+1),A ; Mark end of buffer
   E033 32 F9 10      [13]  188         LD      (PROGST),A      ; Initialise program area
   E036 21 03 E1      [ 9]  189 MSIZE:  LD      HL,#MEMMSG       ; Point to message
   E039 CD 85 F1      [16]  190         CALL    PRS             ; Output "Memory size"
   E03C CD FC E4      [16]  191         CALL    PROMPT          ; Get input with "?"
   E03F CD 36 E8      [16]  192         CALL    GETCHR          ; Get next character
   E042 B7            [ 4]  193         OR      A               ; Set flags
   E043 C2 5B E0      [ 9]  194         JP      NZ,TSTMEM       ; If number - Test if RAM there
   E046 21 5D 11      [ 9]  195         LD      HL,#STLOOK       ; Point to start of RAM
   E049 23            [ 4]  196 MLOOP:  INC     HL              ; Next byte
   E04A 7C            [ 4]  197         LD      A,H             ; Above address FFFF ?
   E04B B5            [ 4]  198         OR      L
   E04C CA 6D E0      [ 9]  199         JP      Z,SETTOP        ; Yes - 64K RAM
   E04F 7E            [ 6]  200         LD      A,(HL)          ; Get contents
   E050 47            [ 4]  201         LD      B,A             ; Save it
   E051 2F            [ 3]  202         CPL                     ; Flip all bits
   E052 77            [ 7]  203         LD      (HL),A          ; Put it back
   E053 BE            [ 6]  204         CP      (HL)            ; RAM there if same
   E054 70            [ 7]  205         LD      (HL),B          ; Restore old contents
   E055 CA 49 E0      [ 9]  206         JP      Z,MLOOP         ; If RAM - test next byte
   E058 C3 6D E0      [ 9]  207         JP      SETTOP          ; Top of RAM found
                            208 
   E05B CD 98 E9      [16]  209 TSTMEM: CALL    ATOH            ; Get high memory into DE
   E05E B7            [ 4]  210         OR      A               ; Set flags on last byte
   E05F C2 AD E3      [ 9]  211         JP      NZ,SNERR        ; ?SN Error if bad character
   E062 EB            [ 3]  212         EX      DE,HL           ; Address into HL
   E063 2B            [ 4]  213         DEC     HL              ; Back one byte
   E064 3E D9         [ 6]  214         LD      A,#0b11011001     ; Test byte
   E066 46            [ 6]  215         LD      B,(HL)          ; Get old contents
   E067 77            [ 7]  216         LD      (HL),A          ; Load test byte
   E068 BE            [ 6]  217         CP      (HL)            ; RAM there if same
   E069 70            [ 7]  218         LD      (HL),B          ; Restore old contents
   E06A C2 36 E0      [ 9]  219         JP      NZ,MSIZE        ; Ask again if no RAM
                            220 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 5.
Hexadecimal [16-Bits]



   E06D 2B            [ 4]  221 SETTOP: DEC     HL              ; Back one byte
   E06E 11 5C 11      [ 9]  222         LD      DE,#STLOOK-1     ; See if enough RAM
   E071 CD 8A E6      [16]  223         CALL    CPDEHL          ; Compare DE with HL
   E074 DA 36 E0      [ 9]  224         JP      C,MSIZE         ; Ask again if not enough RAM
   E077 00            [ 3]  225         NOP
   E078 00            [ 3]  226         NOP
   E079 00            [ 3]  227         NOP
   E07A 00            [ 3]  228         NOP
   E07B 00            [ 3]  229         NOP
   E07C 00            [ 3]  230         NOP
   E07D 00            [ 3]  231         NOP
   E07E 00            [ 3]  232         NOP
   E07F 00            [ 3]  233         NOP
   E080 11 CE FF      [ 9]  234         LD      DE,#0-50         ; 50 Bytes string space
   E083 22 AF 10      [16]  235         LD      (LSTRAM),HL     ; Save last available RAM
   E086 19            [ 7]  236         ADD     HL,DE           ; Allocate string space
   E087 22 5A 10      [16]  237         LD      (STRSPC),HL     ; Save string space
   E08A CD BA E4      [16]  238         CALL    CLRPTR          ; Clear program area
   E08D 2A 5A 10      [15]  239         LD      HL,(STRSPC)     ; Get end of memory
   E090 11 EF FF      [ 9]  240         LD      DE,#0-17         ; Offset for free bytes
   E093 19            [ 7]  241         ADD     HL,DE           ; Adjust HL
   E094 11 F9 10      [ 9]  242         LD      DE,#PROGST       ; Start of program text
   E097 7D            [ 4]  243         LD      A,L             ; Get LSB
   E098 93            [ 4]  244         SUB     E               ; Adjust it
   E099 6F            [ 4]  245         LD      L,A             ; Re-save
   E09A 7C            [ 4]  246         LD      A,H             ; Get MSB
   E09B 9A            [ 4]  247         SBC     A,D             ; Adjust it
   E09C 67            [ 4]  248         LD      H,A             ; Re-save
   E09D E5            [11]  249         PUSH    HL              ; Save bytes free
   E09E 21 C5 E0      [ 9]  250         LD      HL,#SIGNON       ; Sign-on message
   E0A1 CD 85 F1      [16]  251         CALL    PRS             ; Output string
   E0A4 E1            [ 9]  252         POP     HL              ; Get bytes free back
   E0A5 CD 0F F8      [16]  253         CALL    PRNTHL          ; Output amount of free memory
   E0A8 21 B7 E0      [ 9]  254         LD      HL,#BFREE        ; " Bytes free" message
   E0AB CD 85 F1      [16]  255         CALL    PRS             ; Output string
                            256 
   E0AE 31 66 10      [ 9]  257 WARMST: LD      SP,#STACK        ; Temporary stack
   E0B1 CD DF E4      [16]  258 BRKRET: CALL    CLREG           ; Clear registers and stack
   E0B4 C3 F8 E3      [ 9]  259         JP      PRNTOK          ; Go to get command line
                            260 
   E0B7 20 42 79 74 65 73   261 BFREE:  .ascii      " Bytes free"
        20 66 72 65 65
   E0C2 0D 00 00            262         .db         CR,0,0
                            263 
   E0C5 4E 41 53 43 4F 4D   264 SIGNON: .ascii      "NASCOM ROM BASIC Ver 4.7   "
        20 52 4F 4D 20 42
        41 53 49 43 20 56
        65 72 20 34 2E 37
        20 20 20
   E0E0 0D                  265         .db CR
   E0E1 43 6F 70 79 72 69   266         .ascii      "Copyright (C) 1978 by Microsoft"
        67 68 74 20 28 43
        29 20 31 39 37 38
        20 62 79 20 4D 69
        63 72 6F 73 6F 66
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 6.
Hexadecimal [16-Bits]



        74
   E100 0D 00 00            267         .db CR,0,0
                            268 
   E103 4D 65 6D 6F 72 79   269 MEMMSG: .ascii      "Memory size"
        20 73 69 7A 65
   E10E 00                  270         .db 0
                            271 
                            272 ; FUNCTION ADDRESS TABLE
                            273 
   E10F C5 F6               274 FNCTAB: .dw      SGN
   E111 63 F7               275         .dw      INT
   E113 CF F6               276         .dw      ABS
   E115 03 10               277         .dw      USR
   E117 6F F0               278         .dw      FRE
   E119 85 F3               279         .dw      INP
   E11B 93 F0               280         .dw      POS
   E11D C7 F8               281         .dw      SQR
   E11F 79 F9               282         .dw      RND
   E121 AC F5               283         .dw      LOG
   E123 10 F9               284         .dw      EXP
   E125 C4 F9               285         .dw      COS
   E127 C7 F9               286         .dw      SIN
   E129 0B FA               287         .dw      TAN
   E12B 20 FA               288         .dw      ATN
   E12D B3 F4               289         .dw      PEEK
   E12F 0E FB               290         .dw      DEEK
   E131 51 10               291         .dw      POINT
   E133 D7 F2               292         .dw      LEN
   E135 22 F1               293         .dw      STR
   E137 60 F3               294         .dw      VAL
   E139 E3 F2               295         .dw      ASC
   E13B 0D 00               296         .dw      CR
   E13D FF F2               297         .dw      LEFT
   E13F 2B F3               298         .dw      RIGHT
   E141 35 F3               299         .dw      MID
                            300 
                            301 ; RESERVED WORD LIST
                            302 
   E143 C5 4E 44            303 WORDS:  .db      "E"+0x80,"N","D"
   E146 C6 4F 52            304         .db      "F"+0x80,"O","R"
   E149 CE 45 58 54         305         .db      "N"+0x80,"E","X","T"
   E14D C4 41 54 41         306         .db      "D"+0x80,"A","T","A"
   E151 C9 4E 50 55 54      307         .db      "I"+0x80,"N","P","U","T"
   E156 C4 49 4D            308         .db      "D"+0x80,"I","M"
   E159 D2 45 41 44         309         .db      "R"+0x80,"E","A","D"
   E15D CC 45 54            310         .db      "L"+0x80,"E","T"
   E160 C7 4F 54 4F         311         .db      "G"+0x80,"O","T","O"
   E164 D2 55 4E            312         .db      "R"+0x80,"U","N"
   E167 C9 46               313         .db      "I"+0x80,"F"
   E169 D2 45 53 54 4F 52   314         .db      "R"+0x80,"E","S","T","O","R","E"
        45
   E170 C7 4F 53 55 42      315         .db      "G"+0x80,"O","S","U","B"
   E175 D2 45 54 55 52 4E   316         .db      "R"+0x80,"E","T","U","R","N"
   E17B D2 45 4D            317         .db      "R"+0x80,"E","M"
   E17E D3 54 4F 50         318         .db      "S"+0x80,"T","O","P"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 7.
Hexadecimal [16-Bits]



   E182 CF 55 54            319         .db      "O"+0x80,"U","T"
   E185 CF 4E               320         .db      "O"+0x80,"N"
   E187 CE 55 4C 4C         321         .db      "N"+0x80,"U","L","L"
   E18B D7 41 49 54         322         .db      "W"+0x80,"A","I","T"
   E18F C4 45 46            323         .db      "D"+0x80,"E","F"
   E192 D0 4F 4B 45         324         .db      "P"+0x80,"O","K","E"
   E196 C4 4F 4B 45         325         .db      "D"+0x80,"O","K","E"
   E19A D3 43 52 45 45 4E   326         .db      "S"+0x80,"C","R","E","E","N"
   E1A0 CC 49 4E 45 53      327         .db      "L"+0x80,"I","N","E","S"
   E1A5 C3 4C 53            328         .db      "C"+0x80,"L","S"
   E1A8 D7 49 44 54 48      329         .db      "W"+0x80,"I","D","T","H"
   E1AD CD 4F 4E 49 54 4F   330         .db      "M"+0x80,"O","N","I","T","O","R"
        52
   E1B4 D3 45 54            331         .db      "S"+0x80,"E","T"
   E1B7 D2 45 53 45 54      332         .db      "R"+0x80,"E","S","E","T"
   E1BC D0 52 49 4E 54      333         .db      "P"+0x80,"R","I","N","T"
   E1C1 C3 4F 4E 54         334         .db      "C"+0x80,"O","N","T"
   E1C5 CC 49 53 54         335         .db      "L"+0x80,"I","S","T"
   E1C9 C3 4C 45 41 52      336         .db      "C"+0x80,"L","E","A","R"
   E1CE C3 4C 4F 41 44      337         .db      "C"+0x80,"L","O","A","D"
   E1D3 C3 53 41 56 45      338         .db      "C"+0x80,"S","A","V","E"
   E1D8 CE 45 57            339         .db      "N"+0x80,"E","W"
   E1DB D4 41 42 28         340         .db      "T"+0x80,"A","B","("
   E1DF D4 4F               341         .db      "T"+0x80,"O"
   E1E1 C6 4E               342         .db      "F"+0x80,"N"
   E1E3 D3 50 43 28         343         .db      "S"+0x80,"P","C","("
   E1E7 D4 48 45 4E         344         .db      "T"+0x80,"H","E","N"
   E1EB CE 4F 54            345         .db      "N"+0x80,"O","T"
   E1EE D3 54 45 50         346         .db      "S"+0x80,"T","E","P"
                            347 
   E1F2 AB                  348         .db      "+"+0x80
   E1F3 AD                  349         .db      "-"+0x80
   E1F4 AA                  350         .db      "*"+0x80
   E1F5 AF                  351         .db      "/"+0x80
   E1F6 DE                  352         .db      "^"+0x80
   E1F7 C1 4E 44            353         .db      "A"+0x80,"N","D"
   E1FA CF 52               354         .db      "O"+0x80,"R"
   E1FC BE                  355         .db      ">"+0x80
   E1FD BD                  356         .db      "="+0x80
   E1FE BC                  357         .db      "<"+0x80
                            358 
   E1FF D3 47 4E            359         .db      "S"+0x80,"G","N"
   E202 C9 4E 54            360         .db      "I"+0x80,"N","T"
   E205 C1 42 53            361         .db      "A"+0x80,"B","S"
   E208 D5 53 52            362         .db      "U"+0x80,"S","R"
   E20B C6 52 45            363         .db      "F"+0x80,"R","E"
   E20E C9 4E 50            364         .db      "I"+0x80,"N","P"
   E211 D0 4F 53            365         .db      "P"+0x80,"O","S"
   E214 D3 51 52            366         .db      "S"+0x80,"Q","R"
   E217 D2 4E 44            367         .db      "R"+0x80,"N","D"
   E21A CC 4F 47            368         .db      "L"+0x80,"O","G"
   E21D C5 58 50            369         .db      "E"+0x80,"X","P"
   E220 C3 4F 53            370         .db      "C"+0x80,"O","S"
   E223 D3 49 4E            371         .db      "S"+0x80,"I","N"
   E226 D4 41 4E            372         .db      "T"+0x80,"A","N"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 8.
Hexadecimal [16-Bits]



   E229 C1 54 4E            373         .db      "A"+0x80,"T","N"
   E22C D0 45 45 4B         374         .db      "P"+0x80,"E","E","K"
   E230 C4 45 45 4B         375         .db      "D"+0x80,"E","E","K"
   E234 D0 4F 49 4E 54      376         .db      "P"+0x80,"O","I","N","T"
   E239 CC 45 4E            377         .db      "L"+0x80,"E","N"
   E23C D3 54 52 24         378         .db      "S"+0x80,"T","R","$"
   E240 D6 41 4C            379         .db      "V"+0x80,"A","L"
   E243 C1 53 43            380         .db      "A"+0x80,"S","C"
   E246 C3 48 52 24         381         .db      "C"+0x80,"H","R","$"
   E24A CC 45 46 54 24      382         .db      "L"+0x80,"E","F","T","$"
   E24F D2 49 47 48 54 24   383         .db      "R"+0x80,"I","G","H","T","$"
   E255 CD 49 44 24         384         .db      "M"+0x80,"I","D","$"
   E259 80                  385         .db      0x80             ; End of list marker
                            386 
                            387 ; KEYWORD ADDRESS TABLE
                            388 
   E25A 72 E8               389 WORDTB: .dw      PEND
   E25C 79 E7               390         .dw      FOR
   E25E A7 EC               391         .dw      NEXT
   E260 51 EA               392         .dw      DATA
   E262 BE EB               393         .dw      INPUT
   E264 D7 EE               394         .dw      DIM
   E266 ED EB               395         .dw      READ
   E268 64 EA               396         .dw      LET
   E26A 15 EA               397         .dw      GOTO
   E26C FB E9               398         .dw      RUN
   E26E D9 EA               399         .dw      IF
   E270 46 E8               400         .dw      RESTOR
   E272 04 EA               401         .dw      GOSUB
   E274 33 EA               402         .dw      RETURN
   E276 53 EA               403         .dw      REM
   E278 70 E8               404         .dw      STOP
   E27A 91 F3               405         .dw      POUT
   E27C BB EA               406         .dw      ON
   E27E B1 E8               407         .dw      NULL
   E280 97 F3               408         .dw      WAIT
   E282 9B F0               409         .dw      DEF
   E284 BA F4               410         .dw      POKE
   E286 19 FB               411         .dw      DOKE
   E288 34 FB               412         .dw      SCREEN
   E28A FF FA               413         .dw      LINES
   E28C E1 FA               414         .dw      CLS
   E28E F7 FA               415         .dw      WIDTH
   E290 D5 FB               416         .dw      MONITR
   E292 54 10               417         .dw      PSET
   E294 57 10               418         .dw      RESET
   E296 FD EA               419         .dw      PRINT
   E298 9E E8               420         .dw      CONT
   E29A DD E6               421         .dw      LIST
   E29C B8 E9               422         .dw      CLEAR
   E29E 31 F4               423         .dw      CLOAD
   E2A0 04 F4               424         .dw      CSAVE
   E2A2 B9 E4               425         .dw      NEW
                            426 
                            427 ; RESERVED WORD TOKEN VALUES
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 9.
Hexadecimal [16-Bits]



                            428 
                     0080   429 ZEND    .equ     0x080            ; END
                     0081   430 ZFOR    .equ     0x081            ; FOR
                     0083   431 ZDATA   .equ     0x083            ; DATA
                     0088   432 ZGOTO   .equ     0x088            ; GOTO
                     008C   433 ZGOSUB  .equ     0x08C            ; GOSUB
                     008E   434 ZREM    .equ     0x08E            ; REM
                     009E   435 ZPRINT  .equ     0x09E            ; PRINT
                     00A4   436 ZNEW    .equ     0x0A4            ; NEW
                            437 
                     00A5   438 ZTAB    .equ     0x0A5            ; TAB
                     00A6   439 ZTO     .equ     0x0A6            ; TO
                     00A7   440 ZFN     .equ     0x0A7            ; FN
                     00A8   441 ZSPC    .equ     0x0A8            ; SPC
                     00A9   442 ZTHEN   .equ     0x0A9            ; THEN
                     00AA   443 ZNOT    .equ     0x0AA            ; NOT
                     00AB   444 ZSTEP   .equ     0x0AB            ; STEP
                            445 
                     00AC   446 ZPLUS   .equ     0x0AC            ; +
                     00AD   447 ZMINUS  .equ     0x0AD            ; -
                     00AE   448 ZTIMES  .equ     0x0AE            ; *
                     00AF   449 ZDIV    .equ     0x0AF            ; /
                     00B2   450 ZOR     .equ     0x0B2            ; OR
                     00B3   451 ZGTR    .equ     0x0B3            ; >
                     00B4   452 ZEQUAL  .equ     0x0B4            ; M
                     00B5   453 ZLTH    .equ     0x0B5            ; <
                     00B6   454 ZSGN    .equ     0x0B6            ; SGN
                     00C7   455 ZPOINT  .equ     0x0C7            ; POINT
                     00CD   456 ZLEFT   .equ     0x0CD            ; LEFT$
                            457 
                            458 ; ARITHMETIC PRECEDENCE TABLE
                            459 
   E2A4 79                  460 PRITAB: .db      0x79             ; Precedence value
   E2A5 FB F7               461         .dw      PADD            ; FPREG = <last> + FPREG
                            462 
   E2A7 79                  463         .db      0x79             ; Precedence value
   E2A8 D5 F4               464         .dw      PSUB            ; FPREG = <last> - FPREG
                            465 
   E2AA 7C                  466         .db      0x7C             ; Precedence value
   E2AB D0 F5               467         .dw      MULT            ; PPREG = <last> * FPREG
                            468 
   E2AD 7C                  469         .db      0x7C             ; Precedence value
   E2AE 1B F6               470         .dw      DIV             ; FPREG = <last> / FPREG
                            471 
   E2B0 7F                  472         .db      0x7F             ; Precedence value
   E2B1 CD F8               473         .dw      POWER           ; FPREG = <last> ^ FPREG
                            474 
   E2B3 50                  475         .db      0x50             ; Precedence value
   E2B4 32 EE               476         .dw      PAND            ; FPREG = <last> AND FPREG
                            477 
   E2B6 46                  478         .db      0x46             ; Precedence value
   E2B7 31 EE               479         .dw      POR             ; FPREG = <last> OR FPREG
                            480 
                            481 ; BASIC ERROR CODE LIST
                            482 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 10.
Hexadecimal [16-Bits]



   E2B9 4E 46               483 ERRORS: .db      "N","F"            ; NEXT without FOR
   E2BB 53 4E               484         .db      "S","N"            ; Syntax error
   E2BD 52 47               485         .db      "R","G"            ; RETURN without GOSUB
   E2BF 4F 44               486         .db      "O","D"            ; Out of DATA
   E2C1 46 43               487         .db      "F","C"            ; Illegal function call
   E2C3 4F 56               488         .db      "O","V"            ; Overflow error
   E2C5 4F 4D               489         .db      "O","M"            ; Out of memory
   E2C7 55 4C               490         .db      "U","L"            ; Undefined line
   E2C9 42 53               491         .db      "B","S"            ; Bad subscript
   E2CB 44 44               492         .db      "D","D"            ; Re-DIMensioned array
   E2CD 2F 30               493         .db      "/","0"            ; Division by zero
   E2CF 49 44               494         .db      "I","D"            ; Illegal direct
   E2D1 54 4D               495         .db      "T","M"            ; Type mis-match
   E2D3 4F 53               496         .db      "O","S"            ; Out of string space
   E2D5 4C 53               497         .db      "L","S"            ; String too long
   E2D7 53 54               498         .db      "S","T"            ; String formula too complex
   E2D9 43 4E               499         .db      "C","N"            ; Can't CONTinue
   E2DB 55 46               500         .db      "U","F"            ; Undefined FN function
   E2DD 4D 4F               501         .db      "M","O"            ; Missing operand
                            502 
                            503 ; INITIALISATION TABLE
                            504 
   E2DF C3 AE E0      [ 9]  505 INITAB: JP      WARMST          ; Warm start jump
   E2E2 C3 95 E9      [ 9]  506         JP      FCERR           ; "USR (X)" jump (Set to Error)
                            507 
   E2E5 D3 00         [10]  508         OUT     (0),A           ; "OUT p,n" skeleton
   E2E7 C9            [ 9]  509         RET
                            510 
   E2E8 D6 00         [ 6]  511         SUB     #0               ; Division support routine
   E2EA 6F            [ 4]  512         LD      L,A
   E2EB 7C            [ 4]  513         LD      A,H
   E2EC DE 00         [ 6]  514         SBC     A,#0
   E2EE 67            [ 4]  515         LD      H,A
   E2EF 78            [ 4]  516         LD      A,B
   E2F0 DE 00         [ 6]  517         SBC     A,#0
   E2F2 47            [ 4]  518         LD      B,A
   E2F3 3E 00         [ 6]  519         LD      A,#0
   E2F5 C9            [ 9]  520         RET
                            521 
   E2F6 00 00 00            522         .db      0,0,0                   ; Random number seed
                            523                                         ; Table used by RND
   E2F9 35 4A CA 99         524         .db      0x35,0x4A,0xCA,0x99     ;-2.65145E+07
   E2FD 39 1C 76 98         525         .db      0x39,0x1C,0x76,0x98     ; 1.61291E+07
   E301 22 95 B3 98         526         .db      0x22,0x95,0xB3,0x98     ;-1.17691E+07
   E305 0A DD 47 98         527         .db      0x0A,0xDD,0x47,0x98     ; 1.30983E+07
   E309 53 D1 99 99         528         .db      0x53,0xD1,0x99,0x99     ;-2-01612E+07
   E30D 0A 1A 9F 98         529         .db      0x0A,0x1A,0x9F,0x98     ;-1.04269E+07
   E311 65 BC CD 98         530         .db      0x65,0xBC,0xCD,0x98     ;-1.34831E+07
   E315 D6 77 3E 98         531         .db      0xD6,0x77,0x3E,0x98     ; 1.24825E+07
   E319 52 C7 4F 80         532         .db      0x52,0xC7,0x4F,0x80     ; Last random number
                            533 
   E31D DB 00         [ 9]  534         IN      A,(0)           ; INP (x) skeleton
   E31F C9            [ 9]  535         RET
                            536 
   E320 01                  537         .db      1               ; POS (x) number (1)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 11.
Hexadecimal [16-Bits]



   E321 2F                  538         .db      47              ; Terminal width (47)
   E322 1C                  539         .db      28              ; Width for commas (3 columns)
   E323 00                  540         .db      0               ; No nulls after input bytes
   E324 00                  541         .db      0               ; Output enabled (^O off)
                            542 
   E325 05 00               543         .dw      5               ; Initial lines counter
   E327 05 00               544         .dw      5               ; Initial lines number
   E329 00 00               545         .dw      0               ; Array load/save check sum
                            546 
   E32B 00                  547         .db      0               ; Break not by NMI
   E32C 00                  548         .db      0               ; Break flag
                            549 
   E32D C3 07 E6      [ 9]  550         JP      TTYLIN          ; Input reflection (set to TTY)
   E330 C3 84 FC      [ 9]  551         JP      POINTB          ; POINT reflection unused
   E333 C3 57 FC      [ 9]  552         JP      SETB            ; SET reflection
   E336 C3 6A FC      [ 9]  553         JP      RESETB          ; RESET reflection
                            554 
   E339 5D 11               555         .dw      STLOOK          ; Temp string space
   E33B FE FF               556         .dw      -2              ; Current line number (cold)
   E33D FA 10               557         .dw      PROGST+1        ; Start of program text
   E33F                     558 INITBE:                         ; END OF INITIALISATION TABLE
                            559 
   E33F 20 45 72 72 6F 72   560 ERRMSG: .ascii      " Error"
   E345 00                  561         .db 0
   E346 20 69 6E 20         562 INMSG:  .ascii      " in "
   E34A 00                  563         .db 0
u                    FFFFFFFF   564 ZERBYT  .equ     $-1             ; A zero byte
   E34B 4F 6B               565 OKMSG:  .ascii     "Ok"
   E34D 0D 00 00            566         .db     CR,0,0
   E350 42 72 65 61 6B      567 BRKMSG: .ascii      "Break"
   E355 00                  568         .db 0
                            569 
   E356 21 04 00      [ 9]  570 BAKSTK: LD      HL,#4            ; Look for "FOR" block with
   E359 39            [ 7]  571         ADD     HL,SP           ; same index as specified
   E35A 7E            [ 6]  572 LOKFOR: LD      A,(HL)          ; Get block ID
   E35B 23            [ 4]  573         INC     HL              ; Point to index address
   E35C FE 81         [ 6]  574         CP      #ZFOR            ; Is it a "FOR" token
   E35E C0            [10]  575         RET     NZ              ; No - exit
   E35F 4E            [ 6]  576         LD      C,(HL)          ; BC = Address of "FOR" index
   E360 23            [ 4]  577         INC     HL
   E361 46            [ 6]  578         LD      B,(HL)
   E362 23            [ 4]  579         INC     HL              ; Point to sign of STEP
   E363 E5            [11]  580         PUSH    HL              ; Save pointer to sign
   E364 69            [ 4]  581         LD      L,C             ; HL = address of "FOR" index
   E365 60            [ 4]  582         LD      H,B
   E366 7A            [ 4]  583         LD      A,D             ; See if an index was specified
   E367 B3            [ 4]  584         OR      E               ; DE = 0 if no index specified
   E368 EB            [ 3]  585         EX      DE,HL           ; Specified index into HL
   E369 CA 70 E3      [ 9]  586         JP      Z,INDFND        ; Skip if no index given
   E36C EB            [ 3]  587         EX      DE,HL           ; Index back into DE
   E36D CD 8A E6      [16]  588         CALL    CPDEHL          ; Compare index with one given
   E370 01 0D 00      [ 9]  589 INDFND: LD      BC,#16-3         ; Offset to next block
   E373 E1            [ 9]  590         POP     HL              ; Restore pointer to sign
   E374 C8            [10]  591         RET     Z               ; Return if block found
   E375 09            [ 7]  592         ADD     HL,BC           ; Point to next block
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 12.
Hexadecimal [16-Bits]



   E376 C3 5A E3      [ 9]  593         JP      LOKFOR          ; Keep on looking
                            594 
   E379 CD 93 E3      [16]  595 MOVUP:  CALL    ENFMEM          ; See if enough memory
   E37C C5            [11]  596 MOVSTR: PUSH    BC              ; Save end of source
   E37D E3            [16]  597         EX      (SP),HL         ; Swap source and dest" end
   E37E C1            [ 9]  598         POP     BC              ; Get end of destination
   E37F CD 8A E6      [16]  599 MOVLP:  CALL    CPDEHL          ; See if list moved
   E382 7E            [ 6]  600         LD      A,(HL)          ; Get byte
   E383 02            [ 7]  601         LD      (BC),A          ; Move it
   E384 C8            [10]  602         RET     Z               ; Exit if all done
   E385 0B            [ 4]  603         DEC     BC              ; Next byte to move to
   E386 2B            [ 4]  604         DEC     HL              ; Next byte to move
   E387 C3 7F E3      [ 9]  605         JP      MOVLP           ; Loop until all bytes moved
                            606 
   E38A E5            [11]  607 CHKSTK: PUSH    HL              ; Save code string address
   E38B 2A DA 10      [15]  608         LD      HL,(ARREND)     ; Lowest free memory
   E38E 06 00         [ 6]  609         LD      B,#0             ; BC = Number of levels to test
   E390 09            [ 7]  610         ADD     HL,BC           ; 2 Bytes for each level
   E391 09            [ 7]  611         ADD     HL,BC
   E392 3E                  612         .db      0x3E             ; Skip "PUSH HL"
   E393 E5            [11]  613 ENFMEM: PUSH    HL              ; Save code string address
u  E394 3E D0         [ 6]  614         LD      A,#LOW-48       ; 48 Bytes minimum RAM
   E396 95            [ 4]  615         SUB     L
   E397 6F            [ 4]  616         LD      L,A
u  E398 3E D0         [ 6]  617         LD      A,#HIGH-48      ; 48 Bytes minimum RAM
   E39A 9C            [ 4]  618         SBC     A,H
   E39B DA A2 E3      [ 9]  619         JP      C,OMERR         ; Not enough - ?OM Error
   E39E 67            [ 4]  620         LD      H,A
   E39F 39            [ 7]  621         ADD     HL,SP           ; Test if stack is overflowed
   E3A0 E1            [ 9]  622         POP     HL              ; Restore code string address
   E3A1 D8            [10]  623         RET     C               ; Return if enough mmory
   E3A2 1E 0C         [ 6]  624 OMERR:  LD      E,#OM            ; ?OM Error
   E3A4 C3 C1 E3      [ 9]  625         JP      ERROR
                            626 
   E3A7 2A C9 10      [15]  627 DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
   E3AA 22 5C 10      [16]  628         LD      (LINEAT),HL     ; Save as current line
   E3AD 1E 02         [ 6]  629 SNERR:  LD      E,#SN            ; ?SN Error
   E3AF 01                  630         .db      0x01             ; Skip "LD E,DZ"
   E3B0 1E 14         [ 6]  631 DZERR:  LD      E,#DZ            ; ?/0 Error
   E3B2 01                  632         .db      0x01             ; Skip "LD E,NF"
   E3B3 1E 00         [ 6]  633 NFERR:  LD      E,#NF            ; ?NF Error
   E3B5 01                  634         .db      0x01             ; Skip "LD E,DD"
   E3B6 1E 12         [ 6]  635 DDERR:  LD      E,#DD            ; ?DD Error
   E3B8 01                  636         .db      0x01             ; Skip "LD E,UF"
   E3B9 1E 22         [ 6]  637 UFERR:  LD      E,#UF            ; ?UF Error
   E3BB 01                  638         .db      0x01             ; Skip "LD E,OV
   E3BC 1E 0A         [ 6]  639 OVERR:  LD      E,#OV            ; ?OV Error
   E3BE 01                  640         .db      0x01             ; Skip "LD E,TM"
   E3BF 1E 18         [ 6]  641 TMERR:  LD      E,#TM            ; ?TM Error
                            642 
   E3C1 CD DF E4      [16]  643 ERROR:  CALL    CLREG           ; Clear registers and stack
   E3C4 32 45 10      [13]  644         LD      (CTLOFG),A      ; Enable output (A is 0)
   E3C7 CD 4E EB      [16]  645         CALL    STTLIN          ; Start new line
   E3CA 21 B9 E2      [ 9]  646         LD      HL,#ERRORS       ; Point to error codes
   E3CD 57            [ 4]  647         LD      D,A             ; D = 0 (A is 0)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 13.
Hexadecimal [16-Bits]



   E3CE 3E 3F         [ 6]  648         LD      A,#"?"
   E3D0 CD 9B E6      [16]  649         CALL    OUTC            ; Output "?"
   E3D3 19            [ 7]  650         ADD     HL,DE           ; Offset to correct error code
   E3D4 7E            [ 6]  651         LD      A,(HL)          ; First character
   E3D5 CD 9B E6      [16]  652         CALL    OUTC            ; Output it
   E3D8 CD 36 E8      [16]  653         CALL    GETCHR          ; Get next character
   E3DB CD 9B E6      [16]  654         CALL    OUTC            ; Output it
   E3DE 21 3F E3      [ 9]  655         LD      HL,#ERRMSG       ; "Error" message
   E3E1 CD 85 F1      [16]  656 ERRIN:  CALL    PRS             ; Output message
   E3E4 2A 5C 10      [15]  657         LD      HL,(LINEAT)     ; Get line of error
   E3E7 11 FE FF      [ 9]  658         LD      DE,#-2           ; Cold start error if -2
   E3EA CD 8A E6      [16]  659         CALL    CPDEHL          ; See if cold start error
   E3ED CA 12 E0      [ 9]  660         JP      Z,CSTART        ; Cold start error - Restart
   E3F0 7C            [ 4]  661         LD      A,H             ; Was it a direct error?
   E3F1 A5            [ 4]  662         AND     L               ; Line = -1 if direct error
   E3F2 3C            [ 4]  663         INC     A
   E3F3 C4 0A F8      [16]  664         CALL    NZ,LINEIN       ; No - output line of error
   E3F6 3E                  665         .db      0x3E             ; Skip "POP BC"
   E3F7 C1            [ 9]  666 POPNOK: POP     BC              ; Drop address in input buffer
                            667 
   E3F8 AF            [ 4]  668 PRNTOK: XOR     A               ; Output "Ok" and get command
   E3F9 32 45 10      [13]  669         LD      (CTLOFG),A      ; Enable output
   E3FC CD 4E EB      [16]  670         CALL    STTLIN          ; Start new line
   E3FF 21 4B E3      [ 9]  671         LD      HL,#OKMSG        ; "Ok" message
   E402 CD 85 F1      [16]  672         CALL    PRS             ; Output "Ok"
   E405 21 FF FF      [ 9]  673 GETCMD: LD      HL,#-1           ; Flag direct mode
   E408 22 5C 10      [16]  674         LD      (LINEAT),HL     ; Save as current line
   E40B CD F2 E5      [16]  675         CALL    GETLIN          ; Get an input line
   E40E DA 05 E4      [ 9]  676         JP      C,GETCMD        ; Get line again if break
   E411 CD 36 E8      [16]  677         CALL    GETCHR          ; Get first character
   E414 3C            [ 4]  678         INC     A               ; Test if end of line
   E415 3D            [ 4]  679         DEC     A               ; Without affecting Carry
   E416 CA 05 E4      [ 9]  680         JP      Z,GETCMD        ; Nothing entered - Get another
   E419 F5            [11]  681         PUSH    AF              ; Save Carry status
   E41A CD 98 E9      [16]  682         CALL    ATOH            ; Get line number into DE
   E41D D5            [11]  683         PUSH    DE              ; Save line number
   E41E CD 09 E5      [16]  684         CALL    CRUN0xC          ; Tokenise rest of line
   E421 47            [ 4]  685         LD      B,A             ; Length of tokenised line
   E422 D1            [ 9]  686         POP     DE              ; Restore line number
   E423 F1            [ 9]  687         POP     AF              ; Restore Carry
   E424 D2 16 E8      [ 9]  688         JP      NC,EXCUTE       ; No line number - Direct mode
   E427 D5            [11]  689         PUSH    DE              ; Save line number
   E428 C5            [11]  690         PUSH    BC              ; Save length of tokenised line
   E429 AF            [ 4]  691         XOR     A
   E42A 32 CC 10      [13]  692         LD      (LSTBIN),A      ; Clear last byte input
   E42D CD 36 E8      [16]  693         CALL    GETCHR          ; Get next character
   E430 B7            [ 4]  694         OR      A               ; Set flags
   E431 F5            [11]  695         PUSH    AF              ; And save them
   E432 CD 99 E4      [16]  696         CALL    SRCHLN          ; Search for line number in DE
   E435 DA 3E E4      [ 9]  697         JP      C,LINFND        ; Jump if line found
   E438 F1            [ 9]  698         POP     AF              ; Get status
   E439 F5            [11]  699         PUSH    AF              ; And re-save
   E43A CA 2E EA      [ 9]  700         JP      Z,ULERR         ; Nothing after number - Error
   E43D B7            [ 4]  701         OR      A               ; Clear Carry
   E43E C5            [11]  702 LINFND: PUSH    BC              ; Save address of line in prog
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 14.
Hexadecimal [16-Bits]



   E43F D2 55 E4      [ 9]  703         JP      NC,INEWLN       ; Line not found - Insert new
   E442 EB            [ 3]  704         EX      DE,HL           ; Next line address in DE
   E443 2A D6 10      [15]  705         LD      HL,(PROGND)     ; End of program
   E446 1A            [ 6]  706 SFTPRG: LD      A,(DE)          ; Shift rest of program down
   E447 02            [ 7]  707         LD      (BC),A
   E448 03            [ 4]  708         INC     BC              ; Next destination
   E449 13            [ 4]  709         INC     DE              ; Next source
   E44A CD 8A E6      [16]  710         CALL    CPDEHL          ; All done?
   E44D C2 46 E4      [ 9]  711         JP      NZ,SFTPRG       ; More to do
   E450 60            [ 4]  712         LD      H,B             ; HL - New end of program
   E451 69            [ 4]  713         LD      L,C
   E452 22 D6 10      [16]  714         LD      (PROGND),HL     ; Update end of program
                            715 
   E455 D1            [ 9]  716 INEWLN: POP     DE              ; Get address of line,
   E456 F1            [ 9]  717         POP     AF              ; Get status
   E457 CA 7C E4      [ 9]  718         JP      Z,SETPTR        ; No text - Set up pointers
   E45A 2A D6 10      [15]  719         LD      HL,(PROGND)     ; Get end of program
   E45D E3            [16]  720         EX      (SP),HL         ; Get length of input line
   E45E C1            [ 9]  721         POP     BC              ; End of program to BC
   E45F 09            [ 7]  722         ADD     HL,BC           ; Find new end
   E460 E5            [11]  723         PUSH    HL              ; Save new end
   E461 CD 79 E3      [16]  724         CALL    MOVUP           ; Make space for line
   E464 E1            [ 9]  725         POP     HL              ; Restore new end
   E465 22 D6 10      [16]  726         LD      (PROGND),HL     ; Update end of program pointer
   E468 EB            [ 3]  727         EX      DE,HL           ; Get line to move up in HL
   E469 74            [ 7]  728         LD      (HL),H          ; Save MSB
   E46A D1            [ 9]  729         POP     DE              ; Get new line number
   E46B 23            [ 4]  730         INC     HL              ; Skip pointer
   E46C 23            [ 4]  731         INC     HL
   E46D 73            [ 7]  732         LD      (HL),E          ; Save LSB of line number
   E46E 23            [ 4]  733         INC     HL
   E46F 72            [ 7]  734         LD      (HL),D          ; Save MSB of line number
   E470 23            [ 4]  735         INC     HL              ; To first byte in line
   E471 11 61 10      [ 9]  736         LD      DE,#BUFFER       ; Copy buffer to program
   E474 1A            [ 6]  737 MOVBUF: LD      A,(DE)          ; Get source
   E475 77            [ 7]  738         LD      (HL),A          ; Save destinations
   E476 23            [ 4]  739         INC     HL              ; Next source
   E477 13            [ 4]  740         INC     DE              ; Next destination
   E478 B7            [ 4]  741         OR      A               ; Done?
   E479 C2 74 E4      [ 9]  742         JP      NZ,MOVBUF       ; No - Repeat
   E47C CD C5 E4      [16]  743 SETPTR: CALL    RUNFST          ; Set line pointers
   E47F 23            [ 4]  744         INC     HL              ; To LSB of pointer
   E480 EB            [ 3]  745         EX      DE,HL           ; Address to DE
   E481 62            [ 4]  746 PTRLP:  LD      H,D             ; Address to HL
   E482 6B            [ 4]  747         LD      L,E
   E483 7E            [ 6]  748         LD      A,(HL)          ; Get LSB of pointer
   E484 23            [ 4]  749         INC     HL              ; To MSB of pointer
   E485 B6            [ 6]  750         OR      (HL)            ; Compare with MSB pointer
   E486 CA 05 E4      [ 9]  751         JP      Z,GETCMD        ; Get command line if end
   E489 23            [ 4]  752         INC     HL              ; To LSB of line number
   E48A 23            [ 4]  753         INC     HL              ; Skip line number
   E48B 23            [ 4]  754         INC     HL              ; Point to first byte in line
   E48C AF            [ 4]  755         XOR     A               ; Looking for 00 byte
   E48D BE            [ 6]  756 FNDEND: CP      (HL)            ; Found end of line?
   E48E 23            [ 4]  757         INC     HL              ; Move to next byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 15.
Hexadecimal [16-Bits]



   E48F C2 8D E4      [ 9]  758         JP      NZ,FNDEND       ; No - Keep looking
   E492 EB            [ 3]  759         EX      DE,HL           ; Next line address to HL
   E493 73            [ 7]  760         LD      (HL),E          ; Save LSB of pointer
   E494 23            [ 4]  761         INC     HL
   E495 72            [ 7]  762         LD      (HL),D          ; Save MSB of pointer
   E496 C3 81 E4      [ 9]  763         JP      PTRLP           ; Do next line
                            764 
   E499 2A 5E 10      [15]  765 SRCHLN: LD      HL,(BASTXT)     ; Start of program text
   E49C 44            [ 4]  766 SRCHLP: LD      B,H             ; BC = Address to look at
   E49D 4D            [ 4]  767         LD      C,L
   E49E 7E            [ 6]  768         LD      A,(HL)          ; Get address of next line
   E49F 23            [ 4]  769         INC     HL
   E4A0 B6            [ 6]  770         OR      (HL)            ; End of program found?
   E4A1 2B            [ 4]  771         DEC     HL
   E4A2 C8            [10]  772         RET     Z               ; Yes - Line not found
   E4A3 23            [ 4]  773         INC     HL
   E4A4 23            [ 4]  774         INC     HL
   E4A5 7E            [ 6]  775         LD      A,(HL)          ; Get LSB of line number
   E4A6 23            [ 4]  776         INC     HL
   E4A7 66            [ 6]  777         LD      H,(HL)          ; Get MSB of line number
   E4A8 6F            [ 4]  778         LD      L,A
   E4A9 CD 8A E6      [16]  779         CALL    CPDEHL          ; Compare with line in DE
   E4AC 60            [ 4]  780         LD      H,B             ; HL = Start of this line
   E4AD 69            [ 4]  781         LD      L,C
   E4AE 7E            [ 6]  782         LD      A,(HL)          ; Get LSB of next line address
   E4AF 23            [ 4]  783         INC     HL
   E4B0 66            [ 6]  784         LD      H,(HL)          ; Get MSB of next line address
   E4B1 6F            [ 4]  785         LD      L,A             ; Next line to HL
   E4B2 3F            [ 3]  786         CCF
   E4B3 C8            [10]  787         RET     Z               ; Lines found - Exit
   E4B4 3F            [ 3]  788         CCF
   E4B5 D0            [10]  789         RET     NC              ; Line not found,at line after
   E4B6 C3 9C E4      [ 9]  790         JP      SRCHLP          ; Keep looking
                            791 
   E4B9 C0            [10]  792 NEW:    RET     NZ              ; Return if any more on line
   E4BA 2A 5E 10      [15]  793 CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
   E4BD AF            [ 4]  794         XOR     A               ; Set program area to empty
   E4BE 77            [ 7]  795         LD      (HL),A          ; Save LSB = 00
   E4BF 23            [ 4]  796         INC     HL
   E4C0 77            [ 7]  797         LD      (HL),A          ; Save MSB = 00
   E4C1 23            [ 4]  798         INC     HL
   E4C2 22 D6 10      [16]  799         LD      (PROGND),HL     ; Set program end
                            800 
   E4C5 2A 5E 10      [15]  801 RUNFST: LD      HL,(BASTXT)     ; Clear all variables
   E4C8 2B            [ 4]  802         DEC     HL
                            803 
   E4C9 22 CE 10      [16]  804 INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
   E4CC 2A AF 10      [15]  805         LD      HL,(LSTRAM)     ; Get end of RAM
   E4CF 22 C3 10      [16]  806         LD      (STRBOT),HL     ; Clear string space
   E4D2 AF            [ 4]  807         XOR     A
   E4D3 CD 46 E8      [16]  808         CALL    RESTOR          ; Reset DATA pointers
   E4D6 2A D6 10      [15]  809         LD      HL,(PROGND)     ; Get end of program
   E4D9 22 D8 10      [16]  810         LD      (VAREND),HL     ; Clear variables
   E4DC 22 DA 10      [16]  811         LD      (ARREND),HL     ; Clear arrays
                            812 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 16.
Hexadecimal [16-Bits]



   E4DF C1            [ 9]  813 CLREG:  POP     BC              ; Save return address
   E4E0 2A 5A 10      [15]  814         LD      HL,(STRSPC)     ; Get end of working RAN
   E4E3 F9            [ 4]  815         LD      SP,HL           ; Set stack
   E4E4 21 B3 10      [ 9]  816         LD      HL,#TMSTPL       ; Temporary string pool
   E4E7 22 B1 10      [16]  817         LD      (TMSTPT),HL     ; Reset temporary string ptr
   E4EA AF            [ 4]  818         XOR     A               ; A = 00
   E4EB 6F            [ 4]  819         LD      L,A             ; HL = 0000
   E4EC 67            [ 4]  820         LD      H,A
   E4ED 22 D4 10      [16]  821         LD      (CONTAD),HL     ; No CONTinue
   E4F0 32 CB 10      [13]  822         LD      (FORFLG),A      ; Clear FOR flag
   E4F3 22 DE 10      [16]  823         LD      (FNRGNM),HL     ; Clear FN argument
   E4F6 E5            [11]  824         PUSH    HL              ; HL = 0000
   E4F7 C5            [11]  825         PUSH    BC              ; Put back return
   E4F8 2A CE 10      [15]  826 DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
   E4FB C9            [ 9]  827         RET                     ; Return to execution driver
                            828 
   E4FC 3E 3F         [ 6]  829 PROMPT: LD      A,#"?"           ; "?"
   E4FE CD 9B E6      [16]  830         CALL    OUTC            ; Output character
   E501 3E 20         [ 6]  831         LD      A,#" "           ; Space
   E503 CD 9B E6      [16]  832         CALL    OUTC            ; Output character
   E506 C3 4E 10      [ 9]  833         JP      RINPUT          ; Get input line
                            834 
   E509 AF            [ 4]  835 CRUN0xC: XOR     A               ; Tokenise line @ HL to BUFFER
   E50A 32 AE 10      [13]  836         LD      (DATFLG),A      ; Reset literal flag
   E50D 0E 05         [ 6]  837         LD      C,#2+3           ; 2 byte number and 3 nulls
   E50F 11 61 10      [ 9]  838         LD      DE,#BUFFER       ; Start of input buffer
   E512 7E            [ 6]  839 CRNCLP: LD      A,(HL)          ; Get byte
   E513 FE 20         [ 6]  840         CP      #" "             ; Is it a space?
   E515 CA 91 E5      [ 9]  841         JP      Z,MOVDIR        ; Yes - Copy direct
   E518 47            [ 4]  842         LD      B,A             ; Save character
   E519 FE 22         [ 6]  843         CP      #'"'             ; Is it a quote?"
   E51B CA B1 E5      [ 9]  844         JP      Z,CPYLIT        ; Yes - Copy literal string
   E51E B7            [ 4]  845         OR      A               ; Is it end of buffer?
   E51F CA B8 E5      [ 9]  846         JP      Z,ENDBUF        ; Yes - End buffer
   E522 3A AE 10      [12]  847         LD      A,(DATFLG)      ; Get data type
   E525 B7            [ 4]  848         OR      A               ; Literal?
   E526 7E            [ 6]  849         LD      A,(HL)          ; Get byte to copy
   E527 C2 91 E5      [ 9]  850         JP      NZ,MOVDIR       ; Literal - Copy direct
   E52A FE 3F         [ 6]  851         CP      #"?"             ; Is it "?" short for PRINT
   E52C 3E 9E         [ 6]  852         LD      A,#ZPRINT        ; "PRINT" token
   E52E CA 91 E5      [ 9]  853         JP      Z,MOVDIR        ; Yes - replace it
   E531 7E            [ 6]  854         LD      A,(HL)          ; Get byte again
   E532 FE 30         [ 6]  855         CP      #"0"             ; Is it less than "0"
   E534 DA 3C E5      [ 9]  856         JP      C,FNDWRD        ; Yes - Look for reserved words
   E537 FE 3C         [ 6]  857         CP      #";"+1           ; Is it "0123456789:;" ?
   E539 DA 91 E5      [ 9]  858         JP      C,MOVDIR        ; Yes - copy it direct
   E53C D5            [11]  859 FNDWRD: PUSH    DE              ; Look for reserved words
   E53D 11 42 E1      [ 9]  860         LD      DE,#WORDS-1      ; Point to table
   E540 C5            [11]  861         PUSH    BC              ; Save count
   E541 01 8D E5      [ 9]  862         LD      BC,#RETNAD       ; Where to return to
   E544 C5            [11]  863         PUSH    BC              ; Save return address
   E545 06 7F         [ 6]  864         LD      B,#ZEND-1        ; First token value -1
   E547 7E            [ 6]  865         LD      A,(HL)          ; Get byte
   E548 FE 61         [ 6]  866         CP      #"a"             ; Less than "a" ?
   E54A DA 55 E5      [ 9]  867         JP      C,SEARCH        ; Yes - search for words
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 17.
Hexadecimal [16-Bits]



   E54D FE 7B         [ 6]  868         CP      #"z"+1           ; Greater than "z" ?
   E54F D2 55 E5      [ 9]  869         JP      NC,SEARCH       ; Yes - search for words
   E552 E6 5F         [ 6]  870         AND     #0b01011111       ; Force upper case
   E554 77            [ 7]  871         LD      (HL),A          ; Replace byte
   E555 4E            [ 6]  872 SEARCH: LD      C,(HL)          ; Search for a word
   E556 EB            [ 3]  873         EX      DE,HL
   E557 23            [ 4]  874 GETNXT: INC     HL              ; Get next reserved word
   E558 B6            [ 6]  875         OR      (HL)            ; Start of word?
   E559 F2 57 E5      [ 9]  876         JP      P,GETNXT        ; No - move on
   E55C 04            [ 4]  877         INC     B               ; Increment token value
   E55D 7E            [ 6]  878         LD      A, (HL)         ; Get byte from table
   E55E E6 7F         [ 6]  879         AND     #0b01111111       ; Strip bit 7
   E560 C8            [10]  880         RET     Z               ; Return if end of list
   E561 B9            [ 4]  881         CP      C               ; Same character as in buffer?
   E562 C2 57 E5      [ 9]  882         JP      NZ,GETNXT       ; No - get next word
   E565 EB            [ 3]  883         EX      DE,HL
   E566 E5            [11]  884         PUSH    HL              ; Save start of word
                            885 
   E567 13            [ 4]  886 NXTBYT: INC     DE              ; Look through rest of word
   E568 1A            [ 6]  887         LD      A,(DE)          ; Get byte from table
   E569 B7            [ 4]  888         OR      A               ; End of word ?
u  E56A FA 00 00      [ 9]  889         JP      M,#MATCH         ; Yes - Match found
   E56D 4F            [ 4]  890         LD      C,A             ; Save it
   E56E 78            [ 4]  891         LD      A,B             ; Get token value
   E56F FE 88         [ 6]  892         CP      #ZGOTO           ; Is it "GOTO" token ?
   E571 C2 78 E5      [ 9]  893         JP      NZ,NOSPC        ; No - Don't allow spaces
   E574 CD 36 E8      [16]  894         CALL    GETCHR          ; Get next character
   E577 2B            [ 4]  895         DEC     HL              ; Cancel increment from GETCHR
   E578 23            [ 4]  896 NOSPC:  INC     HL              ; Next byte
   E579 7E            [ 6]  897         LD      A,(HL)          ; Get byte
   E57A FE 61         [ 6]  898         CP      #"a"             ; Less than "a" ?
   E57C DA 81 E5      [ 9]  899         JP      C,NOCHNG        ; Yes - don't change
   E57F E6 5F         [ 6]  900         AND     #0b01011111       ; Make upper case
   E581 B9            [ 4]  901 NOCHNG: CP      C               ; Same as in buffer ?
   E582 CA 67 E5      [ 9]  902         JP      Z,NXTBYT        ; Yes - keep testing
   E585 E1            [ 9]  903         POP     HL              ; Get back start of word
   E586 C3 55 E5      [ 9]  904         JP      SEARCH          ; Look at next word
                            905 
   E589 48            [ 4]  906 MAT0xC:  LD      C,B             ; Word found - Save token value
   E58A F1            [ 9]  907         POP     AF              ; Throw away return
   E58B EB            [ 3]  908         EX      DE,HL
   E58C C9            [ 9]  909         RET                     ; Return to "RETNAD"
   E58D EB            [ 3]  910 RETNAD: EX      DE,HL           ; Get address in string
   E58E 79            [ 4]  911         LD      A,C             ; Get token value
   E58F C1            [ 9]  912         POP     BC              ; Restore buffer length
   E590 D1            [ 9]  913         POP     DE              ; Get destination address
   E591 23            [ 4]  914 MOVDIR: INC     HL              ; Next source in buffer
   E592 12            [ 7]  915         LD      (DE),A          ; Put byte in buffer
   E593 13            [ 4]  916         INC     DE              ; Move up buffer
   E594 0C            [ 4]  917         INC     C               ; Increment length of buffer
   E595 D6 3A         [ 6]  918         SUB     #":"             ; End of statement?
   E597 CA 9F E5      [ 9]  919         JP      Z,SETLIT        ; Jump if multi-statement line
   E59A FE 49         [ 6]  920         CP      #ZDATA-0x3A       ; Is it DATA statement ?
   E59C C2 A2 E5      [ 9]  921         JP      NZ,TSTREM       ; No - see if REM
   E59F 32 AE 10      [13]  922 SETLIT: LD      (DATFLG),A      ; Set literal flag
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 18.
Hexadecimal [16-Bits]



   E5A2 D6 54         [ 6]  923 TSTREM: SUB     #ZREM-0x3A        ; Is it REM?
   E5A4 C2 12 E5      [ 9]  924         JP      NZ,CRNCLP       ; No - Leave flag
   E5A7 47            [ 4]  925         LD      B,A             ; Copy rest of buffer
   E5A8 7E            [ 6]  926 NXTCHR: LD      A,(HL)          ; Get byte
   E5A9 B7            [ 4]  927         OR      A               ; End of line ?
   E5AA CA B8 E5      [ 9]  928         JP      Z,ENDBUF        ; Yes - Terminate buffer
   E5AD B8            [ 4]  929         CP      B               ; End of statement ?
   E5AE CA 91 E5      [ 9]  930         JP      Z,MOVDIR        ; Yes - Get next one
   E5B1 23            [ 4]  931 CPYLIT: INC     HL              ; Move up source string
   E5B2 12            [ 7]  932         LD      (DE),A          ; Save in destination
   E5B3 0C            [ 4]  933         INC     C               ; Increment length
   E5B4 13            [ 4]  934         INC     DE              ; Move up destination
   E5B5 C3 A8 E5      [ 9]  935         JP      NXTCHR          ; Repeat
                            936 
   E5B8 21 60 10      [ 9]  937 ENDBUF: LD      HL,#BUFFER-1     ; Point to start of buffer
   E5BB 12            [ 7]  938         LD      (DE),A          ; Mark end of buffer (A = 00)
   E5BC 13            [ 4]  939         INC     DE
   E5BD 12            [ 7]  940         LD      (DE),A          ; A = 00
   E5BE 13            [ 4]  941         INC     DE
   E5BF 12            [ 7]  942         LD      (DE),A          ; A = 00
   E5C0 C9            [ 9]  943         RET
                            944 
   E5C1 3A 44 10      [12]  945 DODEL:  LD      A,(NULFLG)      ; Get null flag status
   E5C4 B7            [ 4]  946         OR      A               ; Is it zero?
   E5C5 3E 00         [ 6]  947         LD      A,#0             ; Zero A - Leave flags
   E5C7 32 44 10      [13]  948         LD      (NULFLG),A      ; Zero null flag
   E5CA C2 D5 E5      [ 9]  949         JP      NZ,ECHDEL       ; Set - Echo it
   E5CD 05            [ 4]  950         DEC     B               ; Decrement length
   E5CE CA F2 E5      [ 9]  951         JP      Z,GETLIN        ; Get line again if empty
   E5D1 CD 9B E6      [16]  952         CALL    OUTC            ; Output null character
   E5D4 3E                  953         .db      0x3E             ; Skip "DEC B"
   E5D5 05            [ 4]  954 ECHDEL: DEC     B               ; Count bytes in buffer
   E5D6 2B            [ 4]  955         DEC     HL              ; Back space buffer
   E5D7 CA E9 E5      [ 9]  956         JP      Z,OTKLN         ; No buffer - Try again
   E5DA 7E            [ 6]  957         LD      A,(HL)          ; Get deleted byte
   E5DB CD 9B E6      [16]  958         CALL    OUTC            ; Echo it
   E5DE C3 10 E6      [ 9]  959         JP      MORINP          ; Get more input
                            960 
   E5E1 05            [ 4]  961 DELCHR: DEC     B               ; Count bytes in buffer
   E5E2 2B            [ 4]  962         DEC     HL              ; Back space buffer
   E5E3 CD 9B E6      [16]  963         CALL    OUTC            ; Output character in A
   E5E6 C2 10 E6      [ 9]  964         JP      NZ,MORINP       ; Not end - Get more
   E5E9 CD 9B E6      [16]  965 OTKLN:  CALL    OUTC            ; Output character in A
   E5EC CD 5B EB      [16]  966 KILIN:  CALL    PRNTCR          ; Output CRLF
   E5EF C3 07 E6      [ 9]  967         JP      TTYLIN          ; Get line again
                            968 
   E5F2 CD A4 FB      [16]  969 GETLIN: CALL    MONTST          ; Is it NAS-SYS?
   E5F5 CA 07 E6      [ 9]  970         JP      Z,TTYLIN        ; No - Character input
   E5F8 2A 75 0C      [15]  971         LD      HL,(CIN)        ; Point to NAS-SYS input table
   E5FB 7E            [ 6]  972         LD      A,(HL)          ; Get input mode
   E5FC FE 74         [ 6]  973         CP      #0x74             ; Is it "X" mode?
   E5FE CA 07 E6      [ 9]  974         JP      Z,TTYLIN        ; Yes - Teletype line input
   E601 CD 10 FC      [16]  975         CALL    INLINE          ; Get a line from NAS-SYS
   E604 C3 60 EB      [ 9]  976         JP      DONULL          ; POS(X)=0 and do nulls
                            977 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 19.
Hexadecimal [16-Bits]



   E607 21 61 10      [ 9]  978 TTYLIN: LD      HL,#BUFFER       ; Get a line by character
   E60A 06 01         [ 6]  979         LD      B,#1             ; Set buffer as empty
   E60C AF            [ 4]  980         XOR     A
   E60D 32 44 10      [13]  981         LD      (NULFLG),A      ; Clear null flag
   E610 CD CC E6      [16]  982 MORINP: CALL    CLOTST          ; Get character and test ^O
   E613 4F            [ 4]  983         LD      C,A             ; Save character in C
   E614 FE 7F         [ 6]  984         CP      #DEL             ; Delete character?
   E616 CA C1 E5      [ 9]  985         JP      Z,DODEL         ; Yes - Process it
   E619 3A 44 10      [12]  986         LD      A,(NULFLG)      ; Get null flag
   E61C B7            [ 4]  987         OR      A               ; Test null flag status
   E61D CA 29 E6      [ 9]  988         JP      Z,PROCES        ; Reset - Process character
   E620 3E 00         [ 6]  989         LD      A,#0             ; Set a null
   E622 CD 9B E6      [16]  990         CALL    OUTC            ; Output null
   E625 AF            [ 4]  991         XOR     A               ; Clear A
   E626 32 44 10      [13]  992         LD      (NULFLG),A      ; Reset null flag
   E629 79            [ 4]  993 PROCES: LD      A,C             ; Get character
   E62A FE 07         [ 6]  994         CP      #CTRLG           ; Bell?
   E62C CA 6D E6      [ 9]  995         JP      Z,PUTCTL        ; Yes - Save it
   E62F FE 03         [ 6]  996         CP      #CTRLC           ; Is it control "C"?
   E631 CC 5B EB      [16]  997         CALL    Z,PRNTCR        ; Yes - Output CRLF
   E634 37            [ 3]  998         SCF                     ; Flag break
   E635 C8            [10]  999         RET     Z               ; Return if control "C"
   E636 FE 0D         [ 6] 1000         CP      #CR              ; Is it enter?
   E638 CA 56 EB      [ 9] 1001         JP      Z,ENDINP        ; Yes - Terminate input
   E63B FE 15         [ 6] 1002         CP      #CTRLU           ; Is it control "U"?
   E63D CA EC E5      [ 9] 1003         JP      Z,KILIN         ; Yes - Get another line
   E640 FE 40         [ 6] 1004         CP      #"@"             ; Is it "kill line"?
   E642 CA E9 E5      [ 9] 1005         JP      Z,OTKLN         ; Yes - Kill line
   E645 FE 5F         [ 6] 1006         CP      #"_"             ; Is it delete?
   E647 CA E1 E5      [ 9] 1007         JP      Z,DELCHR        ; Yes - Delete character
   E64A FE 08         [ 6] 1008         CP      #BKSP            ; Is it backspace?
   E64C CA E1 E5      [ 9] 1009         JP      Z,DELCHR        ; Yes - Delete character
   E64F FE 12         [ 6] 1010         CP      #CTRLR           ; Is it control "R"?
   E651 C2 68 E6      [ 9] 1011         JP      NZ,PUTBUF       ; No - Put in buffer
   E654 C5            [11] 1012         PUSH    BC              ; Save buffer length
   E655 D5            [11] 1013         PUSH    DE              ; Save DE
   E656 E5            [11] 1014         PUSH    HL              ; Save buffer address
   E657 36 00         [ 9] 1015         LD      (HL),#0          ; Mark end of buffer
   E659 CD E8 FC      [16] 1016         CALL    OUTNCR          ; Output and do CRLF
   E65C 21 61 10      [ 9] 1017         LD      HL,#BUFFER       ; Point to buffer start
   E65F CD 85 F1      [16] 1018         CALL    PRS             ; Output buffer
   E662 E1            [ 9] 1019         POP     HL              ; Restore buffer address
   E663 D1            [ 9] 1020         POP     DE              ; Restore DE
   E664 C1            [ 9] 1021         POP     BC              ; Restore buffer length
   E665 C3 10 E6      [ 9] 1022         JP      MORINP          ; Get another character
                           1023 
   E668 FE 20         [ 6] 1024 PUTBUF: CP      #" "             ; Is it a control code?
   E66A DA 10 E6      [ 9] 1025         JP      C,MORINP        ; Yes - Ignore
   E66D 78            [ 4] 1026 PUTCTL: LD      A,B             ; Get number of bytes in buffer
   E66E FE 49         [ 6] 1027         CP      #72+1            ; Test for line overflow
   E670 3E 07         [ 6] 1028         LD      A,#CTRLG         ; Set a bell
   E672 D2 82 E6      [ 9] 1029         JP      NC,OUTNBS       ; Ring bell if buffer full
   E675 79            [ 4] 1030         LD      A,C             ; Get character
   E676 71            [ 7] 1031         LD      (HL),C          ; Save in buffer
   E677 32 CC 10      [13] 1032         LD      (LSTBIN),A      ; Save last input byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 20.
Hexadecimal [16-Bits]



   E67A 23            [ 4] 1033         INC     HL              ; Move up buffer
   E67B 04            [ 4] 1034         INC     B               ; Increment length
   E67C CD 9B E6      [16] 1035 OUTIT:  CALL    OUTC            ; Output the character entered
   E67F C3 10 E6      [ 9] 1036         JP      MORINP          ; Get another character
                           1037 
   E682 CD 9B E6      [16] 1038 OUTNBS: CALL    OUTC            ; Output bell and back over it
   E685 3E 08         [ 6] 1039         LD      A,#BKSP          ; Set back space
   E687 C3 7C E6      [ 9] 1040         JP      OUTIT           ; Output it and get more
                           1041 
   E68A 7C            [ 4] 1042 CPDEHL: LD      A,H             ; Get H
   E68B 92            [ 4] 1043         SUB     D               ; Compare with D
   E68C C0            [10] 1044         RET     NZ              ; Different - Exit
   E68D 7D            [ 4] 1045         LD      A,L             ; Get L
   E68E 93            [ 4] 1046         SUB     E               ; Compare with E
   E68F C9            [ 9] 1047         RET                     ; Return status
                           1048 
   E690 7E            [ 6] 1049 CHKSYN: LD      A,(HL)          ; Check syntax of character
   E691 E3            [16] 1050         EX      (SP),HL         ; Address of test byte
   E692 BE            [ 6] 1051         CP      (HL)            ; Same as in code string?
   E693 23            [ 4] 1052         INC     HL              ; Return address
   E694 E3            [16] 1053         EX      (SP),HL         ; Put it back
   E695 CA 36 E8      [ 9] 1054         JP      Z,GETCHR        ; Yes - Get next character
   E698 C3 AD E3      [ 9] 1055         JP      SNERR           ; Different - ?SN Error
                           1056 
   E69B F5            [11] 1057 OUTC:   PUSH    AF              ; Save character
   E69C 3A 45 10      [12] 1058         LD      A,(CTLOFG)      ; Get control "O" flag
   E69F B7            [ 4] 1059         OR      A               ; Is it set?
   E6A0 C2 B6 F1      [ 9] 1060         JP      NZ,POPAF        ; Yes - don't output
   E6A3 F1            [ 9] 1061         POP     AF              ; Restore character
   E6A4 C5            [11] 1062         PUSH    BC              ; Save buffer length
   E6A5 F5            [11] 1063         PUSH    AF              ; Save character
   E6A6 FE 20         [ 6] 1064         CP      #" "             ; Is it a control code?
   E6A8 DA BF E6      [ 9] 1065         JP      C,DINPOS        ; Yes - Don't INC POS(X)
   E6AB 3A 42 10      [12] 1066         LD      A,(LWIDTH)      ; Get line width
   E6AE 47            [ 4] 1067         LD      B,A             ; To B
   E6AF 3A AB 10      [12] 1068         LD      A,(CURPOS)      ; Get cursor position
   E6B2 04            [ 4] 1069         INC     B               ; Width 255?
   E6B3 CA BB E6      [ 9] 1070         JP      Z,INCLEN        ; Yes - No width limit
   E6B6 05            [ 4] 1071         DEC     B               ; Restore width
   E6B7 B8            [ 4] 1072         CP      B               ; At end of line?
   E6B8 CC 5B EB      [16] 1073         CALL    Z,PRNTCR        ; Yes - output CRLF
   E6BB 3C            [ 4] 1074 INCLEN: INC     A               ; Move on one character
   E6BC 32 AB 10      [13] 1075         LD      (CURPOS),A      ; Save new position
   E6BF F1            [ 9] 1076 DINPOS: POP     AF              ; Restore character
   E6C0 C1            [ 9] 1077         POP     BC              ; Restore buffer length
   E6C1 F5            [11] 1078         PUSH    AF              ; << This sequence >>
   E6C2 F1            [ 9] 1079         POP     AF              ; << is not needed >>
   E6C3 F5            [11] 1080         PUSH    AF              ; Save character
   E6C4 C5            [11] 1081         PUSH    BC              ; Save buffer length
   E6C5 4F            [ 4] 1082         LD      C,A             ; Character to C
   E6C6 CD 5B FA      [16] 1083         CALL    CONMON          ; Send it
   E6C9 C1            [ 9] 1084         POP     BC              ; Restore buffer length
   E6CA F1            [ 9] 1085         POP     AF              ; Restore character
   E6CB C9            [ 9] 1086         RET
                           1087 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 21.
Hexadecimal [16-Bits]



   E6CC CD 7D FA      [16] 1088 CLOTST: CALL    GETINP          ; Get input character
   E6CF E6 7F         [ 6] 1089         AND     #0b01111111       ; Strip bit 7
   E6D1 FE 0F         [ 6] 1090         CP      #CTRLO           ; Is it control "O"?
   E6D3 C0            [10] 1091         RET     NZ              ; No don't flip flag
   E6D4 3A 45 10      [12] 1092         LD      A,(CTLOFG)      ; Get flag
   E6D7 2F            [ 3] 1093         CPL                     ; Flip it
   E6D8 32 45 10      [13] 1094         LD      (CTLOFG),A      ; Put it back
   E6DB AF            [ 4] 1095         XOR     A               ; Null character
   E6DC C9            [ 9] 1096         RET
                           1097 
   E6DD CD 98 E9      [16] 1098 LIST:   CALL    ATOH            ; ASCII number to DE
   E6E0 C0            [10] 1099         RET     NZ              ; Return if anything extra
   E6E1 C1            [ 9] 1100         POP     BC              ; Rubbish - Not needed
   E6E2 CD 99 E4      [16] 1101         CALL    SRCHLN          ; Search for line number in DE
   E6E5 C5            [11] 1102         PUSH    BC              ; Save address of line
   E6E6 CD 33 E7      [16] 1103         CALL    SETLIN          ; Set up lines counter
   E6E9 E1            [ 9] 1104 LISTLP: POP     HL              ; Restore address of line
   E6EA 4E            [ 6] 1105         LD      C,(HL)          ; Get LSB of next line
   E6EB 23            [ 4] 1106         INC     HL
   E6EC 46            [ 6] 1107         LD      B,(HL)          ; Get MSB of next line
   E6ED 23            [ 4] 1108         INC     HL
   E6EE 78            [ 4] 1109         LD      A,B             ; BC = 0 (End of program)?
   E6EF B1            [ 4] 1110         OR      C
   E6F0 CA F8 E3      [ 9] 1111         JP      Z,PRNTOK        ; Yes - Go to command mode
   E6F3 CD 46 E7      [16] 1112         CALL    COUNT           ; Count lines
   E6F6 CD 61 E8      [16] 1113         CALL    TSTBRK          ; Test for break key
   E6F9 C5            [11] 1114         PUSH    BC              ; Save address of next line
   E6FA CD 5B EB      [16] 1115         CALL    PRNTCR          ; Output CRLF
   E6FD 5E            [ 6] 1116         LD      E,(HL)          ; Get LSB of line number
   E6FE 23            [ 4] 1117         INC     HL
   E6FF 56            [ 6] 1118         LD      D,(HL)          ; Get MSB of line number
   E700 23            [ 4] 1119         INC     HL
   E701 E5            [11] 1120         PUSH    HL              ; Save address of line start
   E702 EB            [ 3] 1121         EX      DE,HL           ; Line number to HL
   E703 CD 0F F8      [16] 1122         CALL    PRNTHL          ; Output line number in decimal
   E706 3E 20         [ 6] 1123         LD      A,#" "           ; Space after line number
   E708 E1            [ 9] 1124         POP     HL              ; Restore start of line address
   E709 CD 9B E6      [16] 1125 LSTLP2: CALL    OUTC            ; Output character in A
   E70C 7E            [ 6] 1126 LSTLP3: LD      A,(HL)          ; Get next byte in line
   E70D B7            [ 4] 1127         OR      A               ; End of line?
   E70E 23            [ 4] 1128         INC     HL              ; To next byte in line
   E70F CA E9 E6      [ 9] 1129         JP      Z,LISTLP        ; Yes - get next line
   E712 F2 09 E7      [ 9] 1130         JP      P,LSTLP2        ; No token - output it
   E715 D6 7F         [ 6] 1131         SUB     #ZEND-1          ; Find and output word
   E717 4F            [ 4] 1132         LD      C,A             ; Token offset+1 to C
   E718 11 43 E1      [ 9] 1133         LD      DE,#WORDS        ; Reserved word list
   E71B 1A            [ 6] 1134 FNDTOK: LD      A,(DE)          ; Get character in list
   E71C 13            [ 4] 1135         INC     DE              ; Move on to next
   E71D B7            [ 4] 1136         OR      A               ; Is it start of word?
   E71E F2 1B E7      [ 9] 1137         JP      P,FNDTOK        ; No - Keep looking for word
   E721 0D            [ 4] 1138         DEC     C               ; Count words
   E722 C2 1B E7      [ 9] 1139         JP      NZ,FNDTOK       ; Not there - keep looking
   E725 E6 7F         [ 6] 1140 OUTWRD: AND     #0b01111111       ; Strip bit 7
   E727 CD 9B E6      [16] 1141         CALL    OUTC            ; Output first character
   E72A 1A            [ 6] 1142         LD      A,(DE)          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 22.
Hexadecimal [16-Bits]



   E72B 13            [ 4] 1143         INC     DE              ; Move on to next
   E72C B7            [ 4] 1144         OR      A               ; Is it end of word?
   E72D F2 25 E7      [ 9] 1145         JP      P,OUTWRD        ; No - output the rest
   E730 C3 0C E7      [ 9] 1146         JP      LSTLP3          ; Next byte in line
                           1147 
   E733 E5            [11] 1148 SETLIN: PUSH    HL              ; Set up LINES counter
   E734 2A 48 10      [15] 1149         LD      HL,(LINESN)     ; Get LINES number
   E737 22 46 10      [16] 1150         LD      (LINESC),HL     ; Save in LINES counter
   E73A E1            [ 9] 1151         POP     HL
   E73B C9            [ 9] 1152         RET
                           1153 
   E73C 21 08 FC      [ 9] 1154 LDNMI1: LD      HL,#BREAK        ; Break routine
   E73F 22 7E 0C      [16] 1155         LD      (NMI),HL        ; NMI forces break
   E742 C3 F8 E3      [ 9] 1156         JP      PRNTOK          ; Go to command mode
                           1157 
   E745 FE                 1158         .db      0x0FE            ; <<< NO REFERENCE TO HERE >>>
                           1159 
   E746 E5            [11] 1160 COUNT:  PUSH    HL              ; Save code string address
   E747 D5            [11] 1161         PUSH    DE
   E748 2A 46 10      [15] 1162         LD      HL,(LINESC)     ; Get LINES counter
   E74B 11 FF FF      [ 9] 1163         LD      DE,#-1
   E74E ED 5A         [10] 1164         ADC     HL,DE           ; Decrement
   E750 22 46 10      [16] 1165         LD      (LINESC),HL     ; Put it back
   E753 D1            [ 9] 1166         POP     DE
   E754 E1            [ 9] 1167         POP     HL              ; Restore code string address
   E755 F0            [10] 1168         RET     P               ; Return if more lines to go
   E756 E5            [11] 1169         PUSH    HL              ; Save code string address
   E757 2A 48 10      [15] 1170         LD      HL,(LINESN)     ; Get LINES number
   E75A 22 46 10      [16] 1171         LD      (LINESC),HL     ; Reset LINES counter
   E75D 3A 4C 10      [12] 1172         LD      A,(NMIFLG)      ; Break by NMI?
   E760 B7            [ 4] 1173         OR      A
   E761 C2 0D FC      [ 9] 1174         JP      NZ,ARETN        ; Yes - "RETN"
   E764 CD 7D FA      [16] 1175         CALL    GETINP          ; Get input character
   E767 FE 03         [ 6] 1176         CP      #CTRLC           ; Is it control "C"?
   E769 CA 70 E7      [ 9] 1177         JP      Z,RSLNBK        ; Yes - Reset LINES an break
   E76C E1            [ 9] 1178         POP     HL              ; Restore code string address
   E76D C3 46 E7      [ 9] 1179         JP      COUNT           ; Keep on counting
                           1180 
   E770 2A 48 10      [15] 1181 RSLNBK: LD      HL,(LINESN)     ; Get LINES number
   E773 22 46 10      [16] 1182         LD      (LINESC),HL     ; Reset LINES counter
   E776 C3 B1 E0      [ 9] 1183         JP      BRKRET          ; Go and output "Break"
                           1184 
   E779 3E 64         [ 6] 1185 FOR:    LD      A,#0x64           ; Flag "FOR" assignment
   E77B 32 CB 10      [13] 1186         LD      (FORFLG),A      ; Save "FOR" flag
   E77E CD 64 EA      [16] 1187         CALL    LET             ; Set up initial index
   E781 C1            [ 9] 1188         POP     BC              ; Drop RETurn address
   E782 E5            [11] 1189         PUSH    HL              ; Save code string address
   E783 CD 51 EA      [16] 1190         CALL    DATA            ; Get next statement address
   E786 22 C7 10      [16] 1191         LD      (LOOPST),HL     ; Save it for start of lo6p
   E789 21 02 00      [ 9] 1192         LD      HL,#2            ; Offset for "FOR" block
   E78C 39            [ 7] 1193         ADD     HL,SP           ; Point to it
   E78D CD 5A E3      [16] 1194 FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
   E790 D1            [ 9] 1195         POP     DE              ; Get code string address
   E791 C2 A9 E7      [ 9] 1196         JP      NZ,FORFND       ; No nesting found
   E794 09            [ 7] 1197         ADD     HL,BC           ; Move into "FOR" block
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 23.
Hexadecimal [16-Bits]



   E795 D5            [11] 1198         PUSH    DE              ; Save code string address
   E796 2B            [ 4] 1199         DEC     HL
   E797 56            [ 6] 1200         LD      D,(HL)          ; Get MSB of loop statement
   E798 2B            [ 4] 1201         DEC     HL
   E799 5E            [ 6] 1202         LD      E,(HL)          ; Get LSB of loop statement
   E79A 23            [ 4] 1203         INC     HL
   E79B 23            [ 4] 1204         INC     HL
   E79C E5            [11] 1205         PUSH    HL              ; Save block address
   E79D 2A C7 10      [15] 1206         LD      HL,(LOOPST)     ; Get address of loop statement
   E7A0 CD 8A E6      [16] 1207         CALL    CPDEHL          ; Compare the FOR loops
   E7A3 E1            [ 9] 1208         POP     HL              ; Restore block address
   E7A4 C2 8D E7      [ 9] 1209         JP      NZ,FORSLP       ; Different FORs - Find another
   E7A7 D1            [ 9] 1210         POP     DE              ; Restore code string address
   E7A8 F9            [ 4] 1211         LD      SP,HL           ; Remove all nested loops
                           1212 
   E7A9 EB            [ 3] 1213 FORFND: EX      DE,HL           ; Code string address to HL
   E7AA 0E 08         [ 6] 1214         LD      C,#8
   E7AC CD 8A E3      [16] 1215         CALL    CHKSTK          ; Check for 8 levels of stack
   E7AF E5            [11] 1216         PUSH    HL              ; Save code string address
   E7B0 2A C7 10      [15] 1217         LD      HL,(LOOPST)     ; Get first statement of loop
   E7B3 E3            [16] 1218         EX      (SP),HL         ; Save and restore code string
   E7B4 E5            [11] 1219         PUSH    HL              ; Re-save code string address
   E7B5 2A 5C 10      [15] 1220         LD      HL,(LINEAT)     ; Get current line number
   E7B8 E3            [16] 1221         EX      (SP),HL         ; Save and restore code string
   E7B9 CD F5 EC      [16] 1222         CALL    TSTNUM          ; Make sure it's a number
   E7BC CD 90 E6      [16] 1223         CALL    CHKSYN          ; Make sure "TO" is next
   E7BF A6                 1224         .db      ZTO             ; "TO" token
   E7C0 CD F2 EC      [16] 1225         CALL    GETNUM          ; Get "TO" expression value
   E7C3 E5            [11] 1226         PUSH    HL              ; Save code string address
   E7C4 CD F1 F6      [16] 1227         CALL    BCDEFP          ; Move "TO" value to BCDE
   E7C7 E1            [ 9] 1228         POP     HL              ; Restore code string address
   E7C8 C5            [11] 1229         PUSH    BC              ; Save "TO" value in block
   E7C9 D5            [11] 1230         PUSH    DE
   E7CA 01 00 81      [ 9] 1231         LD      BC,#0x8100        ; BCDE - 1 (default STEP)
   E7CD 51            [ 4] 1232         LD      D,C             ; C=0
   E7CE 5A            [ 4] 1233         LD      E,D             ; D=0
   E7CF 7E            [ 6] 1234         LD      A,(HL)          ; Get next byte in code string
   E7D0 FE AB         [ 6] 1235         CP      #ZSTEP           ; See if "STEP" is stated
   E7D2 3E 01         [ 6] 1236         LD      A,#1             ; Sign of step = 1
   E7D4 C2 E5 E7      [ 9] 1237         JP      NZ,SAVSTP       ; No STEP given - Default to 1
   E7D7 CD 36 E8      [16] 1238         CALL    GETCHR          ; Jump over "STEP" token
   E7DA CD F2 EC      [16] 1239         CALL    GETNUM          ; Get step value
   E7DD E5            [11] 1240         PUSH    HL              ; Save code string address
   E7DE CD F1 F6      [16] 1241         CALL    BCDEFP          ; Move STEP to BCDE
   E7E1 CD B6 F6      [16] 1242         CALL    TSTSGN          ; Test sign of FPREG
   E7E4 E1            [ 9] 1243         POP     HL              ; Restore code string address
   E7E5 C5            [11] 1244 SAVSTP: PUSH    BC              ; Save the STEP value in block
   E7E6 D5            [11] 1245         PUSH    DE
   E7E7 F5            [11] 1246         PUSH    AF              ; Save sign of STEP
   E7E8 33            [ 4] 1247         INC     SP              ; Don't save flags
   E7E9 E5            [11] 1248         PUSH    HL              ; Save code string address
   E7EA 2A CE 10      [15] 1249         LD      HL,(BRKLIN)     ; Get address of index variable
   E7ED E3            [16] 1250         EX      (SP),HL         ; Save and restore code string
   E7EE 06 81         [ 6] 1251 PUTFID: LD      B,#ZFOR          ; "FOR" block marker
   E7F0 C5            [11] 1252         PUSH    BC              ; Save it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 24.
Hexadecimal [16-Bits]



   E7F1 33            [ 4] 1253         INC     SP              ; Don't save C
                           1254 
u  E7F2 CD 00 00      [16] 1255 RUNCNT: CALL    CHKBRK          ; Execution driver - Test break
   E7F5 B7            [ 4] 1256         OR      A               ; Break key hit?
   E7F6 C4 66 E8      [16] 1257         CALL    NZ,STALL        ; Yes - Pause for a key
   E7F9 22 CE 10      [16] 1258         LD      (BRKLIN),HL     ; Save code address for break
   E7FC 7E            [ 6] 1259         LD      A,(HL)          ; Get next byte in code string
   E7FD FE 3A         [ 6] 1260         CP      #":"             ; Multi statement line?
   E7FF CA 16 E8      [ 9] 1261         JP      Z,EXCUTE        ; Yes - Execute it
   E802 B7            [ 4] 1262         OR      A               ; End of line?
   E803 C2 AD E3      [ 9] 1263         JP      NZ,SNERR        ; No - Syntax error
   E806 23            [ 4] 1264         INC     HL              ; Point to address of next line
   E807 7E            [ 6] 1265         LD      A,(HL)          ; Get LSB of line pointer
   E808 23            [ 4] 1266         INC     HL
   E809 B6            [ 6] 1267         OR      (HL)            ; Is it zero (End of prog)?
   E80A CA 7A E8      [ 9] 1268         JP      Z,ENDPRG        ; Yes - Terminate execution
   E80D 23            [ 4] 1269         INC     HL              ; Point to line number
   E80E 5E            [ 6] 1270         LD      E,(HL)          ; Get LSB of line number
   E80F 23            [ 4] 1271         INC     HL
   E810 56            [ 6] 1272         LD      D,(HL)          ; Get MSB of line number
   E811 EB            [ 3] 1273         EX      DE,HL           ; Line number to HL
   E812 22 5C 10      [16] 1274         LD      (LINEAT),HL     ; Save as current line number
   E815 EB            [ 3] 1275         EX      DE,HL           ; Line number back to DE
   E816 CD 36 E8      [16] 1276 EXCUTE: CALL    GETCHR          ; Get key word
   E819 11 F2 E7      [ 9] 1277         LD      DE,#RUNCNT       ; Where to RETurn to
   E81C D5            [11] 1278         PUSH    DE              ; Save for RETurn
   E81D C8            [10] 1279 IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
   E81E D6 80         [ 6] 1280 ONJMP:  SUB     #ZEND            ; Is it a token?
   E820 DA 64 EA      [ 9] 1281         JP      C,LET           ; No - try to assign it
   E823 FE 25         [ 6] 1282         CP      #ZNEW+1-ZEND     ; END to NEW ?
   E825 D2 AD E3      [ 9] 1283         JP      NC,SNERR        ; Not a key word - ?SN Error
   E828 07            [ 3] 1284         RLCA                    ; Double it
   E829 4F            [ 4] 1285         LD      C,A             ; BC = Offset into table
   E82A 06 00         [ 6] 1286         LD      B,#0
   E82C EB            [ 3] 1287         EX      DE,HL           ; Save code string address
   E82D 21 5A E2      [ 9] 1288         LD      HL,#WORDTB       ; Keyword address table
   E830 09            [ 7] 1289         ADD     HL,BC           ; Point to routine address
   E831 4E            [ 6] 1290         LD      C,(HL)          ; Get LSB of routine address
   E832 23            [ 4] 1291         INC     HL
   E833 46            [ 6] 1292         LD      B,(HL)          ; Get MSB of routine address
   E834 C5            [11] 1293         PUSH    BC              ; Save routine address
   E835 EB            [ 3] 1294         EX      DE,HL           ; Restore code string address
                           1295 
   E836 23            [ 4] 1296 GETCHR: INC     HL              ; Point to next character
   E837 7E            [ 6] 1297         LD      A,(HL)          ; Get next code string byte
   E838 FE 3A         [ 6] 1298         CP      #":"             ; Z if ":"
   E83A D0            [10] 1299         RET     NC              ; NC if > "9"
   E83B FE 20         [ 6] 1300         CP      #" "
   E83D CA 36 E8      [ 9] 1301         JP      Z,GETCHR        ; Skip over spaces
   E840 FE 30         [ 6] 1302         CP      #"0"
   E842 3F            [ 3] 1303         CCF                     ; NC if < "0"
   E843 3C            [ 4] 1304         INC     A               ; Test for zero - Leave carry
   E844 3D            [ 4] 1305         DEC     A               ; Z if Null
   E845 C9            [ 9] 1306         RET
                           1307 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 25.
Hexadecimal [16-Bits]



   E846 EB            [ 3] 1308 RESTOR: EX      DE,HL           ; Save code string address
   E847 2A 5E 10      [15] 1309         LD      HL,(BASTXT)     ; Point to start of program
   E84A CA 5B E8      [ 9] 1310         JP      Z,RESTNL        ; Just RESTORE - reset pointer
   E84D EB            [ 3] 1311         EX      DE,HL           ; Restore code string address
   E84E CD 98 E9      [16] 1312         CALL    ATOH            ; Get line number to DE
   E851 E5            [11] 1313         PUSH    HL              ; Save code string address
   E852 CD 99 E4      [16] 1314         CALL    SRCHLN          ; Search for line number in DE
   E855 60            [ 4] 1315         LD      H,B             ; HL = Address of line
   E856 69            [ 4] 1316         LD      L,C
   E857 D1            [ 9] 1317         POP     DE              ; Restore code string address
   E858 D2 2E EA      [ 9] 1318         JP      NC,ULERR        ; ?UL Error if not found
   E85B 2B            [ 4] 1319 RESTNL: DEC     HL              ; Byte before DATA statement
   E85C 22 DC 10      [16] 1320 UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
   E85F EB            [ 3] 1321         EX      DE,HL           ; Restore code string address
   E860 C9            [ 9] 1322         RET
                           1323 
u  E861 CD 00 00      [16] 1324 TSTBRK: CALL    CHKBRK          ; Test for interrupts
   E864 B7            [ 4] 1325         OR      A
   E865 C8            [10] 1326         RET     Z               ; Return if no key pressed
   E866 CD CC E6      [16] 1327 STALL:  CALL    CLOTST          ; Get input and test for ^O
   E869 FE 13         [ 6] 1328         CP      #CTRLS           ; Is it control "S"
   E86B CC CC E6      [16] 1329         CALL    Z,CLOTST        ; Yes - Get another character
   E86E FE 03         [ 6] 1330         CP      #CTRLC           ; Return if not control "C"
   E870 C0            [10] 1331 STOP:   RET     NZ              ; Exit if anything else
   E871 F6                 1332         .db      0x0F6            ; Flag "STOP"
   E872 C0            [10] 1333 PEND:   RET     NZ              ; Exit if anything else
   E873 22 CE 10      [16] 1334         LD      (BRKLIN),HL     ; Save point of break
   E876 21                 1335         .db      0x21             ; Skip "OR 11111111B"
   E877 F6 FF         [ 6] 1336 INPBRK: OR      #0b11111111       ; Flag "Break" wanted
   E879 C1            [ 9] 1337         POP     BC              ; Return not needed and more
   E87A 2A 5C 10      [15] 1338 ENDPRG: LD      HL,(LINEAT)     ; Get current line number
   E87D F5            [11] 1339         PUSH    AF              ; Save STOP / END status
   E87E 7D            [ 4] 1340         LD      A,L             ; Is it direct break?
   E87F A4            [ 4] 1341         AND     H
   E880 3C            [ 4] 1342         INC     A               ; Line is -1 if direct break
   E881 CA 8D E8      [ 9] 1343         JP      Z,NOLIN         ; Yes - No line number
   E884 22 D2 10      [16] 1344         LD      (ERRLIN),HL     ; Save line of break
   E887 2A CE 10      [15] 1345         LD      HL,(BRKLIN)     ; Get point of break
   E88A 22 D4 10      [16] 1346         LD      (CONTAD),HL     ; Save point to CONTinue
   E88D AF            [ 4] 1347 NOLIN:  XOR     A
   E88E 32 45 10      [13] 1348         LD      (CTLOFG),A      ; Enable output
   E891 CD 4E EB      [16] 1349         CALL    STTLIN          ; Start a new line
   E894 F1            [ 9] 1350         POP     AF              ; Restore STOP / END status
   E895 21 50 E3      [ 9] 1351         LD      HL,#BRKMSG       ; "Break" message
   E898 C2 E1 E3      [ 9] 1352         JP      NZ,ERRIN        ; "in line" wanted?
   E89B C3 F8 E3      [ 9] 1353         JP      PRNTOK          ; Go to command mode
                           1354 
   E89E 2A D4 10      [15] 1355 CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
   E8A1 7C            [ 4] 1356         LD      A,H             ; Is it zero?
   E8A2 B5            [ 4] 1357         OR      L
   E8A3 1E 20         [ 6] 1358         LD      E,#CN            ; ?CN Error
   E8A5 CA C1 E3      [ 9] 1359         JP      Z,ERROR         ; Yes - output "?CN Error"
   E8A8 EB            [ 3] 1360         EX      DE,HL           ; Save code string address
   E8A9 2A D2 10      [15] 1361         LD      HL,(ERRLIN)     ; Get line of last break
   E8AC 22 5C 10      [16] 1362         LD      (LINEAT),HL     ; Set up current line number
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 26.
Hexadecimal [16-Bits]



   E8AF EB            [ 3] 1363         EX      DE,HL           ; Restore code string address
   E8B0 C9            [ 9] 1364         RET                     ; CONTinue where left off
                           1365 
   E8B1 CD C8 F3      [16] 1366 NULL:   CALL    GETINT          ; Get integer 0-255
   E8B4 C0            [10] 1367         RET     NZ              ; Return if bad value
   E8B5 32 41 10      [13] 1368         LD      (NULLS),A       ; Set nulls number
   E8B8 C9            [ 9] 1369         RET
                           1370 
   E8B9 06 FF         [ 6] 1371 ARRLD1: LD      B,#-1            ; Flag array load
   E8BB CD 36 E8      [16] 1372 ARRSV1: CALL    GETCHR          ; Skip "*"
   E8BE 78            [ 4] 1373         LD      A,B             ; CLOAD* or CSAVE*
   E8BF 32 CE 10      [13] 1374         LD      (BRKLIN),A      ; Save it
   E8C2 3E 01         [ 6] 1375         LD      A,#1             ; It's an array
   E8C4 32 CB 10      [13] 1376         LD      (FORFLG),A      ; Flag array name
   E8C7 CD D9 EE      [16] 1377         CALL    GETVAR          ; Get address of array name
   E8CA E5            [11] 1378         PUSH    HL              ; Save code string address
   E8CB 32 CB 10      [13] 1379         LD      (FORFLG),A      ; Clear flag
   E8CE 60            [ 4] 1380         LD      H,B             ; Address of array to HL
   E8CF 69            [ 4] 1381         LD      L,C
   E8D0 0B            [ 4] 1382         DEC     BC              ; Back space
   E8D1 0B            [ 4] 1383         DEC     BC              ;  to point
   E8D2 0B            [ 4] 1384         DEC     BC              ;  to the
   E8D3 0B            [ 4] 1385         DEC     BC              ; array name
   E8D4 3A CE 10      [12] 1386         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8D7 B7            [ 4] 1387         OR      A
   E8D8 F5            [11] 1388         PUSH    AF              ; Save CLOAD* / CSAVE* status
   E8D9 EB            [ 3] 1389         EX      DE,HL           ; Array data length
   E8DA 19            [ 7] 1390         ADD     HL,DE           ; End of data
   E8DB EB            [ 3] 1391         EX      DE,HL           ; To DE
   E8DC 4E            [ 6] 1392         LD      C,(HL)          ; Get dimension bytes
   E8DD 06 00         [ 6] 1393         LD      B,#0
   E8DF 09            [ 7] 1394         ADD     HL,BC           ; 2 Bytes each dimension
   E8E0 09            [ 7] 1395         ADD     HL,BC
   E8E1 23            [ 4] 1396         INC     HL              ; Over number of dimensions
   E8E2 E5            [11] 1397         PUSH    HL              ; Address of array data
   E8E3 D5            [11] 1398         PUSH    DE              ; End of array data
   E8E4 C5            [11] 1399         PUSH    BC              ; Number of dimensions
   E8E5 3A CE 10      [12] 1400         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8E8 FE FF         [ 6] 1401         CP      #-1
   E8EA CC 57 FA      [16] 1402         CALL    Z,CASFF         ; CLOAD* - Cassette on
   E8ED 3A CE 10      [12] 1403         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8F0 FE FF         [ 6] 1404         CP      #-1
   E8F2 C4 4C FA      [16] 1405         CALL    NZ,CASFFW       ; CSAVE* - Cassette on and wait
   E8F5 00            [ 3] 1406         NOP
   E8F6 00            [ 3] 1407         NOP
   E8F7 00            [ 3] 1408         NOP
   E8F8 21 00 00      [ 9] 1409         LD      HL,#0
   E8FB 22 4A 10      [16] 1410         LD      (CHKSUM),HL     ; Zero check sum
   E8FE C1            [ 9] 1411         POP     BC              ; Number of dimensions
   E8FF D1            [ 9] 1412         POP     DE              ; End of array data
   E900 E1            [ 9] 1413         POP     HL              ; Address of array data
   E901 06 D2         [ 6] 1414         LD      B,#0b11010010     ; Header byte
   E903 C3 CA FC      [ 9] 1415         JP      JPLDSV          ; CSAVE-SN0xDDR , CLOAD-GETHDR
                           1416 
   E906 78            [ 4] 1417 SN0xDDR: LD      A,B             ; Get header byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 27.
Hexadecimal [16-Bits]



   E907 CD F8 F3      [16] 1418         CALL    WUART2          ; Send 2 bytes to UART
   E90A CD F8 F3      [16] 1419         CALL    WUART2          ; Send 2 bytes to UART
   E90D C3 1D E9      [ 9] 1420         JP      SNDARY          ; Send array data
                           1421 
   E910 0E 04         [ 6] 1422 GETHDR: LD      C,#4             ; 4 Bytes to check
   E912 CD F5 F3      [16] 1423 HDRLP:  CALL    RUART           ; Read byte from UART
   E915 B8            [ 4] 1424         CP      B               ; Same as header?
   E916 C2 10 E9      [ 9] 1425         JP      NZ,GETHDR       ; No - Wait for another
   E919 0D            [ 4] 1426         DEC     C               ; Count bytes
   E91A C2 12 E9      [ 9] 1427         JP      NZ,HDRLP        ; More needed
   E91D CD F5 EC      [16] 1428 SNDARY: CALL    TSTNUM          ; Check it's a numerical array
   E920 CD 8A E6      [16] 1429 ARYLP:  CALL    CPDEHL          ; All array data done
   E923 CA 37 E9      [ 9] 1430         JP      Z,SUMOFF        ; Yes - Do check sum
   E926 F1            [ 9] 1431         POP     AF              ; CLOAD* or CSAVE* ?
   E927 F5            [11] 1432         PUSH    AF              ; Re-save flags
   E928 7E            [ 6] 1433         LD      A,(HL)          ; Get byte
   E929 F4 FB F3      [16] 1434         CALL    P,WUART         ; CSAVE* - Write byte
   E92C FC F5 F3      [16] 1435         CALL    M,RUART         ; CLOAD* - Read byte
   E92F 77            [ 7] 1436         LD      (HL),A          ; Save byte in case of CLOAD*
   E930 CD 40 E9      [16] 1437         CALL    ACCSUM          ; Accumulate check sum
   E933 23            [ 4] 1438         INC     HL              ; Next byte
   E934 C3 20 E9      [ 9] 1439         JP      ARYLP           ; Repeat
                           1440 
   E937 CD 4D E9      [16] 1441 SUMOFF: CALL    DOSUM           ; Do check sum
   E93A CD 57 FA      [16] 1442         CALL    CASFF           ; Cassette off
   E93D F1            [ 9] 1443         POP     AF              ; Not needed any more
   E93E E1            [ 9] 1444         POP     HL              ; Restore code string address
   E93F C9            [ 9] 1445         RET
                           1446 
   E940 E5            [11] 1447 ACCSUM: PUSH    HL              ; Save address in array
   E941 2A 4A 10      [15] 1448         LD      HL,(CHKSUM)     ; Get check sum
   E944 06 00         [ 6] 1449         LD      B,#0             ; BC - Value of byte
   E946 4F            [ 4] 1450         LD      C,A
   E947 09            [ 7] 1451         ADD     HL,BC           ; Add byte to check sum
   E948 22 4A 10      [16] 1452         LD      (CHKSUM),HL     ; Re-save check sum
   E94B E1            [ 9] 1453         POP     HL              ; Restore address in array
   E94C C9            [ 9] 1454         RET
                           1455 
   E94D 3A CE 10      [12] 1456 DOSUM:  LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E950 B7            [ 4] 1457         OR      A
u  E951 FA 00 00      [ 9] 1458         JP      M,CHKSUMS        ; CLOAD* - Check if sums match
   E954 3A 4A 10      [12] 1459         LD      A,(CHKSUM)      ; Get LSB of check sum
   E957 CD FB F3      [16] 1460         CALL    WUART           ; Write to UART
   E95A 3A 4B 10      [12] 1461         LD      A,(CHKSUM+1)    ; Get MSB of check sum
   E95D C3 FB F3      [ 9] 1462         JP      WUART           ; Write to UART and return
                           1463 
q                          1464 0xCSUMS: CALL    RUART           ; Read LSB of check sum
   E960 F5            [11] 1465         PUSH    AF              ; Save it
   E961 CD F5 F3      [16] 1466         CALL    RUART           ; Read MSB of check sum
   E964 C1            [ 9] 1467         POP     BC              ; LSB to B
   E965 58            [ 4] 1468         LD      E,B             ; LSB to E
   E966 57            [ 4] 1469         LD      D,A             ; MSB to D
   E967 2A 4A 10      [15] 1470         LD      HL,(CHKSUM)     ; Get accumulated check sum
   E96A CD 8A E6      [16] 1471         CALL    CPDEHL          ; Are they the same?
   E96D C8            [10] 1472         RET     Z               ; Yes - End CLOAD*
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 28.
Hexadecimal [16-Bits]



   E96E CD 57 FA      [16] 1473         CALL    CASFF           ; Cassette off
   E971 C3 96 F4      [ 9] 1474         JP      OUTBAD          ; Different - Output "Bad"
                           1475 
   E974 7E            [ 6] 1476 CHKLTR: LD      A,(HL)          ; Get byte
   E975 FE 41         [ 6] 1477         CP      #"A"             ; < "A" ?
   E977 D8            [10] 1478         RET     C               ; Carry set if not letter
   E978 FE 5B         [ 6] 1479         CP      #"Z"+1           ; > "Z" ?
   E97A 3F            [ 3] 1480         CCF
   E97B C9            [ 9] 1481         RET                     ; Carry set if not letter
                           1482 
   E97C CD 36 E8      [16] 1483 FPSINT: CALL    GETCHR          ; Get next character
   E97F CD F2 EC      [16] 1484 POSINT: CALL    GETNUM          ; Get integer 0 to 32767
   E982 CD B6 F6      [16] 1485 DEPINT: CALL    TSTSGN          ; Test sign of FPREG
   E985 FA 95 E9      [ 9] 1486         JP      M,FCERR         ; Negative - ?FC Error
   E988 3A E7 10      [12] 1487 DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
a  E98B               [12] 1488         CP      0x80+16          ; Exponent in range (16 bits)?
   E98B DA 3C F7      [ 9] 1489         JP      C,FPINT         ; Yes - convert it
a  E98E               [ 9] 1490         LD      BC,0x9080        ; BCDE = -32768
a  E98E               [ 9] 1491         LD      DE,0000
   E98E E5            [11] 1492         PUSH    HL              ; Save code string address
   E98F CD 15 F7      [16] 1493         CALL    CMPNUM          ; Compare FPREG with BCDE
   E992 E1            [ 9] 1494         POP     HL              ; Restore code string address
   E993 51            [ 4] 1495         LD      D,C             ; MSB to D
   E994 C8            [10] 1496         RET     Z               ; Return if in range
a  E995               [10] 1497 FCERR:  LD      E,FC            ; ?FC Error
   E995 C3 C1 E3      [ 9] 1498         JP      ERROR           ; Output error-
                           1499 
   E998 2B            [ 4] 1500 ATOH:   DEC     HL              ; ASCII number to DE binary
a  E999               [ 4] 1501 GETLN:  LD      DE,0            ; Get number to DE
   E999 CD 36 E8      [16] 1502 GTLNLP: CALL    GETCHR          ; Get next character
   E99C D0            [10] 1503         RET     NC              ; Exit if not a digit
   E99D E5            [11] 1504         PUSH    HL              ; Save code string address
   E99E F5            [11] 1505         PUSH    AF              ; Save digit
   E99F 21 98 19      [ 9] 1506         LD      HL,#65529/10     ; Largest number 65529
   E9A2 CD 8A E6      [16] 1507         CALL    CPDEHL          ; Number in range?
   E9A5 DA AD E3      [ 9] 1508         JP      C,SNERR         ; No - ?SN Error
   E9A8 62            [ 4] 1509         LD      H,D             ; HL = Number
   E9A9 6B            [ 4] 1510         LD      L,E
   E9AA 19            [ 7] 1511         ADD     HL,DE           ; Times 2
   E9AB 29            [ 7] 1512         ADD     HL,HL           ; Times 4
   E9AC 19            [ 7] 1513         ADD     HL,DE           ; Times 5
   E9AD 29            [ 7] 1514         ADD     HL,HL           ; Times 10
   E9AE F1            [ 9] 1515         POP     AF              ; Restore digit
   E9AF D6 30         [ 6] 1516         SUB     #"0"             ; Make it 0 to 9
   E9B1 5F            [ 4] 1517         LD      E,A             ; DE = Value of digit
a  E9B2               [ 4] 1518         LD      D,0
   E9B2 19            [ 7] 1519         ADD     HL,DE           ; Add to number
   E9B3 EB            [ 3] 1520         EX      DE,HL           ; Number to DE
   E9B4 E1            [ 9] 1521         POP     HL              ; Restore code string address
   E9B5 C3 99 E9      [ 9] 1522         JP      GTLNLP          ; Go to next character
                           1523 
   E9B8 CA C9 E4      [ 9] 1524 CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
   E9BB CD 7F E9      [16] 1525         CALL    POSINT          ; Get integer 0 to 32767 to DE
   E9BE 2B            [ 4] 1526         DEC     HL              ; Cancel increment
   E9BF CD 36 E8      [16] 1527         CALL    GETCHR          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 29.
Hexadecimal [16-Bits]



   E9C2 E5            [11] 1528         PUSH    HL              ; Save code string address
   E9C3 2A AF 10      [15] 1529         LD      HL,(LSTRAM)     ; Get end of RAM
   E9C6 CA DB E9      [ 9] 1530         JP      Z,STORED        ; No value given - Use stored
   E9C9 E1            [ 9] 1531         POP     HL              ; Restore code string address
   E9CA CD 90 E6      [16] 1532         CALL    CHKSYN          ; Check for comma
   E9CD 2C                 1533         .db      ","
   E9CE D5            [11] 1534         PUSH    DE              ; Save number
   E9CF CD 7F E9      [16] 1535         CALL    POSINT          ; Get integer 0 to 32767
   E9D2 2B            [ 4] 1536         DEC     HL              ; Cancel increment
   E9D3 CD 36 E8      [16] 1537         CALL    GETCHR          ; Get next character
   E9D6 C2 AD E3      [ 9] 1538         JP      NZ,SNERR        ; ?SN Error if more on line
   E9D9 E3            [16] 1539         EX      (SP),HL         ; Save code string address
   E9DA EB            [ 3] 1540         EX      DE,HL           ; Number to DE
   E9DB 7D            [ 4] 1541 STORED: LD      A,L             ; Get LSB of new RAM top
   E9DC 93            [ 4] 1542         SUB     E               ; Subtract LSB of string space
   E9DD 5F            [ 4] 1543         LD      E,A             ; Save LSB
   E9DE 7C            [ 4] 1544         LD      A,H             ; Get MSB of new RAM top
   E9DF 9A            [ 4] 1545         SBC     A,D             ; Subtract MSB of string space
   E9E0 57            [ 4] 1546         LD      D,A             ; Save MSB
   E9E1 DA A2 E3      [ 9] 1547         JP      C,OMERR         ; ?OM Error if not enough mem
   E9E4 E5            [11] 1548         PUSH    HL              ; Save RAM top
   E9E5 2A D6 10      [15] 1549         LD      HL,(PROGND)     ; Get program end
a  E9E8               [15] 1550         LD      BC,40           ; 40 Bytes minimum working RAM
   E9E8 09            [ 7] 1551         ADD     HL,BC           ; Get lowest address
   E9E9 CD 8A E6      [16] 1552         CALL    CPDEHL          ; Enough memory?
   E9EC D2 A2 E3      [ 9] 1553         JP      NC,OMERR        ; No - ?OM Error
   E9EF EB            [ 3] 1554         EX      DE,HL           ; RAM top to HL
   E9F0 22 5A 10      [16] 1555         LD      (STRSPC),HL     ; Set new string space
   E9F3 E1            [ 9] 1556         POP     HL              ; End of memory to use
   E9F4 22 AF 10      [16] 1557         LD      (LSTRAM),HL     ; Set new top of RAM
   E9F7 E1            [ 9] 1558         POP     HL              ; Restore code string address
   E9F8 C3 C9 E4      [ 9] 1559         JP      INTVAR          ; Initialise variables
                           1560 
   E9FB CA C5 E4      [ 9] 1561 RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
   E9FE CD C9 E4      [16] 1562         CALL    INTVAR          ; Initialise variables
a  EA01               [16] 1563         LD      BC,RUNCNT       ; Execution driver loop
   EA01 C3 14 EA      [ 9] 1564         JP      RUNLIN          ; RUN from line number
                           1565 
   EA04 0E 03         [ 6] 1566 GOSUB:  LD      C,#3             ; 3 Levels of stack needed
   EA06 CD 8A E3      [16] 1567         CALL    CHKSTK          ; Check for 3 levels of stack
   EA09 C1            [ 9] 1568         POP     BC              ; Get return address
   EA0A E5            [11] 1569         PUSH    HL              ; Save code string for RETURN
   EA0B E5            [11] 1570         PUSH    HL              ; And for GOSUB routine
   EA0C 2A 5C 10      [15] 1571         LD      HL,(LINEAT)     ; Get current line
   EA0F E3            [16] 1572         EX      (SP),HL         ; Into stack - Code string out
   EA10 3E 8C         [ 6] 1573         LD      A,#ZGOSUB        ; "GOSUB" token
   EA12 F5            [11] 1574         PUSH    AF              ; Save token
   EA13 33            [ 4] 1575         INC     SP              ; Don't save flags
                           1576 
   EA14 C5            [11] 1577 RUNLIN: PUSH    BC              ; Save return address
   EA15 CD 98 E9      [16] 1578 GOTO:   CALL    ATOH            ; ASCII number to DE binary
   EA18 CD 53 EA      [16] 1579         CALL    REM             ; Get end of line
   EA1B E5            [11] 1580         PUSH    HL              ; Save end of line
   EA1C 2A 5C 10      [15] 1581         LD      HL,(LINEAT)     ; Get current line
   EA1F CD 8A E6      [16] 1582         CALL    CPDEHL          ; Line after current?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 30.
Hexadecimal [16-Bits]



   EA22 E1            [ 9] 1583         POP     HL              ; Restore end of line
   EA23 23            [ 4] 1584         INC     HL              ; Start of next line
   EA24 DC 9C E4      [16] 1585         CALL    C,SRCHLP        ; Line is after current line
   EA27 D4 99 E4      [16] 1586         CALL    NC,SRCHLN       ; Line is before current line
   EA2A 60            [ 4] 1587         LD      H,B             ; Set up code string address
   EA2B 69            [ 4] 1588         LD      L,C
   EA2C 2B            [ 4] 1589         DEC     HL              ; Incremented after
   EA2D D8            [10] 1590         RET     C               ; Line found
   EA2E 1E 0E         [ 6] 1591 ULERR:  LD      E,#UL            ; ?UL Error
   EA30 C3 C1 E3      [ 9] 1592         JP      ERROR           ; Output error message
                           1593 
   EA33 C0            [10] 1594 RETURN: RET     NZ              ; Return if not just RETURN
a  EA34               [10] 1595         LD      D,-1            ; Flag "GOSUB" search
   EA34 CD 56 E3      [16] 1596         CALL    BAKSTK          ; Look "GOSUB" block
   EA37 F9            [ 4] 1597         LD      SP,HL           ; Kill all FORs in subroutine
   EA38 FE 8C         [ 6] 1598         CP      #ZGOSUB          ; Test for "GOSUB" token
a  EA3A               [ 6] 1599         LD      E,RG            ; ?RG Error
   EA3A C2 C1 E3      [ 9] 1600         JP      NZ,ERROR        ; Error if no "GOSUB" found
   EA3D E1            [ 9] 1601         POP     HL              ; Get RETURN line number
   EA3E 22 5C 10      [16] 1602         LD      (LINEAT),HL     ; Save as current
   EA41 23            [ 4] 1603         INC     HL              ; Was it from direct statement?
   EA42 7C            [ 4] 1604         LD      A,H
   EA43 B5            [ 4] 1605         OR      L               ; Return to line
   EA44 C2 4E EA      [ 9] 1606         JP      NZ,RETLIN       ; No - Return to line
   EA47 3A CC 10      [12] 1607         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
   EA4A B7            [ 4] 1608         OR      A               ; If so buffer is corrupted
   EA4B C2 F7 E3      [ 9] 1609         JP      NZ,POPNOK       ; Yes - Go to command mode
a  EA4E               [ 9] 1610 RETLIN: LD      HL,RUNCNT       ; Execution driver loop
   EA4E E3            [16] 1611         EX      (SP),HL         ; Into stack - Code string out
   EA4F 3E                 1612         .db      0x3E             ; Skip "POP HL"
   EA50 E1            [ 9] 1613 NXTDTA: POP     HL              ; Restore code string address
                           1614 
   EA51 01 3A              1615 DATA:   .db      0x01,0x3A         ; ":" End of statement
a  EA53               [ 9] 1616 REM:    LD      C,0             ; 00  End of statement
a  EA53               [ 9] 1617         LD      B,0
   EA53 79            [ 4] 1618 NXTSTL: LD      A,C             ; Statement and byte
   EA54 48            [ 4] 1619         LD      C,B
   EA55 47            [ 4] 1620         LD      B,A             ; Statement end byte
   EA56 7E            [ 6] 1621 NXTSTT: LD      A,(HL)          ; Get byte
   EA57 B7            [ 4] 1622         OR      A               ; End of line?
   EA58 C8            [10] 1623         RET     Z               ; Yes - Exit
   EA59 B8            [ 4] 1624         CP      B               ; End of statement?
   EA5A C8            [10] 1625         RET     Z               ; Yes - Exit
   EA5B 23            [ 4] 1626         INC     HL              ; Next byte
   EA5C FE 22         [ 6] 1627         CP      #'"'             ; Literal string?"
   EA5E CA 53 EA      [ 9] 1628         JP      Z,NXTSTL        ; Yes - Look for another '"'
   EA61 C3 56 EA      [ 9] 1629         JP      NXTSTT          ; Keep looking
                           1630 
   EA64 CD D9 EE      [16] 1631 LET:    CALL    GETVAR          ; Get variable name
   EA67 CD 90 E6      [16] 1632         CALL    CHKSYN          ; Make sure "=" follows
   EA6A B4                 1633         .db      ZEQUAL          ; "=" token
   EA6B D5            [11] 1634         PUSH    DE              ; Save address of variable
   EA6C 3A AD 10      [12] 1635         LD      A,(TYPE)        ; Get data type
   EA6F F5            [11] 1636         PUSH    AF              ; Save type
   EA70 CD 0B ED      [16] 1637         CALL    EVAL            ; Evaluate expression
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 31.
Hexadecimal [16-Bits]



   EA73 F1            [ 9] 1638         POP     AF              ; Restore type
   EA74 E3            [16] 1639         EX      (SP),HL         ; Save code - Get var addr
   EA75 22 CE 10      [16] 1640         LD      (BRKLIN),HL     ; Save address of variable
   EA78 1F            [ 3] 1641         RRA                     ; Adjust type
   EA79 CD F7 EC      [16] 1642         CALL    CHKTYP          ; Check types are the same
   EA7C CA B4 EA      [ 9] 1643         JP      Z,LETNUM        ; Numeric - Move value
   EA7F E5            [11] 1644 LETSTR: PUSH    HL              ; Save address of string var
   EA80 2A E4 10      [15] 1645         LD      HL,(FPREG)      ; Pointer to string entry
   EA83 E5            [11] 1646         PUSH    HL              ; Save it on stack
   EA84 23            [ 4] 1647         INC     HL              ; Skip over length
   EA85 23            [ 4] 1648         INC     HL
   EA86 5E            [ 6] 1649         LD      E,(HL)          ; LSB of string address
   EA87 23            [ 4] 1650         INC     HL
   EA88 56            [ 6] 1651         LD      D,(HL)          ; MSB of string address
   EA89 2A 5E 10      [15] 1652         LD      HL,(BASTXT)     ; Point to start of program
   EA8C CD 8A E6      [16] 1653         CALL    CPDEHL          ; Is string before program?
   EA8F D2 A3 EA      [ 9] 1654         JP      NC,CRESTR       ; Yes - Create string entry
   EA92 2A 5A 10      [15] 1655         LD      HL,(STRSPC)     ; Point to string space
   EA95 CD 8A E6      [16] 1656         CALL    CPDEHL          ; Is string literal in program?
   EA98 D1            [ 9] 1657         POP     DE              ; Restore address of string
   EA99 D2 AB EA      [ 9] 1658         JP      NC,MVSTPT       ; Yes - Set up pointer
a  EA9C               [ 9] 1659         LD      HL,TMPSTR       ; Temporary string pool
   EA9C CD 8A E6      [16] 1660         CALL    CPDEHL          ; Is string in temporary pool?
   EA9F D2 AB EA      [ 9] 1661         JP      NC,MVSTPT       ; No - Set up pointer
   EAA2 3E                 1662         .db      0x3E             ; Skip "POP DE"
   EAA3 D1            [ 9] 1663 CRESTR: POP     DE              ; Restore address of string
   EAA4 CD C6 F2      [16] 1664         CALL    BAKTMP          ; Back to last tmp-str entry
   EAA7 EB            [ 3] 1665         EX      DE,HL           ; Address of string entry
   EAA8 CD 2F F1      [16] 1666         CALL    SAVSTR          ; Save string in string area
   EAAB CD C6 F2      [16] 1667 MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
   EAAE E1            [ 9] 1668         POP     HL              ; Get string pointer
   EAAF CD FA F6      [16] 1669         CALL    DETHL4          ; Move string pointer to var
   EAB2 E1            [ 9] 1670         POP     HL              ; Restore code string address
   EAB3 C9            [ 9] 1671         RET
                           1672 
   EAB4 E5            [11] 1673 LETNUM: PUSH    HL              ; Save address of variable
   EAB5 CD FA F6      [16] 1674         CALL    FPTHL           ; Move value to variable
   EAB8 D1            [ 9] 1675         POP     DE              ; Restore address of variable
   EAB9 E1            [ 9] 1676         POP     HL              ; Restore code string address
   EABA C9            [ 9] 1677         RET
                           1678 
   EABB CD C8 F3      [16] 1679 ON:     CALL    GETINT          ; Get integer 0-255
   EABE 7E            [ 6] 1680         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
   EABF 47            [ 4] 1681         LD      B,A             ; Save in B
   EAC0 FE 8C         [ 6] 1682         CP      #ZGOSUB          ; "GOSUB" token?
   EAC2 CA CA EA      [ 9] 1683         JP      Z,ONGO          ; Yes - Find line number
   EAC5 CD 90 E6      [16] 1684         CALL    CHKSYN          ; Make sure it's "GOTO"
   EAC8 88                 1685         .db      ZGOTO           ; "GOTO" token
   EAC9 2B            [ 4] 1686         DEC     HL              ; Cancel increment
   EACA 4B            [ 4] 1687 ONGO:   LD      C,E             ; Integer of branch value
   EACB 0D            [ 4] 1688 ONGOLP: DEC     C               ; Count branches
   EACC 78            [ 4] 1689         LD      A,B             ; Get "GOTO" or "GOSUB" token
   EACD CA 1E E8      [ 9] 1690         JP      Z,ONJMP         ; Go to that line if right one
   EAD0 CD 99 E9      [16] 1691         CALL    GETLN           ; Get line number to DE
   EAD3 FE 2C         [ 6] 1692         CP      #","             ; Another line number?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 32.
Hexadecimal [16-Bits]



   EAD5 C0            [10] 1693         RET     NZ              ; No - Drop through
   EAD6 C3 CB EA      [ 9] 1694         JP      ONGOLP          ; Yes - loop
                           1695 
   EAD9 CD 0B ED      [16] 1696 IF:     CALL    EVAL            ; Evaluate expression
   EADC 7E            [ 6] 1697         LD      A,(HL)          ; Get token
   EADD FE 88         [ 6] 1698         CP      #ZGOTO           ; "GOTO" token?
   EADF CA E7 EA      [ 9] 1699         JP      Z,IFGO          ; Yes - Get line
   EAE2 CD 90 E6      [16] 1700         CALL    CHKSYN          ; Make sure it's "THEN"
   EAE5 A9                 1701         .db      ZTHEN           ; "THEN" token
   EAE6 2B            [ 4] 1702         DEC     HL              ; Cancel increment
   EAE7 CD F5 EC      [16] 1703 IFGO:   CALL    TSTNUM          ; Make sure it's numeric
   EAEA CD B6 F6      [16] 1704         CALL    TSTSGN          ; Test state of expression
   EAED CA 53 EA      [ 9] 1705         JP      Z,REM           ; False - Drop through
   EAF0 CD 36 E8      [16] 1706         CALL    GETCHR          ; Get next character
   EAF3 DA 15 EA      [ 9] 1707         JP      C,GOTO          ; Number - GOTO that line
   EAF6 C3 1D E8      [ 9] 1708         JP      IFJMP           ; Otherwise do statement
                           1709 
   EAF9 2B            [ 4] 1710 MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
   EAFA CD 36 E8      [16] 1711         CALL    GETCHR          ; Get next character
   EAFD CA 5B EB      [ 9] 1712 PRINT:  JP      Z,PRNTCR        ; CRLF if just PRINT
   EB00 C8            [10] 1713 PRNTLP: RET     Z               ; End of list - Exit
   EB01 FE A5         [ 6] 1714         CP      #ZTAB            ; "TAB(" token?
   EB03 CA 87 EB      [ 9] 1715         JP      Z,DOTAB         ; Yes - Do TAB routine
   EB06 FE A8         [ 6] 1716         CP      #ZSPC            ; "SPC(" token?
   EB08 CA 87 EB      [ 9] 1717         JP      Z,DOTAB         ; Yes - Do SPC routine
   EB0B E5            [11] 1718         PUSH    HL              ; Save code string address
   EB0C FE 2C         [ 6] 1719         CP      #","             ; Comma?
   EB0E CA 72 EB      [ 9] 1720         JP      Z,DOCOM         ; Yes - Move to next zone
   EB11 FE 3B         [ 6] 1721         CP      #";"             ; Semi-colon?
   EB13 CA A8 EB      [ 9] 1722         JP      Z,NEXITM        ; Do semi-colon routine
   EB16 C1            [ 9] 1723         POP     BC              ; Code string address to BC
   EB17 CD 0B ED      [16] 1724         CALL    EVAL            ; Evaluate expression
   EB1A E5            [11] 1725         PUSH    HL              ; Save code string address
   EB1B 3A AD 10      [12] 1726         LD      A,(TYPE)        ; Get variable type
   EB1E B7            [ 4] 1727         OR      A               ; Is it a string variable?
   EB1F C2 47 EB      [ 9] 1728         JP      NZ,PRNTST       ; Yes - Output string contents
   EB22 CD 15 F8      [16] 1729         CALL    NUMASC          ; Convert number to text
   EB25 CD 50 F1      [16] 1730         CALL    CRTST           ; Create temporary string
   EB28 36 20         [ 9] 1731         LD      (HL),#" "        ; Followed by a space
   EB2A 2A E4 10      [15] 1732         LD      HL,(FPREG)      ; Get length of output
   EB2D 34            [10] 1733         INC     (HL)            ; Plus 1 for the space
   EB2E 2A E4 10      [15] 1734         LD      HL,(FPREG)      ; < Not needed >
   EB31 3A 42 10      [12] 1735         LD      A,(LWIDTH)      ; Get width of line
   EB34 47            [ 4] 1736         LD      B,A             ; To B
   EB35 04            [ 4] 1737         INC     B               ; Width 255 (No limit)?
   EB36 CA 43 EB      [ 9] 1738         JP      Z,PRNTNB        ; Yes - Output number string
   EB39 04            [ 4] 1739         INC     B               ; Adjust it
   EB3A 3A AB 10      [12] 1740         LD      A,(CURPOS)      ; Get cursor position
   EB3D 86            [ 6] 1741         ADD     A,(HL)          ; Add length of string
   EB3E 3D            [ 4] 1742         DEC     A               ; Adjust it
   EB3F B8            [ 4] 1743         CP      B               ; Will output fit on this line?
   EB40 D4 5B EB      [16] 1744         CALL    NC,PRNTCR       ; No - CRLF first
   EB43 CD 88 F1      [16] 1745 PRNTNB: CALL    PRS1            ; Output string at (HL)
   EB46 AF            [ 4] 1746         XOR     A               ; Skip CALL by setting "Z" flag
   EB47 C4 88 F1      [16] 1747 PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 33.
Hexadecimal [16-Bits]



   EB4A E1            [ 9] 1748         POP     HL              ; Restore code string address
   EB4B C3 F9 EA      [ 9] 1749         JP      MRPRNT          ; See if more to PRINT
                           1750 
   EB4E 3A AB 10      [12] 1751 STTLIN: LD      A,(CURPOS)      ; Make sure on new line
   EB51 B7            [ 4] 1752         OR      A               ; Already at start?
   EB52 C8            [10] 1753         RET     Z               ; Yes - Do nothing
   EB53 C3 5B EB      [ 9] 1754         JP      PRNTCR          ; Start a new line
                           1755 
   EB56 36 00         [ 9] 1756 ENDINP: LD      (HL),#0          ; Mark end of buffer
   EB58 21 60 10      [ 9] 1757         LD      HL,#BUFFER-1     ; Point to buffer
   EB5B 3E 0D         [ 6] 1758 PRNTCR: LD      A,#CR            ; Load a CR
   EB5D CD 9B E6      [16] 1759         CALL    OUTC            ; Output character
   EB60 AF            [ 4] 1760 DONULL: XOR     A               ; Set to position 0
   EB61 32 AB 10      [13] 1761         LD      (CURPOS),A      ; Store it
   EB64 3A 41 10      [12] 1762         LD      A,(NULLS)       ; Get number of nulls
   EB67 3D            [ 4] 1763 NULLP:  DEC     A               ; Count them
   EB68 C8            [10] 1764         RET     Z               ; Return if done
   EB69 F5            [11] 1765         PUSH    AF              ; Save count
   EB6A AF            [ 4] 1766         XOR     A               ; Load a null
   EB6B CD 9B E6      [16] 1767         CALL    OUTC            ; Output it
   EB6E F1            [ 9] 1768         POP     AF              ; Restore count
   EB6F C3 67 EB      [ 9] 1769         JP      NULLP           ; Keep counting
                           1770 
   EB72 3A 43 10      [12] 1771 DOCOM:  LD      A,(COMMAN)      ; Get comma width
   EB75 47            [ 4] 1772         LD      B,A             ; Save in B
   EB76 3A AB 10      [12] 1773         LD      A,(CURPOS)      ; Get current position
   EB79 B8            [ 4] 1774         CP      B               ; Within the limit?
   EB7A D4 5B EB      [16] 1775         CALL    NC,PRNTCR       ; No - output CRLF
   EB7D D2 A8 EB      [ 9] 1776         JP      NC,NEXITM       ; Get next item
a  EB80               [ 9] 1777 ZONELP: SUB     14              ; Next zone of 14 characters
   EB80 D2 80 EB      [ 9] 1778         JP      NC,ZONELP       ; Repeat if more zones
   EB83 2F            [ 3] 1779         CPL                     ; Number of spaces to output
   EB84 C3 9D EB      [ 9] 1780         JP      ASPCS           ; Output them
                           1781 
   EB87 F5            [11] 1782 DOTAB:  PUSH    AF              ; Save token
   EB88 CD C5 F3      [16] 1783         CALL    FNDNUM          ; Evaluate expression
   EB8B CD 90 E6      [16] 1784         CALL    CHKSYN          ; Make sure ")" follows
   EB8E 29                 1785         .db      ")"
   EB8F 2B            [ 4] 1786         DEC     HL              ; Back space on to ")"
   EB90 F1            [ 9] 1787         POP     AF              ; Restore token
a  EB91               [ 9] 1788         SUB     ZSPC            ; Was it "SPC(" ?
   EB91 E5            [11] 1789         PUSH    HL              ; Save code string address
   EB92 CA 98 EB      [ 9] 1790         JP      Z,DOSPC         ; Yes - Do "E" spaces
   EB95 3A AB 10      [12] 1791         LD      A,(CURPOS)      ; Get current position
   EB98 2F            [ 3] 1792 DOSPC:  CPL                     ; Number of spaces to print to
   EB99 83            [ 4] 1793         ADD     A,E             ; Total number to print
   EB9A D2 A8 EB      [ 9] 1794         JP      NC,NEXITM       ; TAB < Current POS(X)
   EB9D 3C            [ 4] 1795 ASPCS:  INC     A               ; Output A spaces
   EB9E 47            [ 4] 1796         LD      B,A             ; Save number to print
   EB9F 3E 20         [ 6] 1797         LD      A,#" "           ; Space
   EBA1 CD 9B E6      [16] 1798 SPCLP:  CALL    OUTC            ; Output character in A
   EBA4 05            [ 4] 1799         DEC     B               ; Count them
   EBA5 C2 A1 EB      [ 9] 1800         JP      NZ,SPCLP        ; Repeat if more
   EBA8 E1            [ 9] 1801 NEXITM: POP     HL              ; Restore code string address
   EBA9 CD 36 E8      [16] 1802         CALL    GETCHR          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 34.
Hexadecimal [16-Bits]



   EBAC C3 00 EB      [ 9] 1803         JP      PRNTLP          ; More to print
                           1804 
q  EBAF 3F                 1805 REDO:   .db      "?Redo from start",CR,LF,0
                           1806 
   EBB0 3A CD 10      [12] 1807 BADINP: LD      A,(READFG)      ; READ or INPUT?
   EBB3 B7            [ 4] 1808         OR      A
   EBB4 C2 A7 E3      [ 9] 1809         JP      NZ,DATSNR       ; READ - ?SN Error
   EBB7 C1            [ 9] 1810         POP     BC              ; Throw away code string addr
a  EBB8               [ 9] 1811         LD      HL,REDO         ; "Redo from start" message
   EBB8 CD 85 F1      [16] 1812         CALL    PRS             ; Output string
   EBBB C3 F8 E4      [ 9] 1813         JP      DOAGN           ; Do last INPUT again
                           1814 
   EBBE CD 0A F1      [16] 1815 INPUT:  CALL    IDTEST          ; Test for illegal direct
   EBC1 7E            [ 6] 1816         LD      A,(HL)          ; Get character after "INPUT"
   EBC2 FE 22         [ 6] 1817         CP      #'"'             ; Is there a prompt string?"
   EBC4 3E 00         [ 6] 1818         LD      A,#0             ; Clear A and leave flags
   EBC6 32 45 10      [13] 1819         LD      (CTLOFG),A      ; Enable output
   EBC9 C2 D8 EB      [ 9] 1820         JP      NZ,NOPMPT       ; No prompt - get input
   EBCC CD 51 F1      [16] 1821         CALL    QTSTR           ; Get string terminated by '"'
   EBCF CD 90 E6      [16] 1822         CALL    CHKSYN          ; Check for ";" after prompt
   EBD2 3B                 1823         .db      ";"
   EBD3 E5            [11] 1824         PUSH    HL              ; Save code string address
   EBD4 CD 88 F1      [16] 1825         CALL    PRS1            ; Output prompt string
   EBD7 3E                 1826         .db      0x3E             ; Skip "PUSH HL"
   EBD8 E5            [11] 1827 NOPMPT: PUSH    HL              ; Save code string address
   EBD9 CD FC E4      [16] 1828         CALL    PROMPT          ; Get input with "? " prompt
   EBDC C1            [ 9] 1829         POP     BC              ; Restore code string address
   EBDD DA 77 E8      [ 9] 1830         JP      C,INPBRK        ; Break pressed - Exit
   EBE0 23            [ 4] 1831         INC     HL              ; Next byte
   EBE1 7E            [ 6] 1832         LD      A,(HL)          ; Get it
   EBE2 B7            [ 4] 1833         OR      A               ; End of line?
   EBE3 2B            [ 4] 1834         DEC     HL              ; Back again
   EBE4 C5            [11] 1835         PUSH    BC              ; Re-save code string address
   EBE5 CA 50 EA      [ 9] 1836         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
   EBE8 36 2C         [ 9] 1837         LD      (HL),#","        ; Store comma as separator
   EBEA C3 F2 EB      [ 9] 1838         JP      NXTITM          ; Get next item
                           1839 
   EBED E5            [11] 1840 READ:   PUSH    HL              ; Save code string address
   EBEE 2A DC 10      [15] 1841         LD      HL,(NXTDAT)     ; Next DATA statement
   EBF1 F6                 1842         .db      0x0F6            ; Flag "READ"
   EBF2 AF            [ 4] 1843 NXTITM: XOR     A               ; Flag "INPUT"
   EBF3 32 CD 10      [13] 1844         LD      (READFG),A      ; Save "READ"/"INPUT" flag
   EBF6 E3            [16] 1845         EX      (SP),HL         ; Get code str' , Save pointer
   EBF7 C3 FE EB      [ 9] 1846         JP      GTVLUS          ; Get values
                           1847 
   EBFA CD 90 E6      [16] 1848 NEDMOR: CALL    CHKSYN          ; Check for comma between items
   EBFD 2C                 1849         .db      ","
   EBFE CD D9 EE      [16] 1850 GTVLUS: CALL    GETVAR          ; Get variable name
   EC01 E3            [16] 1851         EX      (SP),HL         ; Save code str" , Get pointer
   EC02 D5            [11] 1852         PUSH    DE              ; Save variable address
   EC03 7E            [ 6] 1853         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
   EC04 FE 2C         [ 6] 1854         CP      #","             ; Comma?
   EC06 CA 26 EC      [ 9] 1855         JP      Z,ANTVLU        ; Yes - Get another value
   EC09 3A CD 10      [12] 1856         LD      A,(READFG)      ; Is it READ?
   EC0C B7            [ 4] 1857         OR      A
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 35.
Hexadecimal [16-Bits]



   EC0D C2 83 EC      [ 9] 1858         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
   EC10 3E 3F         [ 6] 1859         LD      A,#"?"           ; More INPUT needed
   EC12 CD 9B E6      [16] 1860         CALL    OUTC            ; Output character
   EC15 CD FC E4      [16] 1861         CALL    PROMPT          ; Get INPUT with prompt
   EC18 D1            [ 9] 1862         POP     DE              ; Variable address
   EC19 C1            [ 9] 1863         POP     BC              ; Code string address
   EC1A DA 77 E8      [ 9] 1864         JP      C,INPBRK        ; Break pressed
   EC1D 23            [ 4] 1865         INC     HL              ; Point to next DATA byte
   EC1E 7E            [ 6] 1866         LD      A,(HL)          ; Get byte
   EC1F B7            [ 4] 1867         OR      A               ; Is it zero (No input) ?
   EC20 2B            [ 4] 1868         DEC     HL              ; Back space INPUT pointer
   EC21 C5            [11] 1869         PUSH    BC              ; Save code string address
   EC22 CA 50 EA      [ 9] 1870         JP      Z,NXTDTA        ; Find end of buffer
   EC25 D5            [11] 1871         PUSH    DE              ; Save variable address
   EC26 3A AD 10      [12] 1872 ANTVLU: LD      A,(TYPE)        ; Check data type
   EC29 B7            [ 4] 1873         OR      A               ; Is it numeric?
   EC2A CA 50 EC      [ 9] 1874         JP      Z,INPBIN        ; Yes - Convert to binary
   EC2D CD 36 E8      [16] 1875         CALL    GETCHR          ; Get next character
   EC30 57            [ 4] 1876         LD      D,A             ; Save input character
   EC31 47            [ 4] 1877         LD      B,A             ; Again
   EC32 FE 22         [ 6] 1878         CP      #'"'             ; Start of literal sting?"
   EC34 CA 44 EC      [ 9] 1879         JP      Z,STRENT        ; Yes - Create string entry
   EC37 3A CD 10      [12] 1880         LD      A,(READFG)      ; "READ" or "INPUT" ?
   EC3A B7            [ 4] 1881         OR      A
   EC3B 57            [ 4] 1882         LD      D,A             ; Save 00 if "INPUT"
   EC3C CA 41 EC      [ 9] 1883         JP      Z,ITMSEP        ; "INPUT" - End with 00
   EC3F 16 3A         [ 6] 1884         LD      D,#":"           ; "DATA" - End with 00 or ":"
   EC41 06 2C         [ 6] 1885 ITMSEP: LD      B,#","           ; Item separator
   EC43 2B            [ 4] 1886         DEC     HL              ; Back space for DTSTR
   EC44 CD 52 F1      [16] 1887 STRENT: CALL    DTSTR           ; Get string terminated by D
   EC47 EB            [ 3] 1888         EX      DE,HL           ; String address to DE
   EC48 21 5B EC      [ 9] 1889         LD      HL,#LTSTND       ; Where to go after LETSTR
   EC4B E3            [16] 1890         EX      (SP),HL         ; Save HL , get input pointer
   EC4C D5            [11] 1891         PUSH    DE              ; Save address of string
   EC4D C3 7F EA      [ 9] 1892         JP      LETSTR          ; Assign string to variable
                           1893 
   EC50 CD 36 E8      [16] 1894 INPBIN: CALL    GETCHR          ; Get next character
   EC53 CD 8B F7      [16] 1895         CALL    ASCTFP          ; Convert ASCII to FP number
   EC56 E3            [16] 1896         EX      (SP),HL         ; Save input ptr, Get var addr
   EC57 CD FA F6      [16] 1897         CALL    FPTHL           ; Move FPREG to variable
   EC5A E1            [ 9] 1898         POP     HL              ; Restore input pointer
   EC5B 2B            [ 4] 1899 LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
   EC5C CD 36 E8      [16] 1900         CALL    GETCHR          ; Get next character
   EC5F CA 67 EC      [ 9] 1901         JP      Z,MORDT         ; End of line - More needed?
   EC62 FE 2C         [ 6] 1902         CP      #","             ; Another value?
   EC64 C2 B0 EB      [ 9] 1903         JP      NZ,BADINP       ; No - Bad input
   EC67 E3            [16] 1904 MORDT:  EX      (SP),HL         ; Get code string address
   EC68 2B            [ 4] 1905         DEC     HL              ; DEC 'cos GETCHR INCs
   EC69 CD 36 E8      [16] 1906         CALL    GETCHR          ; Get next character
   EC6C C2 FA EB      [ 9] 1907         JP      NZ,NEDMOR       ; More needed - Get it
   EC6F D1            [ 9] 1908         POP     DE              ; Restore DATA pointer
   EC70 3A CD 10      [12] 1909         LD      A,(READFG)      ; "READ" or "INPUT" ?
   EC73 B7            [ 4] 1910         OR      A
   EC74 EB            [ 3] 1911         EX      DE,HL           ; DATA pointer to HL
   EC75 C2 5C E8      [ 9] 1912         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 36.
Hexadecimal [16-Bits]



   EC78 D5            [11] 1913         PUSH    DE              ; Save code string address
   EC79 B6            [ 6] 1914         OR      (HL)            ; More input given?
   EC7A 21 82 EC      [ 9] 1915         LD      HL,#EXTIG        ; "?Extra ignored" message
   EC7D C4 85 F1      [16] 1916         CALL    NZ,PRS          ; Output string if extra given
   EC80 E1            [ 9] 1917         POP     HL              ; Restore code string address
   EC81 C9            [ 9] 1918         RET
                           1919 
q  EC82 3F                 1920 EXTIG:  .db      "?Extra ignored",CR,LF,0
                           1921 
   EC83 CD 51 EA      [16] 1922 FDTLP:  CALL    DATA            ; Get next statement
   EC86 B7            [ 4] 1923         OR      A               ; End of line?
   EC87 C2 9C EC      [ 9] 1924         JP      NZ,FANDT        ; No - See if DATA statement
   EC8A 23            [ 4] 1925         INC     HL
   EC8B 7E            [ 6] 1926         LD      A,(HL)          ; End of program?
   EC8C 23            [ 4] 1927         INC     HL
   EC8D B6            [ 6] 1928         OR      (HL)            ; 00 00 Ends program
   EC8E 1E 06         [ 6] 1929         LD      E,#OD            ; ?OD Error
   EC90 CA C1 E3      [ 9] 1930         JP      Z,ERROR         ; Yes - Out of DATA
   EC93 23            [ 4] 1931         INC     HL
   EC94 5E            [ 6] 1932         LD      E,(HL)          ; LSB of line number
   EC95 23            [ 4] 1933         INC     HL
   EC96 56            [ 6] 1934         LD      D,(HL)          ; MSB of line number
   EC97 EB            [ 3] 1935         EX      DE,HL
   EC98 22 C9 10      [16] 1936         LD      (DATLIN),HL     ; Set line of current DATA item
   EC9B EB            [ 3] 1937         EX      DE,HL
   EC9C CD 36 E8      [16] 1938 FANDT:  CALL    GETCHR          ; Get next character
   EC9F FE 83         [ 6] 1939         CP      #ZDATA           ; "DATA" token
   ECA1 C2 83 EC      [ 9] 1940         JP      NZ,FDTLP        ; No "DATA" - Keep looking
   ECA4 C3 26 EC      [ 9] 1941         JP      ANTVLU          ; Found - Convert input
                           1942 
   ECA7 11 00 00      [ 9] 1943 NEXT:   LD      DE,#0            ; In case no index given
   ECAA C4 D9 EE      [16] 1944 NEXT1:  CALL    NZ,GETVAR       ; Get index address
   ECAD 22 CE 10      [16] 1945         LD      (BRKLIN),HL     ; Save code string address
   ECB0 CD 56 E3      [16] 1946         CALL    BAKSTK          ; Look for "FOR" block
   ECB3 C2 B3 E3      [ 9] 1947         JP      NZ,NFERR        ; No "FOR" - ?NF Error
   ECB6 F9            [ 4] 1948         LD      SP,HL           ; Clear nested loops
   ECB7 D5            [11] 1949         PUSH    DE              ; Save index address
   ECB8 7E            [ 6] 1950         LD      A,(HL)          ; Get sign of STEP
   ECB9 23            [ 4] 1951         INC     HL
   ECBA F5            [11] 1952         PUSH    AF              ; Save sign of STEP
   ECBB D5            [11] 1953         PUSH    DE              ; Save index address
   ECBC CD E3 F6      [16] 1954         CALL    PHLTFP          ; Move index value to FPREG
   ECBF E3            [16] 1955         EX      (SP),HL         ; Save address of TO value
   ECC0 E5            [11] 1956         PUSH    HL              ; Save address of index
   ECC1 CD CB F4      [16] 1957         CALL    ADDPHL          ; Add STEP to index value
   ECC4 E1            [ 9] 1958         POP     HL              ; Restore address of index
   ECC5 CD FA F6      [16] 1959         CALL    FPTHL           ; Move value to index variable
   ECC8 E1            [ 9] 1960         POP     HL              ; Restore address of TO value
   ECC9 CD F1 F6      [16] 1961         CALL    LOADFP          ; Move TO value to BCDE
   ECCC E5            [11] 1962         PUSH    HL              ; Save address of line of FOR
   ECCD CD 15 F7      [16] 1963         CALL    CMPNUM          ; Compare index with TO value
   ECD0 E1            [ 9] 1964         POP     HL              ; Restore address of line num
   ECD1 C1            [ 9] 1965         POP     BC              ; Address of sign of STEP
   ECD2 90            [ 4] 1966         SUB     B               ; Compare with expected sign
   ECD3 CD F1 F6      [16] 1967         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 37.
Hexadecimal [16-Bits]



   ECD6 CA E2 EC      [ 9] 1968         JP      Z,KILFOR        ; Loop finished - Terminate it
   ECD9 EB            [ 3] 1969         EX      DE,HL           ; Loop statement line number
   ECDA 22 5C 10      [16] 1970         LD      (LINEAT),HL     ; Set loop line number
   ECDD 69            [ 4] 1971         LD      L,C             ; Set code string to loop
   ECDE 60            [ 4] 1972         LD      H,B
   ECDF C3 EE E7      [ 9] 1973         JP      PUTFID          ; Put back "FOR" and continue
                           1974 
   ECE2 F9            [ 4] 1975 KILFOR: LD      SP,HL           ; Remove "FOR" block
   ECE3 2A CE 10      [15] 1976         LD      HL,(BRKLIN)     ; Code string after "NEXT"
   ECE6 7E            [ 6] 1977         LD      A,(HL)          ; Get next byte in code string
   ECE7 FE 2C         [ 6] 1978         CP      #","             ; More NEXTs ?
   ECE9 C2 F2 E7      [ 9] 1979         JP      NZ,RUNCNT       ; No - Do next statement
   ECEC CD 36 E8      [16] 1980         CALL    GETCHR          ; Position to index name
   ECEF CD AA EC      [16] 1981         CALL    NEXT1           ; Re-enter NEXT routine
                           1982 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           1983 
   ECF2 CD 0B ED      [16] 1984 GETNUM: CALL    EVAL            ; Get a numeric expression
   ECF5 F6                 1985 TSTNUM: .db      0x0F6            ; Clear carry (numeric)
   ECF6 37            [ 3] 1986 TSTSTR: SCF                     ; Set carry (string)
   ECF7 3A AD 10      [12] 1987 CHKTYP: LD      A,(TYPE)        ; Check types match
   ECFA 8F            [ 4] 1988         ADC     A,A             ; Expected + actual
   ECFB B7            [ 4] 1989         OR      A               ; Clear carry , set parity
   ECFC E8            [10] 1990         RET     PE              ; Even parity - Types match
   ECFD C3 BF E3      [ 9] 1991         JP      TMERR           ; Different types - Error
                           1992 
                           1993 ; <<< NO REFERENCE TO HERE >>>
                           1994 
   ED00 CD 90 E6      [16] 1995         CALL    CHKSYN          ; Make sure "=" follows
   ED03 B4                 1996         .db      ZEQUAL          ; "="
   ED04 C3 0B ED      [ 9] 1997         JP      EVAL            ; Evaluate expression
                           1998 
   ED07 CD 90 E6      [16] 1999 OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
   ED0A 28                 2000         .db      #"("
   ED0B 2B            [ 4] 2001 EVAL:   DEC     HL              ; Evaluate expression & save
   ED0C 16 00         [ 6] 2002         LD      D,#0             ; Precedence value
   ED0E D5            [11] 2003 EVAL1:  PUSH    DE              ; Save precedence
   ED0F 0E 01         [ 6] 2004         LD      C,#1
   ED11 CD 8A E3      [16] 2005         CALL    CHKSTK          ; Check for 1 level of stack
   ED14 CD 82 ED      [16] 2006         CALL    OPRND           ; Get next expression value
   ED17 22 D0 10      [16] 2007 EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
   ED1A 2A D0 10      [15] 2008 EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
   ED1D C1            [ 9] 2009         POP     BC              ; Precedence value and operator
   ED1E 78            [ 4] 2010         LD      A,B             ; Get precedence value
   ED1F FE 78         [ 6] 2011         CP      #0x78             ; "AND" or "OR" ?
   ED21 D4 F5 EC      [16] 2012         CALL    NC,TSTNUM       ; No - Make sure it's a number
   ED24 7E            [ 6] 2013         LD      A,(HL)          ; Get next operator / function
   ED25 16 00         [ 6] 2014         LD      D,#0             ; Clear Last relation
   ED27 D6 B3         [ 6] 2015 RLTLP:  SUB     #ZGTR            ; ">" Token
   ED29 DA 43 ED      [ 9] 2016         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
   ED2C FE 03         [ 6] 2017         CP      #ZLTH+1-ZGTR     ; < = >
   ED2E D2 43 ED      [ 9] 2018         JP      NC,FOPRND       ; Function - Call it
   ED31 FE 01         [ 6] 2019         CP      #ZEQUAL-ZGTR     ; "="
   ED33 17            [ 3] 2020         RLA                     ; <- Test for legal
   ED34 AA            [ 4] 2021         XOR     D               ; <- combinations of < = >
   ED35 BA            [ 4] 2022         CP      D               ; <- by combining last token
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 38.
Hexadecimal [16-Bits]



   ED36 57            [ 4] 2023         LD      D,A             ; <- with current one
   ED37 DA AD E3      [ 9] 2024         JP      C,SNERR         ; Error if "<<" "==" or ">>"
   ED3A 22 C5 10      [16] 2025         LD      (CUROPR),HL     ; Save address of current token
   ED3D CD 36 E8      [16] 2026         CALL    GETCHR          ; Get next character
   ED40 C3 27 ED      [ 9] 2027         JP      RLTLP           ; Treat the two as one
                           2028 
   ED43 7A            [ 4] 2029 FOPRND: LD      A,D             ; < = > found ?
   ED44 B7            [ 4] 2030         OR      A
   ED45 C2 59 EE      [ 9] 2031         JP      NZ,TSTRED       ; Yes - Test for reduction
   ED48 7E            [ 6] 2032         LD      A,(HL)          ; Get operator token
   ED49 22 C5 10      [16] 2033         LD      (CUROPR),HL     ; Save operator address
   ED4C D6 AC         [ 6] 2034         SUB     #ZPLUS           ; Operator or function?
   ED4E D8            [10] 2035         RET     C               ; Neither - Exit
   ED4F FE 07         [ 6] 2036         CP      #ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
   ED51 D0            [10] 2037         RET     NC              ; No - Exit
   ED52 5F            [ 4] 2038         LD      E,A             ; Coded operator
   ED53 3A AD 10      [12] 2039         LD      A,(TYPE)        ; Get data type
   ED56 3D            [ 4] 2040         DEC     A               ; FF = numeric , 00 = string
   ED57 B3            [ 4] 2041         OR      E               ; Combine with coded operator
   ED58 7B            [ 4] 2042         LD      A,E             ; Get coded operator
   ED59 CA 60 F2      [ 9] 2043         JP      Z,CONCAT        ; String concatenation
   ED5C 07            [ 3] 2044         RLCA                    ; Times 2
   ED5D 83            [ 4] 2045         ADD     A,E             ; Times 3
   ED5E 5F            [ 4] 2046         LD      E,A             ; To DE (D is 0)
   ED5F 21 A4 E2      [ 9] 2047         LD      HL,#PRITAB       ; Precedence table
   ED62 19            [ 7] 2048         ADD     HL,DE           ; To the operator concerned
   ED63 78            [ 4] 2049         LD      A,B             ; Last operator precedence
   ED64 56            [ 6] 2050         LD      D,(HL)          ; Get evaluation precedence
   ED65 BA            [ 4] 2051         CP      D               ; Compare with eval precedence
   ED66 D0            [10] 2052         RET     NC              ; Exit if higher precedence
   ED67 23            [ 4] 2053         INC     HL              ; Point to routine address
   ED68 CD F5 EC      [16] 2054         CALL    TSTNUM          ; Make sure it's a number
                           2055 
   ED6B C5            [11] 2056 STKTHS: PUSH    BC              ; Save last precedence & token
   ED6C 01 1A ED      [ 9] 2057         LD      BC,#EVAL3        ; Where to go on prec' break
   ED6F C5            [11] 2058         PUSH    BC              ; Save on stack for return
   ED70 43            [ 4] 2059         LD      B,E             ; Save operator
   ED71 4A            [ 4] 2060         LD      C,D             ; Save precedence
   ED72 CD D6 F6      [16] 2061         CALL    STAKFP          ; Move value to stack
   ED75 58            [ 4] 2062         LD      E,B             ; Restore operator
   ED76 51            [ 4] 2063         LD      D,C             ; Restore precedence
   ED77 4E            [ 6] 2064         LD      C,(HL)          ; Get LSB of routine address
   ED78 23            [ 4] 2065         INC     HL
   ED79 46            [ 6] 2066         LD      B,(HL)          ; Get MSB of routine address
   ED7A 23            [ 4] 2067         INC     HL
   ED7B C5            [11] 2068         PUSH    BC              ; Save routine address
   ED7C 2A C5 10      [15] 2069         LD      HL,(CUROPR)     ; Address of current operator
   ED7F C3 0E ED      [ 9] 2070         JP      EVAL1           ; Loop until prec' break
                           2071 
   ED82 AF            [ 4] 2072 OPRND:  XOR     A               ; Get operand routine
   ED83 32 AD 10      [13] 2073         LD      (TYPE),A        ; Set numeric expected
   ED86 CD 36 E8      [16] 2074         CALL    GETCHR          ; Get next character
   ED89 1E 24         [ 6] 2075         LD      E,#MO            ; ?MO Error
   ED8B CA C1 E3      [ 9] 2076         JP      Z,ERROR         ; No operand - Error
   ED8E DA 8B F7      [ 9] 2077         JP      C,ASCTFP        ; Number - Get value
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 39.
Hexadecimal [16-Bits]



   ED91 CD 74 E9      [16] 2078         CALL    CHKLTR          ; See if a letter
   ED94 D2 D3 ED      [ 9] 2079         JP      NC,CONVAR       ; Letter - Find variable
   ED97 FE AC         [ 6] 2080         CP      #ZPLUS           ; "+" Token ?
   ED99 CA 82 ED      [ 9] 2081         JP      Z,OPRND         ; Yes - Look for operand
   ED9C FE 2E         [ 6] 2082         CP      #"."             ; "." ?
   ED9E CA 8B F7      [ 9] 2083         JP      Z,ASCTFP        ; Yes - Create FP number
   EDA1 FE AD         [ 6] 2084         CP      #ZMINUS          ; "-" Token ?
   EDA3 CA C2 ED      [ 9] 2085         JP      Z,MINUS         ; Yes - Do minus
   EDA6 FE 22         [ 6] 2086         CP      #'"'             ; Literal string ?"
   EDA8 CA 51 F1      [ 9] 2087         JP      Z,QTSTR         ; Get string terminated by '"'
   EDAB FE AA         [ 6] 2088         CP      #ZNOT            ; "NOT" Token ?
   EDAD CA B7 EE      [ 9] 2089         JP      Z,EVNOT         ; Yes - Eval NOT expression
   EDB0 FE A7         [ 6] 2090         CP      #ZFN             ; "FN" Token ?
   EDB2 CA C5 F0      [ 9] 2091         JP      Z,DOFN          ; Yes - Do FN routine
   EDB5 D6 B6         [ 6] 2092         SUB     #ZSGN            ; Is it a function?
   EDB7 D2 E4 ED      [ 9] 2093         JP      NC,FNOFST       ; Yes - Evaluate function
   EDBA CD 07 ED      [16] 2094 EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
   EDBD CD 90 E6      [16] 2095         CALL    CHKSYN          ; Make sure ")" follows
   EDC0 29                 2096         .db      ")"
   EDC1 C9            [ 9] 2097         RET
                           2098 
   EDC2 16 7D         [ 6] 2099 MINUS:  LD      D,#0x7D           ; "-" precedence
   EDC4 CD 0E ED      [16] 2100         CALL    EVAL1           ; Evaluate until prec' break
   EDC7 2A D0 10      [15] 2101         LD      HL,(NXTOPR)     ; Get next operator address
   EDCA E5            [11] 2102         PUSH    HL              ; Save next operator address
   EDCB CD D3 F6      [16] 2103         CALL    INVSGN          ; Negate value
   EDCE CD F5 EC      [16] 2104 RETNUM: CALL    TSTNUM          ; Make sure it's a number
   EDD1 E1            [ 9] 2105         POP     HL              ; Restore next operator address
   EDD2 C9            [ 9] 2106         RET
                           2107 
   EDD3 CD D9 EE      [16] 2108 CONVAR: CALL    GETVAR          ; Get variable address to DE
   EDD6 E5            [11] 2109 FRMEVL: PUSH    HL              ; Save code string address
   EDD7 EB            [ 3] 2110         EX      DE,HL           ; Variable address to HL
   EDD8 22 E4 10      [16] 2111         LD      (FPREG),HL      ; Save address of variable
   EDDB 3A AD 10      [12] 2112         LD      A,(TYPE)        ; Get type
   EDDE B7            [ 4] 2113         OR      A               ; Numeric?
   EDDF CC E3 F6      [16] 2114         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
   EDE2 E1            [ 9] 2115         POP     HL              ; Restore code string address
   EDE3 C9            [ 9] 2116         RET
                           2117 
   EDE4 06 00         [ 6] 2118 FNOFST: LD      B,#0             ; Get address of function
   EDE6 07            [ 3] 2119         RLCA                    ; Double function offset
   EDE7 4F            [ 4] 2120         LD      C,A             ; BC = Offset in function table
   EDE8 C5            [11] 2121         PUSH    BC              ; Save adjusted token value
   EDE9 CD 36 E8      [16] 2122         CALL    GETCHR          ; Get next character
   EDEC 79            [ 4] 2123         LD      A,C             ; Get adjusted token value
   EDED FE 22         [ 6] 2124         CP      #2*(ZPOINT-ZSGN) ; Adjusted "POINT" token?
   EDEF CA 84 FC      [ 9] 2125         JP      Z,POINTB        ; Yes - Do "POINT" (not POINTB)
   EDF2 FE 2D         [ 6] 2126         CP      #2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
   EDF4 DA 10 EE      [ 9] 2127         JP      C,FNVAL         ; No - Do function
   EDF7 CD 07 ED      [16] 2128         CALL    OPNPAR          ; Evaluate expression  (X,...
   EDFA CD 90 E6      [16] 2129         CALL    CHKSYN          ; Make sure "," follows
   EDFD 2C                 2130         .db     #","
   EDFE CD F6 EC      [16] 2131         CALL    TSTSTR          ; Make sure it's a string
   EE01 EB            [ 3] 2132         EX      DE,HL           ; Save code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 40.
Hexadecimal [16-Bits]



   EE02 2A E4 10      [15] 2133         LD      HL,(FPREG)      ; Get address of string
   EE05 E3            [16] 2134         EX      (SP),HL         ; Save address of string
   EE06 E5            [11] 2135         PUSH    HL              ; Save adjusted token value
   EE07 EB            [ 3] 2136         EX      DE,HL           ; Restore code string address
   EE08 CD C8 F3      [16] 2137         CALL    GETINT          ; Get integer 0-255
   EE0B EB            [ 3] 2138         EX      DE,HL           ; Save code string address
   EE0C E3            [16] 2139         EX      (SP),HL         ; Save integer,HL = adj' token
   EE0D C3 18 EE      [ 9] 2140         JP      GOFUNC          ; Jump to string function
                           2141 
   EE10 CD BA ED      [16] 2142 FNVAL:  CALL    EVLPAR          ; Evaluate expression
   EE13 E3            [16] 2143         EX      (SP),HL         ; HL = Adjusted token value
   EE14 11 CE ED      [ 9] 2144         LD      DE,#RETNUM       ; Return number from function
   EE17 D5            [11] 2145         PUSH    DE              ; Save on stack
   EE18 01 0F E1      [ 9] 2146 GOFUNC: LD      BC,#FNCTAB       ; Function routine addresses
   EE1B 09            [ 7] 2147         ADD     HL,BC           ; Point to right address
   EE1C 4E            [ 6] 2148         LD      C,(HL)          ; Get LSB of address
   EE1D 23            [ 4] 2149         INC     HL              ;
   EE1E 66            [ 6] 2150         LD      H,(HL)          ; Get MSB of address
   EE1F 69            [ 4] 2151         LD      L,C             ; Address to HL
   EE20 E9            [ 3] 2152         JP      (HL)            ; Jump to function
                           2153 
   EE21 15            [ 4] 2154 SGNEXP: DEC     D               ; Dee to flag negative exponent
   EE22 FE AD         [ 6] 2155         CP      #ZMINUS          ; "-" token ?
   EE24 C8            [10] 2156         RET     Z               ; Yes - Return
   EE25 FE 2D         [ 6] 2157         CP      #"-"             ; "-" ASCII ?
   EE27 C8            [10] 2158         RET     Z               ; Yes - Return
   EE28 14            [ 4] 2159         INC     D               ; Inc to flag positive exponent
   EE29 FE 2B         [ 6] 2160         CP      #"+"             ; "+" ASCII ?
   EE2B C8            [10] 2161         RET     Z               ; Yes - Return
   EE2C FE AC         [ 6] 2162         CP      #ZPLUS           ; "+" token ?
   EE2E C8            [10] 2163         RET     Z               ; Yes - Return
   EE2F 2B            [ 4] 2164         DEC     HL              ; DEC 'cos GETCHR INCs
   EE30 C9            [ 9] 2165         RET                     ; Return "NZ"
                           2166 
   EE31 F6                 2167 POR:    .db      0x0F6            ; Flag "OR"
   EE32 AF            [ 4] 2168 PAND:   XOR     A               ; Flag "AND"
   EE33 F5            [11] 2169         PUSH    AF              ; Save "AND" / "OR" flag
   EE34 CD F5 EC      [16] 2170         CALL    TSTNUM          ; Make sure it's a number
   EE37 CD 88 E9      [16] 2171         CALL    DEINT           ; Get integer -32768 to 32767
   EE3A F1            [ 9] 2172         POP     AF              ; Restore "AND" / "OR" flag
   EE3B EB            [ 3] 2173         EX      DE,HL           ; <- Get last
   EE3C C1            [ 9] 2174         POP     BC              ; <-  value
   EE3D E3            [16] 2175         EX      (SP),HL         ; <-  from
   EE3E EB            [ 3] 2176         EX      DE,HL           ; <-  stack
   EE3F CD E6 F6      [16] 2177         CALL    FPBCDE          ; Move last value to FPREG
   EE42 F5            [11] 2178         PUSH    AF              ; Save "AND" / "OR" flag
   EE43 CD 88 E9      [16] 2179         CALL    DEINT           ; Get integer -32768 to 32767
   EE46 F1            [ 9] 2180         POP     AF              ; Restore "AND" / "OR" flag
   EE47 C1            [ 9] 2181         POP     BC              ; Get value
   EE48 79            [ 4] 2182         LD      A,C             ; Get LSB
   EE49 21 8D F0      [ 9] 2183         LD      HL,#ACPASS       ; Address of save AC as current
   EE4C C2 54 EE      [ 9] 2184         JP      NZ,POR1         ; Jump if OR
   EE4F A3            [ 4] 2185         AND     E               ; "AND" LSBs
   EE50 4F            [ 4] 2186         LD      C,A             ; Save LSB
   EE51 78            [ 4] 2187         LD      A,B             ; Get MBS
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 41.
Hexadecimal [16-Bits]



   EE52 A2            [ 4] 2188         AND     D               ; "AND" MSBs
   EE53 E9            [ 3] 2189         JP      (HL)            ; Save AC as current (ACPASS)
                           2190 
   EE54 B3            [ 4] 2191 POR1:   OR      E               ; "OR" LSBs
   EE55 4F            [ 4] 2192         LD      C,A             ; Save LSB
   EE56 78            [ 4] 2193         LD      A,B             ; Get MSB
   EE57 B2            [ 4] 2194         OR      D               ; "OR" MSBs
   EE58 E9            [ 3] 2195         JP      (HL)            ; Save AC as current (ACPASS)
                           2196 
   EE59 21 6B EE      [ 9] 2197 TSTRED: LD      HL,#CMPLOG       ; Logical compare routine
   EE5C 3A AD 10      [12] 2198         LD      A,(TYPE)        ; Get data type
   EE5F 1F            [ 3] 2199         RRA                     ; Carry set = string
   EE60 7A            [ 4] 2200         LD      A,D             ; Get last precedence value
   EE61 17            [ 3] 2201         RLA                     ; Times 2 plus carry
   EE62 5F            [ 4] 2202         LD      E,A             ; To E
   EE63 16 64         [ 6] 2203         LD      D,#0x64           ; Relational precedence
   EE65 78            [ 4] 2204         LD      A,B             ; Get current precedence
   EE66 BA            [ 4] 2205         CP      D               ; Compare with last
   EE67 D0            [10] 2206         RET     NC              ; Eval if last was rel' or log'
   EE68 C3 6B ED      [ 9] 2207         JP      STKTHS          ; Stack this one and get next
                           2208 
   EE6B 6D EE              2209 CMPLOG: .dw      CMPLG1          ; Compare two values / strings
   EE6D 79            [ 4] 2210 CMPLG1: LD      A,C             ; Get data type
   EE6E B7            [ 4] 2211         OR      A
   EE6F 1F            [ 3] 2212         RRA
   EE70 C1            [ 9] 2213         POP     BC              ; Get last expression to BCDE
   EE71 D1            [ 9] 2214         POP     DE
   EE72 F5            [11] 2215         PUSH    AF              ; Save status
   EE73 CD F7 EC      [16] 2216         CALL    CHKTYP          ; Check that types match
   EE76 21 AF EE      [ 9] 2217         LD      HL,#CMPRES       ; Result to comparison
   EE79 E5            [11] 2218         PUSH    HL              ; Save for RETurn
   EE7A CA 15 F7      [ 9] 2219         JP      Z,CMPNUM        ; Compare values if numeric
   EE7D AF            [ 4] 2220         XOR     A               ; Compare two strings
   EE7E 32 AD 10      [13] 2221         LD      (TYPE),A        ; Set type to numeric
   EE81 D5            [11] 2222         PUSH    DE              ; Save string name
   EE82 CD A8 F2      [16] 2223         CALL    GSTRCU          ; Get current string
   EE85 7E            [ 6] 2224         LD      A,(HL)          ; Get length of string
   EE86 23            [ 4] 2225         INC     HL
   EE87 23            [ 4] 2226         INC     HL
   EE88 4E            [ 6] 2227         LD      C,(HL)          ; Get LSB of address
   EE89 23            [ 4] 2228         INC     HL
   EE8A 46            [ 6] 2229         LD      B,(HL)          ; Get MSB of address
   EE8B D1            [ 9] 2230         POP     DE              ; Restore string name
   EE8C C5            [11] 2231         PUSH    BC              ; Save address of string
   EE8D F5            [11] 2232         PUSH    AF              ; Save length of string
   EE8E CD AC F2      [16] 2233         CALL    GSTRDE          ; Get second string
   EE91 CD F1 F6      [16] 2234         CALL    LOADFP          ; Get address of second string
   EE94 F1            [ 9] 2235         POP     AF              ; Restore length of string 1
   EE95 57            [ 4] 2236         LD      D,A             ; Length to D
   EE96 E1            [ 9] 2237         POP     HL              ; Restore address of string 1
   EE97 7B            [ 4] 2238 CMPSTR: LD      A,E             ; Bytes of string 2 to do
   EE98 B2            [ 4] 2239         OR      D               ; Bytes of string 1 to do
   EE99 C8            [10] 2240         RET     Z               ; Exit if all bytes compared
   EE9A 7A            [ 4] 2241         LD      A,D             ; Get bytes of string 1 to do
   EE9B D6 01         [ 6] 2242         SUB     #1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 42.
Hexadecimal [16-Bits]



   EE9D D8            [10] 2243         RET     C               ; Exit if end of string 1
   EE9E AF            [ 4] 2244         XOR     A
   EE9F BB            [ 4] 2245         CP      E               ; Bytes of string 2 to do
   EEA0 3C            [ 4] 2246         INC     A
   EEA1 D0            [10] 2247         RET     NC              ; Exit if end of string 2
   EEA2 15            [ 4] 2248         DEC     D               ; Count bytes in string 1
   EEA3 1D            [ 4] 2249         DEC     E               ; Count bytes in string 2
   EEA4 0A            [ 6] 2250         LD      A,(BC)          ; Byte in string 2
   EEA5 BE            [ 6] 2251         CP      (HL)            ; Compare to byte in string 1
   EEA6 23            [ 4] 2252         INC     HL              ; Move up string 1
   EEA7 03            [ 4] 2253         INC     BC              ; Move up string 2
   EEA8 CA 97 EE      [ 9] 2254         JP      Z,CMPSTR        ; Same - Try next bytes
   EEAB 3F            [ 3] 2255         CCF                     ; Flag difference (">" or "<")
   EEAC C3 C1 F6      [ 9] 2256         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                           2257 
   EEAF 3C            [ 4] 2258 CMPRES: INC     A               ; Increment current value
   EEB0 8F            [ 4] 2259         ADC     A,A             ; Double plus carry
   EEB1 C1            [ 9] 2260         POP     BC              ; Get other value
   EEB2 A0            [ 4] 2261         AND     B               ; Combine them
a  EEB3               [ 4] 2262         ADD     A,-1            ; Carry set if different
   EEB3 9F            [ 4] 2263         SBC     A,A             ; 00 - Equal , FF - Different
   EEB4 C3 C8 F6      [ 9] 2264         JP      FLGREL          ; Set current value & continue
                           2265 
   EEB7 16 5A         [ 6] 2266 EVNOT:  LD      D,#0x5A           ; Precedence value for "NOT"
   EEB9 CD 0E ED      [16] 2267         CALL    EVAL1           ; Eval until precedence break
   EEBC CD F5 EC      [16] 2268         CALL    TSTNUM          ; Make sure it's a number
   EEBF CD 88 E9      [16] 2269         CALL    DEINT           ; Get integer -32768 - 32767
   EEC2 7B            [ 4] 2270         LD      A,E             ; Get LSB
   EEC3 2F            [ 3] 2271         CPL                     ; Invert LSB
   EEC4 4F            [ 4] 2272         LD      C,A             ; Save "NOT" of LSB
   EEC5 7A            [ 4] 2273         LD      A,D             ; Get MSB
   EEC6 2F            [ 3] 2274         CPL                     ; Invert MSB
   EEC7 CD 8D F0      [16] 2275         CALL    ACPASS          ; Save AC as current
   EECA C1            [ 9] 2276         POP     BC              ; Clean up stack
   EECB C3 1A ED      [ 9] 2277         JP      EVAL3           ; Continue evaluation
                           2278 
   EECE 2B            [ 4] 2279 DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
   EECF CD 36 E8      [16] 2280         CALL    GETCHR          ; Get next character
   EED2 C8            [10] 2281         RET     Z               ; End of DIM statement
   EED3 CD 90 E6      [16] 2282         CALL    CHKSYN          ; Make sure "," follows
   EED6 2C                 2283         .db      ","
a  EED7               [ 4] 2284 DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
   EED7 C5            [11] 2285         PUSH    BC              ; Save on stack
   EED8 F6                 2286         .db      0x0F6            ; Flag "Create" variable
   EED9 AF            [ 4] 2287 GETVAR: XOR     A               ; Find variable address,to DE
   EEDA 32 AC 10      [13] 2288         LD      (LCRFLG),A      ; Set locate / create flag
   EEDD 46            [ 6] 2289         LD      B,(HL)          ; Get First byte of name
   EEDE CD 74 E9      [16] 2290 GTFNAM: CALL    CHKLTR          ; See if a letter
   EEE1 DA AD E3      [ 9] 2291         JP      C,SNERR         ; ?SN Error if not a letter
   EEE4 AF            [ 4] 2292         XOR     A
   EEE5 4F            [ 4] 2293         LD      C,A             ; Clear second byte of name
   EEE6 32 AD 10      [13] 2294         LD      (TYPE),A        ; Set type to numeric
   EEE9 CD 36 E8      [16] 2295         CALL    GETCHR          ; Get next character
   EEEC DA F5 EE      [ 9] 2296         JP      C,SVNAM2        ; Numeric - Save in name
   EEEF CD 74 E9      [16] 2297         CALL    CHKLTR          ; See if a letter
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 43.
Hexadecimal [16-Bits]



q  EEF2 DA CA 00      [ 9] 2298         JP      C,0xCARTY        ; Not a letter - Check type
   EEF5 4F            [ 4] 2299 SVNAM2: LD      C,A             ; Save second byte of name
   EEF6 CD 36 E8      [16] 2300 ENDNAM: CALL    GETCHR          ; Get next character
   EEF9 DA F6 EE      [ 9] 2301         JP      C,ENDNAM        ; Numeric - Get another
   EEFC CD 74 E9      [16] 2302         CALL    CHKLTR          ; See if a letter
   EEFF D2 F6 EE      [ 9] 2303         JP      NC,ENDNAM       ; Letter - Get another
q                          2304 0xCARTY: SUB     #"$"             ; String variable?
   EF02 C2 0F EF      [ 9] 2305         JP      NZ,NOTSTR       ; No - Numeric variable
   EF05 3C            [ 4] 2306         INC     A               ; A = 1 (string type)
   EF06 32 AD 10      [13] 2307         LD      (TYPE),A        ; Set type to string
   EF09 0F            [ 3] 2308         RRCA                    ; A = 0x80 , Flag for string
   EF0A 81            [ 4] 2309         ADD     A,C             ; 2nd byte of name has bit 7 on
   EF0B 4F            [ 4] 2310         LD      C,A             ; Resave second byte on name
   EF0C CD 36 E8      [16] 2311         CALL    GETCHR          ; Get next character
   EF0F 3A CB 10      [12] 2312 NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
   EF12 3D            [ 4] 2313         DEC     A
   EF13 CA B9 EF      [ 9] 2314         JP      Z,ARLDSV        ; Yes - Get array name
   EF16 F2 1F EF      [ 9] 2315         JP      P,NSCFOR        ; No array with "FOR" or "FN"
   EF19 7E            [ 6] 2316         LD      A,(HL)          ; Get byte again
   EF1A D6 28         [ 6] 2317         SUB     #"("             ; Subscripted variable?
   EF1C CA 91 EF      [ 9] 2318         JP      Z,SBSCPT        ; Yes - Sort out subscript
                           2319 
   EF1F AF            [ 4] 2320 NSCFOR: XOR     A               ; Simple variable
   EF20 32 CB 10      [13] 2321         LD      (FORFLG),A      ; Clear "FOR" flag
   EF23 E5            [11] 2322         PUSH    HL              ; Save code string address
   EF24 50            [ 4] 2323         LD      D,B             ; DE = Variable name to find
   EF25 59            [ 4] 2324         LD      E,C
   EF26 2A DE 10      [15] 2325         LD      HL,(FNRGNM)     ; FN argument name
   EF29 CD 8A E6      [16] 2326         CALL    CPDEHL          ; Is it the FN argument?
a  EF2C               [16] 2327         LD      DE,FNARG        ; Point to argument value
   EF2C CA 0E F6      [ 9] 2328         JP      Z,POPHRT        ; Yes - Return FN argument value
   EF2F 2A D8 10      [15] 2329         LD      HL,(VAREND)     ; End of variables
   EF32 EB            [ 3] 2330         EX      DE,HL           ; Address of end of search
   EF33 2A D6 10      [15] 2331         LD      HL,(PROGND)     ; Start of variables address
   EF36 CD 8A E6      [16] 2332 FNDVAR: CALL    CPDEHL          ; End of variable list table?
   EF39 CA 4F EF      [ 9] 2333         JP      Z,CFEVAL        ; Yes - Called from EVAL?
   EF3C 79            [ 4] 2334         LD      A,C             ; Get second byte of name
   EF3D 96            [ 6] 2335         SUB     (HL)            ; Compare with name in list
   EF3E 23            [ 4] 2336         INC     HL              ; Move on to first byte
   EF3F C2 44 EF      [ 9] 2337         JP      NZ,FNTHR        ; Different - Find another
   EF42 78            [ 4] 2338         LD      A,B             ; Get first byte of name
   EF43 96            [ 6] 2339         SUB     (HL)            ; Compare with name in list
   EF44 23            [ 4] 2340 FNTHR:  INC     HL              ; Move on to LSB of value
   EF45 CA 83 EF      [ 9] 2341         JP      Z,RETADR        ; Found - Return address
   EF48 23            [ 4] 2342         INC     HL              ; <- Skip
   EF49 23            [ 4] 2343         INC     HL              ; <- over
   EF4A 23            [ 4] 2344         INC     HL              ; <- F.P.
   EF4B 23            [ 4] 2345         INC     HL              ; <- value
   EF4C C3 36 EF      [ 9] 2346         JP      FNDVAR          ; Keep looking
                           2347 
   EF4F E1            [ 9] 2348 CFEVAL: POP     HL              ; Restore code string address
   EF50 E3            [16] 2349         EX      (SP),HL         ; Get return address
   EF51 D5            [11] 2350         PUSH    DE              ; Save address of variable
   EF52 11 D6 ED      [ 9] 2351         LD      DE,#FRMEVL       ; Return address in EVAL
   EF55 CD 8A E6      [16] 2352         CALL    CPDEHL          ; Called from EVAL ?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 44.
Hexadecimal [16-Bits]



   EF58 D1            [ 9] 2353         POP     DE              ; Restore address of variable
   EF59 CA 86 EF      [ 9] 2354         JP      Z,RETNUL        ; Yes - Return null variable
   EF5C E3            [16] 2355         EX      (SP),HL         ; Put back return
   EF5D E5            [11] 2356         PUSH    HL              ; Save code string address
   EF5E C5            [11] 2357         PUSH    BC              ; Save variable name
   EF5F 01 06 00      [ 9] 2358         LD      BC,#6            ; 2 byte name plus 4 byte data
   EF62 2A DA 10      [15] 2359         LD      HL,(ARREND)     ; End of arrays
   EF65 E5            [11] 2360         PUSH    HL              ; Save end of arrays
   EF66 09            [ 7] 2361         ADD     HL,BC           ; Move up 6 bytes
   EF67 C1            [ 9] 2362         POP     BC              ; Source address in BC
   EF68 E5            [11] 2363         PUSH    HL              ; Save new end address
   EF69 CD 79 E3      [16] 2364         CALL    MOVUP           ; Move arrays up
   EF6C E1            [ 9] 2365         POP     HL              ; Restore new end address
   EF6D 22 DA 10      [16] 2366         LD      (ARREND),HL     ; Set new end address
   EF70 60            [ 4] 2367         LD      H,B             ; End of variables to HL
   EF71 69            [ 4] 2368         LD      L,C
   EF72 22 D8 10      [16] 2369         LD      (VAREND),HL     ; Set new end address
                           2370 
   EF75 2B            [ 4] 2371 ZEROLP: DEC     HL              ; Back through to zero variable
   EF76 36 00         [ 9] 2372         LD      (HL),#0          ; Zero byte in variable
   EF78 CD 8A E6      [16] 2373         CALL    CPDEHL          ; Done them all?
   EF7B C2 75 EF      [ 9] 2374         JP      NZ,ZEROLP       ; No - Keep on going
   EF7E D1            [ 9] 2375         POP     DE              ; Get variable name
   EF7F 73            [ 7] 2376         LD      (HL),E          ; Store second character
   EF80 23            [ 4] 2377         INC     HL
   EF81 72            [ 7] 2378         LD      (HL),D          ; Store first character
   EF82 23            [ 4] 2379         INC     HL
   EF83 EB            [ 3] 2380 RETADR: EX      DE,HL           ; Address of variable in DE
   EF84 E1            [ 9] 2381         POP     HL              ; Restore code string address
   EF85 C9            [ 9] 2382         RET
                           2383 
   EF86 32 E7 10      [13] 2384 RETNUL: LD      (FPEXP),A       ; Set result to zero
   EF89 21 FF FF      [ 9] 2385         LD      HL,#ZERBYT       ; Also set a null string
   EF8C 22 E4 10      [16] 2386         LD      (FPREG),HL      ; Save for EVAL
   EF8F E1            [ 9] 2387         POP     HL              ; Restore code string address
   EF90 C9            [ 9] 2388         RET
                           2389 
   EF91 E5            [11] 2390 SBSCPT: PUSH    HL              ; Save code string address
   EF92 2A AC 10      [15] 2391         LD      HL,(LCRFLG)     ; Locate/Create and Type
   EF95 E3            [16] 2392         EX      (SP),HL         ; Save and get code string
   EF96 57            [ 4] 2393         LD      D,A             ; Zero number of dimensions
   EF97 D5            [11] 2394 SCPTLP: PUSH    DE              ; Save number of dimensions
   EF98 C5            [11] 2395         PUSH    BC              ; Save array name
   EF99 CD 7C E9      [16] 2396         CALL    FPSINT          ; Get subscript (0-32767)
   EF9C C1            [ 9] 2397         POP     BC              ; Restore array name
   EF9D F1            [ 9] 2398         POP     AF              ; Get number of dimensions
   EF9E EB            [ 3] 2399         EX      DE,HL
   EF9F E3            [16] 2400         EX      (SP),HL         ; Save subscript value
   EFA0 E5            [11] 2401         PUSH    HL              ; Save LCRFLG and TYPE
   EFA1 EB            [ 3] 2402         EX      DE,HL
   EFA2 3C            [ 4] 2403         INC     A               ; Count dimensions
   EFA3 57            [ 4] 2404         LD      D,A             ; Save in D
   EFA4 7E            [ 6] 2405         LD      A,(HL)          ; Get next byte in code string
   EFA5 FE 2C         [ 6] 2406         CP      #","             ; Comma (more to come)?
   EFA7 CA 97 EF      [ 9] 2407         JP      Z,SCPTLP        ; Yes - More subscripts
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 45.
Hexadecimal [16-Bits]



   EFAA CD 90 E6      [16] 2408         CALL    CHKSYN          ; Make sure ")" follows
   EFAD 29                 2409         .db     # ")"
   EFAE 22 D0 10      [16] 2410         LD      (NXTOPR),HL     ; Save code string address
   EFB1 E1            [ 9] 2411         POP     HL              ; Get LCRFLG and TYPE
   EFB2 22 AC 10      [16] 2412         LD      (LCRFLG),HL     ; Restore Locate/create & type
   EFB5 1E 00         [ 6] 2413         LD      E,#0             ; Flag not CSAVE* or CLOAD*
   EFB7 D5            [11] 2414         PUSH    DE              ; Save number of dimensions (D)
   EFB8 11                 2415         .db      0x11             ; Skip "PUSH HL" and "PUSH AF'
                           2416 
   EFB9 E5            [11] 2417 ARLDSV: PUSH    HL              ; Save code string address
   EFBA F5            [11] 2418         PUSH    AF              ; A = 00 , Flags set = Z,N
   EFBB 2A D8 10      [15] 2419         LD      HL,(VAREND)     ; Start of arrays
   EFBE 3E                 2420         .db      0x3E             ; Skip "ADD HL,DE"
   EFBF 19            [ 7] 2421 FNDARY: ADD     HL,DE           ; Move to next array start
   EFC0 EB            [ 3] 2422         EX      DE,HL
   EFC1 2A DA 10      [15] 2423         LD      HL,(ARREND)     ; End of arrays
   EFC4 EB            [ 3] 2424         EX      DE,HL           ; Current array pointer
   EFC5 CD 8A E6      [16] 2425         CALL    CPDEHL          ; End of arrays found?
   EFC8 CA F1 EF      [ 9] 2426         JP      Z,CREARY        ; Yes - Create array
   EFCB 7E            [ 6] 2427         LD      A,(HL)          ; Get second byte of name
   EFCC B9            [ 4] 2428         CP      C               ; Compare with name given
   EFCD 23            [ 4] 2429         INC     HL              ; Move on
   EFCE C2 D3 EF      [ 9] 2430         JP      NZ,NXTARY       ; Different - Find next array
   EFD1 7E            [ 6] 2431         LD      A,(HL)          ; Get first byte of name
   EFD2 B8            [ 4] 2432         CP      B               ; Compare with name given
   EFD3 23            [ 4] 2433 NXTARY: INC     HL              ; Move on
   EFD4 5E            [ 6] 2434         LD      E,(HL)          ; Get LSB of next array address
   EFD5 23            [ 4] 2435         INC     HL
   EFD6 56            [ 6] 2436         LD      D,(HL)          ; Get MSB of next array address
   EFD7 23            [ 4] 2437         INC     HL
   EFD8 C2 BF EF      [ 9] 2438         JP      NZ,FNDARY       ; Not found - Keep looking
   EFDB 3A AC 10      [12] 2439         LD      A,(LCRFLG)      ; Found Locate or Create it?
   EFDE B7            [ 4] 2440         OR      A
   EFDF C2 B6 E3      [ 9] 2441         JP      NZ,DDERR        ; Create - ?DD Error
   EFE2 F1            [ 9] 2442         POP     AF              ; Locate - Get number of dim'ns
   EFE3 44            [ 4] 2443         LD      B,H             ; BC Points to array dim'ns
   EFE4 4D            [ 4] 2444         LD      C,L
   EFE5 CA 0E F6      [ 9] 2445         JP      Z,POPHRT        ; Jump if array load/save
   EFE8 96            [ 6] 2446         SUB     (HL)            ; Same number of dimensions?
   EFE9 CA 47 F0      [ 9] 2447         JP      Z,FINDEL        ; Yes - Find element
   EFEC 1E 10         [ 6] 2448 BSERR:  LD      E,#BS            ; ?BS Error
   EFEE C3 C1 E3      [ 9] 2449         JP      ERROR           ; Output error
                           2450 
a  EFF1               [ 9] 2451 CREARY: LD      DE,4            ; 4 Bytes per entry
   EFF1 F1            [ 9] 2452         POP     AF              ; Array to save or 0 dim'ns?
   EFF2 CA 95 E9      [ 9] 2453         JP      Z,FCERR         ; Yes - ?FC Error
   EFF5 71            [ 7] 2454         LD      (HL),C          ; Save second byte of name
   EFF6 23            [ 4] 2455         INC     HL
   EFF7 70            [ 7] 2456         LD      (HL),B          ; Save first byte of name
   EFF8 23            [ 4] 2457         INC     HL
   EFF9 4F            [ 4] 2458         LD      C,A             ; Number of dimensions to C
   EFFA CD 8A E3      [16] 2459         CALL    CHKSTK          ; Check if enough memory
   EFFD 23            [ 4] 2460         INC     HL              ; Point to number of dimensions
   EFFE 23            [ 4] 2461         INC     HL
   EFFF 22 C5 10      [16] 2462         LD      (CUROPR),HL     ; Save address of pointer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 46.
Hexadecimal [16-Bits]



   F002 71            [ 7] 2463         LD      (HL),C          ; Set number of dimensions
   F003 23            [ 4] 2464         INC     HL
   F004 3A AC 10      [12] 2465         LD      A,(LCRFLG)      ; Locate of Create?
   F007 17            [ 3] 2466         RLA                     ; Carry set = Create
   F008 79            [ 4] 2467         LD      A,C             ; Get number of dimensions
a  F009               [ 4] 2468 CRARLP: LD      BC,10+1         ; Default dimension size 10
   F009 D2 0E F0      [ 9] 2469         JP      NC,DEFSIZ       ; Locate - Set default size
   F00C C1            [ 9] 2470         POP     BC              ; Get specified dimension size
   F00D 03            [ 4] 2471         INC     BC              ; Include zero element
   F00E 71            [ 7] 2472 DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
   F00F 23            [ 4] 2473         INC     HL
   F010 70            [ 7] 2474         LD      (HL),B          ; Save MSB of dimension size
   F011 23            [ 4] 2475         INC     HL
   F012 F5            [11] 2476         PUSH    AF              ; Save num' of dim'ns an status
   F013 E5            [11] 2477         PUSH    HL              ; Save address of dim'n size
   F014 CD 75 F7      [16] 2478         CALL    MLDEBC          ; Multiply DE by BC to find
   F017 EB            [ 3] 2479         EX      DE,HL           ; amount of mem needed (to DE)
   F018 E1            [ 9] 2480         POP     HL              ; Restore address of dimension
   F019 F1            [ 9] 2481         POP     AF              ; Restore number of dimensions
   F01A 3D            [ 4] 2482         DEC     A               ; Count them
   F01B C2 09 F0      [ 9] 2483         JP      NZ,CRARLP       ; Do next dimension if more
   F01E F5            [11] 2484         PUSH    AF              ; Save locate/create flag
   F01F 42            [ 4] 2485         LD      B,D             ; MSB of memory needed
   F020 4B            [ 4] 2486         LD      C,E             ; LSB of memory needed
   F021 EB            [ 3] 2487         EX      DE,HL
   F022 19            [ 7] 2488         ADD     HL,DE           ; Add bytes to array start
   F023 DA A2 E3      [ 9] 2489         JP      C,OMERR         ; Too big - Error
   F026 CD 93 E3      [16] 2490         CALL    ENFMEM          ; See if enough memory
   F029 22 DA 10      [16] 2491         LD      (ARREND),HL     ; Save new end of array
                           2492 
   F02C 2B            [ 4] 2493 ZERARY: DEC     HL              ; Back through array data
a  F02D               [ 4] 2494         LD      (HL),0          ; Set array element to zero
   F02D CD 8A E6      [16] 2495         CALL    CPDEHL          ; All elements zeroed?
   F030 C2 2C F0      [ 9] 2496         JP      NZ,ZERARY       ; No - Keep on going
   F033 03            [ 4] 2497         INC     BC              ; Number of bytes + 1
   F034 57            [ 4] 2498         LD      D,A             ; A=0
   F035 2A C5 10      [15] 2499         LD      HL,(CUROPR)     ; Get address of array
   F038 5E            [ 6] 2500         LD      E,(HL)          ; Number of dimensions
   F039 EB            [ 3] 2501         EX      DE,HL           ; To HL
   F03A 29            [ 7] 2502         ADD     HL,HL           ; Two bytes per dimension size
   F03B 09            [ 7] 2503         ADD     HL,BC           ; Add number of bytes
   F03C EB            [ 3] 2504         EX      DE,HL           ; Bytes needed to DE
   F03D 2B            [ 4] 2505         DEC     HL
   F03E 2B            [ 4] 2506         DEC     HL
   F03F 73            [ 7] 2507         LD      (HL),E          ; Save LSB of bytes needed
   F040 23            [ 4] 2508         INC     HL
   F041 72            [ 7] 2509         LD      (HL),D          ; Save MSB of bytes needed
   F042 23            [ 4] 2510         INC     HL
   F043 F1            [ 9] 2511         POP     AF              ; Locate / Create?
   F044 DA 6B F0      [ 9] 2512         JP      C,ENDDIM        ; A is 0 , End if create
   F047 47            [ 4] 2513 FINDEL: LD      B,A             ; Find array element
   F048 4F            [ 4] 2514         LD      C,A
   F049 7E            [ 6] 2515         LD      A,(HL)          ; Number of dimensions
   F04A 23            [ 4] 2516         INC     HL
   F04B 16                 2517         .db      0x16             ; Skip "POP HL"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 47.
Hexadecimal [16-Bits]



   F04C E1            [ 9] 2518 FNDELP: POP     HL              ; Address of next dim' size
   F04D 5E            [ 6] 2519         LD      E,(HL)          ; Get LSB of dim'n size
   F04E 23            [ 4] 2520         INC     HL
   F04F 56            [ 6] 2521         LD      D,(HL)          ; Get MSB of dim'n size
   F050 23            [ 4] 2522         INC     HL
   F051 E3            [16] 2523         EX      (SP),HL         ; Save address - Get index
   F052 F5            [11] 2524         PUSH    AF              ; Save number of dim'ns
   F053 CD 8A E6      [16] 2525         CALL    CPDEHL          ; Dimension too large?
   F056 D2 EC EF      [ 9] 2526         JP      NC,BSERR        ; Yes - ?BS Error
   F059 E5            [11] 2527         PUSH    HL              ; Save index
   F05A CD 75 F7      [16] 2528         CALL    MLDEBC          ; Multiply previous by size
   F05D D1            [ 9] 2529         POP     DE              ; Index supplied to DE
   F05E 19            [ 7] 2530         ADD     HL,DE           ; Add index to pointer
   F05F F1            [ 9] 2531         POP     AF              ; Number of dimensions
   F060 3D            [ 4] 2532         DEC     A               ; Count them
   F061 44            [ 4] 2533         LD      B,H             ; MSB of pointer
   F062 4D            [ 4] 2534         LD      C,L             ; LSB of pointer
   F063 C2 4C F0      [ 9] 2535         JP      NZ,FNDELP       ; More - Keep going
   F066 29            [ 7] 2536         ADD     HL,HL           ; 4 Bytes per element
   F067 29            [ 7] 2537         ADD     HL,HL
   F068 C1            [ 9] 2538         POP     BC              ; Start of array
   F069 09            [ 7] 2539         ADD     HL,BC           ; Point to element
   F06A EB            [ 3] 2540         EX      DE,HL           ; Address of element to DE
   F06B 2A D0 10      [15] 2541 ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
   F06E C9            [ 9] 2542         RET
                           2543 
   F06F 2A DA 10      [15] 2544 FRE:    LD      HL,(ARREND)     ; Start of free memory
   F072 EB            [ 3] 2545         EX      DE,HL           ; To DE
a  F073               [ 3] 2546         LD      HL,0            ; End of free memory
   F073 39            [ 7] 2547         ADD     HL,SP           ; Current stack value
   F074 3A AD 10      [12] 2548         LD      A,(TYPE)        ; Dummy argument type
   F077 B7            [ 4] 2549         OR      A
   F078 CA 88 F0      [ 9] 2550         JP      Z,FRENUM        ; Numeric - Free variable space
   F07B CD A8 F2      [16] 2551         CALL    GSTRCU          ; Current string to pool
   F07E CD BF F1      [16] 2552         CALL    GARBGE          ; Garbage collection
   F081 2A 5A 10      [15] 2553         LD      HL,(STRSPC)     ; Bottom of string space in use
   F084 EB            [ 3] 2554         EX      DE,HL           ; To DE
   F085 2A C3 10      [15] 2555         LD      HL,(STRBOT)     ; Bottom of string space
   F088 7D            [ 4] 2556 FRENUM: LD      A,L             ; Get LSB of end
   F089 93            [ 4] 2557         SUB     E               ; Subtract LSB of beginning
   F08A 4F            [ 4] 2558         LD      C,A             ; Save difference if C
   F08B 7C            [ 4] 2559         LD      A,H             ; Get MSB of end
   F08C 9A            [ 4] 2560         SBC     A,D             ; Subtract MSB of beginning
   F08D 41            [ 4] 2561 ACPASS: LD      B,C             ; Return integer AC
   F08E 50            [ 4] 2562 ABPASS: LD      D,B             ; Return integer AB
a  F08F               [ 4] 2563         LD      E,0
a  F08F               [ 4] 2564         LD      HL,TYPE         ; Point to type
   F08F 73            [ 7] 2565         LD      (HL),E          ; Set type to numeric
a  F090               [ 7] 2566         LD      B,0x80+16        ; 16 bit integer
   F090 C3 C8 F6      [ 9] 2567         JP      RETINT          ; Return the integr
                           2568 
   F093 3A AB 10      [12] 2569 POS:    LD      A,(CURPOS)      ; Get cursor position
   F096 47            [ 4] 2570 PASSA:  LD      B,A             ; Put A into AB
   F097 AF            [ 4] 2571         XOR     A               ; Zero A
   F098 C3 8E F0      [ 9] 2572         JP      ABPASS          ; Return integer AB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 48.
Hexadecimal [16-Bits]



                           2573 
q  F09B CD CE 00      [16] 2574 DEF:    CALL    0xCEKFN          ; Get "FN" and name
   F09E CD 0A F1      [16] 2575         CALL    IDTEST          ; Test for illegal direct
a  F0A1               [16] 2576         LD      BC,DATA         ; To get next statement
   F0A1 C5            [11] 2577         PUSH    BC              ; Save address for RETurn
   F0A2 D5            [11] 2578         PUSH    DE              ; Save address of function ptr
   F0A3 CD 90 E6      [16] 2579         CALL    CHKSYN          ; Make sure "(" follows
   F0A6 28                 2580         .db      "("
   F0A7 CD D9 EE      [16] 2581         CALL    GETVAR          ; Get argument variable name
   F0AA E5            [11] 2582         PUSH    HL              ; Save code string address
   F0AB EB            [ 3] 2583         EX      DE,HL           ; Argument address to HL
   F0AC 2B            [ 4] 2584         DEC     HL
   F0AD 56            [ 6] 2585         LD      D,(HL)          ; Get first byte of arg name
   F0AE 2B            [ 4] 2586         DEC     HL
   F0AF 5E            [ 6] 2587         LD      E,(HL)          ; Get second byte of arg name
   F0B0 E1            [ 9] 2588         POP     HL              ; Restore code string address
   F0B1 CD F5 EC      [16] 2589         CALL    TSTNUM          ; Make sure numeric argument
   F0B4 CD 90 E6      [16] 2590         CALL    CHKSYN          ; Make sure ")" follows
   F0B7 29                 2591         .db      ")"
   F0B8 CD 90 E6      [16] 2592         CALL    CHKSYN          ; Make sure "=" follows
   F0BB B4                 2593         .db      ZEQUAL          ; "=" token
   F0BC 44            [ 4] 2594         LD      B,H             ; Code string address to BC
   F0BD 4D            [ 4] 2595         LD      C,L
   F0BE E3            [16] 2596         EX      (SP),HL         ; Save code str , Get FN ptr
   F0BF 71            [ 7] 2597         LD      (HL),C          ; Save LSB of FN code string
   F0C0 23            [ 4] 2598         INC     HL
   F0C1 70            [ 7] 2599         LD      (HL),B          ; Save MSB of FN code string
   F0C2 C3 4A F1      [ 9] 2600         JP      SVSTAD          ; Save address and do function
                           2601 
q  F0C5 CD CE 00      [16] 2602 DOFN:   CALL    0xCEKFN          ; Make sure FN follows
   F0C8 D5            [11] 2603         PUSH    DE              ; Save function pointer address
   F0C9 CD BA ED      [16] 2604         CALL    EVLPAR          ; Evaluate expression in "()"
   F0CC CD F5 EC      [16] 2605         CALL    TSTNUM          ; Make sure numeric result
   F0CF E3            [16] 2606         EX      (SP),HL         ; Save code str , Get FN ptr
   F0D0 5E            [ 6] 2607         LD      E,(HL)          ; Get LSB of FN code string
   F0D1 23            [ 4] 2608         INC     HL
   F0D2 56            [ 6] 2609         LD      D,(HL)          ; Get MSB of FN code string
   F0D3 23            [ 4] 2610         INC     HL
   F0D4 7A            [ 4] 2611         LD      A,D             ; And function DEFined?
   F0D5 B3            [ 4] 2612         OR      E
   F0D6 CA B9 E3      [ 9] 2613         JP      Z,UFERR         ; No - ?UF Error
   F0D9 7E            [ 6] 2614         LD      A,(HL)          ; Get LSB of argument address
   F0DA 23            [ 4] 2615         INC     HL
   F0DB 66            [ 6] 2616         LD      H,(HL)          ; Get MSB of argument address
   F0DC 6F            [ 4] 2617         LD      L,A             ; HL = Arg variable address
   F0DD E5            [11] 2618         PUSH    HL              ; Save it
   F0DE 2A DE 10      [15] 2619         LD      HL,(FNRGNM)     ; Get old argument name
   F0E1 E3            [16] 2620         EX      (SP),HL ;       ; Save old , Get new
   F0E2 22 DE 10      [16] 2621         LD      (FNRGNM),HL     ; Set new argument name
   F0E5 2A E2 10      [15] 2622         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
   F0E8 E5            [11] 2623         PUSH    HL              ; Save it
   F0E9 2A E0 10      [15] 2624         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
   F0EC E5            [11] 2625         PUSH    HL              ; Save it
a  F0ED               [11] 2626         LD      HL,FNARG        ; HL = Value of argument
   F0ED D5            [11] 2627         PUSH    DE              ; Save FN code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 49.
Hexadecimal [16-Bits]



   F0EE CD FA F6      [16] 2628         CALL    FPTHL           ; Move FPREG to argument
   F0F1 E1            [ 9] 2629         POP     HL              ; Get FN code string address
   F0F2 CD F2 EC      [16] 2630         CALL    GETNUM          ; Get value from function
   F0F5 2B            [ 4] 2631         DEC     HL              ; DEC 'cos GETCHR INCs
   F0F6 CD 36 E8      [16] 2632         CALL    GETCHR          ; Get next character
   F0F9 C2 AD E3      [ 9] 2633         JP      NZ,SNERR        ; Bad character in FN - Error
   F0FC E1            [ 9] 2634         POP     HL              ; Get MSB,EXP of old arg
   F0FD 22 E0 10      [16] 2635         LD      (FNARG),HL      ; Restore it
   F100 E1            [ 9] 2636         POP     HL              ; Get LSB,NLSB of old arg
   F101 22 E2 10      [16] 2637         LD      (FNARG+2),HL    ; Restore it
   F104 E1            [ 9] 2638         POP     HL              ; Get name of old arg
   F105 22 DE 10      [16] 2639         LD      (FNRGNM),HL     ; Restore it
   F108 E1            [ 9] 2640         POP     HL              ; Restore code string address
   F109 C9            [ 9] 2641         RET
                           2642 
   F10A E5            [11] 2643 IDTEST: PUSH    HL              ; Save code string address
   F10B 2A 5C 10      [15] 2644         LD      HL,(LINEAT)     ; Get current line number
   F10E 23            [ 4] 2645         INC     HL              ; -1 means direct statement
   F10F 7C            [ 4] 2646         LD      A,H
   F110 B5            [ 4] 2647         OR      L
   F111 E1            [ 9] 2648         POP     HL              ; Restore code string address
   F112 C0            [10] 2649         RET     NZ              ; Return if in program
a  F113               [10] 2650         LD      E,ID            ; ?ID Error
   F113 C3 C1 E3      [ 9] 2651         JP      ERROR
                           2652 
q                          2653 0xCEKFN: CALL    CHKSYN          ; Make sure FN follows
   F116 A7                 2654         .db      ZFN             ; "FN" token
a  F117               [ 4] 2655         LD      A,0x80
   F117 32 CB 10      [13] 2656         LD      (FORFLG),A      ; Flag FN name to find
   F11A B6            [ 6] 2657         OR      (HL)            ; FN name has bit 7 set
   F11B 47            [ 4] 2658         LD      B,A             ; in first byte of name
   F11C CD DE EE      [16] 2659         CALL    GTFNAM          ; Get FN name
   F11F C3 F5 EC      [ 9] 2660         JP      TSTNUM          ; Make sure numeric function
                           2661 
   F122 CD F5 EC      [16] 2662 STR:    CALL    TSTNUM          ; Make sure it's a number
   F125 CD 15 F8      [16] 2663         CALL    NUMASC          ; Turn number into text
   F128 CD 50 F1      [16] 2664         CALL    CRTST           ; Create string entry for it
   F12B CD A8 F2      [16] 2665         CALL    GSTRCU          ; Current string to pool
a  F12E               [16] 2666         LD      BC,TOPOOL       ; Save in string pool
   F12E C5            [11] 2667         PUSH    BC              ; Save address on stack
                           2668 
   F12F 7E            [ 6] 2669 SAVSTR: LD      A,(HL)          ; Get string length
   F130 23            [ 4] 2670         INC     HL
   F131 23            [ 4] 2671         INC     HL
   F132 E5            [11] 2672         PUSH    HL              ; Save pointer to string
   F133 CD 9C F1      [16] 2673         CALL    TESTR           ; See if enough string space
   F136 E1            [ 9] 2674         POP     HL              ; Restore pointer to string
   F137 4E            [ 6] 2675         LD      C,(HL)          ; Get LSB of address
   F138 23            [ 4] 2676         INC     HL
   F139 46            [ 6] 2677         LD      B,(HL)          ; Get MSB of address
   F13A CD 47 F1      [16] 2678         CALL    CRTMST          ; Create string entry
   F13D E5            [11] 2679         PUSH    HL              ; Save pointer to MSB of addr
   F13E 6F            [ 4] 2680         LD      L,A             ; Length of string
   F13F CD 9B F2      [16] 2681         CALL    TOSTRA          ; Move to string area
   F142 D1            [ 9] 2682         POP     DE              ; Restore pointer to MSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 50.
Hexadecimal [16-Bits]



   F143 C9            [ 9] 2683         RET
                           2684 
   F144 CD 9C F1      [16] 2685 MKTMST: CALL    TESTR           ; See if enough string space
a  F147               [16] 2686 CRTMST: LD      HL,TMPSTR       ; Temporary string
   F147 E5            [11] 2687         PUSH    HL              ; Save it
   F148 77            [ 7] 2688         LD      (HL),A          ; Save length of string
   F149 23            [ 4] 2689         INC     HL
   F14A 23            [ 4] 2690 SVSTAD: INC     HL
   F14B 73            [ 7] 2691         LD      (HL),E          ; Save LSB of address
   F14C 23            [ 4] 2692         INC     HL
   F14D 72            [ 7] 2693         LD      (HL),D          ; Save MSB of address
   F14E E1            [ 9] 2694         POP     HL              ; Restore pointer
   F14F C9            [ 9] 2695         RET
                           2696 
   F150 2B            [ 4] 2697 CRTST:  DEC     HL              ; DEC - INCed after
a  F151               [ 4] 2698 QTSTR:  LD      B,'"'           ; Terminating quote
   F151 50            [ 4] 2699         LD      D,B             ; Quote to D
   F152 E5            [11] 2700 DTSTR:  PUSH    HL              ; Save start
a  F153               [11] 2701         LD      C,-1            ; Set counter to -1
   F153 23            [ 4] 2702 QTSTLP: INC     HL              ; Move on
   F154 7E            [ 6] 2703         LD      A,(HL)          ; Get byte
   F155 0C            [ 4] 2704         INC     C               ; Count bytes
   F156 B7            [ 4] 2705         OR      A               ; End of line?
   F157 CA 62 F1      [ 9] 2706         JP      Z,CRTSTE        ; Yes - Create string entry
   F15A BA            [ 4] 2707         CP      D               ; Terminator D found?
   F15B CA 62 F1      [ 9] 2708         JP      Z,CRTSTE        ; Yes - Create string entry
   F15E B8            [ 4] 2709         CP      B               ; Terminator B found?
   F15F C2 53 F1      [ 9] 2710         JP      NZ,QTSTLP       ; No - Keep looking
a  F162               [ 9] 2711 CRTSTE: CP      '"'             ; End with '"'?
   F162 CC 36 E8      [16] 2712         CALL    Z,GETCHR        ; Yes - Get next character
   F165 E3            [16] 2713         EX      (SP),HL         ; Starting quote
   F166 23            [ 4] 2714         INC     HL              ; First byte of string
   F167 EB            [ 3] 2715         EX      DE,HL           ; To DE
   F168 79            [ 4] 2716         LD      A,C             ; Get length
   F169 CD 47 F1      [16] 2717         CALL    CRTMST          ; Create string entry
a  F16C               [16] 2718 TSTOPL: LD      DE,TMPSTR       ; Temporary string
   F16C 2A B1 10      [15] 2719         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   F16F 22 E4 10      [16] 2720         LD      (FPREG),HL      ; Save address of string ptr
a  F172               [16] 2721         LD      A,1
   F172 32 AD 10      [13] 2722         LD      (TYPE),A        ; Set type to string
   F175 CD FA F6      [16] 2723         CALL    DETHL4          ; Move string to pool
   F178 CD 8A E6      [16] 2724         CALL    CPDEHL          ; Out of string pool?
   F17B 22 B1 10      [16] 2725         LD      (TMSTPT),HL     ; Save new pointer
   F17E E1            [ 9] 2726         POP     HL              ; Restore code string address
   F17F 7E            [ 6] 2727         LD      A,(HL)          ; Get next code byte
   F180 C0            [10] 2728         RET     NZ              ; Return if pool OK
a  F181               [10] 2729         LD      E,ST            ; ?ST Error
   F181 C3 C1 E3      [ 9] 2730         JP      ERROR           ; String pool overflow
                           2731 
   F184 23            [ 4] 2732 PRNUMS: INC     HL              ; Skip leading space
   F185 CD 50 F1      [16] 2733 PRS:    CALL    CRTST           ; Create string entry for it
   F188 CD A8 F2      [16] 2734 PRS1:   CALL    GSTRCU          ; Current string to pool
   F18B CD F1 F6      [16] 2735         CALL    LOADFP          ; Move string block to BCDE
   F18E 1C            [ 4] 2736         INC     E               ; Length + 1
   F18F 1D            [ 4] 2737 PRSLP:  DEC     E               ; Count characters
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 51.
Hexadecimal [16-Bits]



   F190 C8            [10] 2738         RET     Z               ; End of string
   F191 0A            [ 6] 2739         LD      A,(BC)          ; Get byte to output
   F192 CD 9B E6      [16] 2740         CALL    OUTC            ; Output character in A
a  F195               [16] 2741         CP      CR              ; Return?
   F195 CC 60 EB      [16] 2742         CALL    Z,DONULL        ; Yes - Do nulls
   F198 03            [ 4] 2743         INC     BC              ; Next byte in string
   F199 C3 8F F1      [ 9] 2744         JP      PRSLP           ; More characters to output
                           2745 
   F19C B7            [ 4] 2746 TESTR:  OR      A               ; Test if enough room
   F19D 0E                 2747         .db      0x0E             ; No garbage collection done
   F19E F1            [ 9] 2748 GRBDON: POP     AF              ; Garbage collection done
   F19F F5            [11] 2749         PUSH    AF              ; Save status
   F1A0 2A 5A 10      [15] 2750         LD      HL,(STRSPC)     ; Bottom of string space in use
   F1A3 EB            [ 3] 2751         EX      DE,HL           ; To DE
   F1A4 2A C3 10      [15] 2752         LD      HL,(STRBOT)     ; Bottom of string area
   F1A7 2F            [ 3] 2753         CPL                     ; Negate length (Top down)
   F1A8 4F            [ 4] 2754         LD      C,A             ; -Length to BC
a  F1A9               [ 4] 2755         LD      B,-1            ; BC = -ve length of string
   F1A9 09            [ 7] 2756         ADD     HL,BC           ; Add to bottom of space in use
   F1AA 23            [ 4] 2757         INC     HL              ; Plus one for 2's complement
   F1AB CD 8A E6      [16] 2758         CALL    CPDEHL          ; Below string RAM area?
   F1AE DA B8 F1      [ 9] 2759         JP      C,TESTOS        ; Tidy up if not done else err
   F1B1 22 C3 10      [16] 2760         LD      (STRBOT),HL     ; Save new bottom of area
   F1B4 23            [ 4] 2761         INC     HL              ; Point to first byte of string
   F1B5 EB            [ 3] 2762         EX      DE,HL           ; Address to DE
   F1B6 F1            [ 9] 2763 POPAF:  POP     AF              ; Throw away status push
   F1B7 C9            [ 9] 2764         RET
                           2765 
   F1B8 F1            [ 9] 2766 TESTOS: POP     AF              ; Garbage collect been done?
a  F1B9               [ 9] 2767         LD      E,OS            ; ?OS Error
   F1B9 CA C1 E3      [ 9] 2768         JP      Z,ERROR         ; Yes - Not enough string apace
   F1BC BF            [ 4] 2769         CP      A               ; Flag garbage collect done
   F1BD F5            [11] 2770         PUSH    AF              ; Save status
a  F1BE               [11] 2771         LD      BC,GRBDON       ; Garbage collection done
   F1BE C5            [11] 2772         PUSH    BC              ; Save for RETurn
   F1BF 2A AF 10      [15] 2773 GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
   F1C2 22 C3 10      [16] 2774 GARBLP: LD      (STRBOT),HL     ; Reset string pointer
a  F1C5               [16] 2775         LD      HL,0
   F1C5 E5            [11] 2776         PUSH    HL              ; Flag no string found
   F1C6 2A 5A 10      [15] 2777         LD      HL,(STRSPC)     ; Get bottom of string space
   F1C9 E5            [11] 2778         PUSH    HL              ; Save bottom of string space
a  F1CA               [11] 2779         LD      HL,TMSTPL       ; Temporary string pool
   F1CA EB            [ 3] 2780 GRBLP:  EX      DE,HL
   F1CB 2A B1 10      [15] 2781         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   F1CE EB            [ 3] 2782         EX      DE,HL
   F1CF CD 8A E6      [16] 2783         CALL    CPDEHL          ; Temporary string pool done?
a  F1D2               [16] 2784         LD      BC,GRBLP        ; Loop until string pool done
   F1D2 C2 16 F2      [ 9] 2785         JP      NZ,STPOOL       ; No - See if in string area
   F1D5 2A D6 10      [15] 2786         LD      HL,(PROGND)     ; Start of simple variables
   F1D8 EB            [ 3] 2787 SMPVAR: EX      DE,HL
   F1D9 2A D8 10      [15] 2788         LD      HL,(VAREND)     ; End of simple variables
   F1DC EB            [ 3] 2789         EX      DE,HL
   F1DD CD 8A E6      [16] 2790         CALL    CPDEHL          ; All simple strings done?
   F1E0 CA EE F1      [ 9] 2791         JP      Z,ARRLP         ; Yes - Do string arrays
   F1E3 7E            [ 6] 2792         LD      A,(HL)          ; Get type of variable
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 52.
Hexadecimal [16-Bits]



   F1E4 23            [ 4] 2793         INC     HL
   F1E5 23            [ 4] 2794         INC     HL
   F1E6 B7            [ 4] 2795         OR      A               ; "S" flag set if string
   F1E7 CD 17 F2      [16] 2796         CALL    STRADD          ; See if string in string area
   F1EA C3 D8 F1      [ 9] 2797         JP      SMPVAR          ; Loop until simple ones done
                           2798 
   F1ED C1            [ 9] 2799 GNXARY: POP     BC              ; Scrap address of this array
   F1EE EB            [ 3] 2800 ARRLP:  EX      DE,HL
   F1EF 2A DA 10      [15] 2801         LD      HL,(ARREND)     ; End of string arrays
   F1F2 EB            [ 3] 2802         EX      DE,HL
   F1F3 CD 8A E6      [16] 2803         CALL    CPDEHL          ; All string arrays done?
   F1F6 CA 3D F2      [ 9] 2804         JP      Z,SCNEND        ; Yes - Move string if found
   F1F9 CD F1 F6      [16] 2805         CALL    LOADFP          ; Get array name to BCDE
   F1FC 7B            [ 4] 2806         LD      A,E             ; Get type of array     
   F1FD E5            [11] 2807         PUSH    HL              ; Save address of num of dim'ns
   F1FE 09            [ 7] 2808         ADD     HL,BC           ; Start of next array
   F1FF B7            [ 4] 2809         OR      A               ; Test type of array
   F200 F2 ED F1      [ 9] 2810         JP      P,GNXARY        ; Numeric array - Ignore it
   F203 22 C5 10      [16] 2811         LD      (CUROPR),HL     ; Save address of next array
   F206 E1            [ 9] 2812         POP     HL              ; Get address of num of dim'ns
   F207 4E            [ 6] 2813         LD      C,(HL)          ; BC = Number of dimensions
a  F208               [ 6] 2814         LD      B,0
   F208 09            [ 7] 2815         ADD     HL,BC           ; Two bytes per dimension size
   F209 09            [ 7] 2816         ADD     HL,BC
   F20A 23            [ 4] 2817         INC     HL              ; Plus one for number of dim'ns
   F20B EB            [ 3] 2818 GRBARY: EX      DE,HL
   F20C 2A C5 10      [15] 2819         LD      HL,(CUROPR)     ; Get address of next array
   F20F EB            [ 3] 2820         EX      DE,HL
   F210 CD 8A E6      [16] 2821         CALL    CPDEHL          ; Is this array finished?
   F213 CA EE F1      [ 9] 2822         JP      Z,ARRLP         ; Yes - Get next one
a  F216               [ 9] 2823         LD      BC,GRBARY       ; Loop until array all done
   F216 C5            [11] 2824 STPOOL: PUSH    BC              ; Save return address
a  F217               [11] 2825         OR      0x80             ; Flag string type
   F217 7E            [ 6] 2826 STRADD: LD      A,(HL)          ; Get string length
   F218 23            [ 4] 2827         INC     HL
   F219 23            [ 4] 2828         INC     HL
   F21A 5E            [ 6] 2829         LD      E,(HL)          ; Get LSB of string address
   F21B 23            [ 4] 2830         INC     HL
   F21C 56            [ 6] 2831         LD      D,(HL)          ; Get MSB of string address
   F21D 23            [ 4] 2832         INC     HL
   F21E F0            [10] 2833         RET     P               ; Not a string - Return
   F21F B7            [ 4] 2834         OR      A               ; Set flags on string length
   F220 C8            [10] 2835         RET     Z               ; Null string - Return
   F221 44            [ 4] 2836         LD      B,H             ; Save variable pointer
   F222 4D            [ 4] 2837         LD      C,L
   F223 2A C3 10      [15] 2838         LD      HL,(STRBOT)     ; Bottom of new area
   F226 CD 8A E6      [16] 2839         CALL    CPDEHL          ; String been done?
   F229 60            [ 4] 2840         LD      H,B             ; Restore variable pointer
   F22A 69            [ 4] 2841         LD      L,C
   F22B D8            [10] 2842         RET     C               ; String done - Ignore
   F22C E1            [ 9] 2843         POP     HL              ; Return address
   F22D E3            [16] 2844         EX      (SP),HL         ; Lowest available string area
   F22E CD 8A E6      [16] 2845         CALL    CPDEHL          ; String within string area?
   F231 E3            [16] 2846         EX      (SP),HL         ; Lowest available string area
   F232 E5            [11] 2847         PUSH    HL              ; Re-save return address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 53.
Hexadecimal [16-Bits]



   F233 60            [ 4] 2848         LD      H,B             ; Restore variable pointer
   F234 69            [ 4] 2849         LD      L,C
   F235 D0            [10] 2850         RET     NC              ; Outside string area - Ignore
   F236 C1            [ 9] 2851         POP     BC              ; Get return , Throw 2 away
   F237 F1            [ 9] 2852         POP     AF              ; 
   F238 F1            [ 9] 2853         POP     AF              ; 
   F239 E5            [11] 2854         PUSH    HL              ; Save variable pointer
   F23A D5            [11] 2855         PUSH    DE              ; Save address of current
   F23B C5            [11] 2856         PUSH    BC              ; Put back return address
   F23C C9            [ 9] 2857         RET                     ; Go to it
                           2858 
   F23D D1            [ 9] 2859 SCNEND: POP     DE              ; Addresses of strings
   F23E E1            [ 9] 2860         POP     HL              ; 
   F23F 7D            [ 4] 2861         LD      A,L             ; HL = 0 if no more to do
   F240 B4            [ 4] 2862         OR      H
   F241 C8            [10] 2863         RET     Z               ; No more to do - Return
   F242 2B            [ 4] 2864         DEC     HL
   F243 46            [ 6] 2865         LD      B,(HL)          ; MSB of address of string
   F244 2B            [ 4] 2866         DEC     HL
   F245 4E            [ 6] 2867         LD      C,(HL)          ; LSB of address of string
   F246 E5            [11] 2868         PUSH    HL              ; Save variable address
   F247 2B            [ 4] 2869         DEC     HL
   F248 2B            [ 4] 2870         DEC     HL
   F249 6E            [ 6] 2871         LD      L,(HL)          ; HL = Length of string
a  F24A               [ 6] 2872         LD      H,0
   F24A 09            [ 7] 2873         ADD     HL,BC           ; Address of end of string+1
   F24B 50            [ 4] 2874         LD      D,B             ; String address to DE
   F24C 59            [ 4] 2875         LD      E,C
   F24D 2B            [ 4] 2876         DEC     HL              ; Last byte in string
   F24E 44            [ 4] 2877         LD      B,H             ; Address to BC
   F24F 4D            [ 4] 2878         LD      C,L
   F250 2A C3 10      [15] 2879         LD      HL,(STRBOT)     ; Current bottom of string area
   F253 CD 7C E3      [16] 2880         CALL    MOVSTR          ; Move string to new address
   F256 E1            [ 9] 2881         POP     HL              ; Restore variable address
   F257 71            [ 7] 2882         LD      (HL),C          ; Save new LSB of address
   F258 23            [ 4] 2883         INC     HL
   F259 70            [ 7] 2884         LD      (HL),B          ; Save new MSB of address
   F25A 69            [ 4] 2885         LD      L,C             ; Next string area+1 to HL
   F25B 60            [ 4] 2886         LD      H,B
   F25C 2B            [ 4] 2887         DEC     HL              ; Next string area address
   F25D C3 C2 F1      [ 9] 2888         JP      GARBLP          ; Look for more strings
                           2889 
   F260 C5            [11] 2890 CONCAT: PUSH    BC              ; Save prec' opr & code string
   F261 E5            [11] 2891         PUSH    HL              ; 
   F262 2A E4 10      [15] 2892         LD      HL,(FPREG)      ; Get first string
   F265 E3            [16] 2893         EX      (SP),HL         ; Save first string
   F266 CD 82 ED      [16] 2894         CALL    OPRND           ; Get second string
   F269 E3            [16] 2895         EX      (SP),HL         ; Restore first string
   F26A CD F6 EC      [16] 2896         CALL    TSTSTR          ; Make sure it's a string
   F26D 7E            [ 6] 2897         LD      A,(HL)          ; Get length of second string
   F26E E5            [11] 2898         PUSH    HL              ; Save first string
   F26F 2A E4 10      [15] 2899         LD      HL,(FPREG)      ; Get second string
   F272 E5            [11] 2900         PUSH    HL              ; Save second string
   F273 86            [ 6] 2901         ADD     A,(HL)          ; Add length of second string
a  F274               [ 6] 2902         LD      E,LS            ; ?LS Error
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 54.
Hexadecimal [16-Bits]



   F274 DA C1 E3      [ 9] 2903         JP      C,ERROR         ; String too long - Error
   F277 CD 44 F1      [16] 2904         CALL    MKTMST          ; Make temporary string
   F27A D1            [ 9] 2905         POP     DE              ; Get second string to DE
   F27B CD AC F2      [16] 2906         CALL    GSTRDE          ; Move to string pool if needed
   F27E E3            [16] 2907         EX      (SP),HL         ; Get first string
   F27F CD AB F2      [16] 2908         CALL    GSTRHL          ; Move to string pool if needed
   F282 E5            [11] 2909         PUSH    HL              ; Save first string
   F283 2A C1 10      [15] 2910         LD      HL,(TMPSTR+2)   ; Temporary string address
   F286 EB            [ 3] 2911         EX      DE,HL           ; To DE
   F287 CD 92 F2      [16] 2912         CALL    SSTSA           ; First string to string area
   F28A CD 92 F2      [16] 2913         CALL    SSTSA           ; Second string to string area
a  F28D               [16] 2914         LD      HL,EVAL2        ; Return to evaluation loop
   F28D E3            [16] 2915         EX      (SP),HL         ; Save return,get code string
   F28E E5            [11] 2916         PUSH    HL              ; Save code string address
   F28F C3 6C F1      [ 9] 2917         JP      TSTOPL          ; To temporary string to pool
                           2918 
   F292 E1            [ 9] 2919 SSTSA:  POP     HL              ; Return address
   F293 E3            [16] 2920         EX      (SP),HL         ; Get string block,save return
   F294 7E            [ 6] 2921         LD      A,(HL)          ; Get length of string
   F295 23            [ 4] 2922         INC     HL
   F296 23            [ 4] 2923         INC     HL
   F297 4E            [ 6] 2924         LD      C,(HL)          ; Get LSB of string address
   F298 23            [ 4] 2925         INC     HL
   F299 46            [ 6] 2926         LD      B,(HL)          ; Get MSB of string address
   F29A 6F            [ 4] 2927         LD      L,A             ; Length to L
   F29B 2C            [ 4] 2928 TOSTRA: INC     L               ; INC - DECed after
   F29C 2D            [ 4] 2929 TSALP:  DEC     L               ; Count bytes moved
   F29D C8            [10] 2930         RET     Z               ; End of string - Return
   F29E 0A            [ 6] 2931         LD      A,(BC)          ; Get source
   F29F 12            [ 7] 2932         LD      (DE),A          ; Save destination
   F2A0 03            [ 4] 2933         INC     BC              ; Next source
   F2A1 13            [ 4] 2934         INC     DE              ; Next destination
   F2A2 C3 9C F2      [ 9] 2935         JP      TSALP           ; Loop until string moved
                           2936 
   F2A5 CD F6 EC      [16] 2937 GETSTR: CALL    TSTSTR          ; Make sure it's a string
   F2A8 2A E4 10      [15] 2938 GSTRCU: LD      HL,(FPREG)      ; Get current string
   F2AB EB            [ 3] 2939 GSTRHL: EX      DE,HL           ; Save DE
   F2AC CD C6 F2      [16] 2940 GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
   F2AF EB            [ 3] 2941         EX      DE,HL           ; Restore DE
   F2B0 C0            [10] 2942         RET     NZ              ; No - Return
   F2B1 D5            [11] 2943         PUSH    DE              ; Save string
   F2B2 50            [ 4] 2944         LD      D,B             ; String block address to DE
   F2B3 59            [ 4] 2945         LD      E,C
   F2B4 1B            [ 4] 2946         DEC     DE              ; Point to length
   F2B5 4E            [ 6] 2947         LD      C,(HL)          ; Get string length
   F2B6 2A C3 10      [15] 2948         LD      HL,(STRBOT)     ; Current bottom of string area
   F2B9 CD 8A E6      [16] 2949         CALL    CPDEHL          ; Last one in string area?
   F2BC C2 C4 F2      [ 9] 2950         JP      NZ,POPHL        ; No - Return
   F2BF 47            [ 4] 2951         LD      B,A             ; Clear B (A=0)
   F2C0 09            [ 7] 2952         ADD     HL,BC           ; Remove string from str' area
   F2C1 22 C3 10      [16] 2953         LD      (STRBOT),HL     ; Save new bottom of str' area
   F2C4 E1            [ 9] 2954 POPHL:  POP     HL              ; Restore string
   F2C5 C9            [ 9] 2955         RET
                           2956 
   F2C6 2A B1 10      [15] 2957 BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 55.
Hexadecimal [16-Bits]



   F2C9 2B            [ 4] 2958         DEC     HL              ; Back
   F2CA 46            [ 6] 2959         LD      B,(HL)          ; Get MSB of address
   F2CB 2B            [ 4] 2960         DEC     HL              ; Back
   F2CC 4E            [ 6] 2961         LD      C,(HL)          ; Get LSB of address
   F2CD 2B            [ 4] 2962         DEC     HL              ; Back
   F2CE 2B            [ 4] 2963         DEC     HL              ; Back
   F2CF CD 8A E6      [16] 2964         CALL    CPDEHL          ; String last in string pool?
   F2D2 C0            [10] 2965         RET     NZ              ; Yes - Leave it
   F2D3 22 B1 10      [16] 2966         LD      (TMSTPT),HL     ; Save new string pool top
   F2D6 C9            [ 9] 2967         RET
                           2968 
a  F2D7               [ 9] 2969 LEN:    LD      BC,PASSA        ; To return integer A
   F2D7 C5            [11] 2970         PUSH    BC              ; Save address
   F2D8 CD A5 F2      [16] 2971 GETLEN: CALL    GETSTR          ; Get string and its length
   F2DB AF            [ 4] 2972         XOR     A
   F2DC 57            [ 4] 2973         LD      D,A             ; Clear D
   F2DD 32 AD 10      [13] 2974         LD      (TYPE),A        ; Set type to numeric
   F2E0 7E            [ 6] 2975         LD      A,(HL)          ; Get length of string
   F2E1 B7            [ 4] 2976         OR      A               ; Set status flags
   F2E2 C9            [ 9] 2977         RET
                           2978 
a  F2E3               [ 9] 2979 ASC:    LD      BC,PASSA        ; To return integer A
   F2E3 C5            [11] 2980         PUSH    BC              ; Save address
   F2E4 CD D8 F2      [16] 2981 GTFLNM: CALL    GETLEN          ; Get length of string
   F2E7 CA 95 E9      [ 9] 2982         JP      Z,FCERR         ; Null string - Error
   F2EA 23            [ 4] 2983         INC     HL
   F2EB 23            [ 4] 2984         INC     HL
   F2EC 5E            [ 6] 2985         LD      E,(HL)          ; Get LSB of address
   F2ED 23            [ 4] 2986         INC     HL
   F2EE 56            [ 6] 2987         LD      D,(HL)          ; Get MSB of address
   F2EF 1A            [ 6] 2988         LD      A,(DE)          ; Get first byte of string
   F2F0 C9            [ 9] 2989         RET
                           2990 
q                          2991 0xCR:    LD      A,1             ; One character string
   F2F1 CD 44 F1      [16] 2992         CALL    MKTMST          ; Make a temporary string
   F2F4 CD CB F3      [16] 2993         CALL    MAKINT          ; Make it integer A
   F2F7 2A C1 10      [15] 2994         LD      HL,(TMPSTR+2)   ; Get address of string
   F2FA 73            [ 7] 2995         LD      (HL),E          ; Save character
   F2FB C1            [ 9] 2996 TOPOOL: POP     BC              ; Clean up stack
   F2FC C3 6C F1      [ 9] 2997         JP      TSTOPL          ; Temporary string to pool
                           2998 
   F2FF CD 7B F3      [16] 2999 LEFT:   CALL    LFRGNM          ; Get number and ending ")"
   F302 AF            [ 4] 3000         XOR     A               ; Start at first byte in string
   F303 E3            [16] 3001 RIGHT1: EX      (SP),HL         ; Save code string,Get string
   F304 4F            [ 4] 3002         LD      C,A             ; Starting position in string
   F305 E5            [11] 3003 MID1:   PUSH    HL              ; Save string block address
   F306 7E            [ 6] 3004         LD      A,(HL)          ; Get length of string
   F307 B8            [ 4] 3005         CP      B               ; Compare with number given
   F308 DA 0D F3      [ 9] 3006         JP      C,ALLFOL        ; All following bytes required
   F30B 78            [ 4] 3007         LD      A,B             ; Get new length
   F30C 11                 3008         .db      0x11             ; Skip "LD C,0"
a  F30D               [ 9] 3009 ALLFOL: LD      C,0             ; First byte of string
   F30D C5            [11] 3010         PUSH    BC              ; Save position in string
   F30E CD 9C F1      [16] 3011         CALL    TESTR           ; See if enough string space
   F311 C1            [ 9] 3012         POP     BC              ; Get position in string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 56.
Hexadecimal [16-Bits]



   F312 E1            [ 9] 3013         POP     HL              ; Restore string block address
   F313 E5            [11] 3014         PUSH    HL              ; And re-save it
   F314 23            [ 4] 3015         INC     HL
   F315 23            [ 4] 3016         INC     HL
   F316 46            [ 6] 3017         LD      B,(HL)          ; Get LSB of address
   F317 23            [ 4] 3018         INC     HL
   F318 66            [ 6] 3019         LD      H,(HL)          ; Get MSB of address
   F319 68            [ 4] 3020         LD      L,B             ; HL = address of string
a  F31A               [ 4] 3021         LD      B,0             ; BC = starting address
   F31A 09            [ 7] 3022         ADD     HL,BC           ; Point to that byte
   F31B 44            [ 4] 3023         LD      B,H             ; BC = source string
   F31C 4D            [ 4] 3024         LD      C,L
   F31D CD 47 F1      [16] 3025         CALL    CRTMST          ; Create a string entry
   F320 6F            [ 4] 3026         LD      L,A             ; Length of new string
   F321 CD 9B F2      [16] 3027         CALL    TOSTRA          ; Move string to string area
   F324 D1            [ 9] 3028         POP     DE              ; Clear stack
   F325 CD AC F2      [16] 3029         CALL    GSTRDE          ; Move to string pool if needed
   F328 C3 6C F1      [ 9] 3030         JP      TSTOPL          ; Temporary string to pool
                           3031 
   F32B CD 7B F3      [16] 3032 RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
   F32E D1            [ 9] 3033         POP     DE              ; Get string length
   F32F D5            [11] 3034         PUSH    DE              ; And re-save
   F330 1A            [ 6] 3035         LD      A,(DE)          ; Get length
   F331 90            [ 4] 3036         SUB     B               ; Move back N bytes
   F332 C3 03 F3      [ 9] 3037         JP      RIGHT1          ; Go and get sub-string
                           3038 
   F335 EB            [ 3] 3039 MID:    EX      DE,HL           ; Get code string address
   F336 7E            [ 6] 3040         LD      A,(HL)          ; Get next byte "," or ")"
   F337 CD 80 F3      [16] 3041         CALL    MIDNUM          ; Get number supplied
   F33A 04            [ 4] 3042         INC     B               ; Is it character zero?
   F33B 05            [ 4] 3043         DEC     B
   F33C CA 95 E9      [ 9] 3044         JP      Z,FCERR         ; Yes - Error
   F33F C5            [11] 3045         PUSH    BC              ; Save starting position
a  F340               [11] 3046         LD      E,255           ; All of string
   F340 FE 29         [ 6] 3047         CP      #")"             ; Any length given?
   F342 CA 4C F3      [ 9] 3048         JP      Z,#RSTSTR        ; No - Rest of string
   F345 CD 90 E6      [16] 3049         CALL    CHKSYN          ; Make sure "," follows
   F348 2C                 3050         .db     #","
   F349 CD C8 F3      [16] 3051         CALL    GETINT          ; Get integer 0-255
   F34C CD 90 E6      [16] 3052 RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
   F34F 29                 3053         .db     #")"
   F350 F1            [ 9] 3054         POP     AF              ; Restore starting position
   F351 E3            [16] 3055         EX      (SP),HL         ; Get string,8ave code string
a  F352               [16] 3056         LD      BC,MID1         ; Continuation of MID$ routine
   F352 C5            [11] 3057         PUSH    BC              ; Save for return
   F353 3D            [ 4] 3058         DEC     A               ; Starting position-1
   F354 BE            [ 6] 3059         CP      (HL)            ; Compare with length
   F355 06 00         [ 6] 3060         LD      B,#0             ; Zero bytes length
   F357 D0            [10] 3061         RET     NC              ; Null string if start past end
   F358 4F            [ 4] 3062         LD      C,A             ; Save starting position-1
   F359 7E            [ 6] 3063         LD      A,(HL)          ; Get length of string
   F35A 91            [ 4] 3064         SUB     C               ; Subtract start
   F35B BB            [ 4] 3065         CP      E               ; Enough string for it?
   F35C 47            [ 4] 3066         LD      B,A             ; Save maximum length available
   F35D D8            [10] 3067         RET     C               ; Truncate string if needed
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 57.
Hexadecimal [16-Bits]



   F35E 43            [ 4] 3068         LD      B,E             ; Set specified length
   F35F C9            [ 9] 3069         RET                     ; Go and create string
                           3070 
   F360 CD D8 F2      [16] 3071 VAL:    CALL    GETLEN          ; Get length of string
   F363 CA 35 F5      [ 9] 3072         JP      Z,RESZER        ; Result zero
   F366 5F            [ 4] 3073         LD      E,A             ; Save length
   F367 23            [ 4] 3074         INC     HL
   F368 23            [ 4] 3075         INC     HL
   F369 7E            [ 6] 3076         LD      A,(HL)          ; Get LSB of address
   F36A 23            [ 4] 3077         INC     HL
   F36B 66            [ 6] 3078         LD      H,(HL)          ; Get MSB of address
   F36C 6F            [ 4] 3079         LD      L,A             ; HL = String address
   F36D E5            [11] 3080         PUSH    HL              ; Save string address
   F36E 19            [ 7] 3081         ADD     HL,DE
   F36F 46            [ 6] 3082         LD      B,(HL)          ; Get end of string+1 byte
   F370 72            [ 7] 3083         LD      (HL),D          ; Zero it to terminate
   F371 E3            [16] 3084         EX      (SP),HL         ; Save string end,get start
   F372 C5            [11] 3085         PUSH    BC              ; Save end+1 byte
   F373 7E            [ 6] 3086         LD      A,(HL)          ; Get starting byte
   F374 CD 8B F7      [16] 3087         CALL    ASCTFP          ; Convert ASCII string to FP
   F377 C1            [ 9] 3088         POP     BC              ; Restore end+1 byte
   F378 E1            [ 9] 3089         POP     HL              ; Restore end+1 address
   F379 70            [ 7] 3090         LD      (HL),B          ; Put back original byte
   F37A C9            [ 9] 3091         RET
                           3092 
   F37B EB            [ 3] 3093 LFRGNM: EX      DE,HL           ; Code string address to HL
   F37C CD 90 E6      [16] 3094         CALL    CHKSYN          ; Make sure ")" follows
   F37F 29                 3095         .db     #")"
   F380 C1            [ 9] 3096 MIDNUM: POP     BC              ; Get return address
   F381 D1            [ 9] 3097         POP     DE              ; Get number supplied
   F382 C5            [11] 3098         PUSH    BC              ; Re-save return address
   F383 43            [ 4] 3099         LD      B,E             ; Number to B
   F384 C9            [ 9] 3100         RET
                           3101 
   F385 CD CB F3      [16] 3102 INP:    CALL    MAKINT          ; Make it integer A
   F388 32 3F 10      [13] 3103         LD      (INPORT),A      ; Set input port
   F38B CD 3E 10      [16] 3104         CALL    INPSUB          ; Get input from port
   F38E C3 96 F0      [ 9] 3105         JP      PASSA           ; Return integer A
                           3106 
   F391 CD B5 F3      [16] 3107 POUT:   CALL    SETIO           ; Set up port number
   F394 C3 06 10      [ 9] 3108         JP      OUTSUB          ; Output data and return
                           3109 
   F397 CD B5 F3      [16] 3110 WAIT:   CALL    SETIO           ; Set up port number
   F39A F5            [11] 3111         PUSH    AF              ; Save AND mask
   F39B 1E 00         [ 6] 3112         LD      E,#0             ; Assume zero if none given
   F39D 2B            [ 4] 3113         DEC     HL              ; DEC 'cos GETCHR INCs
   F39E CD 36 E8      [16] 3114         CALL    GETCHR          ; Get next character
   F3A1 CA AB F3      [ 9] 3115         JP      Z,NOXOR         ; No XOR byte given
   F3A4 CD 90 E6      [16] 3116         CALL    CHKSYN          ; Make sure "," follows
   F3A7 2C                 3117         .db     #","
   F3A8 CD C8 F3      [16] 3118         CALL    GETINT          ; Get integer 0-255 to XOR with
   F3AB C1            [ 9] 3119 NOXOR:  POP     BC              ; Restore AND mask
   F3AC CD 3E 10      [16] 3120 WAITLP: CALL    INPSUB          ; Get input
   F3AF AB            [ 4] 3121         XOR     E               ; Flip selected bits
   F3B0 A0            [ 4] 3122         AND     B               ; Result non-zero?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 58.
Hexadecimal [16-Bits]



   F3B1 CA AC F3      [ 9] 3123         JP      Z,WAITLP        ; No = keep waiting
   F3B4 C9            [ 9] 3124         RET
                           3125 
   F3B5 CD C8 F3      [16] 3126 SETIO:  CALL    GETINT          ; Get integer 0-255
   F3B8 32 3F 10      [13] 3127         LD      (INPORT),A      ; Set input port
   F3BB 32 07 10      [13] 3128         LD      (OTPORT),A      ; Set output port
   F3BE CD 90 E6      [16] 3129         CALL    CHKSYN          ; Make sure "," follows
   F3C1 2C                 3130         .db     #","
   F3C2 C3 C8 F3      [ 9] 3131         JP      GETINT          ; Get integer 0-255 and return
                           3132 
   F3C5 CD 36 E8      [16] 3133 FNDNUM: CALL    GETCHR          ; Get next character
   F3C8 CD F2 EC      [16] 3134 GETINT: CALL    GETNUM          ; Get a number from 0 to 255
   F3CB CD 82 E9      [16] 3135 MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
   F3CE 7A            [ 4] 3136         LD      A,D             ; Get MSB of number
   F3CF B7            [ 4] 3137         OR      A               ; Zero?
   F3D0 C2 95 E9      [ 9] 3138         JP      NZ,FCERR        ; No - Error
   F3D3 2B            [ 4] 3139         DEC     HL              ; DEC 'cos GETCHR INCs
   F3D4 CD 36 E8      [16] 3140         CALL    GETCHR          ; Get next character
   F3D7 7B            [ 4] 3141         LD      A,E             ; Get number to A
   F3D8 C9            [ 9] 3142         RET
                           3143 
                           3144 ; << NO  REFERENCE  TO  THIS  SECTION  OF  CODE >>
                           3145 ; << Set up another program area (can be in ROM) >>
                           3146 
   F3D9 2A 5E 10      [15] 3147         LD      HL,(BASTXT)     ; Get start of program text
   F3DC 22 D6 10      [16] 3148         LD      (PROGND),HL     ; Set more variable space
   F3DF 21 00 80      [ 9] 3149         LD      HL,#0x8000        ; Address of new program
   F3E2 5E            [ 6] 3150         LD      E,(HL)          ; Get LSB of new RAM end
   F3E3 23            [ 4] 3151         INC     HL
   F3E4 56            [ 6] 3152         LD      D,(HL)          ; Get MSB of new RAM end
   F3E5 23            [ 4] 3153         INC     HL
   F3E6 23            [ 4] 3154         INC     HL              ; Null at start of program
   F3E7 22 5E 10      [16] 3155         LD      (BASTXT),HL     ; New program text area 0x8003
   F3EA EB            [ 3] 3156         EX      DE,HL           ; New RAM end to HL
   F3EB 22 AF 10      [16] 3157         LD      (LSTRAM),HL     ; Set new RAM end
   F3EE 22 5A 10      [16] 3158         LD      (STRSPC),HL     ; Clear string space
a  F3F1               [16] 3159         LD      BC,RUNCNT       ; Execution driver loop
   F3F1 C5            [11] 3160         PUSH    BC              ; Save for return
   F3F2 C3 C5 E4      [ 9] 3161         JP      RUNFST          ; Clear variables and continue
                           3162 
   F3F5 C3 B7 FA      [ 9] 3163 RUART:  JP      GUART           ; Get a byte from UART
                           3164 
   F3F8 CD FB F3      [16] 3165 WUART2: CALL    WUART           ; Send 2 Bytes to UART
   F3FB F5            [11] 3166 WUART:  PUSH    AF              ; Save byte
   F3FC C5            [11] 3167         PUSH    BC              ; Save BC
   F3FD 4F            [ 4] 3168         LD      C,A             ; Byte to C
   F3FE CD C9 FA      [16] 3169         CALL    SUART           ; Send byte to UART
   F401 C1            [ 9] 3170         POP     BC              ; Restore BC
   F402 F1            [ 9] 3171         POP     AF              ; Restore byte
   F403 C9            [ 9] 3172         RET
                           3173 
a  F404               [ 9] 3174 CSAVE:  LD      B,1             ; Flag "CSAVE"
a  F404               [ 9] 3175         CP      ZTIMES          ; "*" token? ("CSAVE*")
   F404 CA BB E8      [ 9] 3176         JP      Z,ARRSV1        ; Yes - Array save
   F407 CD 0B ED      [16] 3177         CALL    EVAL            ; Evaluate expression
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 59.
Hexadecimal [16-Bits]



   F40A E5            [11] 3178         PUSH    HL              ; Save code string address
   F40B CD E4 F2      [16] 3179         CALL    GTFLNM          ; Get file name
   F40E D5            [11] 3180         PUSH    DE              ; Save file name
   F40F CD 4C FA      [16] 3181         CALL    CASFFW          ; Turn on motor and wait
   F412 D1            [ 9] 3182         POP     DE              ; Restore file name
aq F413               [ 9] 3183         LD      A,11010011B     ; Header byte
   F413 CD FB F3      [16] 3184         CALL    WUART           ; Send byte to UART
   F416 CD F8 F3      [16] 3185         CALL    WUART2          ; Send byte twice more
   F419 1A            [ 6] 3186         LD      A,(DE)          ; Get file name
   F41A CD FB F3      [16] 3187         CALL    WUART           ; Send it to UART
   F41D 00            [ 3] 3188         NOP
   F41E 00            [ 3] 3189         NOP
   F41F 00            [ 3] 3190         NOP
a  F420               [ 3] 3191         LD      HL,PROGND       ; Start of program information
   F420 22 0C 0C      [16] 3192         LD      (ARG1),HL       ; Save for monitor save routine
   F423 2A D6 10      [15] 3193         LD      HL,(PROGND)     ; End of program information
   F426 22 0E 0C      [16] 3194         LD      (ARG2),HL       ; Save for monitor save routine
   F429 CD A8 FB      [16] 3195         CALL    SAVE            ; Save program to tape
   F42C CD 5A FA      [16] 3196         CALL    ARET            ; Not much there!
   F42F E1            [ 9] 3197         POP     HL              ; Restore code string address
   F430 C9            [ 9] 3198         RET
                           3199 
   F431 7E            [ 6] 3200 CLOAD:  LD      A,(HL)          ; Get byte after "CLOAD"
a  F432               [ 6] 3201         CP      ZTIMES          ; "*" token? ("CLOAD*")
   F432 CA B9 E8      [ 9] 3202         JP      Z,ARRLD1        ; Yes - Array load
   F435 CD C5 FC      [16] 3203         CALL    SMOTOR          ; Start motor and get "?"
a  F438               [16] 3204         SUB     ZPRINT          ; "?" ("PRINT" token) Verify?
   F438 CA 3D F4      [ 9] 3205         JP      Z,FLGVER        ; Yes - Flag "verify"
   F43B AF            [ 4] 3206         XOR     A               ; Flag "load"
   F43C 01                 3207         .db      0x01             ; Skip "CPL" and "INC HL"
   F43D 2F            [ 3] 3208 FLGVER: CPL                     ; Flag "verify"
   F43E 23            [ 4] 3209         INC     HL              ; Skip over "?"
   F43F F5            [11] 3210         PUSH    AF              ; Save verify flag
   F440 2B            [ 4] 3211         DEC     HL              ; DEC 'cos GETCHR INCs
   F441 CD 36 E8      [16] 3212         CALL    GETCHR          ; Get next character
a  F444               [16] 3213         LD      A,0             ; Any file will do
   F444 CA 4E F4      [ 9] 3214         JP      Z,ANYNAM        ; No name given - Any will do
   F447 CD 0B ED      [16] 3215         CALL    EVAL            ; Evaluate expression
   F44A CD E4 F2      [16] 3216         CALL    GTFLNM          ; Get file name
   F44D 1A            [ 6] 3217         LD      A,(DE)          ; Get first byte of name
   F44E 6F            [ 4] 3218 ANYNAM: LD      L,A             ; Save name to find
   F44F F1            [ 9] 3219         POP     AF              ; Get verify flag
   F450 F5            [11] 3220         PUSH    AF              ; And re-save
   F451 B7            [ 4] 3221         OR      A               ; Verify of load?
   F452 67            [ 4] 3222         LD      H,A
   F453 22 E4 10      [16] 3223         LD      (FPREG),HL      ; Save nam of file to find
   F456 CC BA E4      [16] 3224         CALL    Z,CLRPTR        ; Load - Clear pointers
   F459 2A E4 10      [15] 3225         LD      HL,(FPREG)      ; Get name of program to find
   F45C EB            [ 3] 3226         EX      DE,HL           ; Name to DE
a  F45D               [ 3] 3227 CLOAD1: LD      B,3             ; 3 Header bytes
   F45D CD F5 F3      [16] 3228 CLOAD2: CALL    RUART           ; Get a byte from UART
q  F460                    3229         SUB     11010011B       ; Header byte?
   F460 C2 5D F4      [ 9] 3230         JP      NZ,CLOAD1       ; Look for header
   F463 05            [ 4] 3231         DEC     B               ; Count header bytes
   F464 C2 5D F4      [ 9] 3232         JP      NZ,CLOAD2       ; More to find?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 60.
Hexadecimal [16-Bits]



   F467 CD F5 F3      [16] 3233         CALL    RUART           ; Get name of file
   F46A CD 9C F4      [16] 3234         CALL    FILFND          ; Display "file X found"
   F46D 1C            [ 4] 3235         INC     E               ; Any file name given?
   F46E 1D            [ 4] 3236         DEC     E
   F46F CA 76 F4      [ 9] 3237         JP      Z,THSFIL        ; No - This file will do
   F472 BB            [ 4] 3238         CP      E               ; Has file been found?
   F473 C2 5D F4      [ 9] 3239         JP      NZ,CLOAD1       ; No - Look for another
   F476 00            [ 3] 3240 THSFIL: NOP
   F477 00            [ 3] 3241         NOP
   F478 00            [ 3] 3242         NOP
   F479 F1            [ 9] 3243         POP     AF              ; Get verify flag
   F47A B7            [ 4] 3244         OR      A               ; Load or verify?
   F47B C2 8A F4      [ 9] 3245         JP      NZ,CLOADV       ; Verify program
   F47E CD BD FB      [16] 3246         CALL    MONLD           ; Use monitor to load program
   F481 2A D6 10      [15] 3247         LD      HL,(PROGND)     ; Get end of program
   F484 CD 93 E3      [16] 3248         CALL    ENFMEM          ; See if enough memory
   F487 C3 8D F4      [ 9] 3249         JP      CLOADE          ; "Ok" and set up pointers
                           3250 
   F48A CD DD FB      [16] 3251 CLOADV: CALL    MONVE           ; Use monitor to verify program
a  F48D               [16] 3252 CLOADE: LD      HL,OKMSG        ; "Ok" message
   F48D CD 85 F1      [16] 3253         CALL    PRS             ; Output string
   F490 CD 5A FA      [16] 3254         CALL    ARET            ; Not a lot there!
   F493 C3 7C E4      [ 9] 3255         JP      SETPTR          ; Set up line pointers
                           3256 
a  F496               [ 9] 3257 OUTBAD: LD      HL,BAD          ; "Bad" message
   F496 CD 85 F1      [16] 3258         CALL    PRS             ; Output string
   F499 C3 E1 E3      [ 9] 3259         JP      ERRIN           ; In line message
                           3260 
   F49C C5            [11] 3261 FILFND: PUSH    BC              ; <- Save
   F49D E5            [11] 3262         PUSH    HL              ; <- all
   F49E D5            [11] 3263         PUSH    DE              ; <- the
   F49F F5            [11] 3264         PUSH    AF              ; <- registers
a  F4A0               [11] 3265         LD      HL,FILE         ; "File" message
   F4A0 CD 85 F1      [16] 3266         CALL    PRS             ; Output string
   F4A3 F1            [ 9] 3267         POP     AF              ; Get file name
   F4A4 F5            [11] 3268         PUSH    AF              ; And re-save
   F4A5 CD 5B FA      [16] 3269         CALL    CONMON          ; Output file name to screen
a  F4A8               [16] 3270         LD      HL,FOUND        ; "Found" message
   F4A8 CD 85 F1      [16] 3271         CALL    PRS             ; Output string
   F4AB F1            [ 9] 3272         POP     AF              ; <- Restore
   F4AC D1            [ 9] 3273         POP     DE              ; <- all
   F4AD E1            [ 9] 3274         POP     HL              ; <- the
   F4AE C1            [ 9] 3275         POP     BC              ; <- registers
   F4AF C9            [ 9] 3276         RET
                           3277 
q  F4B0 46                 3278 FILE:   .db      "File ",0
q  F4B1 20                 3279 FOUND:  .db      " Found",CR,LF,0
q  F4B2 42                 3280 BAD:    .db      "Bad",0,0,0
                           3281 
   F4B3 CD 88 E9      [16] 3282 PEEK:   CALL    DEINT           ; Get memory address
   F4B6 1A            [ 6] 3283         LD      A,(DE)          ; Get byte in memory
   F4B7 C3 96 F0      [ 9] 3284         JP      PASSA           ; Return integer A
                           3285 
   F4BA CD F2 EC      [16] 3286 POKE:   CALL    GETNUM          ; Get memory address
   F4BD CD 88 E9      [16] 3287         CALL    DEINT           ; Get integer -32768 to 3276
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 61.
Hexadecimal [16-Bits]



   F4C0 D5            [11] 3288         PUSH    DE              ; Save memory address
   F4C1 CD 90 E6      [16] 3289         CALL    CHKSYN          ; Make sure "," follows
   F4C4 2C                 3290         .db      ","
   F4C5 CD C8 F3      [16] 3291         CALL    GETINT          ; Get integer 0-255
   F4C8 D1            [ 9] 3292         POP     DE              ; Restore memory address
   F4C9 12            [ 7] 3293         LD      (DE),A          ; Load it into memory
   F4CA C9            [ 9] 3294         RET
                           3295 
a  F4CB               [ 9] 3296 ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
   F4CB CD F1 F6      [16] 3297 ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
   F4CE C3 DA F4      [ 9] 3298         JP      FPADD           ; Add BCDE to FPREG
                           3299 
   F4D1 CD F1 F6      [16] 3300 SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
   F4D4 21                 3301         .db      0x21             ; Skip "POP BC" and "POP DE"
   F4D5 C1            [ 9] 3302 PSUB:   POP     BC              ; Get FP number from stack
   F4D6 D1            [ 9] 3303         POP     DE
   F4D7 CD D3 F6      [16] 3304 SUBCDE: CALL    INVSGN          ; Negate FPREG
   F4DA 78            [ 4] 3305 FPADD:  LD      A,B             ; Get FP exponent
   F4DB B7            [ 4] 3306         OR      A               ; Is number zero?
   F4DC C8            [10] 3307         RET     Z               ; Yes - Nothing to add
   F4DD 3A E7 10      [12] 3308         LD      A,(FPEXP)       ; Get FPREG exponent
   F4E0 B7            [ 4] 3309         OR      A               ; Is this number zero?
   F4E1 CA E6 F6      [ 9] 3310         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
   F4E4 90            [ 4] 3311         SUB     B               ; BCDE number larger?
   F4E5 D2 F4 F4      [ 9] 3312         JP      NC,NOSWAP       ; No - Don't swap them
   F4E8 2F            [ 3] 3313         CPL                     ; Two's complement
   F4E9 3C            [ 4] 3314         INC     A               ;  FP exponent
   F4EA EB            [ 3] 3315         EX      DE,HL
   F4EB CD D6 F6      [16] 3316         CALL    STAKFP          ; Put FPREG on stack
   F4EE EB            [ 3] 3317         EX      DE,HL
   F4EF CD E6 F6      [16] 3318         CALL    FPBCDE          ; Move BCDE to FPREG
   F4F2 C1            [ 9] 3319         POP     BC              ; Restore number from stack
   F4F3 D1            [ 9] 3320         POP     DE
a  F4F4               [ 9] 3321 NOSWAP: CP      24+1            ; Second number insignificant?
   F4F4 D0            [10] 3322         RET     NC              ; Yes - First number is result
   F4F5 F5            [11] 3323         PUSH    AF              ; Save number of bits to scale
   F4F6 CD 03 F7      [16] 3324         CALL    SIGNS           ; Set MSBs & sign of result
   F4F9 67            [ 4] 3325         LD      H,A             ; Save sign of result
   F4FA F1            [ 9] 3326         POP     AF              ; Restore scaling factor
   F4FB CD 87 F5      [16] 3327         CALL    SCALE           ; Scale BCDE to same exponent
   F4FE B4            [ 4] 3328         OR      H               ; Result to be positive?
a  F4FF               [ 4] 3329         LD      HL,FPREG        ; Point to FPREG
   F4FF F2 13 F5      [ 9] 3330         JP      P,MINCDE        ; No - Subtract FPREG from CDE
   F502 CD 6A F5      [16] 3331         CALL    PLUCDE          ; Add FPREG to CDE
   F505 D2 52 F5      [ 9] 3332         JP      NC,RONDUP       ; No overflow - Round it up
   F508 23            [ 4] 3333         INC     HL              ; Point to exponent
   F509 34            [10] 3334         INC     (HL)            ; Increment it
   F50A CA BC E3      [ 9] 3335         JP      Z,OVERR         ; Number overflowed - Error
a  F50D               [ 9] 3336         LD      L,1             ; 1 bit to shift right
   F50D CD 95 F5      [16] 3337         CALL    SHRT1           ; Shift result right
   F510 C3 52 F5      [ 9] 3338         JP      RONDUP          ; Round it up
                           3339 
   F513 AF            [ 4] 3340 MINCDE: XOR     A               ; Clear A and carry
   F514 90            [ 4] 3341         SUB     B               ; Negate exponent
   F515 47            [ 4] 3342         LD      B,A             ; Re-save exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 62.
Hexadecimal [16-Bits]



   F516 7E            [ 6] 3343         LD      A,(HL)          ; Get LSB of FPREG
   F517 9B            [ 4] 3344         SBC     A, E            ; Subtract LSB of BCDE
   F518 5F            [ 4] 3345         LD      E,A             ; Save LSB of BCDE
   F519 23            [ 4] 3346         INC     HL
   F51A 7E            [ 6] 3347         LD      A,(HL)          ; Get NMSB of FPREG
   F51B 9A            [ 4] 3348         SBC     A,D             ; Subtract NMSB of BCDE
   F51C 57            [ 4] 3349         LD      D,A             ; Save NMSB of BCDE
   F51D 23            [ 4] 3350         INC     HL
   F51E 7E            [ 6] 3351         LD      A,(HL)          ; Get MSB of FPREG
   F51F 99            [ 4] 3352         SBC     A,C             ; Subtract MSB of BCDE
   F520 4F            [ 4] 3353         LD      C,A             ; Save MSB of BCDE
   F521 DC 76 F5      [16] 3354 CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                           3355 
   F524 68            [ 4] 3356 BNORM:  LD      L,B             ; L = Exponent
   F525 63            [ 4] 3357         LD      H,E             ; H = LSB
   F526 AF            [ 4] 3358         XOR     A
   F527 47            [ 4] 3359 BNRMLP: LD      B,A             ; Save bit count
   F528 79            [ 4] 3360         LD      A,C             ; Get MSB
   F529 B7            [ 4] 3361         OR      A               ; Is it zero?
   F52A C2 42 F5      [ 9] 3362         JP      NZ,PNORM        ; No - Do it bit at a time
   F52D 4A            [ 4] 3363         LD      C,D             ; MSB = NMSB
   F52E 54            [ 4] 3364         LD      D,H             ; NMSB= LSB
   F52F 65            [ 4] 3365         LD      H,L             ; LSB = VLSB
   F530 6F            [ 4] 3366         LD      L,A             ; VLSB= 0
   F531 78            [ 4] 3367         LD      A,B             ; Get exponent
a  F532               [ 4] 3368         SUB     8               ; Count 8 bits
a  F532               [ 4] 3369         CP      -24-8           ; Was number zero?
   F532 C2 27 F5      [ 9] 3370         JP      NZ,BNRMLP       ; No - Keep normalising
   F535 AF            [ 4] 3371 RESZER: XOR     A               ; Result is zero
   F536 32 E7 10      [13] 3372 SAVEXP: LD      (FPEXP),A       ; Save result as zero
   F539 C9            [ 9] 3373         RET
                           3374 
   F53A 05            [ 4] 3375 NORMAL: DEC     B               ; Count bits
   F53B 29            [ 7] 3376         ADD     HL,HL           ; Shift HL left
   F53C 7A            [ 4] 3377         LD      A,D             ; Get NMSB
   F53D 17            [ 3] 3378         RLA                     ; Shift left with last bit
   F53E 57            [ 4] 3379         LD      D,A             ; Save NMSB
   F53F 79            [ 4] 3380         LD      A,C             ; Get MSB
   F540 8F            [ 4] 3381         ADC     A,A             ; Shift left with last bit
   F541 4F            [ 4] 3382         LD      C,A             ; Save MSB
   F542 F2 3A F5      [ 9] 3383 PNORM:  JP      P,NORMAL        ; Not done - Keep going
   F545 78            [ 4] 3384         LD      A,B             ; Number of bits shifted
   F546 5C            [ 4] 3385         LD      E,H             ; Save HL in EB
   F547 45            [ 4] 3386         LD      B,L
   F548 B7            [ 4] 3387         OR      A               ; Any shifting done?
   F549 CA 52 F5      [ 9] 3388         JP      Z,RONDUP        ; No - Round it up
a  F54C               [ 9] 3389         LD      HL,FPEXP        ; Point to exponent
   F54C 86            [ 6] 3390         ADD     A,(HL)          ; Add shifted bits
   F54D 77            [ 7] 3391         LD      (HL),A          ; Re-save exponent
   F54E D2 35 F5      [ 9] 3392         JP      NC,RESZER       ; Underflow - Result is zero
   F551 C8            [10] 3393         RET     Z               ; Result is zero
   F552 78            [ 4] 3394 RONDUP: LD      A,B             ; Get VLSB of number
a  F553               [ 4] 3395 RONDB:  LD      HL,FPEXP        ; Point to exponent
   F553 B7            [ 4] 3396         OR      A               ; Any rounding?
   F554 FC 5F F5      [16] 3397         CALL    M,FPROND        ; Yes - Round number up
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 63.
Hexadecimal [16-Bits]



   F557 46            [ 6] 3398         LD      B,(HL)          ; B = Exponent
   F558 23            [ 4] 3399         INC     HL
   F559 7E            [ 6] 3400         LD      A,(HL)          ; Get sign of result
q  F55A                    3401         AND     10000000B       ; Only bit 7 needed
   F55A A9            [ 4] 3402         XOR     C               ; Set correct sign
   F55B 4F            [ 4] 3403         LD      C,A             ; Save correct sign in number
   F55C C3 E6 F6      [ 9] 3404         JP      FPBCDE          ; Move BCDE to FPREG
                           3405 
   F55F 1C            [ 4] 3406 FPROND: INC     E               ; Round LSB
   F560 C0            [10] 3407         RET     NZ              ; Return if ok
   F561 14            [ 4] 3408         INC     D               ; Round NMSB
   F562 C0            [10] 3409         RET     NZ              ; Return if ok
   F563 0C            [ 4] 3410         INC     C               ; Round MSB
   F564 C0            [10] 3411         RET     NZ              ; Return if ok
a  F565               [10] 3412         LD      C,0x80           ; Set normal value
   F565 34            [10] 3413         INC     (HL)            ; Increment exponent
   F566 C0            [10] 3414         RET     NZ              ; Return if ok
   F567 C3 BC E3      [ 9] 3415         JP      OVERR           ; Overflow error
                           3416 
   F56A 7E            [ 6] 3417 PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
   F56B 83            [ 4] 3418         ADD     A,E             ; Add LSB of BCDE
   F56C 5F            [ 4] 3419         LD      E,A             ; Save LSB of BCDE
   F56D 23            [ 4] 3420         INC     HL
   F56E 7E            [ 6] 3421         LD      A,(HL)          ; Get NMSB of FPREG
   F56F 8A            [ 4] 3422         ADC     A,D             ; Add NMSB of BCDE
   F570 57            [ 4] 3423         LD      D,A             ; Save NMSB of BCDE
   F571 23            [ 4] 3424         INC     HL
   F572 7E            [ 6] 3425         LD      A,(HL)          ; Get MSB of FPREG
   F573 89            [ 4] 3426         ADC     A,C             ; Add MSB of BCDE
   F574 4F            [ 4] 3427         LD      C,A             ; Save MSB of BCDE
   F575 C9            [ 9] 3428         RET
                           3429 
a  F576               [ 9] 3430 COMPL:  LD      HL,SGNRES       ; Sign of result
   F576 7E            [ 6] 3431         LD      A,(HL)          ; Get sign of result
   F577 2F            [ 3] 3432         CPL                     ; Negate it
   F578 77            [ 7] 3433         LD      (HL),A          ; Put it back
   F579 AF            [ 4] 3434         XOR     A
   F57A 6F            [ 4] 3435         LD      L,A             ; Set L to zero
   F57B 90            [ 4] 3436         SUB     B               ; Negate exponent,set carry
   F57C 47            [ 4] 3437         LD      B,A             ; Re-save exponent
   F57D 7D            [ 4] 3438         LD      A,L             ; Load zero
   F57E 9B            [ 4] 3439         SBC     A,E             ; Negate LSB
   F57F 5F            [ 4] 3440         LD      E,A             ; Re-save LSB
   F580 7D            [ 4] 3441         LD      A,L             ; Load zero
   F581 9A            [ 4] 3442         SBC     A,D             ; Negate NMSB
   F582 57            [ 4] 3443         LD      D,A             ; Re-save NMSB
   F583 7D            [ 4] 3444         LD      A,L             ; Load zero
   F584 99            [ 4] 3445         SBC     A,C             ; Negate MSB
   F585 4F            [ 4] 3446         LD      C,A             ; Re-save MSB
   F586 C9            [ 9] 3447         RET
                           3448 
a  F587               [ 9] 3449 SCALE:  LD      B,0             ; Clear underflow
a  F587               [ 9] 3450 SCALLP: SUB     8               ; 8 bits (a whole byte)?
   F587 DA 90 F5      [ 9] 3451         JP      C,SHRITE        ; No - Shift right A bits
   F58A 43            [ 4] 3452         LD      B,E             ; <- Shift
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 64.
Hexadecimal [16-Bits]



   F58B 5A            [ 4] 3453         LD      E,D             ; <- right
   F58C 51            [ 4] 3454         LD      D,C             ; <- eight
a  F58D               [ 4] 3455         LD      C,0             ; <- bits
   F58D C3 87 F5      [ 9] 3456         JP      SCALLP          ; More bits to shift
                           3457 
a  F590               [ 9] 3458 SHRITE: ADD     A,8+1           ; Adjust count
   F590 6F            [ 4] 3459         LD      L,A             ; Save bits to shift
   F591 AF            [ 4] 3460 SHRLP:  XOR     A               ; Flag for all done
   F592 2D            [ 4] 3461         DEC     L               ; All shifting done?
   F593 C8            [10] 3462         RET     Z               ; Yes - Return
   F594 79            [ 4] 3463         LD      A,C             ; Get MSB
   F595 1F            [ 3] 3464 SHRT1:  RRA                     ; Shift it right
   F596 4F            [ 4] 3465         LD      C,A             ; Re-save
   F597 7A            [ 4] 3466         LD      A,D             ; Get NMSB
   F598 1F            [ 3] 3467         RRA                     ; Shift right with last bit
   F599 57            [ 4] 3468         LD      D,A             ; Re-save it
   F59A 7B            [ 4] 3469         LD      A,E             ; Get LSB
   F59B 1F            [ 3] 3470         RRA                     ; Shift right with last bit
   F59C 5F            [ 4] 3471         LD      E,A             ; Re-save it
   F59D 78            [ 4] 3472         LD      A,B             ; Get underflow
   F59E 1F            [ 3] 3473         RRA                     ; Shift right with last bit
   F59F 47            [ 4] 3474         LD      B,A             ; Re-save underflow
   F5A0 C3 91 F5      [ 9] 3475         JP      SHRLP           ; More bits to do
                           3476 
q  F5A3 00 00              3477 UNITY:  .db       0x000,000H,000H,081H    ; 1.00000
                           3478 
   F5A5 03                 3479 LOGTAB: .db      3                       ; Table used by LOG
q  F5A6 AA 38              3480         .db      0x0AA,056H,019H,080H     ; 0.59898
q  F5A8 F1 16              3481         .db      0x0F1,022H,076H,080H     ; 0.96147
q  F5AA 45 00              3482         .db      0x045,0AAH,038H,082H     ; 2.88539
                           3483 
   F5AC CD B6 F6      [16] 3484 LOG:    CALL    TSTSGN          ; Test sign of value
   F5AF B7            [ 4] 3485         OR      A
   F5B0 EA 95 E9      [ 9] 3486         JP      PE,FCERR        ; ?FC Error if <= zero
a  F5B3               [ 9] 3487         LD      HL,FPEXP        ; Point to exponent
   F5B3 7E            [ 6] 3488         LD      A,(HL)          ; Get exponent
a  F5B4               [ 6] 3489         LD      BC,0x8035        ; BCDE = SQR(1/2)
a  F5B4               [ 6] 3490         LD      DE,0x04F3
   F5B4 90            [ 4] 3491         SUB     B               ; Scale value to be < 1
   F5B5 F5            [11] 3492         PUSH    AF              ; Save scale factor
   F5B6 70            [ 7] 3493         LD      (HL),B          ; Save new exponent
   F5B7 D5            [11] 3494         PUSH    DE              ; Save SQR(1/2)
   F5B8 C5            [11] 3495         PUSH    BC
   F5B9 CD DA F4      [16] 3496         CALL    FPADD           ; Add SQR(1/2) to value
   F5BC C1            [ 9] 3497         POP     BC              ; Restore SQR(1/2)
   F5BD D1            [ 9] 3498         POP     DE
   F5BE 04            [ 4] 3499         INC     B               ; Make it SQR(2)
   F5BF CD 1D F6      [16] 3500         CALL    DVBCDE          ; Divide by SQR(2)
a  F5C2               [16] 3501         LD      HL,UNITY        ; Point to 1.
   F5C2 CD D1 F4      [16] 3502         CALL    SUBPHL          ; Subtract FPREG from 1
a  F5C5               [16] 3503         LD      HL,LOGTAB       ; Coefficient table
   F5C5 CD 4C F9      [16] 3504         CALL    SUMSER          ; Evaluate sum of series
a  F5C8               [16] 3505         LD      BC,0x8080        ; BCDE = -0.5
a  F5C8               [16] 3506         LD      DE,0x0000
   F5C8 CD DA F4      [16] 3507         CALL    FPADD           ; Subtract 0.5 from FPREG
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 65.
Hexadecimal [16-Bits]



   F5CB F1            [ 9] 3508         POP     AF              ; Restore scale factor
   F5CC CD F5 F7      [16] 3509         CALL    RSCALE          ; Re-scale number
a  F5CF               [16] 3510 MULLN2: LD      BC,0x8031        ; BCDE = Ln(2)
a  F5CF               [16] 3511         LD      DE,0x7218
   F5CF 21                 3512         .db      0x21             ; Skip "POP BC" and "POP DE"
                           3513 
   F5D0 C1            [ 9] 3514 MULT:   POP     BC              ; Get number from stack
   F5D1 D1            [ 9] 3515         POP     DE
   F5D2 CD B6 F6      [16] 3516 FPMULT: CALL    TSTSGN          ; Test sign of FPREG
   F5D5 C8            [10] 3517         RET     Z               ; Return zero if zero
a  F5D6               [10] 3518         LD      L,0             ; Flag add exponents
   F5D6 CD 7E F6      [16] 3519         CALL    ADDEXP          ; Add exponents
   F5D9 79            [ 4] 3520         LD      A,C             ; Get MSB of multiplier
   F5DA 32 F6 10      [13] 3521         LD      (MULVAL),A      ; Save MSB of multiplier
   F5DD EB            [ 3] 3522         EX      DE,HL
   F5DE 22 F7 10      [16] 3523         LD      (MULVAL+1),HL   ; Save rest of multiplier
a  F5E1               [16] 3524         LD      BC,0            ; Partial product (BCDE) = zero
   F5E1 50            [ 4] 3525         LD      D,B
   F5E2 58            [ 4] 3526         LD      E,B
a  F5E3               [ 4] 3527         LD      HL,BNORM        ; Address of normalise
   F5E3 E5            [11] 3528         PUSH    HL              ; Save for return
a  F5E4               [11] 3529         LD      HL,MULT8        ; Address of 8 bit multiply
   F5E4 E5            [11] 3530         PUSH    HL              ; Save for NMSB,MSB
   F5E5 E5            [11] 3531         PUSH    HL              ; 
a  F5E6               [11] 3532         LD      HL,FPREG        ; Point to number
   F5E6 7E            [ 6] 3533 MULT8:  LD      A,(HL)          ; Get LSB of number
   F5E7 23            [ 4] 3534         INC     HL              ; Point to NMSB
   F5E8 B7            [ 4] 3535         OR      A               ; Test LSB
   F5E9 CA 10 F6      [ 9] 3536         JP      Z,BYTSFT        ; Zero - shift to next byte
   F5EC E5            [11] 3537         PUSH    HL              ; Save address of number
a  F5ED               [11] 3538         LD      L,8             ; 8 bits to multiply by
   F5ED 1F            [ 3] 3539 MUL8LP: RRA                     ; Shift LSB right
   F5EE 67            [ 4] 3540         LD      H,A             ; Save LSB
   F5EF 79            [ 4] 3541         LD      A,C             ; Get MSB
   F5F0 D2 FE F5      [ 9] 3542         JP      NC,NOMADD       ; Bit was zero - Don't add
   F5F3 E5            [11] 3543         PUSH    HL              ; Save LSB and count
   F5F4 2A F7 10      [15] 3544         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
   F5F7 19            [ 7] 3545         ADD     HL,DE           ; Add NMSB and LSB
   F5F8 EB            [ 3] 3546         EX      DE,HL           ; Leave sum in DE
   F5F9 E1            [ 9] 3547         POP     HL              ; Restore MSB and count
   F5FA 3A F6 10      [12] 3548         LD      A,(MULVAL)      ; Get MSB of multiplier
   F5FD 89            [ 4] 3549         ADC     A,C             ; Add MSB
   F5FE 1F            [ 3] 3550 NOMADD: RRA                     ; Shift MSB right
   F5FF 4F            [ 4] 3551         LD      C,A             ; Re-save MSB
   F600 7A            [ 4] 3552         LD      A,D             ; Get NMSB
   F601 1F            [ 3] 3553         RRA                     ; Shift NMSB right
   F602 57            [ 4] 3554         LD      D,A             ; Re-save NMSB
   F603 7B            [ 4] 3555         LD      A,E             ; Get LSB
   F604 1F            [ 3] 3556         RRA                     ; Shift LSB right
   F605 5F            [ 4] 3557         LD      E,A             ; Re-save LSB
   F606 78            [ 4] 3558         LD      A,B             ; Get VLSB
   F607 1F            [ 3] 3559         RRA                     ; Shift VLSB right
   F608 47            [ 4] 3560         LD      B,A             ; Re-save VLSB
   F609 2D            [ 4] 3561         DEC     L               ; Count bits multiplied
   F60A 7C            [ 4] 3562         LD      A,H             ; Get LSB of multiplier
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 66.
Hexadecimal [16-Bits]



   F60B C2 ED F5      [ 9] 3563         JP      NZ,MUL8LP       ; More - Do it
   F60E E1            [ 9] 3564 POPHRT: POP     HL              ; Restore address of number
   F60F C9            [ 9] 3565         RET
                           3566 
   F610 43            [ 4] 3567 BYTSFT: LD      B,E             ; Shift partial product left
   F611 5A            [ 4] 3568         LD      E,D
   F612 51            [ 4] 3569         LD      D,C
   F613 4F            [ 4] 3570         LD      C,A
   F614 C9            [ 9] 3571         RET
                           3572 
   F615 CD D6 F6      [16] 3573 DIV10:  CALL    STAKFP          ; Save FPREG on stack
a  F618               [16] 3574         LD      BC,0x8420        ; BCDE = 10.
a  F618               [16] 3575         LD      DE,0x0000
   F618 CD E6 F6      [16] 3576         CALL    FPBCDE          ; Move 10 to FPREG
                           3577 
   F61B C1            [ 9] 3578 DIV:    POP     BC              ; Get number from stack
   F61C D1            [ 9] 3579         POP     DE
   F61D CD B6 F6      [16] 3580 DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
   F620 CA B0 E3      [ 9] 3581         JP      Z,DZERR         ; Error if division by zero
a  F623               [ 9] 3582         LD      L,-1            ; Flag subtract exponents
   F623 CD 7E F6      [16] 3583         CALL    ADDEXP          ; Subtract exponents
   F626 34            [10] 3584         INC     (HL)            ; Add 2 to exponent to adjust
   F627 34            [10] 3585         INC     (HL)
   F628 2B            [ 4] 3586         DEC     HL              ; Point to MSB
   F629 7E            [ 6] 3587         LD      A,(HL)          ; Get MSB of dividend
   F62A 32 12 10      [13] 3588         LD      (DIV3),A        ; Save for subtraction
   F62D 2B            [ 4] 3589         DEC     HL
   F62E 7E            [ 6] 3590         LD      A,(HL)          ; Get NMSB of dividend
   F62F 32 0E 10      [13] 3591         LD      (DIV2),A        ; Save for subtraction
   F632 2B            [ 4] 3592         DEC     HL
   F633 7E            [ 6] 3593         LD      A,(HL)          ; Get MSB of dividend
   F634 32 0A 10      [13] 3594         LD      (DIV1),A        ; Save for subtraction
   F637 41            [ 4] 3595         LD      B,C             ; Get MSB
   F638 EB            [ 3] 3596         EX      DE,HL           ; NMSB,LSB to HL
   F639 AF            [ 4] 3597         XOR     A
   F63A 4F            [ 4] 3598         LD      C,A             ; Clear MSB of quotient
   F63B 57            [ 4] 3599         LD      D,A             ; Clear NMSB of quotient
   F63C 5F            [ 4] 3600         LD      E,A             ; Clear LSB of quotient
   F63D 32 15 10      [13] 3601         LD      (DIV4),A        ; Clear overflow count
   F640 E5            [11] 3602 DIVLP:  PUSH    HL              ; Save divisor
   F641 C5            [11] 3603         PUSH    BC
   F642 7D            [ 4] 3604         LD      A,L             ; Get LSB of number
   F643 CD 09 10      [16] 3605         CALL    DIVSUP          ; Subt' divisor from dividend
a  F646               [16] 3606         SBC     A,0             ; Count for overflows
   F646 3F            [ 3] 3607         CCF
   F647 D2 51 F6      [ 9] 3608         JP      NC,RESDIV       ; Restore divisor if borrow
   F64A 32 15 10      [13] 3609         LD      (DIV4),A        ; Re-save overflow count
   F64D F1            [ 9] 3610         POP     AF              ; Scrap divisor
   F64E F1            [ 9] 3611         POP     AF
   F64F 37            [ 3] 3612         SCF                     ; Set carry to
   F650 D2                 3613         .db      0x0D2            ; Skip "POP BC" and "POP HL"
                           3614 
   F651 C1            [ 9] 3615 RESDIV: POP     BC              ; Restore divisor
   F652 E1            [ 9] 3616         POP     HL
   F653 79            [ 4] 3617         LD      A,C             ; Get MSB of quotient
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 67.
Hexadecimal [16-Bits]



   F654 3C            [ 4] 3618         INC     A
   F655 3D            [ 4] 3619         DEC     A
   F656 1F            [ 3] 3620         RRA                     ; Bit 0 to bit 7
   F657 FA 53 F5      [ 9] 3621         JP      M,RONDB         ; Done - Normalise result
   F65A 17            [ 3] 3622         RLA                     ; Restore carry
   F65B 7B            [ 4] 3623         LD      A,E             ; Get LSB of quotient
   F65C 17            [ 3] 3624         RLA                     ; Double it
   F65D 5F            [ 4] 3625         LD      E,A             ; Put it back
   F65E 7A            [ 4] 3626         LD      A,D             ; Get NMSB of quotient
   F65F 17            [ 3] 3627         RLA                     ; Double it
   F660 57            [ 4] 3628         LD      D,A             ; Put it back
   F661 79            [ 4] 3629         LD      A,C             ; Get MSB of quotient
   F662 17            [ 3] 3630         RLA                     ; Double it
   F663 4F            [ 4] 3631         LD      C,A             ; Put it back
   F664 29            [ 7] 3632         ADD     HL,HL           ; Double NMSB,LSB of divisor
   F665 78            [ 4] 3633         LD      A,B             ; Get MSB of divisor
   F666 17            [ 3] 3634         RLA                     ; Double it
   F667 47            [ 4] 3635         LD      B,A             ; Put it back
   F668 3A 15 10      [12] 3636         LD      A,(DIV4)        ; Get VLSB of quotient
   F66B 17            [ 3] 3637         RLA                     ; Double it
   F66C 32 15 10      [13] 3638         LD      (DIV4),A        ; Put it back
   F66F 79            [ 4] 3639         LD      A,C             ; Get MSB of quotient
   F670 B2            [ 4] 3640         OR      D               ; Merge NMSB
   F671 B3            [ 4] 3641         OR      E               ; Merge LSB
   F672 C2 40 F6      [ 9] 3642         JP      NZ,DIVLP        ; Not done - Keep dividing
   F675 E5            [11] 3643         PUSH    HL              ; Save divisor
a  F676               [11] 3644         LD      HL,FPEXP        ; Point to exponent
   F676 35            [10] 3645         DEC     (HL)            ; Divide by 2
   F677 E1            [ 9] 3646         POP     HL              ; Restore divisor
   F678 C2 40 F6      [ 9] 3647         JP      NZ,DIVLP        ; Ok - Keep going
   F67B C3 BC E3      [ 9] 3648         JP      OVERR           ; Overflow error
                           3649 
   F67E 78            [ 4] 3650 ADDEXP: LD      A,B             ; Get exponent of dividend
   F67F B7            [ 4] 3651         OR      A               ; Test it
   F680 CA 9D F6      [ 9] 3652         JP      Z,OVTST3        ; Zero - Result zero
   F683 7D            [ 4] 3653         LD      A,L             ; Get add/subtract flag
a  F684               [ 4] 3654         LD      HL,FPEXP        ; Point to exponent
   F684 AE            [ 6] 3655         XOR     (HL)            ; Add or subtract it
   F685 80            [ 4] 3656         ADD     A,B             ; Add the other exponent
   F686 47            [ 4] 3657         LD      B,A             ; Save new exponent
   F687 1F            [ 3] 3658         RRA                     ; Test exponent for overflow
   F688 A8            [ 4] 3659         XOR     B
   F689 78            [ 4] 3660         LD      A,B             ; Get exponent
   F68A F2 9C F6      [ 9] 3661         JP      P,OVTST2        ; Positive - Test for overflow
a  F68D               [ 9] 3662         ADD     A,0x80           ; Add excess 128
   F68D 77            [ 7] 3663         LD      (HL),A          ; Save new exponent
   F68E CA 0E F6      [ 9] 3664         JP      Z,POPHRT        ; Zero - Result zero
   F691 CD 03 F7      [16] 3665         CALL    SIGNS           ; Set MSBs and sign of result
   F694 77            [ 7] 3666         LD      (HL),A          ; Save new exponent
   F695 2B            [ 4] 3667         DEC     HL              ; Point to MSB
   F696 C9            [ 9] 3668         RET
                           3669 
   F697 CD B6 F6      [16] 3670 OVTST1: CALL    TSTSGN          ; Test sign of FPREG
   F69A 2F            [ 3] 3671         CPL                     ; Invert sign
   F69B E1            [ 9] 3672         POP     HL              ; Clean up stack
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 68.
Hexadecimal [16-Bits]



   F69C B7            [ 4] 3673 OVTST2: OR      A               ; Test if new exponent zero
   F69D E1            [ 9] 3674 OVTST3: POP     HL              ; Clear off return address
   F69E F2 35 F5      [ 9] 3675         JP      P,RESZER        ; Result zero
   F6A1 C3 BC E3      [ 9] 3676         JP      OVERR           ; Overflow error
                           3677 
   F6A4 CD F1 F6      [16] 3678 MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
   F6A7 78            [ 4] 3679         LD      A,B             ; Get exponent
   F6A8 B7            [ 4] 3680         OR      A               ; Is it zero?
   F6A9 C8            [10] 3681         RET     Z               ; Yes - Result is zero
a  F6AA               [10] 3682         ADD     A,2             ; Multiply by 4
   F6AA DA BC E3      [ 9] 3683         JP      C,OVERR         ; Overflow - ?OV Error
   F6AD 47            [ 4] 3684         LD      B,A             ; Re-save exponent
   F6AE CD DA F4      [16] 3685         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
a  F6B1               [16] 3686         LD      HL,FPEXP        ; Point to exponent
   F6B1 34            [10] 3687         INC     (HL)            ; Double number (Times 10)
   F6B2 C0            [10] 3688         RET     NZ              ; Ok - Return
   F6B3 C3 BC E3      [ 9] 3689         JP      OVERR           ; Overflow error
                           3690 
   F6B6 3A E7 10      [12] 3691 TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
   F6B9 B7            [ 4] 3692         OR      A
   F6BA C8            [10] 3693         RET     Z               ; RETurn if number is zero
   F6BB 3A E6 10      [12] 3694         LD      A,(FPREG+2)     ; Get MSB of FPREG
   F6BE FE                 3695         .db      0x0FE            ; Test sign
   F6BF 2F            [ 3] 3696 RETREL: CPL                     ; Invert sign
   F6C0 17            [ 3] 3697         RLA                     ; Sign bit to carry
   F6C1 9F            [ 4] 3698 FLGDIF: SBC     A,A             ; Carry to all bits of A
   F6C2 C0            [10] 3699         RET     NZ              ; Return -1 if negative
   F6C3 3C            [ 4] 3700         INC     A               ; Bump to +1
   F6C4 C9            [ 9] 3701         RET                     ; Positive - Return +1
                           3702 
   F6C5 CD B6 F6      [16] 3703 SGN:    CALL    TSTSGN          ; Test sign of FPREG
a  F6C8               [16] 3704 FLGREL: LD      B,0x80+8         ; 8 bit integer in exponent
a  F6C8               [16] 3705         LD      DE,0            ; Zero NMSB and LSB
a  F6C8               [16] 3706 RETINT: LD      HL,FPEXP        ; Point to exponent
   F6C8 4F            [ 4] 3707         LD      C,A             ; CDE = MSB,NMSB and LSB
   F6C9 70            [ 7] 3708         LD      (HL),B          ; Save exponent
a  F6CA               [ 7] 3709         LD      B,0             ; CDE = integer to normalise
   F6CA 23            [ 4] 3710         INC     HL              ; Point to sign of result
a  F6CB               [ 4] 3711         LD      (HL),0x80        ; Set sign of result
   F6CB 17            [ 3] 3712         RLA                     ; Carry = sign of integer
   F6CC C3 21 F5      [ 9] 3713         JP      CONPOS          ; Set sign of result
                           3714 
   F6CF CD B6 F6      [16] 3715 ABS:    CALL    TSTSGN          ; Test sign of FPREG
   F6D2 F0            [10] 3716         RET     P               ; Return if positive
a  F6D3               [10] 3717 INVSGN: LD      HL,FPREG+2      ; Point to MSB
   F6D3 7E            [ 6] 3718         LD      A,(HL)          ; Get sign of mantissa
a  F6D4               [ 6] 3719         XOR     0x80             ; Invert sign of mantissa
   F6D4 77            [ 7] 3720         LD      (HL),A          ; Re-save sign of mantissa
   F6D5 C9            [ 9] 3721         RET
                           3722 
   F6D6 EB            [ 3] 3723 STAKFP: EX      DE,HL           ; Save code string address
   F6D7 2A E4 10      [15] 3724         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
   F6DA E3            [16] 3725         EX      (SP),HL         ; Stack them,get return
   F6DB E5            [11] 3726         PUSH    HL              ; Re-save return
   F6DC 2A E6 10      [15] 3727         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 69.
Hexadecimal [16-Bits]



   F6DF E3            [16] 3728         EX      (SP),HL         ; Stack them,get return
   F6E0 E5            [11] 3729         PUSH    HL              ; Re-save return
   F6E1 EB            [ 3] 3730         EX      DE,HL           ; Restore code string address
   F6E2 C9            [ 9] 3731         RET
                           3732 
   F6E3 CD F1 F6      [16] 3733 PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
   F6E6 EB            [ 3] 3734 FPBCDE: EX      DE,HL           ; Save code string address
   F6E7 22 E4 10      [16] 3735         LD      (FPREG),HL      ; Save LSB,NLSB of number
   F6EA 60            [ 4] 3736         LD      H,B             ; Exponent of number
   F6EB 69            [ 4] 3737         LD      L,C             ; MSB of number
   F6EC 22 E6 10      [16] 3738         LD      (FPREG+2),HL    ; Save MSB and exponent
   F6EF EB            [ 3] 3739         EX      DE,HL           ; Restore code string address
   F6F0 C9            [ 9] 3740         RET
                           3741 
a  F6F1               [ 9] 3742 BCDEFP: LD      HL,FPREG        ; Point to FPREG
   F6F1 5E            [ 6] 3743 LOADFP: LD      E,(HL)          ; Get LSB of number
   F6F2 23            [ 4] 3744         INC     HL
   F6F3 56            [ 6] 3745         LD      D,(HL)          ; Get NMSB of number
   F6F4 23            [ 4] 3746         INC     HL
   F6F5 4E            [ 6] 3747         LD      C,(HL)          ; Get MSB of number
   F6F6 23            [ 4] 3748         INC     HL
   F6F7 46            [ 6] 3749         LD      B,(HL)          ; Get exponent of number
   F6F8 23            [ 4] 3750 IN0xCL:  INC     HL              ; Used for conditional "INC HL"
   F6F9 C9            [ 9] 3751         RET
                           3752 
a  F6FA               [ 9] 3753 FPTHL:  LD      DE,FPREG        ; Point to FPREG
a  F6FA               [ 9] 3754 DETHL4: LD      B,4             ; 4 bytes to move
   F6FA 1A            [ 6] 3755 DETHLB: LD      A,(DE)          ; Get source
   F6FB 77            [ 7] 3756         LD      (HL),A          ; Save destination
   F6FC 13            [ 4] 3757         INC     DE              ; Next source
   F6FD 23            [ 4] 3758         INC     HL              ; Next destination
   F6FE 05            [ 4] 3759         DEC     B               ; Count bytes
   F6FF C2 FA F6      [ 9] 3760         JP      NZ,DETHLB       ; Loop if more
   F702 C9            [ 9] 3761         RET
                           3762 
a  F703               [ 9] 3763 SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
   F703 7E            [ 6] 3764         LD      A,(HL)          ; Get MSB
   F704 07            [ 3] 3765         RLCA                    ; Old sign to carry
   F705 37            [ 3] 3766         SCF                     ; Set MSBit
   F706 1F            [ 3] 3767         RRA                     ; Set MSBit of MSB
   F707 77            [ 7] 3768         LD      (HL),A          ; Save new MSB
   F708 3F            [ 3] 3769         CCF                     ; Complement sign
   F709 1F            [ 3] 3770         RRA                     ; Old sign to carry
   F70A 23            [ 4] 3771         INC     HL
   F70B 23            [ 4] 3772         INC     HL
   F70C 77            [ 7] 3773         LD      (HL),A          ; Set sign of result
   F70D 79            [ 4] 3774         LD      A,C             ; Get MSB
   F70E 07            [ 3] 3775         RLCA                    ; Old sign to carry
   F70F 37            [ 3] 3776         SCF                     ; Set MSBit
   F710 1F            [ 3] 3777         RRA                     ; Set MSBit of MSB
   F711 4F            [ 4] 3778         LD      C,A             ; Save MSB
   F712 1F            [ 3] 3779         RRA
   F713 AE            [ 6] 3780         XOR     (HL)            ; New sign of result
   F714 C9            [ 9] 3781         RET
                           3782 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 70.
Hexadecimal [16-Bits]



   F715 78            [ 4] 3783 CMPNUM: LD      A,B             ; Get exponent of number
   F716 B7            [ 4] 3784         OR      A
   F717 CA B6 F6      [ 9] 3785         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
a  F71A               [ 9] 3786         LD      HL,RETREL       ; Return relation routine
   F71A E5            [11] 3787         PUSH    HL              ; Save for return
   F71B CD B6 F6      [16] 3788         CALL    TSTSGN          ; Test sign of FPREG
   F71E 79            [ 4] 3789         LD      A,C             ; Get MSB of number
   F71F C8            [10] 3790         RET     Z               ; FPREG zero - Number's MSB
a  F720               [10] 3791         LD      HL,FPREG+2      ; MSB of FPREG
   F720 AE            [ 6] 3792         XOR     (HL)            ; Combine signs
   F721 79            [ 4] 3793         LD      A,C             ; Get MSB of number
   F722 F8            [10] 3794         RET     M               ; Exit if signs different
   F723 CD 29 F7      [16] 3795         CALL    CMPFP           ; Compare FP numbers
   F726 1F            [ 3] 3796         RRA                     ; Get carry to sign
   F727 A9            [ 4] 3797         XOR     C               ; Combine with MSB of number
   F728 C9            [ 9] 3798         RET
                           3799 
   F729 23            [ 4] 3800 CMPFP:  INC     HL              ; Point to exponent
   F72A 78            [ 4] 3801         LD      A,B             ; Get exponent
   F72B BE            [ 6] 3802         CP      (HL)            ; Compare exponents
   F72C C0            [10] 3803         RET     NZ              ; Different
   F72D 2B            [ 4] 3804         DEC     HL              ; Point to MBS
   F72E 79            [ 4] 3805         LD      A,C             ; Get MSB
   F72F BE            [ 6] 3806         CP      (HL)            ; Compare MSBs
   F730 C0            [10] 3807         RET     NZ              ; Different
   F731 2B            [ 4] 3808         DEC     HL              ; Point to NMSB
   F732 7A            [ 4] 3809         LD      A,D             ; Get NMSB
   F733 BE            [ 6] 3810         CP      (HL)            ; Compare NMSBs
   F734 C0            [10] 3811         RET     NZ              ; Different
   F735 2B            [ 4] 3812         DEC     HL              ; Point to LSB
   F736 7B            [ 4] 3813         LD      A,E             ; Get LSB
   F737 96            [ 6] 3814         SUB     (HL)            ; Compare LSBs
   F738 C0            [10] 3815         RET     NZ              ; Different
   F739 E1            [ 9] 3816         POP     HL              ; Drop RETurn
   F73A E1            [ 9] 3817         POP     HL              ; Drop another RETurn
   F73B C9            [ 9] 3818         RET
                           3819 
   F73C 47            [ 4] 3820 FPINT:  LD      B,A             ; <- Move
   F73D 4F            [ 4] 3821         LD      C,A             ; <- exponent
   F73E 57            [ 4] 3822         LD      D,A             ; <- to all
   F73F 5F            [ 4] 3823         LD      E,A             ; <- bits
   F740 B7            [ 4] 3824         OR      A               ; Test exponent
   F741 C8            [10] 3825         RET     Z               ; Zero - Return zero
   F742 E5            [11] 3826         PUSH    HL              ; Save pointer to number
   F743 CD F1 F6      [16] 3827         CALL    BCDEFP          ; Move FPREG to BCDE
   F746 CD 03 F7      [16] 3828         CALL    SIGNS           ; Set MSBs & sign of result
   F749 AE            [ 6] 3829         XOR     (HL)            ; Combine with sign of FPREG
   F74A 67            [ 4] 3830         LD      H,A             ; Save combined signs
   F74B FC 5C F7      [16] 3831         CALL    M,DCBCDE        ; Negative - Decrement BCDE
a  F74E               [16] 3832         LD      A,0x80+24        ; 24 bits
   F74E 90            [ 4] 3833         SUB     B               ; Bits to shift
   F74F CD 87 F5      [16] 3834         CALL    SCALE           ; Shift BCDE
   F752 7C            [ 4] 3835         LD      A,H             ; Get combined sign
   F753 17            [ 3] 3836         RLA                     ; Sign to carry
   F754 DC 5F F5      [16] 3837         CALL    C,FPROND        ; Negative - Round number up
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 71.
Hexadecimal [16-Bits]



a  F757               [16] 3838         LD      B,0             ; Zero exponent
   F757 DC 76 F5      [16] 3839         CALL    C,COMPL         ; If negative make positive
   F75A E1            [ 9] 3840         POP     HL              ; Restore pointer to number
   F75B C9            [ 9] 3841         RET
                           3842 
   F75C 1B            [ 4] 3843 DCBCDE: DEC     DE              ; Decrement BCDE
   F75D 7A            [ 4] 3844         LD      A,D             ; Test LSBs
   F75E A3            [ 4] 3845         AND     E
   F75F 3C            [ 4] 3846         INC     A
   F760 C0            [10] 3847         RET     NZ              ; Exit if LSBs not FFFF
   F761 0B            [ 4] 3848         DEC     BC              ; Decrement MSBs
   F762 C9            [ 9] 3849         RET
                           3850 
a  F763               [ 9] 3851 INT:    LD      HL,FPEXP        ; Point to exponent
   F763 7E            [ 6] 3852         LD      A,(HL)          ; Get exponent
a  F764               [ 6] 3853         CP      0x80+24          ; Integer accuracy only?
   F764 3A E4 10      [12] 3854         LD      A,(FPREG)       ; Get LSB
   F767 D0            [10] 3855         RET     NC              ; Yes - Already integer
   F768 7E            [ 6] 3856         LD      A,(HL)          ; Get exponent
   F769 CD 3C F7      [16] 3857         CALL    FPINT           ; F.P to integer
a  F76C               [16] 3858         LD      (HL),0x80+24     ; Save 24 bit integer
   F76C 7B            [ 4] 3859         LD      A,E             ; Get LSB of number
   F76D F5            [11] 3860         PUSH    AF              ; Save LSB
   F76E 79            [ 4] 3861         LD      A,C             ; Get MSB of number
   F76F 17            [ 3] 3862         RLA                     ; Sign to carry
   F770 CD 21 F5      [16] 3863         CALL    CONPOS          ; Set sign of result
   F773 F1            [ 9] 3864         POP     AF              ; Restore LSB of number
   F774 C9            [ 9] 3865         RET
                           3866 
a  F775               [ 9] 3867 MLDEBC: LD      HL,0            ; Clear partial product
   F775 78            [ 4] 3868         LD      A,B             ; Test multiplier
   F776 B1            [ 4] 3869         OR      C
   F777 C8            [10] 3870         RET     Z               ; Return zero if zero
a  F778               [10] 3871         LD      A,16            ; 16 bits
   F778 29            [ 7] 3872 MLDBLP: ADD     HL,HL           ; Shift P.P left
   F779 DA EC EF      [ 9] 3873         JP      C,BSERR         ; ?BS Error if overflow
   F77C EB            [ 3] 3874         EX      DE,HL
   F77D 29            [ 7] 3875         ADD     HL,HL           ; Shift multiplier left
   F77E EB            [ 3] 3876         EX      DE,HL
   F77F D2 86 F7      [ 9] 3877         JP      NC,NOMLAD       ; Bit was zero - No add
   F782 09            [ 7] 3878         ADD     HL,BC           ; Add multiplicand
   F783 DA EC EF      [ 9] 3879         JP      C,BSERR         ; ?BS Error if overflow
   F786 3D            [ 4] 3880 NOMLAD: DEC     A               ; Count bits
   F787 C2 78 F7      [ 9] 3881         JP      NZ,MLDBLP       ; More
   F78A C9            [ 9] 3882         RET
                           3883 
a  F78B               [ 9] 3884 ASCTFP: CP      "-"             ; Negative?
   F78B F5            [11] 3885         PUSH    AF              ; Save it and flags
   F78C CA 93 F7      [ 9] 3886         JP      Z,CNVNUM        ; Yes - Convert number
a  F78F               [ 9] 3887         CP      "+"             ; Positive?
   F78F CA 93 F7      [ 9] 3888         JP      Z,CNVNUM        ; Yes - Convert number
   F792 2B            [ 4] 3889         DEC     HL              ; DEC 'cos GETCHR INCs
   F793 CD 35 F5      [16] 3890 CNVNUM: CALL    RESZER          ; Set result to zero
   F796 47            [ 4] 3891         LD      B,A             ; Digits after point counter
   F797 57            [ 4] 3892         LD      D,A             ; Sign of exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 72.
Hexadecimal [16-Bits]



   F798 5F            [ 4] 3893         LD      E,A             ; Exponent of ten
   F799 2F            [ 3] 3894         CPL
   F79A 4F            [ 4] 3895         LD      C,A             ; Before or after point flag
   F79B CD 36 E8      [16] 3896 MANLP:  CALL    GETCHR          ; Get next character
   F79E DA E0 F7      [ 9] 3897         JP      C,ADDIG         ; Digit - Add to number
a  F7A1               [ 9] 3898         CP      "."
   F7A1 CA BB F7      [ 9] 3899         JP      Z,DPOINT        ; "." - Flag point
a  F7A4               [ 9] 3900         CP      "E"
   F7A4 C2 BF F7      [ 9] 3901         JP      NZ,CONEXP       ; Not "E" - Scale number
   F7A7 CD 36 E8      [16] 3902         CALL    GETCHR          ; Get next character
   F7AA CD 21 EE      [16] 3903         CALL    SGNEXP          ; Get sign of exponent
   F7AD CD 36 E8      [16] 3904 EXPLP:  CALL    GETCHR          ; Get next character
   F7B0 DA 00 F8      [ 9] 3905         JP      C,EDIGIT        ; Digit - Add to exponent
   F7B3 14            [ 4] 3906         INC     D               ; Is sign negative?
   F7B4 C2 BF F7      [ 9] 3907         JP      NZ,CONEXP       ; No - Scale number
   F7B7 AF            [ 4] 3908         XOR     A
   F7B8 93            [ 4] 3909         SUB     E               ; Negate exponent
   F7B9 5F            [ 4] 3910         LD      E,A             ; And re-save it
   F7BA 0C            [ 4] 3911         INC     C               ; Flag end of number
   F7BB 0C            [ 4] 3912 DPOINT: INC     C               ; Flag point passed
   F7BC CA 9B F7      [ 9] 3913         JP      Z,MANLP         ; Zero - Get another digit
   F7BF E5            [11] 3914 CONEXP: PUSH    HL              ; Save code string address
   F7C0 7B            [ 4] 3915         LD      A,E             ; Get exponent
   F7C1 90            [ 4] 3916         SUB     B               ; Subtract digits after point
   F7C2 F4 D8 F7      [16] 3917 SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
   F7C5 F2 CE F7      [ 9] 3918         JP      P,ENDCON        ; Positive - All done
   F7C8 F5            [11] 3919         PUSH    AF              ; Save number of times to /10
   F7C9 CD 15 F6      [16] 3920         CALL    DIV10           ; Divide by 10
   F7CC F1            [ 9] 3921         POP     AF              ; Restore count
   F7CD 3C            [ 4] 3922         INC     A               ; Count divides
                           3923 
   F7CE C2 C2 F7      [ 9] 3924 ENDCON: JP      NZ,SCALMI       ; More to do
   F7D1 D1            [ 9] 3925         POP     DE              ; Restore code string address
   F7D2 F1            [ 9] 3926         POP     AF              ; Restore sign of number
   F7D3 CC D3 F6      [16] 3927         CALL    Z,INVSGN        ; Negative - Negate number
   F7D6 EB            [ 3] 3928         EX      DE,HL           ; Code string address to HL
   F7D7 C9            [ 9] 3929         RET
                           3930 
   F7D8 C8            [10] 3931 SCALPL: RET     Z               ; Exit if no scaling needed
   F7D9 F5            [11] 3932 MULTEN: PUSH    AF              ; Save count
   F7DA CD A4 F6      [16] 3933         CALL    MLSP10          ; Multiply number by 10
   F7DD F1            [ 9] 3934         POP     AF              ; Restore count
   F7DE 3D            [ 4] 3935         DEC     A               ; Count multiplies
   F7DF C9            [ 9] 3936         RET
                           3937 
   F7E0 D5            [11] 3938 ADDIG:  PUSH    DE              ; Save sign of exponent
   F7E1 57            [ 4] 3939         LD      D,A             ; Save digit
   F7E2 78            [ 4] 3940         LD      A,B             ; Get digits after point
   F7E3 89            [ 4] 3941         ADC     A,C             ; Add one if after point
   F7E4 47            [ 4] 3942         LD      B,A             ; Re-save counter
   F7E5 C5            [11] 3943         PUSH    BC              ; Save point flags
   F7E6 E5            [11] 3944         PUSH    HL              ; Save code string address
   F7E7 D5            [11] 3945         PUSH    DE              ; Save digit
   F7E8 CD A4 F6      [16] 3946         CALL    MLSP10          ; Multiply number by 10
   F7EB F1            [ 9] 3947         POP     AF              ; Restore digit
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 73.
Hexadecimal [16-Bits]



a  F7EC               [ 9] 3948         SUB     "0"             ; Make it absolute
   F7EC CD F5 F7      [16] 3949         CALL    RSCALE          ; Re-scale number
   F7EF E1            [ 9] 3950         POP     HL              ; Restore code string address
   F7F0 C1            [ 9] 3951         POP     BC              ; Restore point flags
   F7F1 D1            [ 9] 3952         POP     DE              ; Restore sign of exponent
   F7F2 C3 9B F7      [ 9] 3953         JP      MANLP           ; Get another digit
                           3954 
   F7F5 CD D6 F6      [16] 3955 RSCALE: CALL    STAKFP          ; Put number on stack
   F7F8 CD C8 F6      [16] 3956         CALL    FLGREL          ; Digit to add to FPREG
   F7FB C1            [ 9] 3957 PADD:   POP     BC              ; Restore number
   F7FC D1            [ 9] 3958         POP     DE
   F7FD C3 DA F4      [ 9] 3959         JP      FPADD           ; Add BCDE to FPREG and return
                           3960 
   F800 7B            [ 4] 3961 EDIGIT: LD      A,E             ; Get digit
   F801 07            [ 3] 3962         RLCA                    ; Times 2
   F802 07            [ 3] 3963         RLCA                    ; Times 4
   F803 83            [ 4] 3964         ADD     A,E             ; Times 5
   F804 07            [ 3] 3965         RLCA                    ; Times 10
   F805 86            [ 6] 3966         ADD     A,(HL)          ; Add next digit
a  F806               [ 6] 3967         SUB     "0"             ; Make it absolute
   F806 5F            [ 4] 3968         LD      E,A             ; Save new digit
   F807 C3 AD F7      [ 9] 3969         JP      EXPLP           ; Look for another digit
                           3970 
   F80A E5            [11] 3971 LINEIN: PUSH    HL              ; Save code string address
a  F80B               [11] 3972         LD      HL,INMSG        ; Output " in "
   F80B CD 85 F1      [16] 3973         CALL    PRS             ; Output string at HL
   F80E E1            [ 9] 3974         POP     HL              ; Restore code string address
   F80F EB            [ 3] 3975 PRNTHL: EX      DE,HL           ; Code string address to DE
   F810 AF            [ 4] 3976         XOR     A
a  F811               [ 4] 3977         LD      B,0x80+24        ; 24 bits
   F811 CD C8 F6      [16] 3978         CALL    RETINT          ; Return the integer
a  F814               [16] 3979         LD      HL,PRNUMS       ; Print number string
   F814 E5            [11] 3980         PUSH    HL              ; Save for return
a  F815               [11] 3981 NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
   F815 E5            [11] 3982         PUSH    HL              ; Save for return
   F816 CD B6 F6      [16] 3983         CALL    TSTSGN          ; Test sign of FPREG
a  F819               [16] 3984         LD      (HL)," "        ; Space at start
   F819 F2 1C F8      [ 9] 3985         JP      P,SPCFST        ; Positive - Space to start
a  F81C               [ 9] 3986         LD      (HL),"-"        ; "-" sign at start
   F81C 23            [ 4] 3987 SPCFST: INC     HL              ; First byte of number
a  F81D               [ 4] 3988         LD      (HL),"0"        ; "0" if zero
   F81D CA A8 F8      [ 9] 3989         JP      Z,JSTZER        ; Return "0" if zero
   F820 E5            [11] 3990         PUSH    HL              ; Save buffer address
   F821 FC D3 F6      [16] 3991         CALL    M,INVSGN        ; Negate FPREG if negative
   F824 AF            [ 4] 3992         XOR     A               ; Zero A
   F825 F5            [11] 3993         PUSH    AF              ; Save it
   F826 CD AE F8      [16] 3994         CALL    RNGTST          ; Test number is in range
a  F829               [16] 3995 SIXDIG: LD      BC,0x9143        ; BCDE - 99999.9
a  F829               [16] 3996         LD      DE,0x4FF8
   F829 CD 15 F7      [16] 3997         CALL    CMPNUM          ; Compare numbers
   F82C B7            [ 4] 3998         OR      A
   F82D E2 41 F8      [ 9] 3999         JP      PO,INRNG        ; > 99999.9 - Sort it out
   F830 F1            [ 9] 4000         POP     AF              ; Restore count
   F831 CD D9 F7      [16] 4001         CALL    MULTEN          ; Multiply by ten
   F834 F5            [11] 4002         PUSH    AF              ; Re-save count
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 74.
Hexadecimal [16-Bits]



   F835 C3 29 F8      [ 9] 4003         JP      SIXDIG          ; Test it again
                           4004 
   F838 CD 15 F6      [16] 4005 GTSIXD: CALL    DIV10           ; Divide by 10
   F83B F1            [ 9] 4006         POP     AF              ; Get count
   F83C 3C            [ 4] 4007         INC     A               ; Count divides
   F83D F5            [11] 4008         PUSH    AF              ; Re-save count
   F83E CD AE F8      [16] 4009         CALL    RNGTST          ; Test number is in range
   F841 CD CB F4      [16] 4010 INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
   F844 3C            [ 4] 4011         INC     A
   F845 CD 3C F7      [16] 4012         CALL    FPINT           ; F.P to integer
   F848 CD E6 F6      [16] 4013         CALL    FPBCDE          ; Move BCDE to FPREG
a  F84B               [16] 4014         LD      BC,0x0306        ; 1E+06 to 1E-03 range
   F84B F1            [ 9] 4015         POP     AF              ; Restore count
   F84C 81            [ 4] 4016         ADD     A,C             ; 6 digits before point
   F84D 3C            [ 4] 4017         INC     A               ; Add one
   F84E FA 56 F8      [ 9] 4018         JP      M,MAKNUM        ; Do it in "E" form if < 1E-02
a  F851               [ 9] 4019         CP      6+1+1           ; More than 999999 ?
   F851 D2 56 F8      [ 9] 4020         JP      NC,MAKNUM       ; Yes - Do it in "E" form
   F854 3C            [ 4] 4021         INC     A               ; Adjust for exponent
   F855 47            [ 4] 4022         LD      B,A             ; Exponent of number
a  F856               [ 4] 4023         LD      A,2             ; Make it zero after
                           4024 
   F856 3D            [ 4] 4025 MAKNUM: DEC     A               ; Adjust for digits to do
   F857 3D            [ 4] 4026         DEC     A
   F858 E1            [ 9] 4027         POP     HL              ; Restore buffer address
   F859 F5            [11] 4028         PUSH    AF              ; Save count
a  F85A               [11] 4029         LD      DE,POWERS       ; Powers of ten
   F85A 05            [ 4] 4030         DEC     B               ; Count digits before point
   F85B C2 60 F8      [ 9] 4031         JP      NZ,DIGTXT       ; Not zero - Do number
a  F85E               [ 9] 4032         LD      (HL),"."        ; Save point
   F85E 23            [ 4] 4033         INC     HL              ; Move on
a  F85F               [ 4] 4034         LD      (HL),"0"        ; Save zero
   F85F 23            [ 4] 4035         INC     HL              ; Move on
   F860 05            [ 4] 4036 DIGTXT: DEC     B               ; Count digits before point
a  F861               [ 4] 4037         LD      (HL),"."        ; Save point in case
   F861 CC F8 F6      [16] 4038         CALL    Z,IN0xCL         ; Last digit - move on
   F864 C5            [11] 4039         PUSH    BC              ; Save digits before point
   F865 E5            [11] 4040         PUSH    HL              ; Save buffer address
   F866 D5            [11] 4041         PUSH    DE              ; Save powers of ten
   F867 CD F1 F6      [16] 4042         CALL    BCDEFP          ; Move FPREG to BCDE
   F86A E1            [ 9] 4043         POP     HL              ; Powers of ten table
a  F86B               [ 9] 4044         LD      B, "0"-1        ; ASCII "0" - 1
   F86B 04            [ 4] 4045 TRYAGN: INC     B               ; Count subtractions
   F86C 7B            [ 4] 4046         LD      A,E             ; Get LSB
   F86D 96            [ 6] 4047         SUB     (HL)            ; Subtract LSB
   F86E 5F            [ 4] 4048         LD      E,A             ; Save LSB
   F86F 23            [ 4] 4049         INC     HL
   F870 7A            [ 4] 4050         LD      A,D             ; Get NMSB
   F871 9E            [ 6] 4051         SBC     A,(HL)          ; Subtract NMSB
   F872 57            [ 4] 4052         LD      D,A             ; Save NMSB
   F873 23            [ 4] 4053         INC     HL
   F874 79            [ 4] 4054         LD      A,C             ; Get MSB
   F875 9E            [ 6] 4055         SBC     A,(HL)          ; Subtract MSB
   F876 4F            [ 4] 4056         LD      C,A             ; Save MSB
   F877 2B            [ 4] 4057         DEC     HL              ; Point back to start
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 75.
Hexadecimal [16-Bits]



   F878 2B            [ 4] 4058         DEC     HL
   F879 D2 6B F8      [ 9] 4059         JP      NC,TRYAGN       ; No overflow - Try again
   F87C CD 6A F5      [16] 4060         CALL    PLUCDE          ; Restore number
   F87F 23            [ 4] 4061         INC     HL              ; Start of next number
   F880 CD E6 F6      [16] 4062         CALL    FPBCDE          ; Move BCDE to FPREG
   F883 EB            [ 3] 4063         EX      DE,HL           ; Save point in table
   F884 E1            [ 9] 4064         POP     HL              ; Restore buffer address
   F885 70            [ 7] 4065         LD      (HL),B          ; Save digit in buffer
   F886 23            [ 4] 4066         INC     HL              ; And move on
   F887 C1            [ 9] 4067         POP     BC              ; Restore digit count
   F888 0D            [ 4] 4068         DEC     C               ; Count digits
   F889 C2 60 F8      [ 9] 4069         JP      NZ,DIGTXT       ; More - Do them
   F88C 05            [ 4] 4070         DEC     B               ; Any decimal part?
   F88D CA 98 F8      [ 9] 4071         JP      Z,DOEBIT        ; No - Do "E" bit
   F890 2B            [ 4] 4072 SUPTLZ: DEC     HL              ; Move back through buffer
   F891 7E            [ 6] 4073         LD      A,(HL)          ; Get character
a  F892               [ 6] 4074         CP      "0"             ; "0" character?
   F892 CA 90 F8      [ 9] 4075         JP      Z,SUPTLZ        ; Yes - Look back for more
a  F895               [ 9] 4076         CP      "."             ; A decimal point?
   F895 C4 F8 F6      [16] 4077         CALL    NZ,IN0xCL        ; Move back over digit
                           4078 
   F898 F1            [ 9] 4079 DOEBIT: POP     AF              ; Get "E" flag
   F899 CA AB F8      [ 9] 4080         JP      Z,NOENED        ; No "E" needed - End buffer
a  F89C               [ 9] 4081         LD      (HL),"E"        ; Put "E" in buffer
   F89C 23            [ 4] 4082         INC     HL              ; And move on
a  F89D               [ 4] 4083         LD      (HL),"+"        ; Put '+' in buffer
   F89D F2 A2 F8      [ 9] 4084         JP      P,OUTEXP        ; Positive - Output exponent
a  F8A0               [ 9] 4085         LD      (HL),"-"        ; Put "-" in buffer
   F8A0 2F            [ 3] 4086         CPL                     ; Negate exponent
   F8A1 3C            [ 4] 4087         INC     A
a  F8A2               [ 4] 4088 OUTEXP: LD      B,"0"-1         ; ASCII "0" - 1
   F8A2 04            [ 4] 4089 EXPTEN: INC     B               ; Count subtractions
a  F8A3               [ 4] 4090         SUB     10              ; Tens digit
   F8A3 D2 A2 F8      [ 9] 4091         JP      NC,EXPTEN       ; More to do
a  F8A6               [ 9] 4092         ADD     A,"0"+10        ; Restore and make ASCII
   F8A6 23            [ 4] 4093         INC     HL              ; Move on
   F8A7 70            [ 7] 4094         LD      (HL),B          ; Save MSB of exponent
   F8A8 23            [ 4] 4095 JSTZER: INC     HL              ;
   F8A9 77            [ 7] 4096         LD      (HL),A          ; Save LSB of exponent
   F8AA 23            [ 4] 4097         INC     HL
   F8AB 71            [ 7] 4098 NOENED: LD      (HL),C          ; Mark end of buffer
   F8AC E1            [ 9] 4099         POP     HL              ; Restore code string address
   F8AD C9            [ 9] 4100         RET
                           4101 
a  F8AE               [ 9] 4102 RNGTST: LD      BC,0x9474        ; BCDE = 999999.
a  F8AE               [ 9] 4103         LD      DE,0x23F7
   F8AE CD 15 F7      [16] 4104         CALL    CMPNUM          ; Compare numbers
   F8B1 B7            [ 4] 4105         OR      A
   F8B2 E1            [ 9] 4106         POP     HL              ; Return address to HL
   F8B3 E2 38 F8      [ 9] 4107         JP      PO,GTSIXD       ; Too big - Divide by ten
   F8B6 E9            [ 3] 4108         JP      (HL)            ; Otherwise return to caller
                           4109 
q  F8B7 00 00              4110 HALF:   .db      0x00,00H,00H,80H ; 0.5
                           4111 
q  F8B9 A0 56              4112 POWERS: .db      0x0A0,086H,001H  ; 100000
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 76.
Hexadecimal [16-Bits]



q  F8BB 10 1B              4113         .db      0x010,027H,000H  ;  10000
q  F8BD E8 03              4114         .db      0x0E8,003H,000H  ;   1000
q  F8BF 64 00              4115         .db      0x064,000H,000H  ;    100
q  F8C1 0A 00              4116         .db      0x00A,000H,000H  ;     10
q  F8C3 01 00              4117         .db      0x001,000H,000H  ;      1
                           4118 
a  F8C5               [ 9] 4119 NEGAFT: LD  HL,INVSGN           ; Negate result
   F8C5 E3            [16] 4120         EX      (SP),HL         ; To be done after caller
   F8C6 E9            [ 3] 4121         JP      (HL)            ; Return to caller
                           4122 
   F8C7 CD D6 F6      [16] 4123 SQR:    CALL    STAKFP          ; Put value on stack
a  F8CA               [16] 4124         LD      HL,HALF         ; Set power to 1/2
   F8CA CD E3 F6      [16] 4125         CALL    PHLTFP          ; Move 1/2 to FPREG
                           4126 
   F8CD C1            [ 9] 4127 POWER:  POP     BC              ; Get base
   F8CE D1            [ 9] 4128         POP     DE
   F8CF CD B6 F6      [16] 4129         CALL    TSTSGN          ; Test sign of power
   F8D2 78            [ 4] 4130         LD      A,B             ; Get exponent of base
   F8D3 CA 10 F9      [ 9] 4131         JP      Z,EXP           ; Make result 1 if zero
   F8D6 F2 DD F8      [ 9] 4132         JP      P,POWER1        ; Positive base - Ok
   F8D9 B7            [ 4] 4133         OR      A               ; Zero to negative power?
   F8DA CA B0 E3      [ 9] 4134         JP      Z,DZERR         ; Yes - ?/0 Error
   F8DD B7            [ 4] 4135 POWER1: OR      A               ; Base zero?
   F8DE CA 36 F5      [ 9] 4136         JP      Z,SAVEXP        ; Yes - Return zero
   F8E1 D5            [11] 4137         PUSH    DE              ; Save base
   F8E2 C5            [11] 4138         PUSH    BC
   F8E3 79            [ 4] 4139         LD      A,C             ; Get MSB of base
q  F8E4                    4140         OR      01111111B       ; Get sign status
   F8E4 CD F1 F6      [16] 4141         CALL    BCDEFP          ; Move power to BCDE
   F8E7 F2 F8 F8      [ 9] 4142         JP      P,POWER2        ; Positive base - Ok
   F8EA D5            [11] 4143         PUSH    DE              ; Save power
   F8EB C5            [11] 4144         PUSH    BC
   F8EC CD 63 F7      [16] 4145         CALL    INT             ; Get integer of power
   F8EF C1            [ 9] 4146         POP     BC              ; Restore power
   F8F0 D1            [ 9] 4147         POP     DE
   F8F1 F5            [11] 4148         PUSH    AF              ; MSB of base
   F8F2 CD 15 F7      [16] 4149         CALL    CMPNUM          ; Power an integer?
   F8F5 E1            [ 9] 4150         POP     HL              ; Restore MSB of base
   F8F6 7C            [ 4] 4151         LD      A,H             ; but don't affect flags
   F8F7 1F            [ 3] 4152         RRA                     ; Exponent odd or even?
   F8F8 E1            [ 9] 4153 POWER2: POP     HL              ; Restore MSB and exponent
   F8F9 22 E6 10      [16] 4154         LD      (FPREG+2),HL    ; Save base in FPREG
   F8FC E1            [ 9] 4155         POP     HL              ; LSBs of base
   F8FD 22 E4 10      [16] 4156         LD      (FPREG),HL      ; Save in FPREG
   F900 DC C5 F8      [16] 4157         CALL    C,NEGAFT        ; Odd power - Negate result
   F903 CC D3 F6      [16] 4158         CALL    Z,INVSGN        ; Negative base - Negate it
   F906 D5            [11] 4159         PUSH    DE              ; Save power
   F907 C5            [11] 4160         PUSH    BC
   F908 CD AC F5      [16] 4161         CALL    LOG             ; Get LOG of base
   F90B C1            [ 9] 4162         POP     BC              ; Restore power
   F90C D1            [ 9] 4163         POP     DE
   F90D CD D2 F5      [16] 4164         CALL    FPMULT          ; Multiply LOG by power
                           4165 
   F910 CD D6 F6      [16] 4166 EXP:    CALL    STAKFP          ; Put value on stack
a  F913               [16] 4167         LD      BC,0x08138       ; BCDE = 1/Ln(2)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 77.
Hexadecimal [16-Bits]



a  F913               [16] 4168         LD      DE,0x0AA3B
   F913 CD D2 F5      [16] 4169         CALL    FPMULT          ; Multiply value by 1/LN(2)
   F916 3A E7 10      [12] 4170         LD      A,(FPEXP)       ; Get exponent
a  F919               [12] 4171         CP      0x80+8           ; Is it in range?
   F919 D2 97 F6      [ 9] 4172         JP      NC,OVTST1       ; No - Test for overflow
   F91C CD 63 F7      [16] 4173         CALL    INT             ; Get INT of FPREG
a  F91F               [16] 4174         ADD     A,0x80           ; For excess 128
a  F91F               [16] 4175         ADD     A,2             ; Exponent > 126?
   F91F DA 97 F6      [ 9] 4176         JP      C,OVTST1        ; Yes - Test for overflow
   F922 F5            [11] 4177         PUSH    AF              ; Save scaling factor
a  F923               [11] 4178         LD      HL,UNITY        ; Point to 1.
   F923 CD CB F4      [16] 4179         CALL    ADDPHL          ; Add 1 to FPREG
   F926 CD CF F5      [16] 4180         CALL    MULLN2          ; Multiply by LN(2)
   F929 F1            [ 9] 4181         POP     AF              ; Restore scaling factor
   F92A C1            [ 9] 4182         POP     BC              ; Restore exponent
   F92B D1            [ 9] 4183         POP     DE
   F92C F5            [11] 4184         PUSH    AF              ; Save scaling factor
   F92D CD D7 F4      [16] 4185         CALL    SUBCDE          ; Subtract exponent from FPREG
   F930 CD D3 F6      [16] 4186         CALL    INVSGN          ; Negate result
a  F933               [16] 4187         LD      HL,EXPTAB       ; Coefficient table
   F933 CD 58 F9      [16] 4188         CALL    SMSER1          ; Sum the series
a  F936               [16] 4189         LD      DE,0            ; Zero LSBs
   F936 C1            [ 9] 4190         POP     BC              ; Scaling factor
   F937 4A            [ 4] 4191         LD      C,D             ; Zero MSB
   F938 C3 D2 F5      [ 9] 4192         JP      FPMULT          ; Scale result to correct value
                           4193 
   F93B 08                 4194 EXPTAB: .db      8                       ; Table used by EXP
q  F93C 40 02              4195         .db      0x040,02EH,094H,074H     ; -1/7! (-1/5040)
q  F93E 70 04              4196         .db      0x070,04FH,02EH,077H     ;  1/6! ( 1/720)
q  F940 6E 02              4197         .db      0x06E,002H,088H,07AH     ; -1/5! (-1/120)
q  F942 E6 00              4198         .db      0x0E6,0A0H,02AH,07CH     ;  1/4! ( 1/24)
q  F944 50 00              4199         .db      0x050,0AAH,0AAH,07EH     ; -1/3! (-1/6)
q  F946 FF 00              4200         .db      0x0FF,0FFH,07FH,07FH     ;  1/2! ( 1/2)
q  F948 00 00              4201         .db      0x000,000H,080H,081H     ; -1/1! (-1/1)
q  F94A 00 00              4202         .db      0x000,000H,000H,081H     ;  1/0! ( 1/1)
                           4203 
   F94C CD D6 F6      [16] 4204 SUMSER: CALL    STAKFP          ; Put FPREG on stack
a  F94F               [16] 4205         LD      DE,MULT         ; Multiply by "X"
   F94F D5            [11] 4206         PUSH    DE              ; To be done after
   F950 E5            [11] 4207         PUSH    HL              ; Save address of table
   F951 CD F1 F6      [16] 4208         CALL    BCDEFP          ; Move FPREG to BCDE
   F954 CD D2 F5      [16] 4209         CALL    FPMULT          ; Square the value
   F957 E1            [ 9] 4210         POP     HL              ; Restore address of table
   F958 CD D6 F6      [16] 4211 SMSER1: CALL    STAKFP          ; Put value on stack
   F95B 7E            [ 6] 4212         LD      A,(HL)          ; Get number of coefficients
   F95C 23            [ 4] 4213         INC     HL              ; Point to start of table
   F95D CD E3 F6      [16] 4214         CALL    PHLTFP          ; Move coefficient to FPREG
   F960 06                 4215         .db      0x06             ; Skip "POP AF"
   F961 F1            [ 9] 4216 SUMLP:  POP     AF              ; Restore count
   F962 C1            [ 9] 4217         POP     BC              ; Restore number
   F963 D1            [ 9] 4218         POP     DE
   F964 3D            [ 4] 4219         DEC     A               ; Cont coefficients
   F965 C8            [10] 4220         RET     Z               ; All done
   F966 D5            [11] 4221         PUSH    DE              ; Save number
   F967 C5            [11] 4222         PUSH    BC
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 78.
Hexadecimal [16-Bits]



   F968 F5            [11] 4223         PUSH    AF              ; Save count
   F969 E5            [11] 4224         PUSH    HL              ; Save address in table
   F96A CD D2 F5      [16] 4225         CALL    FPMULT          ; Multiply FPREG by BCDE
   F96D E1            [ 9] 4226         POP     HL              ; Restore address in table
   F96E CD F1 F6      [16] 4227         CALL    LOADFP          ; Number at HL to BCDE
   F971 E5            [11] 4228         PUSH    HL              ; Save address in table
   F972 CD DA F4      [16] 4229         CALL    FPADD           ; Add coefficient to FPREG
   F975 E1            [ 9] 4230         POP     HL              ; Restore address in table
   F976 C3 61 F9      [ 9] 4231         JP      SUMLP           ; More coefficients
                           4232 
   F979 CD B6 F6      [16] 4233 RND:    CALL    TSTSGN          ; Test sign of FPREG
a  F97C               [16] 4234         LD      HL,SEED+2       ; Random number seed
   F97C FA B6 F9      [ 9] 4235         JP      M,RESEED        ; Negative - Re-seed
a  F97F               [ 9] 4236         LD      HL,LSTRND       ; Last random number
   F97F CD E3 F6      [16] 4237         CALL    PHLTFP          ; Move last RND to FPREG
a  F982               [16] 4238         LD      HL,SEED+2       ; Random number seed
   F982 C8            [10] 4239         RET     Z               ; Return if RND(0)
   F983 86            [ 6] 4240         ADD     A,(HL)          ; Add (SEED)+2)
q  F984                    4241         AND     00000111B       ; 0 to 7
a  F984               [ 6] 4242         LD      B,0
   F984 77            [ 7] 4243         LD      (HL),A          ; Re-save seed
   F985 23            [ 4] 4244         INC     HL              ; Move to coefficient table
   F986 87            [ 4] 4245         ADD     A,A             ; 4 bytes
   F987 87            [ 4] 4246         ADD     A,A             ; per entry
   F988 4F            [ 4] 4247         LD      C,A             ; BC = Offset into table
   F989 09            [ 7] 4248         ADD     HL,BC           ; Point to coefficient
   F98A CD F1 F6      [16] 4249         CALL    LOADFP          ; Coefficient to BCDE
   F98D CD D2 F5      [16] 4250         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
   F990 3A 18 10      [12] 4251         LD      A,(SEED+1)      ; Get (SEED+1)
   F993 3C            [ 4] 4252         INC     A               ; Add 1
q  F994                    4253         AND     00000011B       ; 0 to 3
a  F994               [ 4] 4254         LD      B,0
a  F994               [ 4] 4255         CP      1               ; Is it zero?
   F994 88            [ 4] 4256         ADC     A,B             ; Yes - Make it 1
   F995 32 18 10      [13] 4257         LD      (SEED+1),A      ; Re-save seed
a  F998               [13] 4258         LD      HL,RNDTAB-4     ; Addition table
   F998 87            [ 4] 4259         ADD     A,A             ; 4 bytes
   F999 87            [ 4] 4260         ADD     A,A             ; per entry
   F99A 4F            [ 4] 4261         LD      C,A             ; BC = Offset into table
   F99B 09            [ 7] 4262         ADD     HL,BC           ; Point to value
   F99C CD CB F4      [16] 4263         CALL    ADDPHL          ; Add value to FPREG
   F99F CD F1 F6      [16] 4264 RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
   F9A2 7B            [ 4] 4265         LD      A,E             ; Get LSB
   F9A3 59            [ 4] 4266         LD      E,C             ; LSB = MSB
q  F9A4                    4267         XOR     01001111B       ; Fiddle around
   F9A4 4F            [ 4] 4268         LD      C,A             ; New MSB
a  F9A5               [ 4] 4269         LD      (HL),0x80        ; Set exponent
   F9A5 2B            [ 4] 4270         DEC     HL              ; Point to MSB
   F9A6 46            [ 6] 4271         LD      B,(HL)          ; Get MSB
a  F9A7               [ 6] 4272         LD      (HL),0x80        ; Make value -0.5
a  F9A7               [ 6] 4273         LD      HL,SEED         ; Random number seed
   F9A7 34            [10] 4274         INC     (HL)            ; Count seed
   F9A8 7E            [ 6] 4275         LD      A,(HL)          ; Get seed
a  F9A9               [ 6] 4276         SUB     171             ; Do it modulo 171
   F9A9 C2 B0 F9      [ 9] 4277         JP      NZ,RND2         ; Non-zero - Ok
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 79.
Hexadecimal [16-Bits]



   F9AC 77            [ 7] 4278         LD      (HL),A          ; Zero seed
   F9AD 0C            [ 4] 4279         INC     C               ; Fillde about
   F9AE 15            [ 4] 4280         DEC     D               ; with the
   F9AF 1C            [ 4] 4281         INC     E               ; number
   F9B0 CD 24 F5      [16] 4282 RND2:   CALL    BNORM           ; Normalise number
a  F9B3               [16] 4283         LD      HL,LSTRND       ; Save random number
   F9B3 C3 FA F6      [ 9] 4284         JP      FPTHL           ; Move FPREG to last and return
                           4285 
   F9B6 77            [ 7] 4286 RESEED: LD      (HL),A          ; Re-seed random numbers
   F9B7 2B            [ 4] 4287         DEC     HL
   F9B8 77            [ 7] 4288         LD      (HL),A
   F9B9 2B            [ 4] 4289         DEC     HL
   F9BA 77            [ 7] 4290         LD      (HL),A
   F9BB C3 9F F9      [ 9] 4291         JP      RND1            ; Return RND seed
                           4292 
q  F9BE 68 01              4293 RNDTAB: .db      0x068,0B1H,046H,068H     ; Table used by RND
q  F9C0 99 00              4294         .db      0x099,0E9H,092H,069H
q  F9C2 10 01              4295         .db      0x010,0D1H,075H,068H
                           4296 
a  F9C4               [ 9] 4297 COS:    LD      HL,HALFPI       ; Point to PI/2
   F9C4 CD CB F4      [16] 4298         CALL    ADDPHL          ; Add it to PPREG
   F9C7 CD D6 F6      [16] 4299 SIN:    CALL    STAKFP          ; Put angle on stack
a  F9CA               [16] 4300         LD      BC,0x8349        ; BCDE = 2 PI
a  F9CA               [16] 4301         LD      DE,0x0FDB
   F9CA CD E6 F6      [16] 4302         CALL    FPBCDE          ; Move 2 PI to FPREG
   F9CD C1            [ 9] 4303         POP     BC              ; Restore angle
   F9CE D1            [ 9] 4304         POP     DE
   F9CF CD 1D F6      [16] 4305         CALL    DVBCDE          ; Divide angle by 2 PI
   F9D2 CD D6 F6      [16] 4306         CALL    STAKFP          ; Put it on stack
   F9D5 CD 63 F7      [16] 4307         CALL    INT             ; Get INT of result
   F9D8 C1            [ 9] 4308         POP     BC              ; Restore number
   F9D9 D1            [ 9] 4309         POP     DE
   F9DA CD D7 F4      [16] 4310         CALL    SUBCDE          ; Make it 0 <= value < 1
a  F9DD               [16] 4311         LD      HL,QUARTR       ; Point to 0.25
   F9DD CD D1 F4      [16] 4312         CALL    SUBPHL          ; Subtract value from 0.25
   F9E0 CD B6 F6      [16] 4313         CALL    TSTSGN          ; Test sign of value
   F9E3 37            [ 3] 4314         SCF                     ; Flag positive
   F9E4 F2 EE F9      [ 9] 4315         JP      P,SIN1          ; Positive - Ok
   F9E7 CD CB F4      [16] 4316         CALL    ROUND           ; Add 0.5 to value
   F9EA CD B6 F6      [16] 4317         CALL    TSTSGN          ; Test sign of value
   F9ED B7            [ 4] 4318         OR      A               ; Flag negative
   F9EE F5            [11] 4319 SIN1:   PUSH    AF              ; Save sign
   F9EF F4 D3 F6      [16] 4320         CALL    P,INVSGN        ; Negate value if positive
a  F9F2               [16] 4321         LD      HL,QUARTR       ; Point to 0.25
   F9F2 CD CB F4      [16] 4322         CALL    ADDPHL          ; Add 0.25 to value
   F9F5 F1            [ 9] 4323         POP     AF              ; Restore sign
   F9F6 D4 D3 F6      [16] 4324         CALL    NC,INVSGN       ; Negative - Make positive
a  F9F9               [16] 4325         LD      HL,SINTAB       ; Coefficient table
   F9F9 C3 4C F9      [ 9] 4326         JP      SUMSER          ; Evaluate sum of series
                           4327 
q  F9FC DB 00              4328 HALFPI: .db      0x0DB,00FH,049H,081H     ; 1.5708 (PI/2)
                           4329 
q  F9FE 00 00              4330 QUARTR: .db      0x000,000H,000H,07FH     ; 0.25
                           4331 
   FA00 05                 4332 SINTAB: .db      5                       ; Table used by SIN
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 80.
Hexadecimal [16-Bits]



q  FA01 BA 07              4333         .db      0x0BA,0D7H,01EH,086H     ; 39.711
q  FA03 64 1A              4334         .db      0x064,026H,099H,087H     ;-76.575
q  FA05 58 22              4335         .db      0x058,034H,023H,087H     ; 81.602
q  FA07 E0 05              4336         .db      0x0E0,05DH,0A5H,086H     ;-41.342
q  FA09 DA 00              4337         .db      0x0DA,00FH,049H,083H     ;  6.2832
                           4338 
   FA0B CD D6 F6      [16] 4339 TAN:    CALL    STAKFP          ; Put angle on stack
   FA0E CD C7 F9      [16] 4340         CALL    SIN             ; Get SIN of angle
   FA11 C1            [ 9] 4341         POP     BC              ; Restore angle
   FA12 E1            [ 9] 4342         POP     HL
   FA13 CD D6 F6      [16] 4343         CALL    STAKFP          ; Save SIN of angle
   FA16 EB            [ 3] 4344         EX      DE,HL           ; BCDE = Angle
   FA17 CD E6 F6      [16] 4345         CALL    FPBCDE          ; Angle to FPREG
   FA1A CD C4 F9      [16] 4346         CALL    COS             ; Get COS of angle
   FA1D C3 1B F6      [ 9] 4347         JP      DIV             ; TAN = SIN / COS
                           4348 
   FA20 CD B6 F6      [16] 4349 ATN:    CALL    TSTSGN          ; Test sign of value
   FA23 FC C5 F8      [16] 4350         CALL    M,NEGAFT        ; Negate result after if -ve
   FA26 FC D3 F6      [16] 4351         CALL    M,INVSGN        ; Negate value if -ve
   FA29 3A E7 10      [12] 4352         LD      A,(FPEXP)       ; Get exponent
a  FA2C               [12] 4353         CP      0x81             ; Number less than 1?
   FA2C DA 35 FA      [ 9] 4354         JP      C,ATN1          ; Yes - Get arc tangnt
a  FA2F               [ 9] 4355         LD      BC,0x8100        ; BCDE = 1
   FA2F 51            [ 4] 4356         LD      D,C
   FA30 59            [ 4] 4357         LD      E,C
   FA31 CD 1D F6      [16] 4358         CALL    DVBCDE          ; Get reciprocal of number
a  FA34               [16] 4359         LD      HL,SUBPHL       ; Sub angle from PI/2
   FA34 E5            [11] 4360         PUSH    HL              ; Save for angle > 1
a  FA35               [11] 4361 ATN1:   LD      HL,ATNTAB       ; Coefficient table
   FA35 CD 4C F9      [16] 4362         CALL    SUMSER          ; Evaluate sum of series
a  FA38               [16] 4363         LD      HL,HALFPI       ; PI/2 - angle in case > 1
   FA38 C9            [ 9] 4364         RET                     ; Number > 1 - Sub from PI/2
                           4365 
   FA39 09                 4366 ATNTAB: .db      9                       ; Table used by ATN
q  FA3A 4A 07              4367         .db      0x04A,0D7H,03BH,078H     ; 1/17
q  FA3C 02 06              4368         .db      0x002,06EH,084H,07BH     ;-1/15
q  FA3E FE 00              4369         .db      0x0FE,0C1H,02FH,07CH     ; 1/13
q  FA40 74 1F              4370         .db      0x074,031H,09AH,07DH     ;-1/11
q  FA42 84 03              4371         .db      0x084,03DH,05AH,07DH     ; 1/9
q  FA44 C8 07              4372         .db      0x0C8,07FH,091H,07EH     ;-1/7
q  FA46 E4 00              4373         .db      0x0E4,0BBH,04CH,07EH     ; 1/5
q  FA48 6C 00              4374         .db      0x06C,0AAH,0AAH,07FH     ;-1/3
q  FA4A 00 00              4375         .db      0x000,000H,000H,081H     ; 1/1
                           4376 
   FA4C CD 74 FB      [16] 4377 CASFFW: CALL    FLPLED          ; Turn on cassette
a  FA4F               [16] 4378         LD      B,0             ; Set 1 second delay
   FA4F CD ED FA      [16] 4379 DELAYB: CALL    DELAY           ; Wait a bit
   FA52 05            [ 4] 4380         DEC     B               ; Count
   FA53 C2 4F FA      [ 9] 4381         JP      NZ,DELAYB       ; More delay needed
   FA56 C9            [ 9] 4382         RET
                           4383 
   FA57 C3 74 FB      [ 9] 4384 CASFF:  JP      FLPLED          ; Flip tape LED
                           4385 
   FA5A C9            [ 9] 4386 ARET:   RET                     ; A RETurn instruction
                           4387 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 81.
Hexadecimal [16-Bits]



   FA5B E5            [11] 4388 CONMON: PUSH    HL              ; Output character to screen
   FA5C C5            [11] 4389         PUSH    BC              ; 
   FA5D D5            [11] 4390         PUSH    DE              ; 
   FA5E F5            [11] 4391         PUSH    AF              ; 
   FA5F CD A4 FB      [16] 4392         CALL    MONTST          ; See if NAS-SYS
   FA62 C2 73 FA      [ 9] 4393         JP      NZ,NASOUT       ; NAS-SYS - Output ASCII
   FA65 F1            [ 9] 4394         POP     AF              ; Get character
   FA66 F5            [11] 4395         PUSH    AF              ; And re-save
a  FA67               [11] 4396         CP      LF              ; ASCII Line feed?
   FA67 CA 78 FA      [ 9] 4397         JP      Z,IG0xCR         ; Yes - Ignore it
a  FA6A               [ 9] 4398         CP      BKSP            ; ASCII back space?
   FA6A C2 6D FA      [ 9] 4399         JP      NZ,CONOT1       ; No - Test for CR
a  FA6D               [ 9] 4400         LD      A,TBS           ; NASBUG back space
a  FA6D               [ 9] 4401 CONOT1: CP      CR              ; ASCII CR?
   FA6D C2 75 FA      [ 9] 4402         JP      NZ,OUT0xCR       ; No - Output character
a  FA70               [ 9] 4403         LD      A,TCR           ; NASBUG CR
   FA70 C3 75 FA      [ 9] 4404         JP      OUT0xCR          ; Output it
                           4405 
   FA73 F1            [ 9] 4406 NASOUT: POP     AF              ; Get character
   FA74 F5            [11] 4407         PUSH    AF              ; And re-save
   FA75 CD 80 FB      [16] 4408 OUT0xCR: CALL    MONOUT          ; Output it
   FA78 F1            [ 9] 4409 IG0xCR:  POP     AF              ; Restore character
   FA79 D1            [ 9] 4410         POP     DE              ;
   FA7A C1            [ 9] 4411         POP     BC              ;
   FA7B E1            [ 9] 4412         POP     HL              ;
   FA7C C9            [ 9] 4413         RET
                           4414 
   FA7D E5            [11] 4415 GETINP: PUSH    HL              ; Get an input character
   FA7E C5            [11] 4416         PUSH    BC              ;
   FA7F D5            [11] 4417         PUSH    DE              ;
   FA80 CD A4 FB      [16] 4418         CALL    MONTST          ; See if NAS-SYS
   FA83 CA 8B FA      [ 9] 4419         JP      Z,GETTIN        ; "T" monitor - Get input
   FA86 DF 7B              4420         .dw      _BLNK
   FA88 C3 91 FA      [ 9] 4421         JP      CONVIN          ; Convert to ASCII
                           4422 
   FA8B CD 4D 0C      [16] 4423 GETTIN: CALL    TIN             ; "T" input a character
   FA8E D2 8B FA      [ 9] 4424         JP      NC,GETTIN       ; No input - wait
a  FA91               [ 9] 4425 CONVIN: CP      TBS             ; NASBUG back space?
   FA91 C2 94 FA      [ 9] 4426         JP      NZ,CNVIN1       ; No - Test for break
a  FA94               [ 9] 4427         LD      A,BKSP          ; ASCII back space
a  FA94               [ 9] 4428 CNVIN1: CP      TBRK            ; NASBUG break?
   FA94 C2 97 FA      [ 9] 4429         JP      NZ,CNVIN2       ; No - Test for control Z
a  FA97               [ 9] 4430         LD      A,CTRLC         ; Control C
a  FA97               [ 9] 4431 CNVIN2: CP      CTRLZ           ; ^Z?
   FA97 C2 9A FA      [ 9] 4432         JP      NZ,CNVIN3       ; No - Test for escape
a  FA9A               [ 9] 4433         LD      A,DEL           ; Delete
a  FA9A               [ 9] 4434 CNVIN3: CP      ESC             ; "ESC" ?
   FA9A C2 9D FA      [ 9] 4435         JP      NZ,CNVIN4       ; No - Test for CR
a  FA9D               [ 9] 4436         LD      A,CTRLC         ; Control C
a  FA9D               [ 9] 4437 CNVIN4: CP      TCR             ; NASBUG CR?
   FA9D C2 A0 FA      [ 9] 4438         JP      NZ,CNVIN5       ; No - Return character
a  FAA0               [ 9] 4439         LD      A,CR            ; ASCII CR
   FAA0 D1            [ 9] 4440 CNVIN5: POP     DE
   FAA1 C1            [ 9] 4441         POP     BC
   FAA2 E1            [ 9] 4442         POP     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 82.
Hexadecimal [16-Bits]



   FAA3 C9            [ 9] 4443         RET
                           4444 
q                          4445 0xCKBRK: XOR     A               ; Check for break
   FAA4 CD D1 FA      [16] 4446         CALL    SFTENT          ; Test for shift/enter
   FAA7 CA B3 FA      [ 9] 4447         JP      Z,TBRK2         ; Yes - Test for second break
   FAAA 3A 4D 10      [12] 4448         LD      A,(BRKFLG)      ; Get break flag
   FAAD B7            [ 4] 4449         OR      A               ; Break flag set?
   FAAE C2 B3 FA      [ 9] 4450         JP      NZ,TBRK2        ; Yes - Test for second break
   FAB1 AF            [ 4] 4451         XOR     A               ; Flag no break
   FAB2 C9            [ 9] 4452         RET
                           4453 
   FAB3 CD 8E FB      [16] 4454 TBRK2:  CALL    BREAK2          ; Second break?
a  FAB6               [16] 4455         LD      A,-1            ; Flag break
   FAB6 C9            [ 9] 4456         RET
                           4457 
   FAB7 DB 02         [ 9] 4458 GUART:  IN      A,(UARTS)       ; Get UART status
   FAB9 17            [ 3] 4459         RLA                     ; Any data ready?
   FABA D2 B7 FA      [ 9] 4460         JP      NC,GUART        ; No - wait until there is
   FABD DB 01         [ 9] 4461         IN      A,(UARTD)       ; Get data from UART
   FABF C9            [ 9] 4462         RET
                           4463 
   FAC0 D3 01         [10] 4464 UARTOT: OUT     (UARTD),A       ; Send data to UART
   FAC2 DB 02         [ 9] 4465 URTOLP: IN      A,(UARTS)       ; Get status
   FAC4 87            [ 4] 4466         ADD     A,A             ; Byte sent?
   FAC5 F8            [10] 4467         RET     M               ; Yes - Return
   FAC6 C3 C2 FA      [ 9] 4468         JP      URTOLP          ; Keep waiting
                           4469 
   FAC9 F5            [11] 4470 SUART:  PUSH    AF              ; Save A
   FACA CD C0 FA      [16] 4471         CALL    UARTOT          ; Send it to UART
   FACD F1            [ 9] 4472         POP     AF              ; Restore A
   FACE C9            [ 9] 4473         RET
                           4474 
   FACF 00            [ 3] 4475         NOP
   FAD0 00            [ 3] 4476         NOP
                           4477 
   FAD1 E5            [11] 4478 SFTENT: PUSH    HL              ; Test for Shift Enter from KBD
aq FAD2               [11] 4479         LD      A,00000010B     ; Reset KBD counter mask
a  FAD2               [11] 4480         LD      HL,PORT0        ; Get old contents
   FAD2 AE            [ 6] 4481         XOR     (HL)            ; Toggle bit
   FAD3 D3 00         [10] 4482         OUT     (0),A           ; Reset KBD counter
q  FAD5                    4483         XOR     00000001B       ; Toggle bit
   FAD5 D3 00         [10] 4484         OUT     (0),A           ; Next row
q  FAD7                    4485         XOR     00000010B
   FAD7 D3 00         [10] 4486         OUT     (0),A           ; Clear "clear" strobe
   FAD9 7E            [ 6] 4487         LD      A,(HL)          ; Get old value
   FADA D3 00         [10] 4488         OUT     (0),A           ; Original contents
   FADC 19            [ 7] 4489         ADD     HL,DE           ; ?? WHAT ??
   FADD E1            [ 9] 4490         POP     HL              ; Restore HL
   FADE DB 00         [ 9] 4491         IN      A,(0)           ; Read in row
q  FAE0                    4492         AND     00010010B       ; Mask SHIFT and ENTER
   FAE0 C9            [ 9] 4493         RET
                           4494 
   FAE1 CD A4 FB      [16] 4495 CLS:    CALL    MONTST          ; See if NAS-SYS
   FAE4 CA EA FA      [ 9] 4496         JP      Z,TCLS          ; "T" CLS
a  FAE7               [ 9] 4497         LD      A,CS            ; ASCII Clear screen
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 83.
Hexadecimal [16-Bits]



   FAE7 C3 5B FA      [ 9] 4498         JP      CONMON          ; Output character
                           4499 
a  FAEA               [ 9] 4500 TCLS:   LD      A,TCS           ; NASBUG Clear screen
   FAEA C3 5B FA      [ 9] 4501         JP      CONMON          ; Output character
                           4502 
   FAED AF            [ 4] 4503 DELAY:  XOR     A               ; Delay routine
   FAEE F5            [11] 4504 DELAY1: PUSH    AF              ; PUSHes and POPs delay
   FAEF F1            [ 9] 4505         POP     AF
   FAF0 F5            [11] 4506         PUSH    AF
   FAF1 F1            [ 9] 4507         POP     AF
   FAF2 3D            [ 4] 4508         DEC     A               ; Count delays
   FAF3 C2 EE FA      [ 9] 4509         JP      NZ,DELAY1       ; More delay
   FAF6 C9            [ 9] 4510         RET
                           4511 
   FAF7 CD C8 F3      [16] 4512 WIDTH:  CALL    GETINT          ; Get integer 0-255
   FAFA 7B            [ 4] 4513         LD      A,E             ; Width to A
   FAFB 32 42 10      [13] 4514         LD      (LWIDTH),A      ; Set width
   FAFE C9            [ 9] 4515         RET
                           4516 
   FAFF CD F2 EC      [16] 4517 LINES:  CALL    GETNUM          ; Get a number
   FB02 CD 88 E9      [16] 4518         CALL    DEINT           ; Get integer -32768 to 32767
   FB05 ED 53 46 10   [19] 4519         LD      (LINESC),DE     ; Set lines counter
   FB09 ED 53 48 10   [19] 4520         LD      (LINESN),DE     ; Set lines number
   FB0D C9            [ 9] 4521         RET
                           4522 
   FB0E CD 88 E9      [16] 4523 DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
   FB11 D5            [11] 4524         PUSH    DE              ; Save number
   FB12 E1            [ 9] 4525         POP     HL              ; Number to HL
   FB13 46            [ 6] 4526         LD      B,(HL)          ; Get LSB of contents
   FB14 23            [ 4] 4527         INC     HL
   FB15 7E            [ 6] 4528         LD      A,(HL)          ; Get MSB of contents
   FB16 C3 8E F0      [ 9] 4529         JP      ABPASS          ; Return integer AB
                           4530 
   FB19 CD F2 EC      [16] 4531 DOKE:   CALL    GETNUM          ; Get a number
   FB1C CD 88 E9      [16] 4532         CALL    DEINT           ; Get integer -32768 to 32767
   FB1F D5            [11] 4533         PUSH    DE              ; Save address
   FB20 CD 90 E6      [16] 4534         CALL    CHKSYN          ; Make sure "," follows
   FB23 2C                 4535         .db      ","
   FB24 CD F2 EC      [16] 4536         CALL    GETNUM          ; Get a number
   FB27 CD 88 E9      [16] 4537         CALL    DEINT           ; Get integer -32768 to 32767
   FB2A E3            [16] 4538         EX      (SP),HL         ; Save value,get address
   FB2B 73            [ 7] 4539         LD      (HL),E          ; Save LSB of value
   FB2C 23            [ 4] 4540         INC     HL
   FB2D 72            [ 7] 4541         LD      (HL),D          ; Save MSB of value
   FB2E E1            [ 9] 4542         POP     HL              ; Restore code string address
   FB2F C9            [ 9] 4543         RET
                           4544 
   FB30 F3            [ 3] 4545 JJUMP1: DI                      ; Disable interrupts
a  FB31               [ 3] 4546         LD      IX,-1           ; Flag cold start
   FB31 C3 12 E0      [ 9] 4547         JP      CSTART          ; Go and initialise
                           4548 
   FB34 CD C8 F3      [16] 4549 SCREEN: CALL    GETINT          ; Get integer 0 to 255
   FB37 F5            [11] 4550         PUSH    AF              ; Save column
   FB38 CD 90 E6      [16] 4551         CALL    CHKSYN          ; Make sure "," follows
   FB3B 2C                 4552         .db      ","
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 84.
Hexadecimal [16-Bits]



   FB3C CD C8 F3      [16] 4553         CALL    GETINT          ; Get integer 0 to 255
   FB3F C1            [ 9] 4554         POP     BC              ; Column to B
   FB40 E5            [11] 4555         PUSH    HL              ; Save code string address
   FB41 C5            [11] 4556         PUSH    BC              ; Save column
   FB42 CD 5B FB      [16] 4557         CALL    SCRADR          ; Calculate screen address
   FB45 E5            [11] 4558         PUSH    HL              ; Save screen address
   FB46 CD A4 FB      [16] 4559         CALL    MONTST          ; See if NAS-SYS
   FB49 CA 52 FB      [ 9] 4560         JP      Z,TMNCUR        ; "T" monitor - "T" cursor
   FB4C E1            [ 9] 4561         POP     HL              ; Restore screen address
   FB4D 22 29 0C      [16] 4562         LD      (CURSOR),HL     ; Set new cursor position
   FB50 E1            [ 9] 4563         POP     HL              ; Rstore code string address
   FB51 C9            [ 9] 4564         RET
                           4565 
   FB52 2A 18 0C      [15] 4566 TMNCUR: LD      HL,(TCUR)       ; Get address or cursor
a  FB55               [15] 4567         LD      (HL)," "        ; Remove cursor
   FB55 E1            [ 9] 4568         POP     HL              ; Get new cursor address
   FB56 22 18 0C      [16] 4569         LD      (TCUR),HL       ; Set new cursor
a  FB59               [16] 4570         LD      (HL),"_"        ; Put it on screen
   FB59 E1            [ 9] 4571         POP     HL              ; Restore code string address
   FB5A C9            [ 9] 4572         RET
                           4573 
a  FB5B               [ 9] 4574 SCRADR: LD      HL,VDU+10-65    ; SCREEN VDU address (0,0)
a  FB5B               [ 9] 4575         LD      B,0
   FB5B 4F            [ 4] 4576         LD      C,A             ; Line to BC
   FB5C B7            [ 4] 4577         OR      A               ; Test it
   FB5D CA 95 E9      [ 9] 4578         JP      Z,FCERR         ; Zero - ?FC Error
a  FB60               [ 9] 4579         CP      16+1            ; 16 lines
   FB60 F2 95 E9      [ 9] 4580         JP      P,FCERR         ; > 16 - ?FC Error
   FB63 D1            [ 9] 4581         POP     DE              ; RETurn address
   FB64 F1            [ 9] 4582         POP     AF              ; Get column
   FB65 D5            [11] 4583         PUSH    DE              ; Re-save RETurn
a  FB66               [11] 4584         LD      D,0
   FB66 5F            [ 4] 4585         LD      E,A             ; Column to DE
   FB67 B7            [ 4] 4586         OR      A               ; Test it
   FB68 CA 95 E9      [ 9] 4587         JP      Z,FCERR         ; Zero - ?FC Error
a  FB6B               [ 9] 4588         CP      48+1            ; 48 characters per line
   FB6B F2 95 E9      [ 9] 4589         JP      P,FCERR         ; > 48 - ?FC Error
   FB6E 19            [ 7] 4590         ADD     HL,DE           ; Add column to address
a  FB6F               [ 7] 4591         LD      D,0
   FB6F 59            [ 4] 4592         LD      E,C             ; Line to DE
a  FB70               [ 4] 4593         LD      B,64            ; 64 Bytes per line
   FB70 19            [ 7] 4594 ADD64X: ADD     HL,DE           ; Add line
   FB71 10 FD         [ 9] 4595         DJNZ    ADD64X          ; SIXTY FOUR TIMES!!!
   FB73 C9            [ 9] 4596         RET
                           4597 
   FB74 CD A4 FB      [16] 4598 FLPLED: CALL    MONTST          ; See if NAS-SYS
   FB77 CA 7D FB      [ 9] 4599         JP      Z,TMFLP         ; "T" MFLP
   FB7A DF 5F              4600         .dw      _MFLP
   FB7C C9            [ 9] 4601         RET
                           4602 
   FB7D C3 51 00      [ 9] 4603 TMFLP:  JP      MFLP            ; Flip drive LED
                           4604 
   FB80 F5            [11] 4605 MONOUT: PUSH    AF              ; Save character
   FB81 CD A4 FB      [16] 4606         CALL    MONTST          ; See if NAS-SYS
   FB84 CA 8A FB      [ 9] 4607         JP      Z,TMNOUT        ; "T" output
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 85.
Hexadecimal [16-Bits]



   FB87 F1            [ 9] 4608         POP     AF              ; Restore character
   FB88 F7                 4609         .db      _ROUT           ; Output it
   FB89 C9            [ 9] 4610         RET
                           4611 
   FB8A F1            [ 9] 4612 TMNOUT: POP     AF              ; Restore character
   FB8B C3 4A 0C      [ 9] 4613         JP      TOUT            ; "T" output
                           4614 
   FB8E 3A 4D 10      [12] 4615 BREAK2: LD      A,(BRKFLG)      ; Break flag set?
   FB91 C2 A0 FB      [ 9] 4616         JP      NZ,RETCTC       ; Yes - Return ^C
   FB94 CD A4 FB      [16] 4617         CALL    MONTST          ; See if NAS-SYS
   FB97 CA 9D FB      [ 9] 4618         JP      Z,T0xCINP        ; Get "T" character input
   FB9A DF 62              4619         .dw      _RIN            ; Scan for a character
   FB9C C9            [ 9] 4620         RET
                           4621 
   FB9D C3 4D 0C      [ 9] 4622 T0xCINP: JP      TIN             ; "T" input a character
                           4623 
a  FBA0               [ 9] 4624 RETCTC: LD      A,0             ; Clear Break flag
   FBA0 32 4D 10      [13] 4625         LD      (BRKFLG),A
a  FBA3               [13] 4626         LD      A,CTRLC         ; Return ^C
   FBA3 C9            [ 9] 4627         RET
                           4628 
   FBA4 3A 01 00      [12] 4629 MONTST: LD      A,(MONSTT+1)    ; "T" monitor or NAS-SYS?
a  FBA7               [12] 4630         CP      0x33             ; 31 00 10 / 31 33 0C
   FBA7 C9            [ 9] 4631         RET
                           4632 
   FBA8 CD 74 FB      [16] 4633 SAVE:   CALL    FLPLED          ; Flip tape LED
   FBAB CD A4 FB      [16] 4634         CALL    MONTST          ; See if NAS-SYS
   FBAE CA B4 FB      [ 9] 4635         JP      Z,TSAVE         ; "T" save
   FBB1 DF 57              4636         .dw      _WRIT           ; Save program
   FBB3 C9            [ 9] 4637         RET
                           4638 
   FBB4 3A 8D 00      [12] 4639 TSAVE:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
   FBB7 CA 00 04      [ 9] 4640         JP      Z,T4WR          ; T4 Write
   FBBA C3 D1 03      [ 9] 4641         JP      T2DUMP          ; T2 Dump
                           4642 
   FBBD CD 74 FB      [16] 4643 MONLD:  CALL    FLPLED          ; Flip tape LED
   FBC0 CD A4 FB      [16] 4644         CALL    MONTST          ; See if NAS-SYS
   FBC3 CA CC FB      [ 9] 4645         JP      Z,TLOAD         ; "T" load
a  FBC6               [ 9] 4646         LD      A,"R"           ; Set READ
   FBC6 32 2B 0C      [13] 4647         LD      (ARGN),A
   FBC9 DF 52              4648         .dw      _READ           ; Load program
   FBCB C9            [ 9] 4649         RET
                           4650 
   FBCC 3A 8D 00      [12] 4651 TLOAD:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
   FBCF CA 0C 07      [ 9] 4652         JP      Z,T4READ        ; T4 Read
   FBD2 C3 D1 03      [ 9] 4653         JP      T2DUMP          ; T2 Dump ??????????
                           4654 
   FBD5 CD A4 FB      [16] 4655 MONITR: CALL    MONTST          ; See if NAS-SYS
   FBD8 CA 00 00      [ 9] 4656         JP      Z,MONSTT        ; Jump to zero if "T"
   FBDB DF 5B              4657         .dw      _MRET           ; Return to NAS-SYS
                           4658 
   FBDD CD 74 FB      [16] 4659 MONVE:  CALL    FLPLED          ; Flip tape LED
   FBE0 CD A4 FB      [16] 4660         CALL    MONTST          ; See if NAS-SYS
   FBE3 CA 95 E9      [ 9] 4661         JP      Z,FCERR         ; Verify not available on "T"
a  FBE6               [ 9] 4662         LD      A,"V"           ; Set VERIFY
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 86.
Hexadecimal [16-Bits]



   FBE6 32 2B 0C      [13] 4663         LD      (ARGN),A
   FBE9 DF 56              4664         .dw      _VRFY           ; Verify tape
   FBEB C9            [ 9] 4665         RET
                           4666 
a  FBEC               [ 9] 4667 INITST: LD      A,0             ; Clear break flag
   FBEC 32 4D 10      [13] 4668         LD      (BRKFLG),A
   FBEF CD A4 FB      [16] 4669         CALL    MONTST          ; See if NAS-SYS
   FBF2 CA 19 E0      [ 9] 4670         JP      Z,INIT          ; "T" - No NMI vector
a  FBF5               [ 9] 4671         LD      HL,BREAK        ; Set NMI gives break
   FBF5 22 7E 0C      [16] 4672         LD      (NMI),HL
   FBF8 DD E5         [14] 4673         PUSH    IX              ; Get start up condition
   FBFA F1            [ 9] 4674         POP     AF              ; "Z" set if cold , Else clear
   FBFB B7            [ 4] 4675         OR      A               ; "Cold" or "Cool" start?
   FBFC C2 19 E0      [ 9] 4676         JP      NZ,INIT         ; "Cool" don't init NAS-SYS
a  FBFF               [ 9] 4677         LD      B,15            ; Delay for keyboard clear
   FBFF CD 4F FA      [16] 4678         CALL    DELAYB          ; Allow time for key release
   FC02 CD 0D 00      [16] 4679         CALL    STMON           ; Initialise NAS-SYS
   FC05 C3 19 E0      [ 9] 4680         JP      INIT            ; Initialise BASIC
                           4681 
   FC08 F5            [11] 4682 BREAK:  PUSH    AF              ; Save character
a  FC09               [11] 4683         LD      A,-1
   FC09 32 4D 10      [13] 4684         LD      (BRKFLG),A      ; Flag break
   FC0C F1            [ 9] 4685         POP     AF              ; Restore character
   FC0D ED 45         [12] 4686 ARETN:  RETN                    ; Return from NMI
                           4687 
   FC0F 00            [ 3] 4688         NOP
                           4689 
   FC10 DF 63              4690 INLINE: .dw      _INLN           ; Get an input line
   FC12 D5            [11] 4691         PUSH    DE              ; Save cursor address
   FC13 D5            [11] 4692         PUSH    DE              ; Cursor address to HL
   FC14 E1            [ 9] 4693         POP     HL
a  FC15               [ 9] 4694         LD      DE,48-1         ; Length of line-1
   FC15 19            [ 7] 4695         ADD     HL,DE           ; Point to end of line
   FC16 7E            [ 6] 4696 ENDLIN: LD      A,(HL)          ; Get end of line
a  FC17               [ 6] 4697         CP      " "             ; Space?
   FC17 C2 23 FC      [ 9] 4698         JP      NZ,LINTBF       ; No - Copy to buffer
   FC1A 1D            [ 4] 4699         DEC     E               ; Back 1 character
a  FC1B               [ 4] 4700         LD      A,0             ; Wasteful test on E
   FC1B B3            [ 4] 4701         OR      E
   FC1C CA 23 FC      [ 9] 4702         JP      Z,LINTBF        ; Start of line - Copy it
   FC1F 2B            [ 4] 4703         DEC     HL              ; Back 1 character
   FC20 C3 16 FC      [ 9] 4704         JP      ENDLIN          ; Keep looking for end
                           4705 
   FC23 D5            [11] 4706 LINTBF: PUSH    DE              ; Line length to BC
   FC24 C1            [ 9] 4707         POP     BC
   FC25 03            [ 4] 4708         INC     BC              ; Length +1
a  FC26               [ 4] 4709         LD      DE,BUFFER       ; Input buffer
   FC26 E1            [ 9] 4710         POP     HL              ; Line start
   FC27 C5            [11] 4711         PUSH    BC              ; Save length
   FC28 ED B0         [14] 4712         LDIR                    ; Move line to buffer
a  FC2A               [14] 4713         LD      A,0
   FC2A 12            [ 7] 4714         LD      (DE),A          ; Mark end of buffer with 00
   FC2B C1            [ 9] 4715         POP     BC              ; Restore buffer length
   FC2C 41            [ 4] 4716         LD      B,C             ; Length returned in B
a  FC2D               [ 4] 4717         LD      HL,BUFFER-1     ; Point to start of buffer-1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 87.
Hexadecimal [16-Bits]



   FC2D C9            [ 9] 4718         RET
                           4719 
   FC2E CD 90 E6      [16] 4720 GETXYA: CALL    CHKSYN          ; Make sure "(" follows
   FC31 28                 4721         .db      "("
   FC32 CD F2 EC      [16] 4722         CALL    GETNUM          ; Get a number
   FC35 CD 88 E9      [16] 4723         CALL    DEINT           ; Get integer -32768 to 32767
   FC38 D5            [11] 4724         PUSH    DE              ; Save "X"
   FC39 CD 90 E6      [16] 4725         CALL    CHKSYN          ; Make sure "," follows
   FC3C 2C                 4726         .db      ","
   FC3D CD F2 EC      [16] 4727         CALL    GETNUM          ; Get a number
   FC40 CD 90 E6      [16] 4728         CALL    CHKSYN          ; Make sure ")" follows
   FC43 29                 4729         .db      ")"
   FC44 CD 88 E9      [16] 4730         CALL    DEINT           ; Get integer -32768 to 32767
   FC47 E5            [11] 4731         PUSH    HL              ; Save code string address
   FC48 FD E1         [12] 4732         POP     IY              ; In IY
   FC4A CD 98 FC      [16] 4733         CALL    XYPOS           ; Address and bit mask
   FC4D F5            [11] 4734         PUSH    AF              ; Save mask
   FC4E CD B8 FC      [16] 4735         CALL    ADJCOL          ; Adjust column
   FC51 CD 5B FB      [16] 4736         CALL    SCRADR          ; Get VDU address
   FC54 F1            [ 9] 4737         POP     AF              ; Restore bit mask
aq FC55               [ 9] 4738         LD      B,11000000B     ; Block graphics base
   FC55 B0            [ 4] 4739         OR      B               ; Set bits 7 & 6
   FC56 C9            [ 9] 4740         RET
                           4741 
   FC57 CD 2E FC      [16] 4742 SETB:   CALL    GETXYA          ; Get co-ords and VDU address
   FC5A F5            [11] 4743         PUSH    AF              ; Save bit mask
   FC5B 7E            [ 6] 4744         LD      A,(HL)          ; Get character from screen
q  FC5C                    4745         CP      11000000B       ; Is it a block graphic?
   FC5C D2 65 FC      [ 9] 4746         JP      NC,SETOR        ; Yes - OR new bit
   FC5F F1            [ 9] 4747         POP     AF              ; Restore bit mask
   FC60 77            [ 7] 4748 PUTBIT: LD      (HL),A          ; Put character on screen
   FC61 FD E5         [14] 4749 RESCSA: PUSH    IY              ; Restore code string address
   FC63 E1            [ 9] 4750         POP     HL              ; From IY
   FC64 C9            [ 9] 4751         RET
                           4752 
   FC65 C1            [ 9] 4753 SETOR:  POP     BC              ; Restore bit mask
   FC66 B0            [ 4] 4754         OR      B               ; Merge the bits
   FC67 C3 60 FC      [ 9] 4755         JP      PUTBIT          ; Save on screen
                           4756 
   FC6A CD 2E FC      [16] 4757 RESETB: CALL    GETXYA          ; Get co-ords and VDU address
   FC6D F5            [11] 4758         PUSH    AF              ; Save bit mask
   FC6E 7E            [ 6] 4759         LD      A,(HL)          ; Get byte from screen
q  FC6F                    4760         CP      11000000B       ; Is it a block graphic?
   FC6F DA 80 FC      [ 9] 4761         JP      C,NORES         ; No - Leave it
aq FC72               [ 9] 4762         LD      B,00111111B     ; Six bits per block
   FC72 A0            [ 4] 4763         AND     B               ; Clear bits 7 & 6
   FC73 C1            [ 9] 4764         POP     BC              ; Get bit mask
   FC74 A0            [ 4] 4765         AND     B               ; Test for common bit
   FC75 CA 61 FC      [ 9] 4766         JP      Z,RESCSA        ; None - Leave it
   FC78 7E            [ 6] 4767         LD      A,(HL)          ; Get byte from screen
q  FC79                    4768         AND     00111111B       ; Isolate bit
   FC79 A8            [ 4] 4769         XOR     B               ; Clear that bit
q  FC7A                    4770         CP      11000000B       ; Is it a graphic blank?
   FC7A C2 60 FC      [ 9] 4771         JP      NZ,PUTBIT       ; No - Save character
a  FC7D               [ 9] 4772         LD      A," "           ; Put a space there
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 88.
Hexadecimal [16-Bits]



   FC7D C3 60 FC      [ 9] 4773         JP      PUTBIT          ; Save the space
                           4774 
   FC80 C1            [ 9] 4775 NORES:  POP     BC              ; Drop bit mask
   FC81 C3 61 FC      [ 9] 4776         JP      RESCSA          ; Restore code string address
                           4777 
   FC84 CD 2E FC      [16] 4778 POINTB: CALL    GETXYA          ; Get co-ords and VDU address
   FC87 46            [ 6] 4779         LD      B,(HL)          ; Get character from screen
   FC88 CD E1 FC      [16] 4780         CALL    TSTBIT          ; Test if bit is set
   FC8B C2 95 FC      [ 9] 4781         JP      NZ,POINT0       ; Different - Return zero
a  FC8E               [ 9] 4782         LD      A,0
a  FC8E               [ 9] 4783         LD      B,1             ; Integer AB = 1
   FC8E E1            [ 9] 4784 POINTX: POP     HL              ; Drop return
   FC8F FD E5         [14] 4785         PUSH    IY              ; PUSH code string address
a  FC91               [14] 4786         LD      DE,RETNUM       ; To return a number
   FC91 D5            [11] 4787         PUSH    DE              ; Save for return
   FC92 C3 8E F0      [ 9] 4788         JP      ABPASS          ; Return integer AB
                           4789 
a  FC95               [ 9] 4790 POINT0: LD      B,0             ; Set zero
   FC95 C3 8E FC      [ 9] 4791         JP      POINTX          ; Return value
                           4792 
   FC98 C1            [ 9] 4793 XYPOS:  POP     BC              ; Get return address
   FC99 E1            [ 9] 4794         POP     HL              ; Get column
   FC9A E5            [11] 4795         PUSH    HL              ; And re-save
   FC9B C5            [11] 4796         PUSH    BC              ; Put back return address
   FC9C 7D            [ 4] 4797         LD      A,L             ; Get column
aq FC9D               [ 4] 4798         LD      B,00000001B     ; 2 bits per character
   FC9D A0            [ 4] 4799         AND     B               ; Odd or even bit
   FC9E F5            [11] 4800         PUSH    AF              ; Save it
   FC9F D5            [11] 4801         PUSH    DE              ; Get row
   FCA0 E1            [ 9] 4802         POP     HL              ; to HL
a  FCA1               [ 9] 4803         LD      DE,0            ; Zero line count
a  FCA1               [ 9] 4804         LD      BC,3            ; 3 blocks per line
   FCA1 23            [ 4] 4805         INC     HL
   FCA2 ED 42         [10] 4806 DIV3LP: SBC     HL,BC           ; Subtract 3
   FCA4 13            [ 4] 4807         INC     DE              ; Count the subtractions
   FCA5 CA AB FC      [ 9] 4808         JP      Z,DIV3EX        ; Exactly - Exit
   FCA8 F2 A2 FC      [ 9] 4809         JP      P,DIV3LP        ; More to do
                           4810 
   FCAB 09            [ 7] 4811 DIV3EX: ADD     HL,BC           ; Restore number
   FCAC F1            [ 9] 4812         POP     AF              ; Restore column and odd/even
   FCAD B7            [ 4] 4813         OR      A               ; Set flags (NZ or Z)
   FCAE 7D            [ 4] 4814         LD      A,L             ; Get remainder from /3
   FCAF CA B2 FC      [ 9] 4815         JP      Z,NOREMD        ; No remainder
a  FCB2               [ 9] 4816         ADD     A,3             ; Adjust remainder
   FCB2 47            [ 4] 4817 NOREMD: LD      B,A             ; Bit number+1 to B
aq FCB3               [ 4] 4818         LD      A,00000001B     ; Bit to rotate
   FCB3 07            [ 3] 4819 SHFTBT: RLCA                    ; Shift bit left
   FCB4 10 FD         [ 9] 4820         DJNZ    SHFTBT          ; Count shifts
   FCB6 1F            [ 3] 4821         RRA                     ; Restore correct place
   FCB7 C9            [ 9] 4822         RET
                           4823 
   FCB8 C1            [ 9] 4824 ADJCOL: POP     BC              ; Restore return address
   FCB9 F1            [ 9] 4825         POP     AF              ; Get bit mask
   FCBA E1            [ 9] 4826         POP     HL              ; Get column
   FCBB F5            [11] 4827         PUSH    AF              ; Re-save but mask
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 89.
Hexadecimal [16-Bits]



   FCBC 7D            [ 4] 4828         LD      A,L             ; Get column
   FCBD 1F            [ 3] 4829         RRA                     ; Divide by 2
a  FCBE               [ 3] 4830         ADD     A,1             ; Start at column 1
   FCBE E6 11         [ 6] 4831         AND     #0x00111111       ; 0 to 63
   FCC0 67            [ 4] 4832         LD      H,A             ; Save column in H
   FCC1 E5            [11] 4833         PUSH    HL              ; Re-save column
   FCC2 C5            [11] 4834         PUSH    BC              ; Put back return
   FCC3 7B            [ 4] 4835         LD      A,E             ; Get row
   FCC4 C9            [ 9] 4836         RET
                           4837 
   FCC5 CD 57 FA      [16] 4838 SMOTOR: CALL    CASFF           ; Flip tape drive
   FCC8 7E            [ 6] 4839         LD      A,(HL)          ; Get byte
   FCC9 C9            [ 9] 4840         RET
                           4841 
   FCCA 3A CE 10      [12] 4842 JPLDSV: LD      A,(BRKLIN)      ; CLOAD or CSAVE?
   FCCD FE FF         [ 6] 4843         CP      #-1
   FCCF C2 06 E9      [ 9] 4844         JP      NZ,SN0xDDR       ; CSAVE - Send header
   FCD2 C3 10 E9      [ 9] 4845         JP      GETHDR          ; CLOAD - Get header
                           4846 
   FCD5 CD 5B EB      [16] 4847 CRLIN1: CALL    PRNTCR          ; Output CRLF
   FCD8 C3 F2 E5      [ 9] 4848         JP      GETLIN          ; Get an input line
                           4849 
   FCDB CD 5B EB      [16] 4850 CRLIN:  CALL    PRNTCR          ; Output CRLF
   FCDE C3 F2 E5      [ 9] 4851         JP      GETLIN          ; Get an input line
                           4852 
   FCE1 F5            [11] 4853 TSTBIT: PUSH    AF              ; Save bit mask
   FCE2 A0            [ 4] 4854         AND     B               ; Get common bits
   FCE3 C1            [ 9] 4855         POP     BC              ; Restore bit mask
   FCE4 B8            [ 4] 4856         CP      B               ; Same bit set?
   FCE5 3E 00         [ 6] 4857         LD      A,#0             ; Return 0 in A
   FCE7 C9            [ 9] 4858         RET
                           4859 
   FCE8 CD 9B E6      [16] 4860 OUTNCR: CALL    OUTC            ; Output character in A
   FCEB C3 5B EB      [ 9] 4861         JP      PRNTCR          ; Output CRLF
                           4862 
   FCEE C3 30 FB      [ 9] 4863 JJUMP:  JP      JJUMP1          ; "Cool" start
                           4864 
   FCF1 C3 B1 E0      [ 9] 4865 ZJUMP:  JP      BRKRET          ; Warm start
q                          4866         END
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 90.
Hexadecimal [16-Bits]

Symbol Table

    $          **** X   |     .__.$$$.=  2710 L   |     .__.ABS.=  0000 G
    .__.CPU.=  0001 L   |     .__.H$L.=  0000 L   |   2 ABPASS     F08E R
  2 ABS        F6CF R   |   2 ACCSUM     E940 R   |   2 ACPASS     F08D R
  2 ADD64X     FB70 R   |   2 ADDEXP     F67E R   |   2 ADDIG      F7E0 R
  2 ADDPHL     F4CB R   |   2 ADJCOL     FCB8 R   |   2 ALLFOL     F30D R
  2 ANTVLU     EC26 R   |   2 ANYNAM     F44E R   |   2 ARET       FA5A R
  2 ARETN      FC0D R   |     ARG1    =  0C0C     |     ARG2    =  0C0E 
    ARGN    =  0C2B     |   2 ARLDSV     EFB9 R   |     ARREND  =  10DA 
  2 ARRLD1     E8B9 R   |   2 ARRLP      F1EE R   |   2 ARRSV1     E8BB R
  2 ARYLP      E920 R   |   2 ASC        F2E3 R   |   2 ASCTFP     F78B R
  2 ASPCS      EB9D R   |   2 ATN        FA20 R   |   2 ATN1       FA35 R
  2 ATNTAB     FA39 R   |   2 ATOH       E998 R   |   2 BAD        F4B2 R
  2 BADINP     EBB0 R   |   2 BAKSTK     E356 R   |   2 BAKTMP     F2C6 R
    BASTXT  =  105E     |   2 BCDEFP     F6F1 R   |   2 BFREE      E0B7 R
    BKSP    =  0008     |   2 BNORM      F524 R   |   2 BNRMLP     F527 R
  2 BREAK      FC08 R   |   2 BREAK2     FB8E R   |     BRKFLG  =  104D 
    BRKLIN  =  10CE     |   2 BRKMSG     E350 R   |   2 BRKRET     E0B1 R
    BS      =  0010     |   2 BSERR      EFEC R   |     BUFFER  =  1061 
  2 BYTSFT     F610 R   |   2 CASFF      FA57 R   |   2 CASFFW     FA4C R
  2 CFEVAL     EF4F R   |     CHKBRK     **** X   |   2 CHKLTR     E974 R
  2 CHKSTK     E38A R   |     CHKSUM  =  104A     |     CHKSUMS    **** X
  2 CHKSYN     E690 R   |   2 CHKTYP     ECF7 R   |     CIN     =  0C75 
  2 CLEAR      E9B8 R   |   2 CLOAD      F431 R   |   2 CLOAD1     F45D R
  2 CLOAD2     F45D R   |   2 CLOADE     F48D R   |   2 CLOADV     F48A R
  2 CLOTST     E6CC R   |   2 CLREG      E4DF R   |   2 CLRPTR     E4BA R
  2 CLS        FAE1 R   |   2 CMPFP      F729 R   |   2 CMPLG1     EE6D R
  2 CMPLOG     EE6B R   |   2 CMPNUM     F715 R   |   2 CMPRES     EEAF R
  2 CMPSTR     EE97 R   |     CN      =  0020     |   2 CNVIN1     FA94 R
  2 CNVIN2     FA97 R   |   2 CNVIN3     FA9A R   |   2 CNVIN4     FA9D R
  2 CNVIN5     FAA0 R   |   2 CNVNUM     F793 R   |     COMMAN  =  1043 
  2 COMPL      F576 R   |   2 CONCAT     F260 R   |   2 CONEXP     F7BF R
  2 CONMON     FA5B R   |   2 CONOT1     FA6D R   |   2 CONPOS     F521 R
  2 CONT       E89E R   |     CONTAD  =  10D4     |   2 CONVAR     EDD3 R
  2 CONVIN     FA91 R   |   2 COPY       E021 R   |   2 COS        F9C4 R
  2 COUNT      E746 R   |   2 CPDEHL     E68A R   |   2 CPYLIT     E5B1 R
    CR      =  000D     |   2 CRARLP     F009 R   |   2 CREARY     EFF1 R
  2 CRESTR     EAA3 R   |   2 CRLIN      FCDB R   |   2 CRLIN1     FCD5 R
  2 CRNCLP     E512 R   |   2 CRTMST     F147 R   |   2 CRTST      F150 R
  2 CRTSTE     F162 R   |   2 CRUN0xC    E509 R   |     CS      =  000C 
  2 CSAVE      F404 R   |   2 CSTART     E012 R   |     CTLOFG  =  1045 
    CTRLC   =  0003     |     CTRLG   =  0007     |     CTRLO   =  000F 
    CTRLR   =  0012     |     CTRLS   =  0013     |     CTRLU   =  0015 
    CTRLZ   =  001A     |     CUROPR  =  10C5     |     CURPOS  =  10AB 
    CURSOR  =  0C29     |   2 DATA       EA51 R   |     DATFLG  =  10AE 
    DATLIN  =  10C9     |   2 DATSNR     E3A7 R   |   2 DCBCDE     F75C R
    DD      =  0012     |   2 DDERR      E3B6 R   |   2 DEEK       FB0E R
  2 DEF        F09B R   |   2 DEFSIZ     F00E R   |   2 DEINT      E988 R
    DEL     =  007F     |   2 DELAY      FAED R   |   2 DELAY1     FAEE R
  2 DELAYB     FA4F R   |   2 DELCHR     E5E1 R   |   2 DEPINT     E982 R
  2 DETHL4     F6FA R   |   2 DETHLB     F6FA R   |   2 DIGTXT     F860 R
  2 DIM        EED7 R   |   2 DIMRET     EECE R   |   2 DINPOS     E6BF R
  2 DIV        F61B R   |     DIV1    =  100A     |   2 DIV10      F615 R
    DIV2    =  100E     |     DIV3    =  1012     |   2 DIV3EX     FCAB R
  2 DIV3LP     FCA2 R   |     DIV4    =  1015     |   2 DIVLP      F640 R
    DIVSUP  =  1009     |   2 DOAGN      E4F8 R   |   2 DOCOM      EB72 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 91.
Hexadecimal [16-Bits]

Symbol Table

  2 DODEL      E5C1 R   |   2 DOEBIT     F898 R   |   2 DOFN       F0C5 R
  2 DOKE       FB19 R   |   2 DONULL     EB60 R   |   2 DOSPC      EB98 R
  2 DOSUM      E94D R   |   2 DOTAB      EB87 R   |   2 DPOINT     F7BB R
  2 DTSTR      F152 R   |   2 DVBCDE     F61D R   |     DZ      =  0014 
  2 DZERR      E3B0 R   |   2 ECHDEL     E5D5 R   |   2 EDIGIT     F800 R
  2 ENDBUF     E5B8 R   |   2 ENDCON     F7CE R   |   2 ENDDIM     F06B R
  2 ENDINP     EB56 R   |   2 ENDLIN     FC16 R   |   2 ENDNAM     EEF6 R
  2 ENDPRG     E87A R   |   2 ENFMEM     E393 R   |   2 ERRIN      E3E1 R
    ERRLIN  =  10D2     |   2 ERRMSG     E33F R   |   2 ERROR      E3C1 R
  2 ERRORS     E2B9 R   |     ESC     =  001B     |   2 EVAL       ED0B R
  2 EVAL1      ED0E R   |   2 EVAL2      ED17 R   |   2 EVAL3      ED1A R
  2 EVLPAR     EDBA R   |   2 EVNOT      EEB7 R   |   2 EXCUTE     E816 R
  2 EXP        F910 R   |   2 EXPLP      F7AD R   |   2 EXPTAB     F93B R
  2 EXPTEN     F8A2 R   |   2 EXTIG      EC82 R   |   2 FANDT      EC9C R
    FC      =  0008     |   2 FCERR      E995 R   |   2 FDTLP      EC83 R
  2 FILE       F4B0 R   |   2 FILFND     F49C R   |   2 FINDEL     F047 R
  2 FLGDIF     F6C1 R   |   2 FLGREL     F6C8 R   |   2 FLGVER     F43D R
  2 FLPLED     FB74 R   |     FNARG   =  10E0     |   2 FNCTAB     E10F R
  2 FNDARY     EFBF R   |   2 FNDELP     F04C R   |   2 FNDEND     E48D R
  2 FNDNUM     F3C5 R   |   2 FNDTOK     E71B R   |   2 FNDVAR     EF36 R
  2 FNDWRD     E53C R   |   2 FNOFST     EDE4 R   |     FNRGNM  =  10DE 
  2 FNTHR      EF44 R   |   2 FNVAL      EE10 R   |   2 FOPRND     ED43 R
  2 FOR        E779 R   |     FORFLG  =  10CB     |   2 FORFND     E7A9 R
  2 FORSLP     E78D R   |   2 FOUND      F4B1 R   |   2 FPADD      F4DA R
  2 FPBCDE     F6E6 R   |     FPEXP   =  10E7     |   2 FPINT      F73C R
  2 FPMULT     F5D2 R   |     FPREG   =  10E4     |   2 FPROND     F55F R
  2 FPSINT     E97C R   |   2 FPTHL      F6FA R   |   2 FRE        F06F R
  2 FRENUM     F088 R   |   2 FRMEVL     EDD6 R   |   2 GARBGE     F1BF R
  2 GARBLP     F1C2 R   |   2 GETCHR     E836 R   |   2 GETCMD     E405 R
  2 GETHDR     E910 R   |   2 GETINP     FA7D R   |   2 GETINT     F3C8 R
  2 GETLEN     F2D8 R   |   2 GETLIN     E5F2 R   |   2 GETLN      E999 R
  2 GETNUM     ECF2 R   |   2 GETNXT     E557 R   |   2 GETSTR     F2A5 R
  2 GETTIN     FA8B R   |   2 GETVAR     EED9 R   |   2 GETXYA     FC2E R
  2 GNXARY     F1ED R   |   2 GOFUNC     EE18 R   |   2 GOSUB      EA04 R
  2 GOTO       EA15 R   |   2 GRBARY     F20B R   |   2 GRBDON     F19E R
  2 GRBLP      F1CA R   |   2 GSTRCU     F2A8 R   |   2 GSTRDE     F2AC R
  2 GSTRHL     F2AB R   |   2 GTFLNM     F2E4 R   |   2 GTFNAM     EEDE R
  2 GTLNLP     E999 R   |   2 GTSIXD     F838 R   |   2 GTVLUS     EBFE R
  2 GUART      FAB7 R   |   2 HALF       F8B7 R   |   2 HALFPI     F9FC R
  2 HDRLP      E912 R   |     HIGH       **** X   |     ID      =  0016 
  2 IDTEST     F10A R   |   2 IF         EAD9 R   |   2 IFGO       EAE7 R
  2 IFJMP      E81D R   |   2 IG0xCR     FA78 R   |   2 IN0xCL     F6F8 R
  2 INCLEN     E6BB R   |   2 INDFND     E370 R   |   2 INEWLN     E455 R
  2 INIT       E019 R   |   2 INITAB     E2DF R   |   2 INITBE     E33F R
  2 INITST     FBEC R   |   2 INLINE     FC10 R   |   2 INMSG      E346 R
  2 INP        F385 R   |   2 INPBIN     EC50 R   |   2 INPBRK     E877 R
    INPORT  =  103F     |     INPSUB  =  103E     |   2 INPUT      EBBE R
  2 INRNG      F841 R   |   2 INT        F763 R   |   2 INTVAR     E4C9 R
  2 INVSGN     F6D3 R   |   2 ITMSEP     EC41 R   |   2 JJUMP      FCEE R
  2 JJUMP1     FB30 R   |   2 JPLDSV     FCCA R   |   2 JSTZER     F8A8 R
  2 KILFOR     ECE2 R   |   2 KILIN      E5EC R   |     LCRFLG  =  10AC 
  2 LDNMI1     E73C R   |   2 LEFT       F2FF R   |   2 LEN        F2D7 R
  2 LET        EA64 R   |   2 LETNUM     EAB4 R   |   2 LETSTR     EA7F R
    LF      =  000A     |   2 LFRGNM     F37B R   |     LINEAT  =  105C 
  2 LINEIN     F80A R   |   2 LINES      FAFF R   |     LINESC  =  1046 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 92.
Hexadecimal [16-Bits]

Symbol Table

    LINESN  =  1048     |   2 LINFND     E43E R   |   2 LINTBF     FC23 R
  2 LIST       E6DD R   |   2 LISTLP     E6E9 R   |   2 LOADFP     F6F1 R
  2 LOG        F5AC R   |   2 LOGTAB     F5A5 R   |   2 LOKFOR     E35A R
    LOOPST  =  10C7     |     LOW        **** X   |     LS      =  001C 
    LSTBIN  =  10CC     |   2 LSTLP2     E709 R   |   2 LSTLP3     E70C R
    LSTRAM  =  10AF     |     LSTRND  =  103A     |   2 LTSTND     EC5B R
    LWIDTH  =  1042     |   2 MAKINT     F3CB R   |   2 MAKNUM     F856 R
  2 MANLP      F79B R   |   2 MAT0xC     E589 R   |     MATCH      **** X
  2 MEMMSG     E103 R   |     MFLP    =  0051     |   2 MID        F335 R
  2 MID1       F305 R   |   2 MIDNUM     F380 R   |   2 MINCDE     F513 R
  2 MINUS      EDC2 R   |   2 MKTMST     F144 R   |   2 MLDBLP     F778 R
  2 MLDEBC     F775 R   |   2 MLOOP      E049 R   |   2 MLSP10     F6A4 R
    MO      =  0024     |   2 MONITR     FBD5 R   |   2 MONLD      FBBD R
  2 MONOUT     FB80 R   |     MONSTT  =  0000     |   2 MONTST     FBA4 R
    MONTYP  =  008D     |   2 MONVE      FBDD R   |   2 MORDT      EC67 R
  2 MORINP     E610 R   |   2 MOVBUF     E474 R   |   2 MOVDIR     E591 R
  2 MOVLP      E37F R   |   2 MOVSTR     E37C R   |   2 MOVUP      E379 R
  2 MRPRNT     EAF9 R   |   2 MSIZE      E036 R   |   2 MUL8LP     F5ED R
  2 MULLN2     F5CF R   |   2 MULT       F5D0 R   |   2 MULT8      F5E6 R
  2 MULTEN     F7D9 R   |     MULVAL  =  10F6     |   2 MVSTPT     EAAB R
  2 NASOUT     FA73 R   |   2 NEDMOR     EBFA R   |   2 NEGAFT     F8C5 R
  2 NEW        E4B9 R   |   2 NEXITM     EBA8 R   |   2 NEXT       ECA7 R
  2 NEXT1      ECAA R   |     NF      =  0000     |   2 NFERR      E3B3 R
    NMI     =  0C7E     |     NMIFLG  =  104C     |   2 NOCHNG     E581 R
  2 NOENED     F8AB R   |   2 NOLIN      E88D R   |   2 NOMADD     F5FE R
  2 NOMLAD     F786 R   |   2 NOPMPT     EBD8 R   |   2 NOREMD     FCB2 R
  2 NORES      FC80 R   |   2 NORMAL     F53A R   |   2 NOSPC      E578 R
  2 NOSWAP     F4F4 R   |   2 NOTSTR     EF0F R   |   2 NOXOR      F3AB R
  2 NSCFOR     EF1F R   |     NULFLG  =  1044     |   2 NULL       E8B1 R
  2 NULLP      EB67 R   |     NULLS   =  1041     |   2 NUMASC     F815 R
  2 NXTARY     EFD3 R   |   2 NXTBYT     E567 R   |   2 NXTCHR     E5A8 R
    NXTDAT  =  10DC     |   2 NXTDTA     EA50 R   |   2 NXTITM     EBF2 R
    NXTOPR  =  10D0     |   2 NXTSTL     EA53 R   |   2 NXTSTT     EA56 R
    OD      =  0006     |   2 OKMSG      E34B R   |     OM      =  000C 
  2 OMERR      E3A2 R   |   2 ON         EABB R   |   2 ONGO       EACA R
  2 ONGOLP     EACB R   |   2 ONJMP      E81E R   |   2 OPNPAR     ED07 R
  2 OPRND      ED82 R   |     OS      =  001A     |   2 OTKLN      E5E9 R
    OTPORT  =  1007     |   2 OUT0xCR    FA75 R   |   2 OUTBAD     F496 R
  2 OUTC       E69B R   |   2 OUTEXP     F8A2 R   |   2 OUTIT      E67C R
  2 OUTNBS     E682 R   |   2 OUTNCR     FCE8 R   |     OUTSUB  =  1006 
  2 OUTWRD     E725 R   |     OV      =  000A     |   2 OVERR      E3BC R
  2 OVTST1     F697 R   |   2 OVTST2     F69C R   |   2 OVTST3     F69D R
  2 PADD       F7FB R   |   2 PAND       EE32 R   |   2 PASSA      F096 R
    PBUFF   =  10E9     |   2 PEEK       F4B3 R   |   2 PEND       E872 R
  2 PHLTFP     F6E3 R   |   2 PLUCDE     F56A R   |   2 PNORM      F542 R
    POINT   =  1051     |   2 POINT0     FC95 R   |   2 POINTB     FC84 R
  2 POINTX     FC8E R   |   2 POKE       F4BA R   |   2 POPAF      F1B6 R
  2 POPHL      F2C4 R   |   2 POPHRT     F60E R   |   2 POPNOK     E3F7 R
  2 POR        EE31 R   |   2 POR1       EE54 R   |     PORT0   =  0C00 
  2 POS        F093 R   |   2 POSINT     E97F R   |   2 POUT       F391 R
  2 POWER      F8CD R   |   2 POWER1     F8DD R   |   2 POWER2     F8F8 R
  2 POWERS     F8B9 R   |   2 PRINT      EAFD R   |   2 PRITAB     E2A4 R
  2 PRNTCR     EB5B R   |   2 PRNTHL     F80F R   |   2 PRNTLP     EB00 R
  2 PRNTNB     EB43 R   |   2 PRNTOK     E3F8 R   |   2 PRNTST     EB47 R
  2 PRNUMS     F184 R   |   2 PROCES     E629 R   |     PROGND  =  10D6 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 93.
Hexadecimal [16-Bits]

Symbol Table

    PROGST  =  10F9     |   2 PROMPT     E4FC R   |   2 PRS        F185 R
  2 PRS1       F188 R   |   2 PRSLP      F18F R   |     PSET    =  1054 
  2 PSUB       F4D5 R   |   2 PTRLP      E481 R   |   2 PUTBIT     FC60 R
  2 PUTBUF     E668 R   |   2 PUTCTL     E66D R   |   2 PUTFID     E7EE R
  2 QTSTLP     F153 R   |   2 QTSTR      F151 R   |   2 QUARTR     F9FE R
  2 READ       EBED R   |     READFG  =  10CD     |   2 REDO       EBAF R
  2 REM        EA53 R   |   2 RESCSA     FC61 R   |   2 RESDIV     F651 R
  2 RESEED     F9B6 R   |     RESET   =  1057     |   2 RESETB     FC6A R
  2 RESTNL     E85B R   |   2 RESTOR     E846 R   |   2 RESZER     F535 R
  2 RETADR     EF83 R   |   2 RETCTC     FBA0 R   |   2 RETINT     F6C8 R
  2 RETLIN     EA4E R   |   2 RETNAD     E58D R   |   2 RETNUL     EF86 R
  2 RETNUM     EDCE R   |   2 RETREL     F6BF R   |   2 RETURN     EA33 R
    RG      =  0004     |   2 RIGHT      F32B R   |   2 RIGHT1     F303 R
    RINPUT  =  104E     |   2 RLTLP      ED27 R   |   2 RND        F979 R
  2 RND1       F99F R   |   2 RND2       F9B0 R   |   2 RNDTAB     F9BE R
  2 RNGTST     F8AE R   |   2 RONDB      F553 R   |   2 RONDUP     F552 R
  2 ROUND      F4CB R   |   2 RSCALE     F7F5 R   |   2 RSLNBK     E770 R
  2 RSTSTR     F34C R   |   2 RUART      F3F5 R   |   2 RUN        E9FB R
  2 RUNCNT     E7F2 R   |   2 RUNFST     E4C5 R   |   2 RUNLIN     EA14 R
  2 SAVE       FBA8 R   |   2 SAVEXP     F536 R   |   2 SAVSTP     E7E5 R
  2 SAVSTR     F12F R   |   2 SBSCPT     EF91 R   |   2 SCALE      F587 R
  2 SCALLP     F587 R   |   2 SCALMI     F7C2 R   |   2 SCALPL     F7D8 R
  2 SCNEND     F23D R   |   2 SCPTLP     EF97 R   |   2 SCRADR     FB5B R
  2 SCREEN     FB34 R   |   2 SEARCH     E555 R   |     SEED    =  1017 
  2 SETB       FC57 R   |   2 SETIO      F3B5 R   |   2 SETLIN     E733 R
  2 SETLIT     E59F R   |   2 SETOR      FC65 R   |   2 SETPTR     E47C R
  2 SETTOP     E06D R   |   2 SFTENT     FAD1 R   |   2 SFTPRG     E446 R
  2 SGN        F6C5 R   |   2 SGNEXP     EE21 R   |     SGNRES  =  10E8 
  2 SHFTBT     FCB3 R   |   2 SHRITE     F590 R   |   2 SHRLP      F591 R
  2 SHRT1      F595 R   |   2 SIGNON     E0C5 R   |   2 SIGNS      F703 R
  2 SIN        F9C7 R   |   2 SIN1       F9EE R   |   2 SINTAB     FA00 R
  2 SIXDIG     F829 R   |   2 SMOTOR     FCC5 R   |   2 SMPVAR     F1D8 R
  2 SMSER1     F958 R   |     SN      =  0002     |   2 SN0xDDR    E906 R
  2 SNDARY     E91D R   |   2 SNERR      E3AD R   |   2 SPCFST     F81C R
  2 SPCLP      EBA1 R   |   2 SQR        F8C7 R   |   2 SRCHLN     E499 R
  2 SRCHLP     E49C R   |   2 SSTSA      F292 R   |     ST      =  001E 
    STACK   =  1066     |   2 STAKFP     F6D6 R   |   2 STALL      E866 R
  2 START      E000 R   |   2 STARTB     E003 R   |   2 STKTHS     ED6B R
    STLOOK  =  115D     |     STMON   =  000D     |   2 STOP       E870 R
  2 STORED     E9DB R   |   2 STPOOL     F216 R   |   2 STR        F122 R
  2 STRADD     F217 R   |     STRBOT  =  10C3     |   2 STRENT     EC44 R
    STRSPC  =  105A     |   2 STTLIN     EB4E R   |   2 SUART      FAC9 R
  2 SUBCDE     F4D7 R   |   2 SUBPHL     F4D1 R   |   2 SUMLP      F961 R
  2 SUMOFF     E937 R   |   2 SUMSER     F94C R   |   2 SUPTLZ     F890 R
  2 SVNAM2     EEF5 R   |   2 SVSTAD     F14A R   |   2 T0xCINP    FB9D R
    T2DUMP  =  03D1     |     T4READ  =  070C     |     T4WR    =  0400 
  2 TAN        FA0B R   |     TBRK    =  001C     |   2 TBRK2      FAB3 R
    TBS     =  001D     |   2 TCLS       FAEA R   |     TCR     =  001F 
    TCS     =  001E     |     TCUR    =  0C18     |   2 TESTOS     F1B8 R
  2 TESTR      F19C R   |   2 THSFIL     F476 R   |     TIN     =  0C4D 
  2 TLOAD      FBCC R   |     TM      =  0018     |   2 TMERR      E3BF R
  2 TMFLP      FB7D R   |   2 TMNCUR     FB52 R   |   2 TMNOUT     FB8A R
    TMPSTR  =  10BF     |     TMSTPL  =  10B3     |     TMSTPT  =  10B1 
  2 TOPOOL     F2FB R   |   2 TOSTRA     F29B R   |     TOUT    =  0C4A 
  2 TRYAGN     F86B R   |   2 TSALP      F29C R   |   2 TSAVE      FBB4 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 94.
Hexadecimal [16-Bits]

Symbol Table

  2 TSTBIT     FCE1 R   |   2 TSTBRK     E861 R   |   2 TSTMEM     E05B R
  2 TSTNUM     ECF5 R   |   2 TSTOPL     F16C R   |   2 TSTRED     EE59 R
  2 TSTREM     E5A2 R   |   2 TSTSGN     F6B6 R   |   2 TSTSTR     ECF6 R
  2 TTYLIN     E607 R   |     TYPE    =  10AD     |     UARTD   =  0001 
  2 UARTOT     FAC0 R   |     UARTS   =  0002     |     UF      =  0022 
  2 UFERR      E3B9 R   |     UL      =  000E     |   2 ULERR      EA2E R
  2 UNITY      F5A3 R   |   2 UPDATA     E85C R   |   2 URTOLP     FAC2 R
    USR     =  1003     |   2 VAL        F360 R   |     VAREND  =  10D8 
    VDU     =  0800     |   2 WAIT       F397 R   |   2 WAITLP     F3AC R
  2 WARMST     E0AE R   |   2 WIDTH      FAF7 R   |   2 WORDS      E143 R
  2 WORDTB     E25A R   |     WRKSPC  =  1000     |   2 WUART      F3FB R
  2 WUART2     F3F8 R   |   2 XYPOS      FC98 R   |     ZDATA   =  0083 
    ZDIV    =  00AF     |     ZEND    =  0080     |     ZEQUAL  =  00B4 
  2 ZERARY     F02C R   |     ZERBYT  =  FFFFFFFF     |   2 ZEROLP     EF75 R
    ZFN     =  00A7     |     ZFOR    =  0081     |     ZGOSUB  =  008C 
    ZGOTO   =  0088     |     ZGTR    =  00B3     |   2 ZJUMP      FCF1 R
    ZLEFT   =  00CD     |     ZLTH    =  00B5     |     ZMINUS  =  00AD 
    ZNEW    =  00A4     |     ZNOT    =  00AA     |   2 ZONELP     EB80 R
    ZOR     =  00B2     |     ZPLUS   =  00AC     |     ZPOINT  =  00C7 
    ZPRINT  =  009E     |     ZREM    =  008E     |     ZSGN    =  00B6 
    ZSPC    =  00A8     |     ZSTEP   =  00AB     |     ZTAB    =  00A5 
    ZTHEN   =  00A9     |     ZTIMES  =  00AE     |     ZTO     =  00A6 
    _BLNK   =  7BDF     |     _INLN   =  63DF     |     _MFLP   =  5FDF 
    _MRET   =  5BDF     |     _READ   =  52DF     |     _RIN    =  62DF 
    _ROUT   =  00F7     |     _VRFY   =  56DF     |     _WRIT   =  57DF 

ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 95.
Hexadecimal [16-Bits]

Area Table

   0 _CODE      size    0   flags    0
   1 CODE       size    0   flags    8
   2 CODE0      size 1CF4   flags    8

