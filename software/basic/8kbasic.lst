ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 1.
Hexadecimal [16-Bits]



                              1 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                              2 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                              3 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                              4 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                              5 ; the original ROM code (checksum 0xA934). PA
                              6 
                              7 .z180
                              8 
                              9 .area CODE (ABS)
                             10 
                             11 
                             12 ; MONITOR EQUATES (RESTART INSTRUCTIONS)
                             13 
                     00F7    14 _ROUT   .equ     0xF7            ; ROUT - Output char in A
                     7BDF    15 _BLNK   .equ     0x7BDF          ; SCAL BLINK - Get input char in A
                     63DF    16 _INLN   .equ     0x63DF          ; SCAL INLIN - Get input line
                     5FDF    17 _MFLP   .equ     0x5FDF          ; SCAL MFLP - Toggle tape drv LED
                     5BDF    18 _MRET   .equ     0x5BDF          ; SCAL MRET - Return to monitor
                     52DF    19 _READ   .equ     0x52DF          ; SCAL READ
                     62DF    20 _RIN    .equ     0x62DF          ; SCAL RIN - Scan for input char
                     56DF    21 _VRFY   .equ     0x56DF          ; SCAL VERIFY
                     57DF    22 _WRIT   .equ     0x57DF          ; SCAL WRITE
                             23 
                             24 ; GENERAL .equATES
                             25 
                     0001    26 UARTD   .equ     0x01             ; UART data port
                     0002    27 UARTS   .equ     0x02             ; UART status port
                     0003    28 CTRLC   .equ     0x03             ; Control "C"
                     0007    29 CTRLG   .equ     0x07             ; Control "G"
                     0008    30 BKSP    .equ     0x08             ; Back space
                     000A    31 LF      .equ     0x0A             ; Line feed
                     000C    32 CS      .equ     0x0C             ; Clear screen
                     000D    33 CR      .equ     0x0D             ; Carriage return
                     000F    34 CTRLO   .equ     0x0F             ; Control "O"
                     0012    35 CTRLR   .equ     0x12             ; Control "R"
                     0013    36 CTRLS   .equ     0x13             ; Control "S"
                     0015    37 CTRLU   .equ     0x15             ; Control "U"
                     001A    38 CTRLZ   .equ     0x1A             ; Control "Z"
                     001B    39 ESC     .equ     0x1B             ; Escape
                     001C    40 TBRK    .equ     0x1C             ; "T" monitor break
                     001D    41 TBS     .equ     0x1D             ; "T" monitor back space
                     001E    42 TCS     .equ     0x1E             ; "T" monitor clear screen
                     001F    43 TCR     .equ     0x1F             ; "T" monitor carriage return
                     007F    44 DEL     .equ     0x7F             ; Delete
                             45 
                             46 ; MONITOR LOCATIONS
                             47 
                     0000    48 MONSTT  .equ     0x0000           ; Start of monitor
                     000D    49 STMON   .equ     0x000D           ; NAS-SYS initialisation
                     0051    50 MFLP    .equ     0x0051           ; Flip tape LED ("T")
                     008D    51 MONTYP  .equ     0x008D           ; Type of "T" monitor
                     03D1    52 T2DUMP  .equ     0x03D1           ; "T2" Dump routine
                     0400    53 T4WR    .equ     0x0400           ; "T4" Write routine
                     070C    54 T4READ  .equ     0x070C           ; "T4" Read routine
                     0800    55 VDU     .equ     0x0800           ; NASCOM Video RAM base
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 2.
Hexadecimal [16-Bits]



                             56 
                             57 ; MONITOR WORK SPACE LOCATIONS
                             58 
                     0C00    59 PORT0   .equ     0x0C00           ; Copy of output port 0
                     0C0C    60 ARG1    .equ     0x0C0C           ; Argument 1
                     0C0E    61 ARG2    .equ     0x0C0E           ; Argument 2
                     0C18    62 TCUR    .equ     0x0C18           ; "T" monitor cursor
                     0C29    63 CURSOR  .equ     0x0C29           ; NAS-SYS Cursor
                     0C2B    64 ARGN    .equ     0x0C2B           ; Number of ARGS
                     0C4A    65 TOUT    .equ     0x0C4A           ; "T" Output reflection
                     0C4D    66 TIN     .equ     0x0C4D           ; "T" Input reflection
                     0C75    67 CIN     .equ     0x0C75           ; NAS-SYS Input table
                     0C7E    68 NMI     .equ     0x0C7E           ; NAS-SYS NMI Jump
                             69 
                             70 ; BASIC WORK SPACE LOCATIONS
                             71 
                     1000    72 WRKSPC  .equ     0x1000           ; BASIC Work space
                     1003    73 USR     .equ     0x1003           ; "USR (x)" jump
                     1006    74 OUTSUB  .equ     0x1006           ; "OUT p,n"
                     1007    75 OTPORT  .equ     0x1007           ; Port (p)
                     1009    76 DIVSUP  .equ     0x1009           ; Division support routine
                     100A    77 DIV1    .equ     0x100A           ; <- Values
                     100E    78 DIV2    .equ     0x100E           ; <-   to
                     1012    79 DIV3    .equ     0x1012           ; <-   be
                     1015    80 DIV4    .equ     0x1015           ; <-inserted
                     1017    81 SEED    .equ     0x1017           ; Random number seed
                     103A    82 LSTRND  .equ     0x103A           ; Last random number
                     103E    83 INPSUB  .equ     0x103E           ; #INP (x)" Routine
                     103F    84 INPORT  .equ     0x103F           ; PORT (x)
                     1041    85 NULLS   .equ     0x1041           ; Number of nulls
                     1042    86 LWIDTH  .equ     0x1042           ; Terminal width
                     1043    87 COMMAN  .equ     0x1043           ; Width for commas
                     1044    88 NULFLG  .equ     0x1044           ; Null after input byte flag
                     1045    89 CTLOFG  .equ     0x1045           ; Control "O" flag
                     1046    90 LINESC  .equ     0x1046           ; Lines counter
                     1048    91 LINESN  .equ     0x1048           ; Lines number
                     104A    92 CHKSUM  .equ     0x104A           ; Array load/save check sum
                     104C    93 NMIFLG  .equ     0x104C           ; Flag for NMI break routine
                     104D    94 BRKFLG  .equ     0x104D           ; Break flag
                     104E    95 RINPUT  .equ     0x104E           ; Input reflection
                     1051    96 POINT   .equ     0x1051           ; "POINT" reflection (unused)
                     1054    97 PSET    .equ     0x1054           ; "SET"   reflection
                     1057    98 RESET   .equ     0x1057           ; "RESET" reflection
                     105A    99 STRSPC  .equ     0x105A           ; Bottom of string space
                     105C   100 LINEAT  .equ     0x105C           ; Current line number
                     105E   101 BASTXT  .equ     0x105E           ; Pointer to start of program
                     1061   102 BUFFER  .equ     0x1061           ; Input buffer
                     1066   103 STACK   .equ     0x1066           ; Initial stack
                     10AB   104 CURPOS  .equ     0x10AB           ; Character position on line
                     10AC   105 LCRFLG  .equ     0x10AC           ; Locate/Create flag
                     10AD   106 TYPE    .equ     0x10AD           ; Data type flag
                     10AE   107 DATFLG  .equ     0x10AE           ; Literal statement flag
                     10AF   108 LSTRAM  .equ     0x10AF           ; Last available RAM
                     10B1   109 TMSTPT  .equ     0x10B1           ; Temporary string pointer
                     10B3   110 TMSTPL  .equ     0x10B3           ; Temporary string pool
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 3.
Hexadecimal [16-Bits]



                     10BF   111 TMPSTR  .equ     0x10BF           ; Temporary string
                     10C3   112 STRBOT  .equ     0x10C3           ; Bottom of string space
                     10C5   113 CUROPR  .equ     0x10C5           ; Current operator in EVAL
                     10C7   114 LOOPST  .equ     0x10C7           ; First statement of loop
                     10C9   115 DATLIN  .equ     0x10C9           ; Line of current DATA item
                     10CB   116 FORFLG  .equ     0x10CB           ; "FOR" loop flag
                     10CC   117 LSTBIN  .equ     0x10CC           ; Last byte entered
                     10CD   118 READFG  .equ     0x10CD           ; Read/Input flag
                     10CE   119 BRKLIN  .equ     0x10CE           ; Line of break
                     10D0   120 NXTOPR  .equ     0x10D0           ; Next operator in EVAL
                     10D2   121 ERRLIN  .equ     0x10D2           ; Line of error
                     10D4   122 CONTAD  .equ     0x10D4           ; Where to CONTinue
                     10D6   123 PROGND  .equ     0x10D6           ; End of program
                     10D8   124 VAREND  .equ     0x10D8           ; End of variables
                     10DA   125 ARREND  .equ     0x10DA           ; End of arrays
                     10DC   126 NXTDAT  .equ     0x10DC           ; Next data item
                     10DE   127 FNRGNM  .equ     0x10DE           ; Name of FN argument
                     10E0   128 FNARG   .equ     0x10E0           ; FN argument value
                     10E4   129 FPREG   .equ     0x10E4           ; Floating point register
                     10E7   130 FPEXP   .equ     FPREG+3         ; Floating point exponent
                     10E8   131 SGNRES  .equ     0x10E8           ; Sign of result
                     10E9   132 PBUFF   .equ     0x10E9           ; Number print buffer
                     10F6   133 MULVAL  .equ     0x10F6           ; Multiplier
                     10F9   134 PROGST  .equ     0x10F9           ; Start of program text area
                     115D   135 STLOOK  .equ     0x115D           ; Start of memory test
                            136 
                            137 ; BASIC ERROR CODE VALUES
                            138 
                     0000   139 NF      .equ     0x00             ; NEXT without FOR
                     0002   140 SN      .equ     0x02             ; Syntax error
                     0004   141 RG      .equ     0x04             ; RETURN without GOSUB
                     0006   142 OD      .equ     0x06             ; Out of DATA
                     0008   143 FC      .equ     0x08             ; Function call error
                     000A   144 OV      .equ     0x0A             ; Overflow
                     000C   145 OM      .equ     0x0C             ; Out of memory
                     000E   146 UL      .equ     0x0E             ; Undefined line number
                     0010   147 BS      .equ     0x10             ; Bad subscript
                     0012   148 DD      .equ     0x12             ; Re-DIMensioned array
                     0014   149 DZ      .equ     0x14             ; Division by zero (/0)
                     0016   150 ID      .equ     0x16             ; Illegal direct
                     0018   151 TM      .equ     0x18             ; Type miss-match
                     001A   152 OS      .equ     0x1A             ; Out of string space
                     001C   153 LS      .equ     0x1C             ; String too long
                     001E   154 ST      .equ     0x1E             ; String formula too complex
                     0020   155 CN      .equ     0x20             ; Can't CONTinue
                     0022   156 UF      .equ     0x22             ; UnDEFined FN function
                     0024   157 MO      .equ     0x24             ; Missing operand
                            158 
   E000                     159         .org     0xE000
                            160 
   E000 C3 03 E0      [ 9]  161 START:  JP      STARTB          ; Jump for restart jump
   E003 F3            [ 3]  162 STARTB: DI                      ; No interrupts
   E004 DD 21 00 00   [12]  163         LD      IX,#0            ; Flag cold start
   E008 C3 12 E0      [ 9]  164         JP      CSTART          ; Jump to initialise
                            165 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 4.
Hexadecimal [16-Bits]



   E00B 8B E9               166         .dw      DEINT           ; Get integer -32768 to 32767
   E00D F2 F0               167         .dw      ABPASS          ; Return integer in AB
                            168 
   E00F C3 3C E7      [ 9]  169         JP      LDNMI1          ; << NO REFERENCE TO HERE >>
                            170 
   E012 21 00 10      [ 9]  171 CSTART: LD      HL,#WRKSPC       ; Start of workspace RAM
   E015 F9            [ 4]  172         LD      SP,HL           ; Set up a temporary stack
   E016 C3 BB FE      [ 9]  173         JP      INITST          ; Go to initialise
                            174 
   E019 11 DF E2      [ 9]  175 INIT:   LD      DE,#INITAB       ; Initialise workspace
   E01C 06 63         [ 6]  176         LD      B,#INITBE-#INITAB+#3; Bytes to copy
   E01E 21 00 10      [ 9]  177         LD      HL,#WRKSPC       ; Into workspace RAM
   E021 1A            [ 6]  178 COPY:   LD      A,(DE)          ; Get source
   E022 77            [ 7]  179         LD      (HL),A          ; To destination
   E023 23            [ 4]  180         INC     HL              ; Next destination
   E024 13            [ 4]  181         INC     DE              ; Next source
   E025 05            [ 4]  182         DEC     B               ; Count bytes
   E026 C2 21 E0      [ 9]  183         JP      NZ,#COPY         ; More to move
   E029 F9            [ 4]  184         LD      SP,HL           ; Temporary stack
   E02A CD DF E4      [16]  185         CALL    CLREG           ; Clear registers and stack
   E02D CD 81 EB      [16]  186         CALL    PRNTCR          ; Output CRLF
   E030 32 AA 10      [13]  187         LD      (BUFFER+72+1),A ; Mark end of buffer
   E033 32 F9 10      [13]  188         LD      (PROGST),A      ; Initialise program area
   E036 21 03 E1      [ 9]  189 MSIZE:  LD      HL,#MEMMSG       ; Point to message
   E039 CD 10 F2      [16]  190         CALL    PRS             ; Output "Memory size"
   E03C CD FC E4      [16]  191         CALL    PROMPT          ; Get input with "?"
   E03F CD 36 E8      [16]  192         CALL    GETCHR          ; Get next character
   E042 B7            [ 4]  193         OR      A               ; Set flags
   E043 C2 5B E0      [ 9]  194         JP      NZ,TSTMEM       ; If number - Test if RAM there
   E046 21 5D 11      [ 9]  195         LD      HL,#STLOOK       ; Point to start of RAM
   E049 23            [ 4]  196 MLOOP:  INC     HL              ; Next byte
   E04A 7C            [ 4]  197         LD      A,H             ; Above address FFFF ?
   E04B B5            [ 4]  198         OR      L
   E04C CA 6D E0      [ 9]  199         JP      Z,SETTOP        ; Yes - 64K RAM
   E04F 7E            [ 6]  200         LD      A,(HL)          ; Get contents
   E050 47            [ 4]  201         LD      B,A             ; Save it
   E051 2F            [ 3]  202         CPL                     ; Flip all bits
   E052 77            [ 7]  203         LD      (HL),A          ; Put it back
   E053 BE            [ 6]  204         CP      (HL)            ; RAM there if same
   E054 70            [ 7]  205         LD      (HL),B          ; Restore old contents
   E055 CA 49 E0      [ 9]  206         JP      Z,MLOOP         ; If RAM - test next byte
   E058 C3 6D E0      [ 9]  207         JP      SETTOP          ; Top of RAM found
                            208 
   E05B CD A5 E9      [16]  209 TSTMEM: CALL    ATOH            ; Get high memory into DE
   E05E B7            [ 4]  210         OR      A               ; Set flags on last byte
   E05F C2 AD E3      [ 9]  211         JP      NZ,SNERR        ; ?SN Error if bad character
   E062 EB            [ 3]  212         EX      DE,HL           ; Address into HL
   E063 2B            [ 4]  213         DEC     HL              ; Back one byte
   E064 3E D9         [ 6]  214         LD      A,#0b11011001     ; Test byte
   E066 46            [ 6]  215         LD      B,(HL)          ; Get old contents
   E067 77            [ 7]  216         LD      (HL),A          ; Load test byte
   E068 BE            [ 6]  217         CP      (HL)            ; RAM there if same
   E069 70            [ 7]  218         LD      (HL),B          ; Restore old contents
   E06A C2 36 E0      [ 9]  219         JP      NZ,MSIZE        ; Ask again if no RAM
                            220 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 5.
Hexadecimal [16-Bits]



   E06D 2B            [ 4]  221 SETTOP: DEC     HL              ; Back one byte
   E06E 11 5C 11      [ 9]  222         LD      DE,#STLOOK-1     ; See if enough RAM
   E071 CD 8A E6      [16]  223         CALL    CPDEHL          ; Compare DE with HL
   E074 DA 36 E0      [ 9]  224         JP      C,MSIZE         ; Ask again if not enough RAM
   E077 00            [ 3]  225         NOP
   E078 00            [ 3]  226         NOP
   E079 00            [ 3]  227         NOP
   E07A 00            [ 3]  228         NOP
   E07B 00            [ 3]  229         NOP
   E07C 00            [ 3]  230         NOP
   E07D 00            [ 3]  231         NOP
   E07E 00            [ 3]  232         NOP
   E07F 00            [ 3]  233         NOP
   E080 11 CE FF      [ 9]  234         LD      DE,#0-50         ; 50 Bytes string space
   E083 22 AF 10      [16]  235         LD      (LSTRAM),HL     ; Save last available RAM
   E086 19            [ 7]  236         ADD     HL,DE           ; Allocate string space
   E087 22 5A 10      [16]  237         LD      (STRSPC),HL     ; Save string space
   E08A CD BA E4      [16]  238         CALL    CLRPTR          ; Clear program area
   E08D 2A 5A 10      [15]  239         LD      HL,(STRSPC)     ; Get end of memory
   E090 11 EF FF      [ 9]  240         LD      DE,#0-17         ; Offset for free bytes
   E093 19            [ 7]  241         ADD     HL,DE           ; Adjust HL
   E094 11 F9 10      [ 9]  242         LD      DE,#PROGST       ; Start of program text
   E097 7D            [ 4]  243         LD      A,L             ; Get LSB
   E098 93            [ 4]  244         SUB     E               ; Adjust it
   E099 6F            [ 4]  245         LD      L,A             ; Re-save
   E09A 7C            [ 4]  246         LD      A,H             ; Get MSB
   E09B 9A            [ 4]  247         SBC     A,D             ; Adjust it
   E09C 67            [ 4]  248         LD      H,A             ; Re-save
   E09D E5            [11]  249         PUSH    HL              ; Save bytes free
   E09E 21 C5 E0      [ 9]  250         LD      HL,#SIGNON       ; Sign-on message
   E0A1 CD 10 F2      [16]  251         CALL    PRS             ; Output string
   E0A4 E1            [ 9]  252         POP     HL              ; Get bytes free back
   E0A5 CD AD F9      [16]  253         CALL    PRNTHL          ; Output amount of free memory
   E0A8 21 B7 E0      [ 9]  254         LD      HL,#BFREE        ; " Bytes free" message
   E0AB CD 10 F2      [16]  255         CALL    PRS             ; Output string
                            256 
   E0AE 31 66 10      [ 9]  257 WARMST: LD      SP,#STACK        ; Temporary stack
   E0B1 CD DF E4      [16]  258 BRKRET: CALL    CLREG           ; Clear registers and stack
   E0B4 C3 F8 E3      [ 9]  259         JP      PRNTOK          ; Go to get command line
                            260 
   E0B7 20 42 79 74 65 73   261 BFREE:  .ascii      " Bytes free"
        20 66 72 65 65
   E0C2 0D 00 00            262         .db         CR,0,0
                            263 
   E0C5 4E 41 53 43 4F 4D   264 SIGNON: .ascii      "NASCOM ROM BASIC Ver 4.7   "
        20 52 4F 4D 20 42
        41 53 49 43 20 56
        65 72 20 34 2E 37
        20 20 20
   E0E0 0D                  265         .db CR
   E0E1 43 6F 70 79 72 69   266         .ascii      "Copyright (C) 1978 by Microsoft"
        67 68 74 20 28 43
        29 20 31 39 37 38
        20 62 79 20 4D 69
        63 72 6F 73 6F 66
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 6.
Hexadecimal [16-Bits]



        74
   E100 0D 00 00            267         .db CR,0,0
                            268 
   E103 4D 65 6D 6F 72 79   269 MEMMSG: .ascii      "Memory size"
        20 73 69 7A 65
   E10E 00                  270         .db 0
                            271 
                            272 ; FUNCTION ADDRESS TABLE
                            273 
   E10F 22 F8               274 FNCTAB: .dw      SGN
   E111 E6 F8               275         .dw      INT
   E113 38 F8               276         .dw      ABS
   E115 03 10               277         .dw      USR
   E117 D0 F0               278         .dw      FRE
   E119 41 F4               279         .dw      INP
   E11B FE F0               280         .dw      POS
   E11D AC FA               281         .dw      SQR
   E11F 8B FB               282         .dw      RND
   E121 C7 F6               283         .dw      LOG
   E123 FA FA               284         .dw      EXP
   E125 00 FC               285         .dw      COS
   E127 06 FC               286         .dw      SIN
   E129 67 FC               287         .dw      TAN
   E12B 7C FC               288         .dw      ATN
   E12D A3 F5               289         .dw      PEEK
   E12F BC FD               290         .dw      DEEK
   E131 51 10               291         .dw      POINT
   E133 82 F3               292         .dw      LEN
   E135 9A F1               293         .dw      STR
   E137 1C F4               294         .dw      VAL
   E139 91 F3               295         .dw      ASC
   E13B A2 F3               296         .dw      CHR
   E13D B2 F3               297         .dw      LEFT
   E13F E2 F3               298         .dw      RIGHT
   E141 EC F3               299         .dw      MID
                            300 
                            301 ; RESERVED WORD LIST
                            302 
   E143 C5 4E 44            303 WORDS:  .db      "E"+0x80,"N","D"
   E146 C6 4F 52            304         .db      "F"+0x80,"O","R"
   E149 CE 45 58 54         305         .db      "N"+0x80,"E","X","T"
   E14D C4 41 54 41         306         .db      "D"+0x80,"A","T","A"
   E151 C9 4E 50 55 54      307         .db      "I"+0x80,"N","P","U","T"
   E156 C4 49 4D            308         .db      "D"+0x80,"I","M"
   E159 D2 45 41 44         309         .db      "R"+0x80,"E","A","D"
   E15D CC 45 54            310         .db      "L"+0x80,"E","T"
   E160 C7 4F 54 4F         311         .db      "G"+0x80,"O","T","O"
   E164 D2 55 4E            312         .db      "R"+0x80,"U","N"
   E167 C9 46               313         .db      "I"+0x80,"F"
   E169 D2 45 53 54 4F 52   314         .db      "R"+0x80,"E","S","T","O","R","E"
        45
   E170 C7 4F 53 55 42      315         .db      "G"+0x80,"O","S","U","B"
   E175 D2 45 54 55 52 4E   316         .db      "R"+0x80,"E","T","U","R","N"
   E17B D2 45 4D            317         .db      "R"+0x80,"E","M"
   E17E D3 54 4F 50         318         .db      "S"+0x80,"T","O","P"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 7.
Hexadecimal [16-Bits]



   E182 CF 55 54            319         .db      "O"+0x80,"U","T"
   E185 CF 4E               320         .db      "O"+0x80,"N"
   E187 CE 55 4C 4C         321         .db      "N"+0x80,"U","L","L"
   E18B D7 41 49 54         322         .db      "W"+0x80,"A","I","T"
   E18F C4 45 46            323         .db      "D"+0x80,"E","F"
   E192 D0 4F 4B 45         324         .db      "P"+0x80,"O","K","E"
   E196 C4 4F 4B 45         325         .db      "D"+0x80,"O","K","E"
   E19A D3 43 52 45 45 4E   326         .db      "S"+0x80,"C","R","E","E","N"
   E1A0 CC 49 4E 45 53      327         .db      "L"+0x80,"I","N","E","S"
   E1A5 C3 4C 53            328         .db      "C"+0x80,"L","S"
   E1A8 D7 49 44 54 48      329         .db      "W"+0x80,"I","D","T","H"
   E1AD CD 4F 4E 49 54 4F   330         .db      "M"+0x80,"O","N","I","T","O","R"
        52
   E1B4 D3 45 54            331         .db      "S"+0x80,"E","T"
   E1B7 D2 45 53 45 54      332         .db      "R"+0x80,"E","S","E","T"
   E1BC D0 52 49 4E 54      333         .db      "P"+0x80,"R","I","N","T"
   E1C1 C3 4F 4E 54         334         .db      "C"+0x80,"O","N","T"
   E1C5 CC 49 53 54         335         .db      "L"+0x80,"I","S","T"
   E1C9 C3 4C 45 41 52      336         .db      "C"+0x80,"L","E","A","R"
   E1CE C3 4C 4F 41 44      337         .db      "C"+0x80,"L","O","A","D"
   E1D3 C3 53 41 56 45      338         .db      "C"+0x80,"S","A","V","E"
   E1D8 CE 45 57            339         .db      "N"+0x80,"E","W"
   E1DB D4 41 42 28         340         .db      "T"+0x80,"A","B","("
   E1DF D4 4F               341         .db      "T"+0x80,"O"
   E1E1 C6 4E               342         .db      "F"+0x80,"N"
   E1E3 D3 50 43 28         343         .db      "S"+0x80,"P","C","("
   E1E7 D4 48 45 4E         344         .db      "T"+0x80,"H","E","N"
   E1EB CE 4F 54            345         .db      "N"+0x80,"O","T"
   E1EE D3 54 45 50         346         .db      "S"+0x80,"T","E","P"
                            347 
   E1F2 AB                  348         .db      "+"+0x80
   E1F3 AD                  349         .db      "-"+0x80
   E1F4 AA                  350         .db      "*"+0x80
   E1F5 AF                  351         .db      "/"+0x80
   E1F6 DE                  352         .db      "^"+0x80
   E1F7 C1 4E 44            353         .db      "A"+0x80,"N","D"
   E1FA CF 52               354         .db      "O"+0x80,"R"
   E1FC BE                  355         .db      ">"+0x80
   E1FD BD                  356         .db      "="+0x80
   E1FE BC                  357         .db      "<"+0x80
                            358 
   E1FF D3 47 4E            359         .db      "S"+0x80,"G","N"
   E202 C9 4E 54            360         .db      "I"+0x80,"N","T"
   E205 C1 42 53            361         .db      "A"+0x80,"B","S"
   E208 D5 53 52            362         .db      "U"+0x80,"S","R"
   E20B C6 52 45            363         .db      "F"+0x80,"R","E"
   E20E C9 4E 50            364         .db      "I"+0x80,"N","P"
   E211 D0 4F 53            365         .db      "P"+0x80,"O","S"
   E214 D3 51 52            366         .db      "S"+0x80,"Q","R"
   E217 D2 4E 44            367         .db      "R"+0x80,"N","D"
   E21A CC 4F 47            368         .db      "L"+0x80,"O","G"
   E21D C5 58 50            369         .db      "E"+0x80,"X","P"
   E220 C3 4F 53            370         .db      "C"+0x80,"O","S"
   E223 D3 49 4E            371         .db      "S"+0x80,"I","N"
   E226 D4 41 4E            372         .db      "T"+0x80,"A","N"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 8.
Hexadecimal [16-Bits]



   E229 C1 54 4E            373         .db      "A"+0x80,"T","N"
   E22C D0 45 45 4B         374         .db      "P"+0x80,"E","E","K"
   E230 C4 45 45 4B         375         .db      "D"+0x80,"E","E","K"
   E234 D0 4F 49 4E 54      376         .db      "P"+0x80,"O","I","N","T"
   E239 CC 45 4E            377         .db      "L"+0x80,"E","N"
   E23C D3 54 52 24         378         .db      "S"+0x80,"T","R","$"
   E240 D6 41 4C            379         .db      "V"+0x80,"A","L"
   E243 C1 53 43            380         .db      "A"+0x80,"S","C"
   E246 C3 48 52 24         381         .db      "C"+0x80,"H","R","$"
   E24A CC 45 46 54 24      382         .db      "L"+0x80,"E","F","T","$"
   E24F D2 49 47 48 54 24   383         .db      "R"+0x80,"I","G","H","T","$"
   E255 CD 49 44 24         384         .db      "M"+0x80,"I","D","$"
   E259 80                  385         .db      0x80             ; End of list marker
                            386 
                            387 ; KEYWORD ADDRESS TABLE
                            388 
   E25A 72 E8               389 WORDTB: .dw      PEND
   E25C 79 E7               390         .dw      FOR
   E25E F6 EC               391         .dw      NEXT
   E260 70 EA               392         .dw      DATA
   E262 FD EB               393         .dw      INPUT
   E264 28 EF               394         .dw      DIM
   E266 2C EC               395         .dw      READ
   E268 87 EA               396         .dw      LET
   E26A 2D EA               397         .dw      GOTO
   E26C 10 EA               398         .dw      RUN
   E26E FF EA               399         .dw      IF
   E270 46 E8               400         .dw      RESTOR
   E272 1C EA               401         .dw      GOSUB
   E274 4B EA               402         .dw      RETURN
   E276 72 EA               403         .dw      REM
   E278 70 E8               404         .dw      STOP
   E27A 4D F4               405         .dw      POUT
   E27C E1 EA               406         .dw      ON
   E27E B1 E8               407         .dw      NULL
   E280 53 F4               408         .dw      WAIT
   E282 06 F1               409         .dw      DEF
   E284 AA F5               410         .dw      POKE
   E286 C7 FD               411         .dw      DOKE
   E288 E6 FD               412         .dw      SCREEN
   E28A AD FD               413         .dw      LINES
   E28C 8B FD               414         .dw      CLS
   E28E A5 FD               415         .dw      WIDTH
   E290 A2 FE               416         .dw      MONITR
   E292 54 10               417         .dw      PSET
   E294 57 10               418         .dw      RESET
   E296 23 EB               419         .dw      PRINT
   E298 9E E8               420         .dw      CONT
   E29A DD E6               421         .dw      LIST
   E29C CA E9               422         .dw      CLEAR
   E29E F9 F4               423         .dw      CLOAD
   E2A0 C3 F4               424         .dw      CSAVE
   E2A2 B9 E4               425         .dw      NEW
                            426 
                            427 ; RESERVED WORD TOKEN VALUES
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 9.
Hexadecimal [16-Bits]



                            428 
                     0080   429 ZEND    .equ     0x080            ; END
                     0081   430 ZFOR    .equ     0x081            ; FOR
                     0083   431 ZDATA   .equ     0x083            ; DATA
                     0088   432 ZGOTO   .equ     0x088            ; GOTO
                     008C   433 ZGOSUB  .equ     0x08C            ; GOSUB
                     008E   434 ZREM    .equ     0x08E            ; REM
                     009E   435 ZPRINT  .equ     0x09E            ; PRINT
                     00A4   436 ZNEW    .equ     0x0A4            ; NEW
                            437 
                     00A5   438 ZTAB    .equ     0x0A5            ; TAB
                     00A6   439 ZTO     .equ     0x0A6            ; TO
                     00A7   440 ZFN     .equ     0x0A7            ; FN
                     00A8   441 ZSPC    .equ     0x0A8            ; SPC
                     00A9   442 ZTHEN   .equ     0x0A9            ; THEN
                     00AA   443 ZNOT    .equ     0x0AA            ; NOT
                     00AB   444 ZSTEP   .equ     0x0AB            ; STEP
                            445 
                     00AC   446 ZPLUS   .equ     0x0AC            ; +
                     00AD   447 ZMINUS  .equ     0x0AD            ; -
                     00AE   448 ZTIMES  .equ     0x0AE            ; *
                     00AF   449 ZDIV    .equ     0x0AF            ; /
                     00B2   450 ZOR     .equ     0x0B2            ; OR
                     00B3   451 ZGTR    .equ     0x0B3            ; >
                     00B4   452 ZEQUAL  .equ     0x0B4            ; M
                     00B5   453 ZLTH    .equ     0x0B5            ; <
                     00B6   454 ZSGN    .equ     0x0B6            ; SGN
                     00C7   455 ZPOINT  .equ     0x0C7            ; POINT
                     00CD   456 ZLEFT   .equ     0x0CD            ; LEFT$
                            457 
                            458 ; ARITHMETIC PRECEDENCE TABLE
                            459 
   E2A4 79                  460 PRITAB: .db      0x79             ; Precedence value
   E2A5 94 F9               461         .dw      PADD            ; FPREG = <last> + FPREG
                            462 
   E2A7 79                  463         .db      0x79             ; Precedence value
   E2A8 C8 F5               464         .dw      PSUB            ; FPREG = <last> - FPREG
                            465 
   E2AA 7C                  466         .db      0x7C             ; Precedence value
   E2AB 06 F7               467         .dw      MULT            ; PPREG = <last> * FPREG
                            468 
   E2AD 7C                  469         .db      0x7C             ; Precedence value
   E2AE 67 F7               470         .dw      DIV             ; FPREG = <last> / FPREG
                            471 
   E2B0 7F                  472         .db      0x7F             ; Precedence value
   E2B1 B5 FA               473         .dw      POWER           ; FPREG = <last> ^ FPREG
                            474 
   E2B3 50                  475         .db      0x50             ; Precedence value
   E2B4 81 EE               476         .dw      PAND            ; FPREG = <last> AND FPREG
                            477 
   E2B6 46                  478         .db      0x46             ; Precedence value
   E2B7 80 EE               479         .dw      POR             ; FPREG = <last> OR FPREG
                            480 
                            481 ; BASIC ERROR CODE LIST
                            482 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 10.
Hexadecimal [16-Bits]



   E2B9 4E 46               483 ERRORS: .db      "N","F"            ; NEXT without FOR
   E2BB 53 4E               484         .db      "S","N"            ; Syntax error
   E2BD 52 47               485         .db      "R","G"            ; RETURN without GOSUB
   E2BF 4F 44               486         .db      "O","D"            ; Out of DATA
   E2C1 46 43               487         .db      "F","C"            ; Illegal function call
   E2C3 4F 56               488         .db      "O","V"            ; Overflow error
   E2C5 4F 4D               489         .db      "O","M"            ; Out of memory
   E2C7 55 4C               490         .db      "U","L"            ; Undefined line
   E2C9 42 53               491         .db      "B","S"            ; Bad subscript
   E2CB 44 44               492         .db      "D","D"            ; Re-DIMensioned array
   E2CD 2F 30               493         .db      "/","0"            ; Division by zero
   E2CF 49 44               494         .db      "I","D"            ; Illegal direct
   E2D1 54 4D               495         .db      "T","M"            ; Type mis-match
   E2D3 4F 53               496         .db      "O","S"            ; Out of string space
   E2D5 4C 53               497         .db      "L","S"            ; String too long
   E2D7 53 54               498         .db      "S","T"            ; String formula too complex
   E2D9 43 4E               499         .db      "C","N"            ; Can't CONTinue
   E2DB 55 46               500         .db      "U","F"            ; Undefined FN function
   E2DD 4D 4F               501         .db      "M","O"            ; Missing operand
                            502 
                            503 ; INITIALISATION TABLE
                            504 
   E2DF C3 AE E0      [ 9]  505 INITAB: JP      WARMST          ; Warm start jump
   E2E2 C3 A0 E9      [ 9]  506         JP      FCERR           ; "USR (X)" jump (Set to Error)
                            507 
   E2E5 D3 00         [10]  508         OUT     (0),A           ; "OUT p,n" skeleton
   E2E7 C9            [ 9]  509         RET
                            510 
   E2E8 D6 00         [ 6]  511         SUB     #0               ; Division support routine
   E2EA 6F            [ 4]  512         LD      L,A
   E2EB 7C            [ 4]  513         LD      A,H
   E2EC DE 00         [ 6]  514         SBC     A,#0
   E2EE 67            [ 4]  515         LD      H,A
   E2EF 78            [ 4]  516         LD      A,B
   E2F0 DE 00         [ 6]  517         SBC     A,#0
   E2F2 47            [ 4]  518         LD      B,A
   E2F3 3E 00         [ 6]  519         LD      A,#0
   E2F5 C9            [ 9]  520         RET
                            521 
   E2F6 00 00 00            522         .db      0,0,0                   ; Random number seed
                            523                                         ; Table used by RND
   E2F9 35 4A CA 99         524         .db      0x35,0x4A,0xCA,0x99     ;-2.65145E+07
   E2FD 39 1C 76 98         525         .db      0x39,0x1C,0x76,0x98     ; 1.61291E+07
   E301 22 95 B3 98         526         .db      0x22,0x95,0xB3,0x98     ;-1.17691E+07
   E305 0A DD 47 98         527         .db      0x0A,0xDD,0x47,0x98     ; 1.30983E+07
   E309 53 D1 99 99         528         .db      0x53,0xD1,0x99,0x99     ;-2-01612E+07
   E30D 0A 1A 9F 98         529         .db      0x0A,0x1A,0x9F,0x98     ;-1.04269E+07
   E311 65 BC CD 98         530         .db      0x65,0xBC,0xCD,0x98     ;-1.34831E+07
   E315 D6 77 3E 98         531         .db      0xD6,0x77,0x3E,0x98     ; 1.24825E+07
   E319 52 C7 4F 80         532         .db      0x52,0xC7,0x4F,0x80     ; Last random number
                            533 
   E31D DB 00         [ 9]  534         IN      A,(0)           ; INP (x) skeleton
   E31F C9            [ 9]  535         RET
                            536 
   E320 01                  537         .db      1               ; POS (x) number (1)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 11.
Hexadecimal [16-Bits]



   E321 2F                  538         .db      47              ; Terminal width (47)
   E322 1C                  539         .db      28              ; Width for commas (3 columns)
   E323 00                  540         .db      0               ; No nulls after input bytes
   E324 00                  541         .db      0               ; Output enabled (^O off)
                            542 
   E325 05 00               543         .dw      5               ; Initial lines counter
   E327 05 00               544         .dw      5               ; Initial lines number
   E329 00 00               545         .dw      0               ; Array load/save check sum
                            546 
   E32B 00                  547         .db      0               ; Break not by NMI
   E32C 00                  548         .db      0               ; Break flag
                            549 
   E32D C3 07 E6      [ 9]  550         JP      TTYLIN          ; Input reflection (set to TTY)
   E330 C3 79 FF      [ 9]  551         JP      POINTB          ; POINT reflection unused
   E333 C3 40 FF      [ 9]  552         JP      SETB            ; SET reflection
   E336 C3 55 FF      [ 9]  553         JP      RESETB          ; RESET reflection
                            554 
   E339 5D 11               555         .dw      STLOOK          ; Temp string space
   E33B FE FF               556         .dw      -2              ; Current line number (cold)
   E33D FA 10               557         .dw      PROGST+1        ; Start of program text
   E33F                     558 INITBE:                         ; END OF INITIALISATION TABLE
                            559 
   E33F 20 45 72 72 6F 72   560 ERRMSG: .ascii      " Error"
   E345 00                  561         .db 0
   E346 20 69 6E 20         562 INMSG:  .ascii      " in "
   E34A 00                  563 ZERBYT:  .db 0
                            564            ; A zero byte
   E34B 4F 6B               565 OKMSG:  .ascii     "Ok"
   E34D 0D 00 00            566         .db     CR,0,0
   E350 42 72 65 61 6B      567 BRKMSG: .ascii      "Break"
   E355 00                  568         .db 0
                            569 
   E356 21 04 00      [ 9]  570 BAKSTK: LD      HL,#4            ; Look for "FOR" block with
   E359 39            [ 7]  571         ADD     HL,SP           ; same index as specified
   E35A 7E            [ 6]  572 LOKFOR: LD      A,(HL)          ; Get block ID
   E35B 23            [ 4]  573         INC     HL              ; Point to index address
   E35C FE 81         [ 6]  574         CP      #ZFOR            ; Is it a "FOR" token
   E35E C0            [10]  575         RET     NZ              ; No - exit
   E35F 4E            [ 6]  576         LD      C,(HL)          ; BC = Address of "FOR" index
   E360 23            [ 4]  577         INC     HL
   E361 46            [ 6]  578         LD      B,(HL)
   E362 23            [ 4]  579         INC     HL              ; Point to sign of STEP
   E363 E5            [11]  580         PUSH    HL              ; Save pointer to sign
   E364 69            [ 4]  581         LD      L,C             ; HL = address of "FOR" index
   E365 60            [ 4]  582         LD      H,B
   E366 7A            [ 4]  583         LD      A,D             ; See if an index was specified
   E367 B3            [ 4]  584         OR      E               ; DE = 0 if no index specified
   E368 EB            [ 3]  585         EX      DE,HL           ; Specified index into HL
   E369 CA 70 E3      [ 9]  586         JP      Z,INDFND        ; Skip if no index given
   E36C EB            [ 3]  587         EX      DE,HL           ; Index back into DE
   E36D CD 8A E6      [16]  588         CALL    CPDEHL          ; Compare index with one given
   E370 01 0D 00      [ 9]  589 INDFND: LD      BC,#16-3         ; Offset to next block
   E373 E1            [ 9]  590         POP     HL              ; Restore pointer to sign
   E374 C8            [10]  591         RET     Z               ; Return if block found
   E375 09            [ 7]  592         ADD     HL,BC           ; Point to next block
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 12.
Hexadecimal [16-Bits]



   E376 C3 5A E3      [ 9]  593         JP      LOKFOR          ; Keep on looking
                            594 
   E379 CD 93 E3      [16]  595 MOVUP:  CALL    ENFMEM          ; See if enough memory
   E37C C5            [11]  596 MOVSTR: PUSH    BC              ; Save end of source
   E37D E3            [16]  597         EX      (SP),HL         ; Swap source and dest" end
   E37E C1            [ 9]  598         POP     BC              ; Get end of destination
   E37F CD 8A E6      [16]  599 MOVLP:  CALL    CPDEHL          ; See if list moved
   E382 7E            [ 6]  600         LD      A,(HL)          ; Get byte
   E383 02            [ 7]  601         LD      (BC),A          ; Move it
   E384 C8            [10]  602         RET     Z               ; Exit if all done
   E385 0B            [ 4]  603         DEC     BC              ; Next byte to move to
   E386 2B            [ 4]  604         DEC     HL              ; Next byte to move
   E387 C3 7F E3      [ 9]  605         JP      MOVLP           ; Loop until all bytes moved
                            606 
   E38A E5            [11]  607 CHKSTK: PUSH    HL              ; Save code string address
   E38B 2A DA 10      [15]  608         LD      HL,(ARREND)     ; Lowest free memory
   E38E 06 00         [ 6]  609         LD      B,#0             ; BC = Number of levels to test
   E390 09            [ 7]  610         ADD     HL,BC           ; 2 Bytes for each level
   E391 09            [ 7]  611         ADD     HL,BC
   E392 3E                  612         .db      0x3E             ; Skip "PUSH HL"
   E393 E5            [11]  613 ENFMEM: PUSH    HL              ; Save code string address
   E394 3E D0         [ 6]  614         LD      A,#-48          ; LOW -48 Bytes minimum RAM
   E396 95            [ 4]  615         SUB     L
   E397 6F            [ 4]  616         LD      L,A
   E398 3E FF         [ 6]  617         LD      A,#0xFF          ; HIGH -48 Bytes minimum RAM
   E39A 9C            [ 4]  618         SBC     A,H
   E39B DA A2 E3      [ 9]  619         JP      C,OMERR         ; Not enough - ?OM Error
   E39E 67            [ 4]  620         LD      H,A
   E39F 39            [ 7]  621         ADD     HL,SP           ; Test if stack is overflowed
   E3A0 E1            [ 9]  622         POP     HL              ; Restore code string address
   E3A1 D8            [10]  623         RET     C               ; Return if enough mmory
   E3A2 1E 0C         [ 6]  624 OMERR:  LD      E,#OM            ; ?OM Error
   E3A4 C3 C1 E3      [ 9]  625         JP      ERROR
                            626 
   E3A7 2A C9 10      [15]  627 DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
   E3AA 22 5C 10      [16]  628         LD      (LINEAT),HL     ; Save as current line
   E3AD 1E 02         [ 6]  629 SNERR:  LD      E,#SN            ; ?SN Error
   E3AF 01                  630         .db      0x01             ; Skip "LD E,DZ"
   E3B0 1E 14         [ 6]  631 DZERR:  LD      E,#DZ            ; ?/0 Error
   E3B2 01                  632         .db      0x01             ; Skip "LD E,NF"
   E3B3 1E 00         [ 6]  633 NFERR:  LD      E,#NF            ; ?NF Error
   E3B5 01                  634         .db      0x01             ; Skip "LD E,DD"
   E3B6 1E 12         [ 6]  635 DDERR:  LD      E,#DD            ; ?DD Error
   E3B8 01                  636         .db      0x01             ; Skip "LD E,UF"
   E3B9 1E 22         [ 6]  637 UFERR:  LD      E,#UF            ; ?UF Error
   E3BB 01                  638         .db      0x01             ; Skip "LD E,OV
   E3BC 1E 0A         [ 6]  639 OVERR:  LD      E,#OV            ; ?OV Error
   E3BE 01                  640         .db      0x01             ; Skip "LD E,TM"
   E3BF 1E 18         [ 6]  641 TMERR:  LD      E,#TM            ; ?TM Error
                            642 
   E3C1 CD DF E4      [16]  643 ERROR:  CALL    CLREG           ; Clear registers and stack
   E3C4 32 45 10      [13]  644         LD      (CTLOFG),A      ; Enable output (A is 0)
   E3C7 CD 74 EB      [16]  645         CALL    STTLIN          ; Start new line
   E3CA 21 B9 E2      [ 9]  646         LD      HL,#ERRORS       ; Point to error codes
   E3CD 57            [ 4]  647         LD      D,A             ; D = 0 (A is 0)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 13.
Hexadecimal [16-Bits]



   E3CE 3E 3F         [ 6]  648         LD      A,#"?"
   E3D0 CD 9B E6      [16]  649         CALL    OUTC            ; Output "?"
   E3D3 19            [ 7]  650         ADD     HL,DE           ; Offset to correct error code
   E3D4 7E            [ 6]  651         LD      A,(HL)          ; First character
   E3D5 CD 9B E6      [16]  652         CALL    OUTC            ; Output it
   E3D8 CD 36 E8      [16]  653         CALL    GETCHR          ; Get next character
   E3DB CD 9B E6      [16]  654         CALL    OUTC            ; Output it
   E3DE 21 3F E3      [ 9]  655         LD      HL,#ERRMSG       ; "Error" message
   E3E1 CD 10 F2      [16]  656 ERRIN:  CALL    PRS             ; Output message
   E3E4 2A 5C 10      [15]  657         LD      HL,(LINEAT)     ; Get line of error
   E3E7 11 FE FF      [ 9]  658         LD      DE,#-2           ; Cold start error if -2
   E3EA CD 8A E6      [16]  659         CALL    CPDEHL          ; See if cold start error
   E3ED CA 12 E0      [ 9]  660         JP      Z,CSTART        ; Cold start error - Restart
   E3F0 7C            [ 4]  661         LD      A,H             ; Was it a direct error?
   E3F1 A5            [ 4]  662         AND     L               ; Line = -1 if direct error
   E3F2 3C            [ 4]  663         INC     A
   E3F3 C4 A5 F9      [16]  664         CALL    NZ,LINEIN       ; No - output line of error
   E3F6 3E                  665         .db      0x3E             ; Skip "POP BC"
   E3F7 C1            [ 9]  666 POPNOK: POP     BC              ; Drop address in input buffer
                            667 
   E3F8 AF            [ 4]  668 PRNTOK: XOR     A               ; Output "Ok" and get command
   E3F9 32 45 10      [13]  669         LD      (CTLOFG),A      ; Enable output
   E3FC CD 74 EB      [16]  670         CALL    STTLIN          ; Start new line
   E3FF 21 4B E3      [ 9]  671         LD      HL,#OKMSG        ; "Ok" message
   E402 CD 10 F2      [16]  672         CALL    PRS             ; Output "Ok"
   E405 21 FF FF      [ 9]  673 GETCMD: LD      HL,#-1           ; Flag direct mode
   E408 22 5C 10      [16]  674         LD      (LINEAT),HL     ; Save as current line
   E40B CD F2 E5      [16]  675         CALL    GETLIN          ; Get an input line
   E40E DA 05 E4      [ 9]  676         JP      C,GETCMD        ; Get line again if break
   E411 CD 36 E8      [16]  677         CALL    GETCHR          ; Get first character
   E414 3C            [ 4]  678         INC     A               ; Test if end of line
   E415 3D            [ 4]  679         DEC     A               ; Without affecting Carry
   E416 CA 05 E4      [ 9]  680         JP      Z,GETCMD        ; Nothing entered - Get another
   E419 F5            [11]  681         PUSH    AF              ; Save Carry status
   E41A CD A5 E9      [16]  682         CALL    ATOH            ; Get line number into DE
   E41D D5            [11]  683         PUSH    DE              ; Save line number
   E41E CD 09 E5      [16]  684         CALL    CRUNCH          ; Tokenise rest of line
   E421 47            [ 4]  685         LD      B,A             ; Length of tokenised line
   E422 D1            [ 9]  686         POP     DE              ; Restore line number
   E423 F1            [ 9]  687         POP     AF              ; Restore Carry
   E424 D2 16 E8      [ 9]  688         JP      NC,EXCUTE       ; No line number - Direct mode
   E427 D5            [11]  689         PUSH    DE              ; Save line number
   E428 C5            [11]  690         PUSH    BC              ; Save length of tokenised line
   E429 AF            [ 4]  691         XOR     A
   E42A 32 CC 10      [13]  692         LD      (LSTBIN),A      ; Clear last byte input
   E42D CD 36 E8      [16]  693         CALL    GETCHR          ; Get next character
   E430 B7            [ 4]  694         OR      A               ; Set flags
   E431 F5            [11]  695         PUSH    AF              ; And save them
   E432 CD 99 E4      [16]  696         CALL    SRCHLN          ; Search for line number in DE
   E435 DA 3E E4      [ 9]  697         JP      C,LINFND        ; Jump if line found
   E438 F1            [ 9]  698         POP     AF              ; Get status
   E439 F5            [11]  699         PUSH    AF              ; And re-save
   E43A CA 46 EA      [ 9]  700         JP      Z,ULERR         ; Nothing after number - Error
   E43D B7            [ 4]  701         OR      A               ; Clear Carry
   E43E C5            [11]  702 LINFND: PUSH    BC              ; Save address of line in prog
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 14.
Hexadecimal [16-Bits]



   E43F D2 55 E4      [ 9]  703         JP      NC,INEWLN       ; Line not found - Insert new
   E442 EB            [ 3]  704         EX      DE,HL           ; Next line address in DE
   E443 2A D6 10      [15]  705         LD      HL,(PROGND)     ; End of program
   E446 1A            [ 6]  706 SFTPRG: LD      A,(DE)          ; Shift rest of program down
   E447 02            [ 7]  707         LD      (BC),A
   E448 03            [ 4]  708         INC     BC              ; Next destination
   E449 13            [ 4]  709         INC     DE              ; Next source
   E44A CD 8A E6      [16]  710         CALL    CPDEHL          ; All done?
   E44D C2 46 E4      [ 9]  711         JP      NZ,SFTPRG       ; More to do
   E450 60            [ 4]  712         LD      H,B             ; HL - New end of program
   E451 69            [ 4]  713         LD      L,C
   E452 22 D6 10      [16]  714         LD      (PROGND),HL     ; Update end of program
                            715 
   E455 D1            [ 9]  716 INEWLN: POP     DE              ; Get address of line,
   E456 F1            [ 9]  717         POP     AF              ; Get status
   E457 CA 7C E4      [ 9]  718         JP      Z,SETPTR        ; No text - Set up pointers
   E45A 2A D6 10      [15]  719         LD      HL,(PROGND)     ; Get end of program
   E45D E3            [16]  720         EX      (SP),HL         ; Get length of input line
   E45E C1            [ 9]  721         POP     BC              ; End of program to BC
   E45F 09            [ 7]  722         ADD     HL,BC           ; Find new end
   E460 E5            [11]  723         PUSH    HL              ; Save new end
   E461 CD 79 E3      [16]  724         CALL    MOVUP           ; Make space for line
   E464 E1            [ 9]  725         POP     HL              ; Restore new end
   E465 22 D6 10      [16]  726         LD      (PROGND),HL     ; Update end of program pointer
   E468 EB            [ 3]  727         EX      DE,HL           ; Get line to move up in HL
   E469 74            [ 7]  728         LD      (HL),H          ; Save MSB
   E46A D1            [ 9]  729         POP     DE              ; Get new line number
   E46B 23            [ 4]  730         INC     HL              ; Skip pointer
   E46C 23            [ 4]  731         INC     HL
   E46D 73            [ 7]  732         LD      (HL),E          ; Save LSB of line number
   E46E 23            [ 4]  733         INC     HL
   E46F 72            [ 7]  734         LD      (HL),D          ; Save MSB of line number
   E470 23            [ 4]  735         INC     HL              ; To first byte in line
   E471 11 61 10      [ 9]  736         LD      DE,#BUFFER       ; Copy buffer to program
   E474 1A            [ 6]  737 MOVBUF: LD      A,(DE)          ; Get source
   E475 77            [ 7]  738         LD      (HL),A          ; Save destinations
   E476 23            [ 4]  739         INC     HL              ; Next source
   E477 13            [ 4]  740         INC     DE              ; Next destination
   E478 B7            [ 4]  741         OR      A               ; Done?
   E479 C2 74 E4      [ 9]  742         JP      NZ,MOVBUF       ; No - Repeat
   E47C CD C5 E4      [16]  743 SETPTR: CALL    RUNFST          ; Set line pointers
   E47F 23            [ 4]  744         INC     HL              ; To LSB of pointer
   E480 EB            [ 3]  745         EX      DE,HL           ; Address to DE
   E481 62            [ 4]  746 PTRLP:  LD      H,D             ; Address to HL
   E482 6B            [ 4]  747         LD      L,E
   E483 7E            [ 6]  748         LD      A,(HL)          ; Get LSB of pointer
   E484 23            [ 4]  749         INC     HL              ; To MSB of pointer
   E485 B6            [ 6]  750         OR      (HL)            ; Compare with MSB pointer
   E486 CA 05 E4      [ 9]  751         JP      Z,GETCMD        ; Get command line if end
   E489 23            [ 4]  752         INC     HL              ; To LSB of line number
   E48A 23            [ 4]  753         INC     HL              ; Skip line number
   E48B 23            [ 4]  754         INC     HL              ; Point to first byte in line
   E48C AF            [ 4]  755         XOR     A               ; Looking for 00 byte
   E48D BE            [ 6]  756 FNDEND: CP      (HL)            ; Found end of line?
   E48E 23            [ 4]  757         INC     HL              ; Move to next byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 15.
Hexadecimal [16-Bits]



   E48F C2 8D E4      [ 9]  758         JP      NZ,FNDEND       ; No - Keep looking
   E492 EB            [ 3]  759         EX      DE,HL           ; Next line address to HL
   E493 73            [ 7]  760         LD      (HL),E          ; Save LSB of pointer
   E494 23            [ 4]  761         INC     HL
   E495 72            [ 7]  762         LD      (HL),D          ; Save MSB of pointer
   E496 C3 81 E4      [ 9]  763         JP      PTRLP           ; Do next line
                            764 
   E499 2A 5E 10      [15]  765 SRCHLN: LD      HL,(BASTXT)     ; Start of program text
   E49C 44            [ 4]  766 SRCHLP: LD      B,H             ; BC = Address to look at
   E49D 4D            [ 4]  767         LD      C,L
   E49E 7E            [ 6]  768         LD      A,(HL)          ; Get address of next line
   E49F 23            [ 4]  769         INC     HL
   E4A0 B6            [ 6]  770         OR      (HL)            ; End of program found?
   E4A1 2B            [ 4]  771         DEC     HL
   E4A2 C8            [10]  772         RET     Z               ; Yes - Line not found
   E4A3 23            [ 4]  773         INC     HL
   E4A4 23            [ 4]  774         INC     HL
   E4A5 7E            [ 6]  775         LD      A,(HL)          ; Get LSB of line number
   E4A6 23            [ 4]  776         INC     HL
   E4A7 66            [ 6]  777         LD      H,(HL)          ; Get MSB of line number
   E4A8 6F            [ 4]  778         LD      L,A
   E4A9 CD 8A E6      [16]  779         CALL    CPDEHL          ; Compare with line in DE
   E4AC 60            [ 4]  780         LD      H,B             ; HL = Start of this line
   E4AD 69            [ 4]  781         LD      L,C
   E4AE 7E            [ 6]  782         LD      A,(HL)          ; Get LSB of next line address
   E4AF 23            [ 4]  783         INC     HL
   E4B0 66            [ 6]  784         LD      H,(HL)          ; Get MSB of next line address
   E4B1 6F            [ 4]  785         LD      L,A             ; Next line to HL
   E4B2 3F            [ 3]  786         CCF
   E4B3 C8            [10]  787         RET     Z               ; Lines found - Exit
   E4B4 3F            [ 3]  788         CCF
   E4B5 D0            [10]  789         RET     NC              ; Line not found,at line after
   E4B6 C3 9C E4      [ 9]  790         JP      SRCHLP          ; Keep looking
                            791 
   E4B9 C0            [10]  792 NEW:    RET     NZ              ; Return if any more on line
   E4BA 2A 5E 10      [15]  793 CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
   E4BD AF            [ 4]  794         XOR     A               ; Set program area to empty
   E4BE 77            [ 7]  795         LD      (HL),A          ; Save LSB = 00
   E4BF 23            [ 4]  796         INC     HL
   E4C0 77            [ 7]  797         LD      (HL),A          ; Save MSB = 00
   E4C1 23            [ 4]  798         INC     HL
   E4C2 22 D6 10      [16]  799         LD      (PROGND),HL     ; Set program end
                            800 
   E4C5 2A 5E 10      [15]  801 RUNFST: LD      HL,(BASTXT)     ; Clear all variables
   E4C8 2B            [ 4]  802         DEC     HL
                            803 
   E4C9 22 CE 10      [16]  804 INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
   E4CC 2A AF 10      [15]  805         LD      HL,(LSTRAM)     ; Get end of RAM
   E4CF 22 C3 10      [16]  806         LD      (STRBOT),HL     ; Clear string space
   E4D2 AF            [ 4]  807         XOR     A
   E4D3 CD 46 E8      [16]  808         CALL    RESTOR          ; Reset DATA pointers
   E4D6 2A D6 10      [15]  809         LD      HL,(PROGND)     ; Get end of program
   E4D9 22 D8 10      [16]  810         LD      (VAREND),HL     ; Clear variables
   E4DC 22 DA 10      [16]  811         LD      (ARREND),HL     ; Clear arrays
                            812 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 16.
Hexadecimal [16-Bits]



   E4DF C1            [ 9]  813 CLREG:  POP     BC              ; Save return address
   E4E0 2A 5A 10      [15]  814         LD      HL,(STRSPC)     ; Get end of working RAN
   E4E3 F9            [ 4]  815         LD      SP,HL           ; Set stack
   E4E4 21 B3 10      [ 9]  816         LD      HL,#TMSTPL       ; Temporary string pool
   E4E7 22 B1 10      [16]  817         LD      (TMSTPT),HL     ; Reset temporary string ptr
   E4EA AF            [ 4]  818         XOR     A               ; A = 00
   E4EB 6F            [ 4]  819         LD      L,A             ; HL = 0000
   E4EC 67            [ 4]  820         LD      H,A
   E4ED 22 D4 10      [16]  821         LD      (CONTAD),HL     ; No CONTinue
   E4F0 32 CB 10      [13]  822         LD      (FORFLG),A      ; Clear FOR flag
   E4F3 22 DE 10      [16]  823         LD      (FNRGNM),HL     ; Clear FN argument
   E4F6 E5            [11]  824         PUSH    HL              ; HL = 0000
   E4F7 C5            [11]  825         PUSH    BC              ; Put back return
   E4F8 2A CE 10      [15]  826 DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
   E4FB C9            [ 9]  827         RET                     ; Return to execution driver
                            828 
   E4FC 3E 3F         [ 6]  829 PROMPT: LD      A,#"?"           ; "?"
   E4FE CD 9B E6      [16]  830         CALL    OUTC            ; Output character
   E501 3E 20         [ 6]  831         LD      A,#" "           ; Space
   E503 CD 9B E6      [16]  832         CALL    OUTC            ; Output character
   E506 C3 4E 10      [ 9]  833         JP      RINPUT          ; Get input line
                            834 
   E509 AF            [ 4]  835 CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
   E50A 32 AE 10      [13]  836         LD      (DATFLG),A      ; Reset literal flag
   E50D 0E 05         [ 6]  837         LD      C,#2+3           ; 2 byte number and 3 nulls
   E50F 11 61 10      [ 9]  838         LD      DE,#BUFFER       ; Start of input buffer
   E512 7E            [ 6]  839 CRNCLP: LD      A,(HL)          ; Get byte
   E513 FE 20         [ 6]  840         CP      #" "             ; Is it a space?
   E515 CA 91 E5      [ 9]  841         JP      Z,MOVDIR        ; Yes - Copy direct
   E518 47            [ 4]  842         LD      B,A             ; Save character
   E519 FE 22         [ 6]  843         CP      #'"'             ; Is it a quote?"
   E51B CA B1 E5      [ 9]  844         JP      Z,CPYLIT        ; Yes - Copy literal string
   E51E B7            [ 4]  845         OR      A               ; Is it end of buffer?
   E51F CA B8 E5      [ 9]  846         JP      Z,ENDBUF        ; Yes - End buffer
   E522 3A AE 10      [12]  847         LD      A,(DATFLG)      ; Get data type
   E525 B7            [ 4]  848         OR      A               ; Literal?
   E526 7E            [ 6]  849         LD      A,(HL)          ; Get byte to copy
   E527 C2 91 E5      [ 9]  850         JP      NZ,MOVDIR       ; Literal - Copy direct
   E52A FE 3F         [ 6]  851         CP      #"?"             ; Is it "?" short for PRINT
   E52C 3E 9E         [ 6]  852         LD      A,#ZPRINT        ; "PRINT" token
   E52E CA 91 E5      [ 9]  853         JP      Z,MOVDIR        ; Yes - replace it
   E531 7E            [ 6]  854         LD      A,(HL)          ; Get byte again
   E532 FE 30         [ 6]  855         CP      #"0"             ; Is it less than "0"
   E534 DA 3C E5      [ 9]  856         JP      C,FNDWRD        ; Yes - Look for reserved words
   E537 FE 3C         [ 6]  857         CP      #";"+1           ; Is it "0123456789:;" ?
   E539 DA 91 E5      [ 9]  858         JP      C,MOVDIR        ; Yes - copy it direct
   E53C D5            [11]  859 FNDWRD: PUSH    DE              ; Look for reserved words
   E53D 11 42 E1      [ 9]  860         LD      DE,#WORDS-1      ; Point to table
   E540 C5            [11]  861         PUSH    BC              ; Save count
   E541 01 8D E5      [ 9]  862         LD      BC,#RETNAD       ; Where to return to
   E544 C5            [11]  863         PUSH    BC              ; Save return address
   E545 06 7F         [ 6]  864         LD      B,#ZEND-1        ; First token value -1
   E547 7E            [ 6]  865         LD      A,(HL)          ; Get byte
   E548 FE 61         [ 6]  866         CP      #"a"             ; Less than "a" ?
   E54A DA 55 E5      [ 9]  867         JP      C,SEARCH        ; Yes - search for words
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 17.
Hexadecimal [16-Bits]



   E54D FE 7B         [ 6]  868         CP      #"z"+1           ; Greater than "z" ?
   E54F D2 55 E5      [ 9]  869         JP      NC,SEARCH       ; Yes - search for words
   E552 E6 5F         [ 6]  870         AND     #0b01011111       ; Force upper case
   E554 77            [ 7]  871         LD      (HL),A          ; Replace byte
   E555 4E            [ 6]  872 SEARCH: LD      C,(HL)          ; Search for a word
   E556 EB            [ 3]  873         EX      DE,HL
   E557 23            [ 4]  874 GETNXT: INC     HL              ; Get next reserved word
   E558 B6            [ 6]  875         OR      (HL)            ; Start of word?
   E559 F2 57 E5      [ 9]  876         JP      P,GETNXT        ; No - move on
   E55C 04            [ 4]  877         INC     B               ; Increment token value
   E55D 7E            [ 6]  878         LD      A, (HL)         ; Get byte from table
   E55E E6 7F         [ 6]  879         AND     #0b01111111       ; Strip bit 7
   E560 C8            [10]  880         RET     Z               ; Return if end of list
   E561 B9            [ 4]  881         CP      C               ; Same character as in buffer?
   E562 C2 57 E5      [ 9]  882         JP      NZ,GETNXT       ; No - get next word
   E565 EB            [ 3]  883         EX      DE,HL
   E566 E5            [11]  884         PUSH    HL              ; Save start of word
                            885 
   E567 13            [ 4]  886 NXTBYT: INC     DE              ; Look through rest of word
   E568 1A            [ 6]  887         LD      A,(DE)          ; Get byte from table
   E569 B7            [ 4]  888         OR      A               ; End of word ?
   E56A FA 89 E5      [ 9]  889         JP      M,#MATCH         ; Yes - Match found
   E56D 4F            [ 4]  890         LD      C,A             ; Save it
   E56E 78            [ 4]  891         LD      A,B             ; Get token value
   E56F FE 88         [ 6]  892         CP      #ZGOTO           ; Is it "GOTO" token ?
   E571 C2 78 E5      [ 9]  893         JP      NZ,NOSPC        ; No - Don't allow spaces
   E574 CD 36 E8      [16]  894         CALL    GETCHR          ; Get next character
   E577 2B            [ 4]  895         DEC     HL              ; Cancel increment from GETCHR
   E578 23            [ 4]  896 NOSPC:  INC     HL              ; Next byte
   E579 7E            [ 6]  897         LD      A,(HL)          ; Get byte
   E57A FE 61         [ 6]  898         CP      #"a"             ; Less than "a" ?
   E57C DA 81 E5      [ 9]  899         JP      C,NOCHNG        ; Yes - don't change
   E57F E6 5F         [ 6]  900         AND     #0b01011111       ; Make upper case
   E581 B9            [ 4]  901 NOCHNG: CP      C               ; Same as in buffer ?
   E582 CA 67 E5      [ 9]  902         JP      Z,NXTBYT        ; Yes - keep testing
   E585 E1            [ 9]  903         POP     HL              ; Get back start of word
   E586 C3 55 E5      [ 9]  904         JP      SEARCH          ; Look at next word
                            905 
   E589 48            [ 4]  906 MATCH:  LD      C,B             ; Word found - Save token value
   E58A F1            [ 9]  907         POP     AF              ; Throw away return
   E58B EB            [ 3]  908         EX      DE,HL
   E58C C9            [ 9]  909         RET                     ; Return to "RETNAD"
   E58D EB            [ 3]  910 RETNAD: EX      DE,HL           ; Get address in string
   E58E 79            [ 4]  911         LD      A,C             ; Get token value
   E58F C1            [ 9]  912         POP     BC              ; Restore buffer length
   E590 D1            [ 9]  913         POP     DE              ; Get destination address
   E591 23            [ 4]  914 MOVDIR: INC     HL              ; Next source in buffer
   E592 12            [ 7]  915         LD      (DE),A          ; Put byte in buffer
   E593 13            [ 4]  916         INC     DE              ; Move up buffer
   E594 0C            [ 4]  917         INC     C               ; Increment length of buffer
   E595 D6 3A         [ 6]  918         SUB     #":"             ; End of statement?
   E597 CA 9F E5      [ 9]  919         JP      Z,SETLIT        ; Jump if multi-statement line
   E59A FE 49         [ 6]  920         CP      #ZDATA-0x3A       ; Is it DATA statement ?
   E59C C2 A2 E5      [ 9]  921         JP      NZ,TSTREM       ; No - see if REM
   E59F 32 AE 10      [13]  922 SETLIT: LD      (DATFLG),A      ; Set literal flag
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 18.
Hexadecimal [16-Bits]



   E5A2 D6 54         [ 6]  923 TSTREM: SUB     #ZREM-0x3A        ; Is it REM?
   E5A4 C2 12 E5      [ 9]  924         JP      NZ,CRNCLP       ; No - Leave flag
   E5A7 47            [ 4]  925         LD      B,A             ; Copy rest of buffer
   E5A8 7E            [ 6]  926 NXTCHR: LD      A,(HL)          ; Get byte
   E5A9 B7            [ 4]  927         OR      A               ; End of line ?
   E5AA CA B8 E5      [ 9]  928         JP      Z,ENDBUF        ; Yes - Terminate buffer
   E5AD B8            [ 4]  929         CP      B               ; End of statement ?
   E5AE CA 91 E5      [ 9]  930         JP      Z,MOVDIR        ; Yes - Get next one
   E5B1 23            [ 4]  931 CPYLIT: INC     HL              ; Move up source string
   E5B2 12            [ 7]  932         LD      (DE),A          ; Save in destination
   E5B3 0C            [ 4]  933         INC     C               ; Increment length
   E5B4 13            [ 4]  934         INC     DE              ; Move up destination
   E5B5 C3 A8 E5      [ 9]  935         JP      NXTCHR          ; Repeat
                            936 
   E5B8 21 60 10      [ 9]  937 ENDBUF: LD      HL,#BUFFER-1     ; Point to start of buffer
   E5BB 12            [ 7]  938         LD      (DE),A          ; Mark end of buffer (A = 00)
   E5BC 13            [ 4]  939         INC     DE
   E5BD 12            [ 7]  940         LD      (DE),A          ; A = 00
   E5BE 13            [ 4]  941         INC     DE
   E5BF 12            [ 7]  942         LD      (DE),A          ; A = 00
   E5C0 C9            [ 9]  943         RET
                            944 
   E5C1 3A 44 10      [12]  945 DODEL:  LD      A,(NULFLG)      ; Get null flag status
   E5C4 B7            [ 4]  946         OR      A               ; Is it zero?
   E5C5 3E 00         [ 6]  947         LD      A,#0             ; Zero A - Leave flags
   E5C7 32 44 10      [13]  948         LD      (NULFLG),A      ; Zero null flag
   E5CA C2 D5 E5      [ 9]  949         JP      NZ,ECHDEL       ; Set - Echo it
   E5CD 05            [ 4]  950         DEC     B               ; Decrement length
   E5CE CA F2 E5      [ 9]  951         JP      Z,GETLIN        ; Get line again if empty
   E5D1 CD 9B E6      [16]  952         CALL    OUTC            ; Output null character
   E5D4 3E                  953         .db      0x3E             ; Skip "DEC B"
   E5D5 05            [ 4]  954 ECHDEL: DEC     B               ; Count bytes in buffer
   E5D6 2B            [ 4]  955         DEC     HL              ; Back space buffer
   E5D7 CA E9 E5      [ 9]  956         JP      Z,OTKLN         ; No buffer - Try again
   E5DA 7E            [ 6]  957         LD      A,(HL)          ; Get deleted byte
   E5DB CD 9B E6      [16]  958         CALL    OUTC            ; Echo it
   E5DE C3 10 E6      [ 9]  959         JP      MORINP          ; Get more input
                            960 
   E5E1 05            [ 4]  961 DELCHR: DEC     B               ; Count bytes in buffer
   E5E2 2B            [ 4]  962         DEC     HL              ; Back space buffer
   E5E3 CD 9B E6      [16]  963         CALL    OUTC            ; Output character in A
   E5E6 C2 10 E6      [ 9]  964         JP      NZ,MORINP       ; Not end - Get more
   E5E9 CD 9B E6      [16]  965 OTKLN:  CALL    OUTC            ; Output character in A
   E5EC CD 81 EB      [16]  966 KILIN:  CALL    PRNTCR          ; Output CRLF
   E5EF C3 07 E6      [ 9]  967         JP      TTYLIN          ; Get line again
                            968 
   E5F2 CD 6D FE      [16]  969 GETLIN: CALL    MONTST          ; Is it NAS-SYS?
   E5F5 CA 07 E6      [ 9]  970         JP      Z,TTYLIN        ; No - Character input
   E5F8 2A 75 0C      [15]  971         LD      HL,(CIN)        ; Point to NAS-SYS input table
   E5FB 7E            [ 6]  972         LD      A,(HL)          ; Get input mode
   E5FC FE 74         [ 6]  973         CP      #0x74             ; Is it "X" mode?
   E5FE CA 07 E6      [ 9]  974         JP      Z,TTYLIN        ; Yes - Teletype line input
   E601 CD E8 FE      [16]  975         CALL    INLINE          ; Get a line from NAS-SYS
   E604 C3 86 EB      [ 9]  976         JP      DONULL          ; POS(X)=0 and do nulls
                            977 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 19.
Hexadecimal [16-Bits]



   E607 21 61 10      [ 9]  978 TTYLIN: LD      HL,#BUFFER       ; Get a line by character
   E60A 06 01         [ 6]  979         LD      B,#1             ; Set buffer as empty
   E60C AF            [ 4]  980         XOR     A
   E60D 32 44 10      [13]  981         LD      (NULFLG),A      ; Clear null flag
   E610 CD CC E6      [16]  982 MORINP: CALL    CLOTST          ; Get character and test ^O
   E613 4F            [ 4]  983         LD      C,A             ; Save character in C
   E614 FE 7F         [ 6]  984         CP      #DEL             ; Delete character?
   E616 CA C1 E5      [ 9]  985         JP      Z,DODEL         ; Yes - Process it
   E619 3A 44 10      [12]  986         LD      A,(NULFLG)      ; Get null flag
   E61C B7            [ 4]  987         OR      A               ; Test null flag status
   E61D CA 29 E6      [ 9]  988         JP      Z,PROCES        ; Reset - Process character
   E620 3E 00         [ 6]  989         LD      A,#0             ; Set a null
   E622 CD 9B E6      [16]  990         CALL    OUTC            ; Output null
   E625 AF            [ 4]  991         XOR     A               ; Clear A
   E626 32 44 10      [13]  992         LD      (NULFLG),A      ; Reset null flag
   E629 79            [ 4]  993 PROCES: LD      A,C             ; Get character
   E62A FE 07         [ 6]  994         CP      #CTRLG           ; Bell?
   E62C CA 6D E6      [ 9]  995         JP      Z,PUTCTL        ; Yes - Save it
   E62F FE 03         [ 6]  996         CP      #CTRLC           ; Is it control "C"?
   E631 CC 81 EB      [16]  997         CALL    Z,PRNTCR        ; Yes - Output CRLF
   E634 37            [ 3]  998         SCF                     ; Flag break
   E635 C8            [10]  999         RET     Z               ; Return if control "C"
   E636 FE 0D         [ 6] 1000         CP      #CR              ; Is it enter?
   E638 CA 7C EB      [ 9] 1001         JP      Z,ENDINP        ; Yes - Terminate input
   E63B FE 15         [ 6] 1002         CP      #CTRLU           ; Is it control "U"?
   E63D CA EC E5      [ 9] 1003         JP      Z,KILIN         ; Yes - Get another line
   E640 FE 40         [ 6] 1004         CP      #"@"             ; Is it "kill line"?
   E642 CA E9 E5      [ 9] 1005         JP      Z,OTKLN         ; Yes - Kill line
   E645 FE 5F         [ 6] 1006         CP      #"_"             ; Is it delete?
   E647 CA E1 E5      [ 9] 1007         JP      Z,DELCHR        ; Yes - Delete character
   E64A FE 08         [ 6] 1008         CP      #BKSP            ; Is it backspace?
   E64C CA E1 E5      [ 9] 1009         JP      Z,DELCHR        ; Yes - Delete character
   E64F FE 12         [ 6] 1010         CP      #CTRLR           ; Is it control "R"?
   E651 C2 68 E6      [ 9] 1011         JP      NZ,PUTBUF       ; No - Put in buffer
   E654 C5            [11] 1012         PUSH    BC              ; Save buffer length
   E655 D5            [11] 1013         PUSH    DE              ; Save DE
   E656 E5            [11] 1014         PUSH    HL              ; Save buffer address
   E657 36 00         [ 9] 1015         LD      (HL),#0          ; Mark end of buffer
   E659 CD F4 FF      [16] 1016         CALL    OUTNCR          ; Output and do CRLF
   E65C 21 61 10      [ 9] 1017         LD      HL,#BUFFER       ; Point to buffer start
   E65F CD 10 F2      [16] 1018         CALL    PRS             ; Output buffer
   E662 E1            [ 9] 1019         POP     HL              ; Restore buffer address
   E663 D1            [ 9] 1020         POP     DE              ; Restore DE
   E664 C1            [ 9] 1021         POP     BC              ; Restore buffer length
   E665 C3 10 E6      [ 9] 1022         JP      MORINP          ; Get another character
                           1023 
   E668 FE 20         [ 6] 1024 PUTBUF: CP      #" "             ; Is it a control code?
   E66A DA 10 E6      [ 9] 1025         JP      C,MORINP        ; Yes - Ignore
   E66D 78            [ 4] 1026 PUTCTL: LD      A,B             ; Get number of bytes in buffer
   E66E FE 49         [ 6] 1027         CP      #72+1            ; Test for line overflow
   E670 3E 07         [ 6] 1028         LD      A,#CTRLG         ; Set a bell
   E672 D2 82 E6      [ 9] 1029         JP      NC,OUTNBS       ; Ring bell if buffer full
   E675 79            [ 4] 1030         LD      A,C             ; Get character
   E676 71            [ 7] 1031         LD      (HL),C          ; Save in buffer
   E677 32 CC 10      [13] 1032         LD      (LSTBIN),A      ; Save last input byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 20.
Hexadecimal [16-Bits]



   E67A 23            [ 4] 1033         INC     HL              ; Move up buffer
   E67B 04            [ 4] 1034         INC     B               ; Increment length
   E67C CD 9B E6      [16] 1035 OUTIT:  CALL    OUTC            ; Output the character entered
   E67F C3 10 E6      [ 9] 1036         JP      MORINP          ; Get another character
                           1037 
   E682 CD 9B E6      [16] 1038 OUTNBS: CALL    OUTC            ; Output bell and back over it
   E685 3E 08         [ 6] 1039         LD      A,#BKSP          ; Set back space
   E687 C3 7C E6      [ 9] 1040         JP      OUTIT           ; Output it and get more
                           1041 
   E68A 7C            [ 4] 1042 CPDEHL: LD      A,H             ; Get H
   E68B 92            [ 4] 1043         SUB     D               ; Compare with D
   E68C C0            [10] 1044         RET     NZ              ; Different - Exit
   E68D 7D            [ 4] 1045         LD      A,L             ; Get L
   E68E 93            [ 4] 1046         SUB     E               ; Compare with E
   E68F C9            [ 9] 1047         RET                     ; Return status
                           1048 
   E690 7E            [ 6] 1049 CHKSYN: LD      A,(HL)          ; Check syntax of character
   E691 E3            [16] 1050         EX      (SP),HL         ; Address of test byte
   E692 BE            [ 6] 1051         CP      (HL)            ; Same as in code string?
   E693 23            [ 4] 1052         INC     HL              ; Return address
   E694 E3            [16] 1053         EX      (SP),HL         ; Put it back
   E695 CA 36 E8      [ 9] 1054         JP      Z,GETCHR        ; Yes - Get next character
   E698 C3 AD E3      [ 9] 1055         JP      SNERR           ; Different - ?SN Error
                           1056 
   E69B F5            [11] 1057 OUTC:   PUSH    AF              ; Save character
   E69C 3A 45 10      [12] 1058         LD      A,(CTLOFG)      ; Get control "O" flag
   E69F B7            [ 4] 1059         OR      A               ; Is it set?
   E6A0 C2 45 F2      [ 9] 1060         JP      NZ,POPAF        ; Yes - don't output
   E6A3 F1            [ 9] 1061         POP     AF              ; Restore character
   E6A4 C5            [11] 1062         PUSH    BC              ; Save buffer length
   E6A5 F5            [11] 1063         PUSH    AF              ; Save character
   E6A6 FE 20         [ 6] 1064         CP      #" "             ; Is it a control code?
   E6A8 DA BF E6      [ 9] 1065         JP      C,DINPOS        ; Yes - Don't INC POS(X)
   E6AB 3A 42 10      [12] 1066         LD      A,(LWIDTH)      ; Get line width
   E6AE 47            [ 4] 1067         LD      B,A             ; To B
   E6AF 3A AB 10      [12] 1068         LD      A,(CURPOS)      ; Get cursor position
   E6B2 04            [ 4] 1069         INC     B               ; Width 255?
   E6B3 CA BB E6      [ 9] 1070         JP      Z,INCLEN        ; Yes - No width limit
   E6B6 05            [ 4] 1071         DEC     B               ; Restore width
   E6B7 B8            [ 4] 1072         CP      B               ; At end of line?
   E6B8 CC 81 EB      [16] 1073         CALL    Z,PRNTCR        ; Yes - output CRLF
   E6BB 3C            [ 4] 1074 INCLEN: INC     A               ; Move on one character
   E6BC 32 AB 10      [13] 1075         LD      (CURPOS),A      ; Save new position
   E6BF F1            [ 9] 1076 DINPOS: POP     AF              ; Restore character
   E6C0 C1            [ 9] 1077         POP     BC              ; Restore buffer length
   E6C1 F5            [11] 1078         PUSH    AF              ; << This sequence >>
   E6C2 F1            [ 9] 1079         POP     AF              ; << is not needed >>
   E6C3 F5            [11] 1080         PUSH    AF              ; Save character
   E6C4 C5            [11] 1081         PUSH    BC              ; Save buffer length
   E6C5 4F            [ 4] 1082         LD      C,A             ; Character to C
   E6C6 CD D9 FC      [16] 1083         CALL    CONMON          ; Send it
   E6C9 C1            [ 9] 1084         POP     BC              ; Restore buffer length
   E6CA F1            [ 9] 1085         POP     AF              ; Restore character
   E6CB C9            [ 9] 1086         RET
                           1087 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 21.
Hexadecimal [16-Bits]



   E6CC CD 05 FD      [16] 1088 CLOTST: CALL    GETINP          ; Get input character
   E6CF E6 7F         [ 6] 1089         AND     #0b01111111       ; Strip bit 7
   E6D1 FE 0F         [ 6] 1090         CP      #CTRLO           ; Is it control "O"?
   E6D3 C0            [10] 1091         RET     NZ              ; No don't flip flag
   E6D4 3A 45 10      [12] 1092         LD      A,(CTLOFG)      ; Get flag
   E6D7 2F            [ 3] 1093         CPL                     ; Flip it
   E6D8 32 45 10      [13] 1094         LD      (CTLOFG),A      ; Put it back
   E6DB AF            [ 4] 1095         XOR     A               ; Null character
   E6DC C9            [ 9] 1096         RET
                           1097 
   E6DD CD A5 E9      [16] 1098 LIST:   CALL    ATOH            ; ASCII number to DE
   E6E0 C0            [10] 1099         RET     NZ              ; Return if anything extra
   E6E1 C1            [ 9] 1100         POP     BC              ; Rubbish - Not needed
   E6E2 CD 99 E4      [16] 1101         CALL    SRCHLN          ; Search for line number in DE
   E6E5 C5            [11] 1102         PUSH    BC              ; Save address of line
   E6E6 CD 33 E7      [16] 1103         CALL    SETLIN          ; Set up lines counter
   E6E9 E1            [ 9] 1104 LISTLP: POP     HL              ; Restore address of line
   E6EA 4E            [ 6] 1105         LD      C,(HL)          ; Get LSB of next line
   E6EB 23            [ 4] 1106         INC     HL
   E6EC 46            [ 6] 1107         LD      B,(HL)          ; Get MSB of next line
   E6ED 23            [ 4] 1108         INC     HL
   E6EE 78            [ 4] 1109         LD      A,B             ; BC = 0 (End of program)?
   E6EF B1            [ 4] 1110         OR      C
   E6F0 CA F8 E3      [ 9] 1111         JP      Z,PRNTOK        ; Yes - Go to command mode
   E6F3 CD 46 E7      [16] 1112         CALL    COUNT           ; Count lines
   E6F6 CD 61 E8      [16] 1113         CALL    TSTBRK          ; Test for break key
   E6F9 C5            [11] 1114         PUSH    BC              ; Save address of next line
   E6FA CD 81 EB      [16] 1115         CALL    PRNTCR          ; Output CRLF
   E6FD 5E            [ 6] 1116         LD      E,(HL)          ; Get LSB of line number
   E6FE 23            [ 4] 1117         INC     HL
   E6FF 56            [ 6] 1118         LD      D,(HL)          ; Get MSB of line number
   E700 23            [ 4] 1119         INC     HL
   E701 E5            [11] 1120         PUSH    HL              ; Save address of line start
   E702 EB            [ 3] 1121         EX      DE,HL           ; Line number to HL
   E703 CD AD F9      [16] 1122         CALL    PRNTHL          ; Output line number in decimal
   E706 3E 20         [ 6] 1123         LD      A,#" "           ; Space after line number
   E708 E1            [ 9] 1124         POP     HL              ; Restore start of line address
   E709 CD 9B E6      [16] 1125 LSTLP2: CALL    OUTC            ; Output character in A
   E70C 7E            [ 6] 1126 LSTLP3: LD      A,(HL)          ; Get next byte in line
   E70D B7            [ 4] 1127         OR      A               ; End of line?
   E70E 23            [ 4] 1128         INC     HL              ; To next byte in line
   E70F CA E9 E6      [ 9] 1129         JP      Z,LISTLP        ; Yes - get next line
   E712 F2 09 E7      [ 9] 1130         JP      P,LSTLP2        ; No token - output it
   E715 D6 7F         [ 6] 1131         SUB     #ZEND-1          ; Find and output word
   E717 4F            [ 4] 1132         LD      C,A             ; Token offset+1 to C
   E718 11 43 E1      [ 9] 1133         LD      DE,#WORDS        ; Reserved word list
   E71B 1A            [ 6] 1134 FNDTOK: LD      A,(DE)          ; Get character in list
   E71C 13            [ 4] 1135         INC     DE              ; Move on to next
   E71D B7            [ 4] 1136         OR      A               ; Is it start of word?
   E71E F2 1B E7      [ 9] 1137         JP      P,FNDTOK        ; No - Keep looking for word
   E721 0D            [ 4] 1138         DEC     C               ; Count words
   E722 C2 1B E7      [ 9] 1139         JP      NZ,FNDTOK       ; Not there - keep looking
   E725 E6 7F         [ 6] 1140 OUTWRD: AND     #0b01111111       ; Strip bit 7
   E727 CD 9B E6      [16] 1141         CALL    OUTC            ; Output first character
   E72A 1A            [ 6] 1142         LD      A,(DE)          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 22.
Hexadecimal [16-Bits]



   E72B 13            [ 4] 1143         INC     DE              ; Move on to next
   E72C B7            [ 4] 1144         OR      A               ; Is it end of word?
   E72D F2 25 E7      [ 9] 1145         JP      P,OUTWRD        ; No - output the rest
   E730 C3 0C E7      [ 9] 1146         JP      LSTLP3          ; Next byte in line
                           1147 
   E733 E5            [11] 1148 SETLIN: PUSH    HL              ; Set up LINES counter
   E734 2A 48 10      [15] 1149         LD      HL,(LINESN)     ; Get LINES number
   E737 22 46 10      [16] 1150         LD      (LINESC),HL     ; Save in LINES counter
   E73A E1            [ 9] 1151         POP     HL
   E73B C9            [ 9] 1152         RET
                           1153 
   E73C 21 DE FE      [ 9] 1154 LDNMI1: LD      HL,#BREAK        ; Break routine
   E73F 22 7E 0C      [16] 1155         LD      (NMI),HL        ; NMI forces break
   E742 C3 F8 E3      [ 9] 1156         JP      PRNTOK          ; Go to command mode
                           1157 
   E745 FE                 1158         .db      0x0FE            ; <<< NO REFERENCE TO HERE >>>
                           1159 
   E746 E5            [11] 1160 COUNT:  PUSH    HL              ; Save code string address
   E747 D5            [11] 1161         PUSH    DE
   E748 2A 46 10      [15] 1162         LD      HL,(LINESC)     ; Get LINES counter
   E74B 11 FF FF      [ 9] 1163         LD      DE,#-1
   E74E ED 5A         [10] 1164         ADC     HL,DE           ; Decrement
   E750 22 46 10      [16] 1165         LD      (LINESC),HL     ; Put it back
   E753 D1            [ 9] 1166         POP     DE
   E754 E1            [ 9] 1167         POP     HL              ; Restore code string address
   E755 F0            [10] 1168         RET     P               ; Return if more lines to go
   E756 E5            [11] 1169         PUSH    HL              ; Save code string address
   E757 2A 48 10      [15] 1170         LD      HL,(LINESN)     ; Get LINES number
   E75A 22 46 10      [16] 1171         LD      (LINESC),HL     ; Reset LINES counter
   E75D 3A 4C 10      [12] 1172         LD      A,(NMIFLG)      ; Break by NMI?
   E760 B7            [ 4] 1173         OR      A
   E761 C2 E5 FE      [ 9] 1174         JP      NZ,ARETN        ; Yes - "RETN"
   E764 CD 05 FD      [16] 1175         CALL    GETINP          ; Get input character
   E767 FE 03         [ 6] 1176         CP      #CTRLC           ; Is it control "C"?
   E769 CA 70 E7      [ 9] 1177         JP      Z,RSLNBK        ; Yes - Reset LINES an break
   E76C E1            [ 9] 1178         POP     HL              ; Restore code string address
   E76D C3 46 E7      [ 9] 1179         JP      COUNT           ; Keep on counting
                           1180 
   E770 2A 48 10      [15] 1181 RSLNBK: LD      HL,(LINESN)     ; Get LINES number
   E773 22 46 10      [16] 1182         LD      (LINESC),HL     ; Reset LINES counter
   E776 C3 B1 E0      [ 9] 1183         JP      BRKRET          ; Go and output "Break"
                           1184 
   E779 3E 64         [ 6] 1185 FOR:    LD      A,#0x64           ; Flag "FOR" assignment
   E77B 32 CB 10      [13] 1186         LD      (FORFLG),A      ; Save "FOR" flag
   E77E CD 87 EA      [16] 1187         CALL    LET             ; Set up initial index
   E781 C1            [ 9] 1188         POP     BC              ; Drop RETurn address
   E782 E5            [11] 1189         PUSH    HL              ; Save code string address
   E783 CD 70 EA      [16] 1190         CALL    DATA            ; Get next statement address
   E786 22 C7 10      [16] 1191         LD      (LOOPST),HL     ; Save it for start of lo6p
   E789 21 02 00      [ 9] 1192         LD      HL,#2            ; Offset for "FOR" block
   E78C 39            [ 7] 1193         ADD     HL,SP           ; Point to it
   E78D CD 5A E3      [16] 1194 FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
   E790 D1            [ 9] 1195         POP     DE              ; Get code string address
   E791 C2 A9 E7      [ 9] 1196         JP      NZ,FORFND       ; No nesting found
   E794 09            [ 7] 1197         ADD     HL,BC           ; Move into "FOR" block
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 23.
Hexadecimal [16-Bits]



   E795 D5            [11] 1198         PUSH    DE              ; Save code string address
   E796 2B            [ 4] 1199         DEC     HL
   E797 56            [ 6] 1200         LD      D,(HL)          ; Get MSB of loop statement
   E798 2B            [ 4] 1201         DEC     HL
   E799 5E            [ 6] 1202         LD      E,(HL)          ; Get LSB of loop statement
   E79A 23            [ 4] 1203         INC     HL
   E79B 23            [ 4] 1204         INC     HL
   E79C E5            [11] 1205         PUSH    HL              ; Save block address
   E79D 2A C7 10      [15] 1206         LD      HL,(LOOPST)     ; Get address of loop statement
   E7A0 CD 8A E6      [16] 1207         CALL    CPDEHL          ; Compare the FOR loops
   E7A3 E1            [ 9] 1208         POP     HL              ; Restore block address
   E7A4 C2 8D E7      [ 9] 1209         JP      NZ,FORSLP       ; Different FORs - Find another
   E7A7 D1            [ 9] 1210         POP     DE              ; Restore code string address
   E7A8 F9            [ 4] 1211         LD      SP,HL           ; Remove all nested loops
                           1212 
   E7A9 EB            [ 3] 1213 FORFND: EX      DE,HL           ; Code string address to HL
   E7AA 0E 08         [ 6] 1214         LD      C,#8
   E7AC CD 8A E3      [16] 1215         CALL    CHKSTK          ; Check for 8 levels of stack
   E7AF E5            [11] 1216         PUSH    HL              ; Save code string address
   E7B0 2A C7 10      [15] 1217         LD      HL,(LOOPST)     ; Get first statement of loop
   E7B3 E3            [16] 1218         EX      (SP),HL         ; Save and restore code string
   E7B4 E5            [11] 1219         PUSH    HL              ; Re-save code string address
   E7B5 2A 5C 10      [15] 1220         LD      HL,(LINEAT)     ; Get current line number
   E7B8 E3            [16] 1221         EX      (SP),HL         ; Save and restore code string
   E7B9 CD 44 ED      [16] 1222         CALL    TSTNUM          ; Make sure it's a number
   E7BC CD 90 E6      [16] 1223         CALL    CHKSYN          ; Make sure "TO" is next
   E7BF A6                 1224         .db      ZTO             ; "TO" token
   E7C0 CD 41 ED      [16] 1225         CALL    GETNUM          ; Get "TO" expression value
   E7C3 E5            [11] 1226         PUSH    HL              ; Save code string address
   E7C4 CD 5F F8      [16] 1227         CALL    BCDEFP          ; Move "TO" value to BCDE
   E7C7 E1            [ 9] 1228         POP     HL              ; Restore code string address
   E7C8 C5            [11] 1229         PUSH    BC              ; Save "TO" value in block
   E7C9 D5            [11] 1230         PUSH    DE
   E7CA 01 00 81      [ 9] 1231         LD      BC,#0x8100        ; BCDE - 1 (default STEP)
   E7CD 51            [ 4] 1232         LD      D,C             ; C=0
   E7CE 5A            [ 4] 1233         LD      E,D             ; D=0
   E7CF 7E            [ 6] 1234         LD      A,(HL)          ; Get next byte in code string
   E7D0 FE AB         [ 6] 1235         CP      #ZSTEP           ; See if "STEP" is stated
   E7D2 3E 01         [ 6] 1236         LD      A,#1             ; Sign of step = 1
   E7D4 C2 E5 E7      [ 9] 1237         JP      NZ,SAVSTP       ; No STEP given - Default to 1
   E7D7 CD 36 E8      [16] 1238         CALL    GETCHR          ; Jump over "STEP" token
   E7DA CD 41 ED      [16] 1239         CALL    GETNUM          ; Get step value
   E7DD E5            [11] 1240         PUSH    HL              ; Save code string address
   E7DE CD 5F F8      [16] 1241         CALL    BCDEFP          ; Move STEP to BCDE
   E7E1 CD 13 F8      [16] 1242         CALL    TSTSGN          ; Test sign of FPREG
   E7E4 E1            [ 9] 1243         POP     HL              ; Restore code string address
   E7E5 C5            [11] 1244 SAVSTP: PUSH    BC              ; Save the STEP value in block
   E7E6 D5            [11] 1245         PUSH    DE
   E7E7 F5            [11] 1246         PUSH    AF              ; Save sign of STEP
   E7E8 33            [ 4] 1247         INC     SP              ; Don't save flags
   E7E9 E5            [11] 1248         PUSH    HL              ; Save code string address
   E7EA 2A CE 10      [15] 1249         LD      HL,(BRKLIN)     ; Get address of index variable
   E7ED E3            [16] 1250         EX      (SP),HL         ; Save and restore code string
   E7EE 06 81         [ 6] 1251 PUTFID: LD      B,#ZFOR          ; "FOR" block marker
   E7F0 C5            [11] 1252         PUSH    BC              ; Save it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 24.
Hexadecimal [16-Bits]



   E7F1 33            [ 4] 1253         INC     SP              ; Don't save C
                           1254 
   E7F2 CD 40 FD      [16] 1255 RUNCNT: CALL    CHKBRK          ; Execution driver - Test break
   E7F5 B7            [ 4] 1256         OR      A               ; Break key hit?
   E7F6 C4 66 E8      [16] 1257         CALL    NZ,STALL        ; Yes - Pause for a key
   E7F9 22 CE 10      [16] 1258         LD      (BRKLIN),HL     ; Save code address for break
   E7FC 7E            [ 6] 1259         LD      A,(HL)          ; Get next byte in code string
   E7FD FE 3A         [ 6] 1260         CP      #":"             ; Multi statement line?
   E7FF CA 16 E8      [ 9] 1261         JP      Z,EXCUTE        ; Yes - Execute it
   E802 B7            [ 4] 1262         OR      A               ; End of line?
   E803 C2 AD E3      [ 9] 1263         JP      NZ,SNERR        ; No - Syntax error
   E806 23            [ 4] 1264         INC     HL              ; Point to address of next line
   E807 7E            [ 6] 1265         LD      A,(HL)          ; Get LSB of line pointer
   E808 23            [ 4] 1266         INC     HL
   E809 B6            [ 6] 1267         OR      (HL)            ; Is it zero (End of prog)?
   E80A CA 7A E8      [ 9] 1268         JP      Z,ENDPRG        ; Yes - Terminate execution
   E80D 23            [ 4] 1269         INC     HL              ; Point to line number
   E80E 5E            [ 6] 1270         LD      E,(HL)          ; Get LSB of line number
   E80F 23            [ 4] 1271         INC     HL
   E810 56            [ 6] 1272         LD      D,(HL)          ; Get MSB of line number
   E811 EB            [ 3] 1273         EX      DE,HL           ; Line number to HL
   E812 22 5C 10      [16] 1274         LD      (LINEAT),HL     ; Save as current line number
   E815 EB            [ 3] 1275         EX      DE,HL           ; Line number back to DE
   E816 CD 36 E8      [16] 1276 EXCUTE: CALL    GETCHR          ; Get key word
   E819 11 F2 E7      [ 9] 1277         LD      DE,#RUNCNT       ; Where to RETurn to
   E81C D5            [11] 1278         PUSH    DE              ; Save for RETurn
   E81D C8            [10] 1279 IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
   E81E D6 80         [ 6] 1280 ONJMP:  SUB     #ZEND            ; Is it a token?
   E820 DA 87 EA      [ 9] 1281         JP      C,LET           ; No - try to assign it
   E823 FE 25         [ 6] 1282         CP      #ZNEW+1-ZEND     ; END to NEW ?
   E825 D2 AD E3      [ 9] 1283         JP      NC,SNERR        ; Not a key word - ?SN Error
   E828 07            [ 3] 1284         RLCA                    ; Double it
   E829 4F            [ 4] 1285         LD      C,A             ; BC = Offset into table
   E82A 06 00         [ 6] 1286         LD      B,#0
   E82C EB            [ 3] 1287         EX      DE,HL           ; Save code string address
   E82D 21 5A E2      [ 9] 1288         LD      HL,#WORDTB       ; Keyword address table
   E830 09            [ 7] 1289         ADD     HL,BC           ; Point to routine address
   E831 4E            [ 6] 1290         LD      C,(HL)          ; Get LSB of routine address
   E832 23            [ 4] 1291         INC     HL
   E833 46            [ 6] 1292         LD      B,(HL)          ; Get MSB of routine address
   E834 C5            [11] 1293         PUSH    BC              ; Save routine address
   E835 EB            [ 3] 1294         EX      DE,HL           ; Restore code string address
                           1295 
   E836 23            [ 4] 1296 GETCHR: INC     HL              ; Point to next character
   E837 7E            [ 6] 1297         LD      A,(HL)          ; Get next code string byte
   E838 FE 3A         [ 6] 1298         CP      #":"             ; Z if ":"
   E83A D0            [10] 1299         RET     NC              ; NC if > "9"
   E83B FE 20         [ 6] 1300         CP      #" "
   E83D CA 36 E8      [ 9] 1301         JP      Z,GETCHR        ; Skip over spaces
   E840 FE 30         [ 6] 1302         CP      #"0"
   E842 3F            [ 3] 1303         CCF                     ; NC if < "0"
   E843 3C            [ 4] 1304         INC     A               ; Test for zero - Leave carry
   E844 3D            [ 4] 1305         DEC     A               ; Z if Null
   E845 C9            [ 9] 1306         RET
                           1307 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 25.
Hexadecimal [16-Bits]



   E846 EB            [ 3] 1308 RESTOR: EX      DE,HL           ; Save code string address
   E847 2A 5E 10      [15] 1309         LD      HL,(BASTXT)     ; Point to start of program
   E84A CA 5B E8      [ 9] 1310         JP      Z,RESTNL        ; Just RESTORE - reset pointer
   E84D EB            [ 3] 1311         EX      DE,HL           ; Restore code string address
   E84E CD A5 E9      [16] 1312         CALL    ATOH            ; Get line number to DE
   E851 E5            [11] 1313         PUSH    HL              ; Save code string address
   E852 CD 99 E4      [16] 1314         CALL    SRCHLN          ; Search for line number in DE
   E855 60            [ 4] 1315         LD      H,B             ; HL = Address of line
   E856 69            [ 4] 1316         LD      L,C
   E857 D1            [ 9] 1317         POP     DE              ; Restore code string address
   E858 D2 46 EA      [ 9] 1318         JP      NC,ULERR        ; ?UL Error if not found
   E85B 2B            [ 4] 1319 RESTNL: DEC     HL              ; Byte before DATA statement
   E85C 22 DC 10      [16] 1320 UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
   E85F EB            [ 3] 1321         EX      DE,HL           ; Restore code string address
   E860 C9            [ 9] 1322         RET
                           1323 
   E861 CD 40 FD      [16] 1324 TSTBRK: CALL    CHKBRK          ; Test for interrupts
   E864 B7            [ 4] 1325         OR      A
   E865 C8            [10] 1326         RET     Z               ; Return if no key pressed
   E866 CD CC E6      [16] 1327 STALL:  CALL    CLOTST          ; Get input and test for ^O
   E869 FE 13         [ 6] 1328         CP      #CTRLS           ; Is it control "S"
   E86B CC CC E6      [16] 1329         CALL    Z,CLOTST        ; Yes - Get another character
   E86E FE 03         [ 6] 1330         CP      #CTRLC           ; Return if not control "C"
   E870 C0            [10] 1331 STOP:   RET     NZ              ; Exit if anything else
   E871 F6                 1332         .db      0x0F6            ; Flag "STOP"
   E872 C0            [10] 1333 PEND:   RET     NZ              ; Exit if anything else
   E873 22 CE 10      [16] 1334         LD      (BRKLIN),HL     ; Save point of break
   E876 21                 1335         .db      0x21             ; Skip "OR 11111111B"
   E877 F6 FF         [ 6] 1336 INPBRK: OR      #0b11111111       ; Flag "Break" wanted
   E879 C1            [ 9] 1337         POP     BC              ; Return not needed and more
   E87A 2A 5C 10      [15] 1338 ENDPRG: LD      HL,(LINEAT)     ; Get current line number
   E87D F5            [11] 1339         PUSH    AF              ; Save STOP / END status
   E87E 7D            [ 4] 1340         LD      A,L             ; Is it direct break?
   E87F A4            [ 4] 1341         AND     H
   E880 3C            [ 4] 1342         INC     A               ; Line is -1 if direct break
   E881 CA 8D E8      [ 9] 1343         JP      Z,NOLIN         ; Yes - No line number
   E884 22 D2 10      [16] 1344         LD      (ERRLIN),HL     ; Save line of break
   E887 2A CE 10      [15] 1345         LD      HL,(BRKLIN)     ; Get point of break
   E88A 22 D4 10      [16] 1346         LD      (CONTAD),HL     ; Save point to CONTinue
   E88D AF            [ 4] 1347 NOLIN:  XOR     A
   E88E 32 45 10      [13] 1348         LD      (CTLOFG),A      ; Enable output
   E891 CD 74 EB      [16] 1349         CALL    STTLIN          ; Start a new line
   E894 F1            [ 9] 1350         POP     AF              ; Restore STOP / END status
   E895 21 50 E3      [ 9] 1351         LD      HL,#BRKMSG       ; "Break" message
   E898 C2 E1 E3      [ 9] 1352         JP      NZ,ERRIN        ; "in line" wanted?
   E89B C3 F8 E3      [ 9] 1353         JP      PRNTOK          ; Go to command mode
                           1354 
   E89E 2A D4 10      [15] 1355 CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
   E8A1 7C            [ 4] 1356         LD      A,H             ; Is it zero?
   E8A2 B5            [ 4] 1357         OR      L
   E8A3 1E 20         [ 6] 1358         LD      E,#CN            ; ?CN Error
   E8A5 CA C1 E3      [ 9] 1359         JP      Z,ERROR         ; Yes - output "?CN Error"
   E8A8 EB            [ 3] 1360         EX      DE,HL           ; Save code string address
   E8A9 2A D2 10      [15] 1361         LD      HL,(ERRLIN)     ; Get line of last break
   E8AC 22 5C 10      [16] 1362         LD      (LINEAT),HL     ; Set up current line number
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 26.
Hexadecimal [16-Bits]



   E8AF EB            [ 3] 1363         EX      DE,HL           ; Restore code string address
   E8B0 C9            [ 9] 1364         RET                     ; CONTinue where left off
                           1365 
   E8B1 CD 84 F4      [16] 1366 NULL:   CALL    GETINT          ; Get integer 0-255
   E8B4 C0            [10] 1367         RET     NZ              ; Return if bad value
   E8B5 32 41 10      [13] 1368         LD      (NULLS),A       ; Set nulls number
   E8B8 C9            [ 9] 1369         RET
                           1370 
   E8B9 06 FF         [ 6] 1371 ARRLD1: LD      B,#-1            ; Flag array load
   E8BB CD 36 E8      [16] 1372 ARRSV1: CALL    GETCHR          ; Skip "*"
   E8BE 78            [ 4] 1373         LD      A,B             ; CLOAD* or CSAVE*
   E8BF 32 CE 10      [13] 1374         LD      (BRKLIN),A      ; Save it
   E8C2 3E 01         [ 6] 1375         LD      A,#1             ; It's an array
   E8C4 32 CB 10      [13] 1376         LD      (FORFLG),A      ; Flag array name
   E8C7 CD 2D EF      [16] 1377         CALL    GETVAR          ; Get address of array name
   E8CA E5            [11] 1378         PUSH    HL              ; Save code string address
   E8CB 32 CB 10      [13] 1379         LD      (FORFLG),A      ; Clear flag
   E8CE 60            [ 4] 1380         LD      H,B             ; Address of array to HL
   E8CF 69            [ 4] 1381         LD      L,C
   E8D0 0B            [ 4] 1382         DEC     BC              ; Back space
   E8D1 0B            [ 4] 1383         DEC     BC              ;  to point
   E8D2 0B            [ 4] 1384         DEC     BC              ;  to the
   E8D3 0B            [ 4] 1385         DEC     BC              ; array name
   E8D4 3A CE 10      [12] 1386         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8D7 B7            [ 4] 1387         OR      A
   E8D8 F5            [11] 1388         PUSH    AF              ; Save CLOAD* / CSAVE* status
   E8D9 EB            [ 3] 1389         EX      DE,HL           ; Array data length
   E8DA 19            [ 7] 1390         ADD     HL,DE           ; End of data
   E8DB EB            [ 3] 1391         EX      DE,HL           ; To DE
   E8DC 4E            [ 6] 1392         LD      C,(HL)          ; Get dimension bytes
   E8DD 06 00         [ 6] 1393         LD      B,#0
   E8DF 09            [ 7] 1394         ADD     HL,BC           ; 2 Bytes each dimension
   E8E0 09            [ 7] 1395         ADD     HL,BC
   E8E1 23            [ 4] 1396         INC     HL              ; Over number of dimensions
   E8E2 E5            [11] 1397         PUSH    HL              ; Address of array data
   E8E3 D5            [11] 1398         PUSH    DE              ; End of array data
   E8E4 C5            [11] 1399         PUSH    BC              ; Number of dimensions
   E8E5 3A CE 10      [12] 1400         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8E8 FE FF         [ 6] 1401         CP      #-1
   E8EA CC D5 FC      [16] 1402         CALL    Z,CASFF         ; CLOAD* - Cassette on
   E8ED 3A CE 10      [12] 1403         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8F0 FE FF         [ 6] 1404         CP      #-1
   E8F2 C4 C8 FC      [16] 1405         CALL    NZ,CASFFW       ; CSAVE* - Cassette on and wait
   E8F5 00            [ 3] 1406         NOP
   E8F6 00            [ 3] 1407         NOP
   E8F7 00            [ 3] 1408         NOP
   E8F8 21 00 00      [ 9] 1409         LD      HL,#0
   E8FB 22 4A 10      [16] 1410         LD      (CHKSUM),HL     ; Zero check sum
   E8FE C1            [ 9] 1411         POP     BC              ; Number of dimensions
   E8FF D1            [ 9] 1412         POP     DE              ; End of array data
   E900 E1            [ 9] 1413         POP     HL              ; Address of array data
   E901 06 D2         [ 6] 1414         LD      B,#0b11010010     ; Header byte
   E903 C3 D6 FF      [ 9] 1415         JP      JPLDSV          ; CSAVE-SNDHDR , CLOAD-GETHDR
                           1416 
   E906 78            [ 4] 1417 SNDHDR: LD      A,B             ; Get header byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 27.
Hexadecimal [16-Bits]



   E907 CD B7 F4      [16] 1418         CALL    WUART2          ; Send 2 bytes to UART
   E90A CD B7 F4      [16] 1419         CALL    WUART2          ; Send 2 bytes to UART
   E90D C3 1D E9      [ 9] 1420         JP      SNDARY          ; Send array data
                           1421 
   E910 0E 04         [ 6] 1422 GETHDR: LD      C,#4             ; 4 Bytes to check
   E912 CD B4 F4      [16] 1423 HDRLP:  CALL    RUART           ; Read byte from UART
   E915 B8            [ 4] 1424         CP      B               ; Same as header?
   E916 C2 10 E9      [ 9] 1425         JP      NZ,GETHDR       ; No - Wait for another
   E919 0D            [ 4] 1426         DEC     C               ; Count bytes
   E91A C2 12 E9      [ 9] 1427         JP      NZ,HDRLP        ; More needed
   E91D CD 44 ED      [16] 1428 SNDARY: CALL    TSTNUM          ; Check it's a numerical array
   E920 CD 8A E6      [16] 1429 ARYLP:  CALL    CPDEHL          ; All array data done
   E923 CA 37 E9      [ 9] 1430         JP      Z,SUMOFF        ; Yes - Do check sum
   E926 F1            [ 9] 1431         POP     AF              ; CLOAD* or CSAVE* ?
   E927 F5            [11] 1432         PUSH    AF              ; Re-save flags
   E928 7E            [ 6] 1433         LD      A,(HL)          ; Get byte
   E929 F4 BA F4      [16] 1434         CALL    P,WUART         ; CSAVE* - Write byte
   E92C FC B4 F4      [16] 1435         CALL    M,RUART         ; CLOAD* - Read byte
   E92F 77            [ 7] 1436         LD      (HL),A          ; Save byte in case of CLOAD*
   E930 CD 40 E9      [16] 1437         CALL    ACCSUM          ; Accumulate check sum
   E933 23            [ 4] 1438         INC     HL              ; Next byte
   E934 C3 20 E9      [ 9] 1439         JP      ARYLP           ; Repeat
                           1440 
   E937 CD 4D E9      [16] 1441 SUMOFF: CALL    DOSUM           ; Do check sum
   E93A CD D5 FC      [16] 1442         CALL    CASFF           ; Cassette off
   E93D F1            [ 9] 1443         POP     AF              ; Not needed any more
   E93E E1            [ 9] 1444         POP     HL              ; Restore code string address
   E93F C9            [ 9] 1445         RET
                           1446 
   E940 E5            [11] 1447 ACCSUM: PUSH    HL              ; Save address in array
   E941 2A 4A 10      [15] 1448         LD      HL,(CHKSUM)     ; Get check sum
   E944 06 00         [ 6] 1449         LD      B,#0             ; BC - Value of byte
   E946 4F            [ 4] 1450         LD      C,A
   E947 09            [ 7] 1451         ADD     HL,BC           ; Add byte to check sum
   E948 22 4A 10      [16] 1452         LD      (CHKSUM),HL     ; Re-save check sum
   E94B E1            [ 9] 1453         POP     HL              ; Restore address in array
   E94C C9            [ 9] 1454         RET
                           1455 
   E94D 3A CE 10      [12] 1456 DOSUM:  LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E950 B7            [ 4] 1457         OR      A
   E951 FA 60 E9      [ 9] 1458         JP      M,CHSUMS        ; CLOAD* - Check if sums match
   E954 3A 4A 10      [12] 1459         LD      A,(CHKSUM)      ; Get LSB of check sum
   E957 CD BA F4      [16] 1460         CALL    WUART           ; Write to UART
   E95A 3A 4B 10      [12] 1461         LD      A,(CHKSUM+1)    ; Get MSB of check sum
   E95D C3 BA F4      [ 9] 1462         JP      WUART           ; Write to UART and return
                           1463 
   E960 CD B4 F4      [16] 1464 CHSUMS: CALL    RUART           ; Read LSB of check sum
   E963 F5            [11] 1465         PUSH    AF              ; Save it
   E964 CD B4 F4      [16] 1466         CALL    RUART           ; Read MSB of check sum
   E967 C1            [ 9] 1467         POP     BC              ; LSB to B
   E968 58            [ 4] 1468         LD      E,B             ; LSB to E
   E969 57            [ 4] 1469         LD      D,A             ; MSB to D
   E96A 2A 4A 10      [15] 1470         LD      HL,(CHKSUM)     ; Get accumulated check sum
   E96D CD 8A E6      [16] 1471         CALL    CPDEHL          ; Are they the same?
   E970 C8            [10] 1472         RET     Z               ; Yes - End CLOAD*
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 28.
Hexadecimal [16-Bits]



   E971 CD D5 FC      [16] 1473         CALL    CASFF           ; Cassette off
   E974 C3 6B F5      [ 9] 1474         JP      OUTBAD          ; Different - Output "Bad"
                           1475 
   E977 7E            [ 6] 1476 CHKLTR: LD      A,(HL)          ; Get byte
   E978 FE 41         [ 6] 1477         CP      #"A"             ; < "A" ?
   E97A D8            [10] 1478         RET     C               ; Carry set if not letter
   E97B FE 5B         [ 6] 1479         CP      #"Z"+1           ; > "Z" ?
   E97D 3F            [ 3] 1480         CCF
   E97E C9            [ 9] 1481         RET                     ; Carry set if not letter
                           1482 
   E97F CD 36 E8      [16] 1483 FPSINT: CALL    GETCHR          ; Get next character
   E982 CD 41 ED      [16] 1484 POSINT: CALL    GETNUM          ; Get integer 0 to 32767
   E985 CD 13 F8      [16] 1485 DEPINT: CALL    TSTSGN          ; Test sign of FPREG
   E988 FA A0 E9      [ 9] 1486         JP      M,FCERR         ; Negative - ?FC Error
   E98B 3A E7 10      [12] 1487 DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
   E98E FE 90         [ 6] 1488         CP      #0x80+16          ; Exponent in range (16 bits)?
   E990 DA BB F8      [ 9] 1489         JP      C,FPINT         ; Yes - convert it
   E993 01 80 90      [ 9] 1490         LD      BC,#0x9080        ; BCDE = -32768
   E996 11 00 00      [ 9] 1491         LD      DE,#0000
   E999 E5            [11] 1492         PUSH    HL              ; Save code string address
   E99A CD 8E F8      [16] 1493         CALL    CMPNUM          ; Compare FPREG with BCDE
   E99D E1            [ 9] 1494         POP     HL              ; Restore code string address
   E99E 51            [ 4] 1495         LD      D,C             ; MSB to D
   E99F C8            [10] 1496         RET     Z               ; Return if in range
   E9A0 1E 08         [ 6] 1497 FCERR:  LD      E,#FC            ; ?FC Error
   E9A2 C3 C1 E3      [ 9] 1498         JP      ERROR           ; Output error-
                           1499 
   E9A5 2B            [ 4] 1500 ATOH:   DEC     HL              ; ASCII number to DE binary
   E9A6 11 00 00      [ 9] 1501 GETLN:  LD      DE,#0            ; Get number to DE
   E9A9 CD 36 E8      [16] 1502 GTLNLP: CALL    GETCHR          ; Get next character
   E9AC D0            [10] 1503         RET     NC              ; Exit if not a digit
   E9AD E5            [11] 1504         PUSH    HL              ; Save code string address
   E9AE F5            [11] 1505         PUSH    AF              ; Save digit
   E9AF 21 98 19      [ 9] 1506         LD      HL,#65529/10     ; Largest number 65529
   E9B2 CD 8A E6      [16] 1507         CALL    CPDEHL          ; Number in range?
   E9B5 DA AD E3      [ 9] 1508         JP      C,SNERR         ; No - ?SN Error
   E9B8 62            [ 4] 1509         LD      H,D             ; HL = Number
   E9B9 6B            [ 4] 1510         LD      L,E
   E9BA 19            [ 7] 1511         ADD     HL,DE           ; Times 2
   E9BB 29            [ 7] 1512         ADD     HL,HL           ; Times 4
   E9BC 19            [ 7] 1513         ADD     HL,DE           ; Times 5
   E9BD 29            [ 7] 1514         ADD     HL,HL           ; Times 10
   E9BE F1            [ 9] 1515         POP     AF              ; Restore digit
   E9BF D6 30         [ 6] 1516         SUB     #"0"             ; Make it 0 to 9
   E9C1 5F            [ 4] 1517         LD      E,A             ; DE = Value of digit
   E9C2 16 00         [ 6] 1518         LD      D,#0
   E9C4 19            [ 7] 1519         ADD     HL,DE           ; Add to number
   E9C5 EB            [ 3] 1520         EX      DE,HL           ; Number to DE
   E9C6 E1            [ 9] 1521         POP     HL              ; Restore code string address
   E9C7 C3 A9 E9      [ 9] 1522         JP      GTLNLP          ; Go to next character
                           1523 
   E9CA CA C9 E4      [ 9] 1524 CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
   E9CD CD 82 E9      [16] 1525         CALL    POSINT          ; Get integer 0 to 32767 to DE
   E9D0 2B            [ 4] 1526         DEC     HL              ; Cancel increment
   E9D1 CD 36 E8      [16] 1527         CALL    GETCHR          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 29.
Hexadecimal [16-Bits]



   E9D4 E5            [11] 1528         PUSH    HL              ; Save code string address
   E9D5 2A AF 10      [15] 1529         LD      HL,(LSTRAM)     ; Get end of RAM
   E9D8 CA ED E9      [ 9] 1530         JP      Z,STORED        ; No value given - Use stored
   E9DB E1            [ 9] 1531         POP     HL              ; Restore code string address
   E9DC CD 90 E6      [16] 1532         CALL    CHKSYN          ; Check for comma
   E9DF 2C                 1533         .db      ","
   E9E0 D5            [11] 1534         PUSH    DE              ; Save number
   E9E1 CD 82 E9      [16] 1535         CALL    POSINT          ; Get integer 0 to 32767
   E9E4 2B            [ 4] 1536         DEC     HL              ; Cancel increment
   E9E5 CD 36 E8      [16] 1537         CALL    GETCHR          ; Get next character
   E9E8 C2 AD E3      [ 9] 1538         JP      NZ,SNERR        ; ?SN Error if more on line
   E9EB E3            [16] 1539         EX      (SP),HL         ; Save code string address
   E9EC EB            [ 3] 1540         EX      DE,HL           ; Number to DE
   E9ED 7D            [ 4] 1541 STORED: LD      A,L             ; Get LSB of new RAM top
   E9EE 93            [ 4] 1542         SUB     E               ; Subtract LSB of string space
   E9EF 5F            [ 4] 1543         LD      E,A             ; Save LSB
   E9F0 7C            [ 4] 1544         LD      A,H             ; Get MSB of new RAM top
   E9F1 9A            [ 4] 1545         SBC     A,D             ; Subtract MSB of string space
   E9F2 57            [ 4] 1546         LD      D,A             ; Save MSB
   E9F3 DA A2 E3      [ 9] 1547         JP      C,OMERR         ; ?OM Error if not enough mem
   E9F6 E5            [11] 1548         PUSH    HL              ; Save RAM top
   E9F7 2A D6 10      [15] 1549         LD      HL,(PROGND)     ; Get program end
   E9FA 01 28 00      [ 9] 1550         LD      BC,#40           ; 40 Bytes minimum working RAM
   E9FD 09            [ 7] 1551         ADD     HL,BC           ; Get lowest address
   E9FE CD 8A E6      [16] 1552         CALL    CPDEHL          ; Enough memory?
   EA01 D2 A2 E3      [ 9] 1553         JP      NC,OMERR        ; No - ?OM Error
   EA04 EB            [ 3] 1554         EX      DE,HL           ; RAM top to HL
   EA05 22 5A 10      [16] 1555         LD      (STRSPC),HL     ; Set new string space
   EA08 E1            [ 9] 1556         POP     HL              ; End of memory to use
   EA09 22 AF 10      [16] 1557         LD      (LSTRAM),HL     ; Set new top of RAM
   EA0C E1            [ 9] 1558         POP     HL              ; Restore code string address
   EA0D C3 C9 E4      [ 9] 1559         JP      INTVAR          ; Initialise variables
                           1560 
   EA10 CA C5 E4      [ 9] 1561 RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
   EA13 CD C9 E4      [16] 1562         CALL    INTVAR          ; Initialise variables
   EA16 01 F2 E7      [ 9] 1563         LD      BC,#RUNCNT       ; Execution driver loop
   EA19 C3 2C EA      [ 9] 1564         JP      RUNLIN          ; RUN from line number
                           1565 
   EA1C 0E 03         [ 6] 1566 GOSUB:  LD      C,#3             ; 3 Levels of stack needed
   EA1E CD 8A E3      [16] 1567         CALL    CHKSTK          ; Check for 3 levels of stack
   EA21 C1            [ 9] 1568         POP     BC              ; Get return address
   EA22 E5            [11] 1569         PUSH    HL              ; Save code string for RETURN
   EA23 E5            [11] 1570         PUSH    HL              ; And for GOSUB routine
   EA24 2A 5C 10      [15] 1571         LD      HL,(LINEAT)     ; Get current line
   EA27 E3            [16] 1572         EX      (SP),HL         ; Into stack - Code string out
   EA28 3E 8C         [ 6] 1573         LD      A,#ZGOSUB        ; "GOSUB" token
   EA2A F5            [11] 1574         PUSH    AF              ; Save token
   EA2B 33            [ 4] 1575         INC     SP              ; Don't save flags
                           1576 
   EA2C C5            [11] 1577 RUNLIN: PUSH    BC              ; Save return address
   EA2D CD A5 E9      [16] 1578 GOTO:   CALL    ATOH            ; ASCII number to DE binary
   EA30 CD 72 EA      [16] 1579         CALL    REM             ; Get end of line
   EA33 E5            [11] 1580         PUSH    HL              ; Save end of line
   EA34 2A 5C 10      [15] 1581         LD      HL,(LINEAT)     ; Get current line
   EA37 CD 8A E6      [16] 1582         CALL    CPDEHL          ; Line after current?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 30.
Hexadecimal [16-Bits]



   EA3A E1            [ 9] 1583         POP     HL              ; Restore end of line
   EA3B 23            [ 4] 1584         INC     HL              ; Start of next line
   EA3C DC 9C E4      [16] 1585         CALL    C,SRCHLP        ; Line is after current line
   EA3F D4 99 E4      [16] 1586         CALL    NC,SRCHLN       ; Line is before current line
   EA42 60            [ 4] 1587         LD      H,B             ; Set up code string address
   EA43 69            [ 4] 1588         LD      L,C
   EA44 2B            [ 4] 1589         DEC     HL              ; Incremented after
   EA45 D8            [10] 1590         RET     C               ; Line found
   EA46 1E 0E         [ 6] 1591 ULERR:  LD      E,#UL            ; ?UL Error
   EA48 C3 C1 E3      [ 9] 1592         JP      ERROR           ; Output error message
                           1593 
   EA4B C0            [10] 1594 RETURN: RET     NZ              ; Return if not just RETURN
   EA4C 16 FF         [ 6] 1595         LD      D,#-1            ; Flag "GOSUB" search
   EA4E CD 56 E3      [16] 1596         CALL    BAKSTK          ; Look "GOSUB" block
   EA51 F9            [ 4] 1597         LD      SP,HL           ; Kill all FORs in subroutine
   EA52 FE 8C         [ 6] 1598         CP      #ZGOSUB          ; Test for "GOSUB" token
   EA54 1E 04         [ 6] 1599         LD      E,#RG            ; ?RG Error
   EA56 C2 C1 E3      [ 9] 1600         JP      NZ,ERROR        ; Error if no "GOSUB" found
   EA59 E1            [ 9] 1601         POP     HL              ; Get RETURN line number
   EA5A 22 5C 10      [16] 1602         LD      (LINEAT),HL     ; Save as current
   EA5D 23            [ 4] 1603         INC     HL              ; Was it from direct statement?
   EA5E 7C            [ 4] 1604         LD      A,H
   EA5F B5            [ 4] 1605         OR      L               ; Return to line
   EA60 C2 6A EA      [ 9] 1606         JP      NZ,RETLIN       ; No - Return to line
   EA63 3A CC 10      [12] 1607         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
   EA66 B7            [ 4] 1608         OR      A               ; If so buffer is corrupted
   EA67 C2 F7 E3      [ 9] 1609         JP      NZ,POPNOK       ; Yes - Go to command mode
   EA6A 21 F2 E7      [ 9] 1610 RETLIN: LD      HL,#RUNCNT       ; Execution driver loop
   EA6D E3            [16] 1611         EX      (SP),HL         ; Into stack - Code string out
   EA6E 3E                 1612         .db      0x3E             ; Skip "POP HL"
   EA6F E1            [ 9] 1613 NXTDTA: POP     HL              ; Restore code string address
                           1614 
   EA70 01 3A              1615 DATA:   .db      0x01,0x3A         ; ":" End of statement
   EA72 0E 00         [ 6] 1616 REM:    LD      C,#0             ; 00  End of statement
   EA74 06 00         [ 6] 1617         LD      B,#0
   EA76 79            [ 4] 1618 NXTSTL: LD      A,C             ; Statement and byte
   EA77 48            [ 4] 1619         LD      C,B
   EA78 47            [ 4] 1620         LD      B,A             ; Statement end byte
   EA79 7E            [ 6] 1621 NXTSTT: LD      A,(HL)          ; Get byte
   EA7A B7            [ 4] 1622         OR      A               ; End of line?
   EA7B C8            [10] 1623         RET     Z               ; Yes - Exit
   EA7C B8            [ 4] 1624         CP      B               ; End of statement?
   EA7D C8            [10] 1625         RET     Z               ; Yes - Exit
   EA7E 23            [ 4] 1626         INC     HL              ; Next byte
   EA7F FE 22         [ 6] 1627         CP      #'"'             ; Literal string?"
   EA81 CA 76 EA      [ 9] 1628         JP      Z,NXTSTL        ; Yes - Look for another '"'
   EA84 C3 79 EA      [ 9] 1629         JP      NXTSTT          ; Keep looking
                           1630 
   EA87 CD 2D EF      [16] 1631 LET:    CALL    GETVAR          ; Get variable name
   EA8A CD 90 E6      [16] 1632         CALL    CHKSYN          ; Make sure "=" follows
   EA8D B4                 1633         .db      ZEQUAL          ; "=" token
   EA8E D5            [11] 1634         PUSH    DE              ; Save address of variable
   EA8F 3A AD 10      [12] 1635         LD      A,(TYPE)        ; Get data type
   EA92 F5            [11] 1636         PUSH    AF              ; Save type
   EA93 CD 5A ED      [16] 1637         CALL    EVAL            ; Evaluate expression
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 31.
Hexadecimal [16-Bits]



   EA96 F1            [ 9] 1638         POP     AF              ; Restore type
   EA97 E3            [16] 1639         EX      (SP),HL         ; Save code - Get var addr
   EA98 22 CE 10      [16] 1640         LD      (BRKLIN),HL     ; Save address of variable
   EA9B 1F            [ 3] 1641         RRA                     ; Adjust type
   EA9C CD 46 ED      [16] 1642         CALL    CHKTYP          ; Check types are the same
   EA9F CA DA EA      [ 9] 1643         JP      Z,LETNUM        ; Numeric - Move value
   EAA2 E5            [11] 1644 LETSTR: PUSH    HL              ; Save address of string var
   EAA3 2A E4 10      [15] 1645         LD      HL,(FPREG)      ; Pointer to string entry
   EAA6 E5            [11] 1646         PUSH    HL              ; Save it on stack
   EAA7 23            [ 4] 1647         INC     HL              ; Skip over length
   EAA8 23            [ 4] 1648         INC     HL
   EAA9 5E            [ 6] 1649         LD      E,(HL)          ; LSB of string address
   EAAA 23            [ 4] 1650         INC     HL
   EAAB 56            [ 6] 1651         LD      D,(HL)          ; MSB of string address
   EAAC 2A 5E 10      [15] 1652         LD      HL,(BASTXT)     ; Point to start of program
   EAAF CD 8A E6      [16] 1653         CALL    CPDEHL          ; Is string before program?
   EAB2 D2 C9 EA      [ 9] 1654         JP      NC,CRESTR       ; Yes - Create string entry
   EAB5 2A 5A 10      [15] 1655         LD      HL,(STRSPC)     ; Point to string space
   EAB8 CD 8A E6      [16] 1656         CALL    CPDEHL          ; Is string literal in program?
   EABB D1            [ 9] 1657         POP     DE              ; Restore address of string
   EABC D2 D1 EA      [ 9] 1658         JP      NC,MVSTPT       ; Yes - Set up pointer
   EABF 21 BF 10      [ 9] 1659         LD      HL,#TMPSTR       ; Temporary string pool
   EAC2 CD 8A E6      [16] 1660         CALL    CPDEHL          ; Is string in temporary pool?
   EAC5 D2 D1 EA      [ 9] 1661         JP      NC,MVSTPT       ; No - Set up pointer
   EAC8 3E                 1662         .db      0x3E             ; Skip "POP DE"
   EAC9 D1            [ 9] 1663 CRESTR: POP     DE              ; Restore address of string
   EACA CD 71 F3      [16] 1664         CALL    BAKTMP          ; Back to last tmp-str entry
   EACD EB            [ 3] 1665         EX      DE,HL           ; Address of string entry
   EACE CD AA F1      [16] 1666         CALL    SAVSTR          ; Save string in string area
   EAD1 CD 71 F3      [16] 1667 MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
   EAD4 E1            [ 9] 1668         POP     HL              ; Get string pointer
   EAD5 CD 6E F8      [16] 1669         CALL    DETHL4          ; Move string pointer to var
   EAD8 E1            [ 9] 1670         POP     HL              ; Restore code string address
   EAD9 C9            [ 9] 1671         RET
                           1672 
   EADA E5            [11] 1673 LETNUM: PUSH    HL              ; Save address of variable
   EADB CD 6B F8      [16] 1674         CALL    FPTHL           ; Move value to variable
   EADE D1            [ 9] 1675         POP     DE              ; Restore address of variable
   EADF E1            [ 9] 1676         POP     HL              ; Restore code string address
   EAE0 C9            [ 9] 1677         RET
                           1678 
   EAE1 CD 84 F4      [16] 1679 ON:     CALL    GETINT          ; Get integer 0-255
   EAE4 7E            [ 6] 1680         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
   EAE5 47            [ 4] 1681         LD      B,A             ; Save in B
   EAE6 FE 8C         [ 6] 1682         CP      #ZGOSUB          ; "GOSUB" token?
   EAE8 CA F0 EA      [ 9] 1683         JP      Z,ONGO          ; Yes - Find line number
   EAEB CD 90 E6      [16] 1684         CALL    CHKSYN          ; Make sure it's "GOTO"
   EAEE 88                 1685         .db      ZGOTO           ; "GOTO" token
   EAEF 2B            [ 4] 1686         DEC     HL              ; Cancel increment
   EAF0 4B            [ 4] 1687 ONGO:   LD      C,E             ; Integer of branch value
   EAF1 0D            [ 4] 1688 ONGOLP: DEC     C               ; Count branches
   EAF2 78            [ 4] 1689         LD      A,B             ; Get "GOTO" or "GOSUB" token
   EAF3 CA 1E E8      [ 9] 1690         JP      Z,ONJMP         ; Go to that line if right one
   EAF6 CD A6 E9      [16] 1691         CALL    GETLN           ; Get line number to DE
   EAF9 FE 2C         [ 6] 1692         CP      #","             ; Another line number?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 32.
Hexadecimal [16-Bits]



   EAFB C0            [10] 1693         RET     NZ              ; No - Drop through
   EAFC C3 F1 EA      [ 9] 1694         JP      ONGOLP          ; Yes - loop
                           1695 
   EAFF CD 5A ED      [16] 1696 IF:     CALL    EVAL            ; Evaluate expression
   EB02 7E            [ 6] 1697         LD      A,(HL)          ; Get token
   EB03 FE 88         [ 6] 1698         CP      #ZGOTO           ; "GOTO" token?
   EB05 CA 0D EB      [ 9] 1699         JP      Z,IFGO          ; Yes - Get line
   EB08 CD 90 E6      [16] 1700         CALL    CHKSYN          ; Make sure it's "THEN"
   EB0B A9                 1701         .db      ZTHEN           ; "THEN" token
   EB0C 2B            [ 4] 1702         DEC     HL              ; Cancel increment
   EB0D CD 44 ED      [16] 1703 IFGO:   CALL    TSTNUM          ; Make sure it's numeric
   EB10 CD 13 F8      [16] 1704         CALL    TSTSGN          ; Test state of expression
   EB13 CA 72 EA      [ 9] 1705         JP      Z,REM           ; False - Drop through
   EB16 CD 36 E8      [16] 1706         CALL    GETCHR          ; Get next character
   EB19 DA 2D EA      [ 9] 1707         JP      C,GOTO          ; Number - GOTO that line
   EB1C C3 1D E8      [ 9] 1708         JP      IFJMP           ; Otherwise do statement
                           1709 
   EB1F 2B            [ 4] 1710 MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
   EB20 CD 36 E8      [16] 1711         CALL    GETCHR          ; Get next character
   EB23 CA 81 EB      [ 9] 1712 PRINT:  JP      Z,PRNTCR        ; CRLF if just PRINT
   EB26 C8            [10] 1713 PRNTLP: RET     Z               ; End of list - Exit
   EB27 FE A5         [ 6] 1714         CP      #ZTAB            ; "TAB(" token?
   EB29 CA AF EB      [ 9] 1715         JP      Z,DOTAB         ; Yes - Do TAB routine
   EB2C FE A8         [ 6] 1716         CP      #ZSPC            ; "SPC(" token?
   EB2E CA AF EB      [ 9] 1717         JP      Z,DOTAB         ; Yes - Do SPC routine
   EB31 E5            [11] 1718         PUSH    HL              ; Save code string address
   EB32 FE 2C         [ 6] 1719         CP      #","             ; Comma?
   EB34 CA 98 EB      [ 9] 1720         JP      Z,DOCOM         ; Yes - Move to next zone
   EB37 FE 3B         [ 6] 1721         CP      #";"             ; Semi-colon?
   EB39 CA D2 EB      [ 9] 1722         JP      Z,NEXITM        ; Do semi-colon routine
   EB3C C1            [ 9] 1723         POP     BC              ; Code string address to BC
   EB3D CD 5A ED      [16] 1724         CALL    EVAL            ; Evaluate expression
   EB40 E5            [11] 1725         PUSH    HL              ; Save code string address
   EB41 3A AD 10      [12] 1726         LD      A,(TYPE)        ; Get variable type
   EB44 B7            [ 4] 1727         OR      A               ; Is it a string variable?
   EB45 C2 6D EB      [ 9] 1728         JP      NZ,PRNTST       ; Yes - Output string contents
   EB48 CD B8 F9      [16] 1729         CALL    NUMASC          ; Convert number to text
   EB4B CD CE F1      [16] 1730         CALL    CRTST           ; Create temporary string
   EB4E 36 20         [ 9] 1731         LD      (HL),#" "        ; Followed by a space
   EB50 2A E4 10      [15] 1732         LD      HL,(FPREG)      ; Get length of output
   EB53 34            [10] 1733         INC     (HL)            ; Plus 1 for the space
   EB54 2A E4 10      [15] 1734         LD      HL,(FPREG)      ; < Not needed >
   EB57 3A 42 10      [12] 1735         LD      A,(LWIDTH)      ; Get width of line
   EB5A 47            [ 4] 1736         LD      B,A             ; To B
   EB5B 04            [ 4] 1737         INC     B               ; Width 255 (No limit)?
   EB5C CA 69 EB      [ 9] 1738         JP      Z,PRNTNB        ; Yes - Output number string
   EB5F 04            [ 4] 1739         INC     B               ; Adjust it
   EB60 3A AB 10      [12] 1740         LD      A,(CURPOS)      ; Get cursor position
   EB63 86            [ 6] 1741         ADD     A,(HL)          ; Add length of string
   EB64 3D            [ 4] 1742         DEC     A               ; Adjust it
   EB65 B8            [ 4] 1743         CP      B               ; Will output fit on this line?
   EB66 D4 81 EB      [16] 1744         CALL    NC,PRNTCR       ; No - CRLF first
   EB69 CD 13 F2      [16] 1745 PRNTNB: CALL    PRS1            ; Output string at (HL)
   EB6C AF            [ 4] 1746         XOR     A               ; Skip CALL by setting "Z" flag
   EB6D C4 13 F2      [16] 1747 PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 33.
Hexadecimal [16-Bits]



   EB70 E1            [ 9] 1748         POP     HL              ; Restore code string address
   EB71 C3 1F EB      [ 9] 1749         JP      MRPRNT          ; See if more to PRINT
                           1750 
   EB74 3A AB 10      [12] 1751 STTLIN: LD      A,(CURPOS)      ; Make sure on new line
   EB77 B7            [ 4] 1752         OR      A               ; Already at start?
   EB78 C8            [10] 1753         RET     Z               ; Yes - Do nothing
   EB79 C3 81 EB      [ 9] 1754         JP      PRNTCR          ; Start a new line
                           1755 
   EB7C 36 00         [ 9] 1756 ENDINP: LD      (HL),#0          ; Mark end of buffer
   EB7E 21 60 10      [ 9] 1757         LD      HL,#BUFFER-1     ; Point to buffer
   EB81 3E 0D         [ 6] 1758 PRNTCR: LD      A,#CR            ; Load a CR
   EB83 CD 9B E6      [16] 1759         CALL    OUTC            ; Output character
   EB86 AF            [ 4] 1760 DONULL: XOR     A               ; Set to position 0
   EB87 32 AB 10      [13] 1761         LD      (CURPOS),A      ; Store it
   EB8A 3A 41 10      [12] 1762         LD      A,(NULLS)       ; Get number of nulls
   EB8D 3D            [ 4] 1763 NULLP:  DEC     A               ; Count them
   EB8E C8            [10] 1764         RET     Z               ; Return if done
   EB8F F5            [11] 1765         PUSH    AF              ; Save count
   EB90 AF            [ 4] 1766         XOR     A               ; Load a null
   EB91 CD 9B E6      [16] 1767         CALL    OUTC            ; Output it
   EB94 F1            [ 9] 1768         POP     AF              ; Restore count
   EB95 C3 8D EB      [ 9] 1769         JP      NULLP           ; Keep counting
                           1770 
   EB98 3A 43 10      [12] 1771 DOCOM:  LD      A,(COMMAN)      ; Get comma width
   EB9B 47            [ 4] 1772         LD      B,A             ; Save in B
   EB9C 3A AB 10      [12] 1773         LD      A,(CURPOS)      ; Get current position
   EB9F B8            [ 4] 1774         CP      B               ; Within the limit?
   EBA0 D4 81 EB      [16] 1775         CALL    NC,PRNTCR       ; No - output CRLF
   EBA3 D2 D2 EB      [ 9] 1776         JP      NC,NEXITM       ; Get next item
   EBA6 D6 0E         [ 6] 1777 ZONELP: SUB     #14              ; Next zone of 14 characters
   EBA8 D2 A6 EB      [ 9] 1778         JP      NC,ZONELP       ; Repeat if more zones
   EBAB 2F            [ 3] 1779         CPL                     ; Number of spaces to output
   EBAC C3 C7 EB      [ 9] 1780         JP      ASPCS           ; Output them
                           1781 
   EBAF F5            [11] 1782 DOTAB:  PUSH    AF              ; Save token
   EBB0 CD 81 F4      [16] 1783         CALL    FNDNUM          ; Evaluate expression
   EBB3 CD 90 E6      [16] 1784         CALL    CHKSYN          ; Make sure ")" follows
   EBB6 29                 1785         .db      ")"
   EBB7 2B            [ 4] 1786         DEC     HL              ; Back space on to ")"
   EBB8 F1            [ 9] 1787         POP     AF              ; Restore token
   EBB9 D6 A8         [ 6] 1788         SUB     #ZSPC            ; Was it "SPC(" ?
   EBBB E5            [11] 1789         PUSH    HL              ; Save code string address
   EBBC CA C2 EB      [ 9] 1790         JP      Z,DOSPC         ; Yes - Do "E" spaces
   EBBF 3A AB 10      [12] 1791         LD      A,(CURPOS)      ; Get current position
   EBC2 2F            [ 3] 1792 DOSPC:  CPL                     ; Number of spaces to print to
   EBC3 83            [ 4] 1793         ADD     A,E             ; Total number to print
   EBC4 D2 D2 EB      [ 9] 1794         JP      NC,NEXITM       ; TAB < Current POS(X)
   EBC7 3C            [ 4] 1795 ASPCS:  INC     A               ; Output A spaces
   EBC8 47            [ 4] 1796         LD      B,A             ; Save number to print
   EBC9 3E 20         [ 6] 1797         LD      A,#" "           ; Space
   EBCB CD 9B E6      [16] 1798 SPCLP:  CALL    OUTC            ; Output character in A
   EBCE 05            [ 4] 1799         DEC     B               ; Count them
   EBCF C2 CB EB      [ 9] 1800         JP      NZ,SPCLP        ; Repeat if more
   EBD2 E1            [ 9] 1801 NEXITM: POP     HL              ; Restore code string address
   EBD3 CD 36 E8      [16] 1802         CALL    GETCHR          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 34.
Hexadecimal [16-Bits]



   EBD6 C3 26 EB      [ 9] 1803         JP      PRNTLP          ; More to print
                           1804 
   EBD9 3F 52 65 64 6F 20  1805 REDO:   .ascii      "?Redo from start"
        66 72 6F 6D 20 73
        74 61 72 74
   EBE9 0D 0A 00           1806         .db CR,LF,0
                           1807 
   EBEC 3A CD 10      [12] 1808 BADINP: LD      A,(READFG)      ; READ or INPUT?
   EBEF B7            [ 4] 1809         OR      A
   EBF0 C2 A7 E3      [ 9] 1810         JP      NZ,DATSNR       ; READ - ?SN Error
   EBF3 C1            [ 9] 1811         POP     BC              ; Throw away code string addr
   EBF4 21 D9 EB      [ 9] 1812         LD      HL,#REDO         ; "Redo from start" message
   EBF7 CD 10 F2      [16] 1813         CALL    PRS             ; Output string
   EBFA C3 F8 E4      [ 9] 1814         JP      DOAGN           ; Do last INPUT again
                           1815 
   EBFD CD 7B F1      [16] 1816 INPUT:  CALL    IDTEST          ; Test for illegal direct
   EC00 7E            [ 6] 1817         LD      A,(HL)          ; Get character after "INPUT"
   EC01 FE 22         [ 6] 1818         CP      #'"'             ; Is there a prompt string?"
   EC03 3E 00         [ 6] 1819         LD      A,#0             ; Clear A and leave flags
   EC05 32 45 10      [13] 1820         LD      (CTLOFG),A      ; Enable output
   EC08 C2 17 EC      [ 9] 1821         JP      NZ,NOPMPT       ; No prompt - get input
   EC0B CD CF F1      [16] 1822         CALL    QTSTR           ; Get string terminated by '"'
   EC0E CD 90 E6      [16] 1823         CALL    CHKSYN          ; Check for ";" after prompt
   EC11 3B                 1824         .db      ";"
   EC12 E5            [11] 1825         PUSH    HL              ; Save code string address
   EC13 CD 13 F2      [16] 1826         CALL    PRS1            ; Output prompt string
   EC16 3E                 1827         .db      0x3E             ; Skip "PUSH HL"
   EC17 E5            [11] 1828 NOPMPT: PUSH    HL              ; Save code string address
   EC18 CD FC E4      [16] 1829         CALL    PROMPT          ; Get input with "? " prompt
   EC1B C1            [ 9] 1830         POP     BC              ; Restore code string address
   EC1C DA 77 E8      [ 9] 1831         JP      C,INPBRK        ; Break pressed - Exit
   EC1F 23            [ 4] 1832         INC     HL              ; Next byte
   EC20 7E            [ 6] 1833         LD      A,(HL)          ; Get it
   EC21 B7            [ 4] 1834         OR      A               ; End of line?
   EC22 2B            [ 4] 1835         DEC     HL              ; Back again
   EC23 C5            [11] 1836         PUSH    BC              ; Re-save code string address
   EC24 CA 6F EA      [ 9] 1837         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
   EC27 36 2C         [ 9] 1838         LD      (HL),#","        ; Store comma as separator
   EC29 C3 31 EC      [ 9] 1839         JP      NXTITM          ; Get next item
                           1840 
   EC2C E5            [11] 1841 READ:   PUSH    HL              ; Save code string address
   EC2D 2A DC 10      [15] 1842         LD      HL,(NXTDAT)     ; Next DATA statement
   EC30 F6                 1843         .db      0x0F6            ; Flag "READ"
   EC31 AF            [ 4] 1844 NXTITM: XOR     A               ; Flag "INPUT"
   EC32 32 CD 10      [13] 1845         LD      (READFG),A      ; Save "READ"/"INPUT" flag
   EC35 E3            [16] 1846         EX      (SP),HL         ; Get code str' , Save pointer
   EC36 C3 3D EC      [ 9] 1847         JP      GTVLUS          ; Get values
                           1848 
   EC39 CD 90 E6      [16] 1849 NEDMOR: CALL    CHKSYN          ; Check for comma between items
   EC3C 2C                 1850         .db      ","
   EC3D CD 2D EF      [16] 1851 GTVLUS: CALL    GETVAR          ; Get variable name
   EC40 E3            [16] 1852         EX      (SP),HL         ; Save code str" , Get pointer
   EC41 D5            [11] 1853         PUSH    DE              ; Save variable address
   EC42 7E            [ 6] 1854         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
   EC43 FE 2C         [ 6] 1855         CP      #","             ; Comma?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 35.
Hexadecimal [16-Bits]



   EC45 CA 65 EC      [ 9] 1856         JP      Z,ANTVLU        ; Yes - Get another value
   EC48 3A CD 10      [12] 1857         LD      A,(READFG)      ; Is it READ?
   EC4B B7            [ 4] 1858         OR      A
   EC4C C2 D2 EC      [ 9] 1859         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
   EC4F 3E 3F         [ 6] 1860         LD      A,#"?"           ; More INPUT needed
   EC51 CD 9B E6      [16] 1861         CALL    OUTC            ; Output character
   EC54 CD FC E4      [16] 1862         CALL    PROMPT          ; Get INPUT with prompt
   EC57 D1            [ 9] 1863         POP     DE              ; Variable address
   EC58 C1            [ 9] 1864         POP     BC              ; Code string address
   EC59 DA 77 E8      [ 9] 1865         JP      C,INPBRK        ; Break pressed
   EC5C 23            [ 4] 1866         INC     HL              ; Point to next DATA byte
   EC5D 7E            [ 6] 1867         LD      A,(HL)          ; Get byte
   EC5E B7            [ 4] 1868         OR      A               ; Is it zero (No input) ?
   EC5F 2B            [ 4] 1869         DEC     HL              ; Back space INPUT pointer
   EC60 C5            [11] 1870         PUSH    BC              ; Save code string address
   EC61 CA 6F EA      [ 9] 1871         JP      Z,NXTDTA        ; Find end of buffer
   EC64 D5            [11] 1872         PUSH    DE              ; Save variable address
   EC65 3A AD 10      [12] 1873 ANTVLU: LD      A,(TYPE)        ; Check data type
   EC68 B7            [ 4] 1874         OR      A               ; Is it numeric?
   EC69 CA 8F EC      [ 9] 1875         JP      Z,INPBIN        ; Yes - Convert to binary
   EC6C CD 36 E8      [16] 1876         CALL    GETCHR          ; Get next character
   EC6F 57            [ 4] 1877         LD      D,A             ; Save input character
   EC70 47            [ 4] 1878         LD      B,A             ; Again
   EC71 FE 22         [ 6] 1879         CP      #'"'             ; Start of literal sting?"
   EC73 CA 83 EC      [ 9] 1880         JP      Z,STRENT        ; Yes - Create string entry
   EC76 3A CD 10      [12] 1881         LD      A,(READFG)      ; "READ" or "INPUT" ?
   EC79 B7            [ 4] 1882         OR      A
   EC7A 57            [ 4] 1883         LD      D,A             ; Save 00 if "INPUT"
   EC7B CA 80 EC      [ 9] 1884         JP      Z,ITMSEP        ; "INPUT" - End with 00
   EC7E 16 3A         [ 6] 1885         LD      D,#":"           ; "DATA" - End with 00 or ":"
   EC80 06 2C         [ 6] 1886 ITMSEP: LD      B,#","           ; Item separator
   EC82 2B            [ 4] 1887         DEC     HL              ; Back space for DTSTR
   EC83 CD D2 F1      [16] 1888 STRENT: CALL    DTSTR           ; Get string terminated by D
   EC86 EB            [ 3] 1889         EX      DE,HL           ; String address to DE
   EC87 21 9A EC      [ 9] 1890         LD      HL,#LTSTND       ; Where to go after LETSTR
   EC8A E3            [16] 1891         EX      (SP),HL         ; Save HL , get input pointer
   EC8B D5            [11] 1892         PUSH    DE              ; Save address of string
   EC8C C3 A2 EA      [ 9] 1893         JP      LETSTR          ; Assign string to variable
                           1894 
   EC8F CD 36 E8      [16] 1895 INPBIN: CALL    GETCHR          ; Get next character
   EC92 CD 1A F9      [16] 1896         CALL    ASCTFP          ; Convert ASCII to FP number
   EC95 E3            [16] 1897         EX      (SP),HL         ; Save input ptr, Get var addr
   EC96 CD 6B F8      [16] 1898         CALL    FPTHL           ; Move FPREG to variable
   EC99 E1            [ 9] 1899         POP     HL              ; Restore input pointer
   EC9A 2B            [ 4] 1900 LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
   EC9B CD 36 E8      [16] 1901         CALL    GETCHR          ; Get next character
   EC9E CA A6 EC      [ 9] 1902         JP      Z,MORDT         ; End of line - More needed?
   ECA1 FE 2C         [ 6] 1903         CP      #","             ; Another value?
   ECA3 C2 EC EB      [ 9] 1904         JP      NZ,BADINP       ; No - Bad input
   ECA6 E3            [16] 1905 MORDT:  EX      (SP),HL         ; Get code string address
   ECA7 2B            [ 4] 1906         DEC     HL              ; DEC 'cos GETCHR INCs
   ECA8 CD 36 E8      [16] 1907         CALL    GETCHR          ; Get next character
   ECAB C2 39 EC      [ 9] 1908         JP      NZ,NEDMOR       ; More needed - Get it
   ECAE D1            [ 9] 1909         POP     DE              ; Restore DATA pointer
   ECAF 3A CD 10      [12] 1910         LD      A,(READFG)      ; "READ" or "INPUT" ?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 36.
Hexadecimal [16-Bits]



   ECB2 B7            [ 4] 1911         OR      A
   ECB3 EB            [ 3] 1912         EX      DE,HL           ; DATA pointer to HL
   ECB4 C2 5C E8      [ 9] 1913         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
   ECB7 D5            [11] 1914         PUSH    DE              ; Save code string address
   ECB8 B6            [ 6] 1915         OR      (HL)            ; More input given?
   ECB9 21 C1 EC      [ 9] 1916         LD      HL,#EXTIG        ; "?Extra ignored" message
   ECBC C4 10 F2      [16] 1917         CALL    NZ,PRS          ; Output string if extra given
   ECBF E1            [ 9] 1918         POP     HL              ; Restore code string address
   ECC0 C9            [ 9] 1919         RET
                           1920 
   ECC1 3F 45 78 74 72 61  1921 EXTIG:  .ascii      "?Extra ignored"
        20 69 67 6E 6F 72
        65 64
   ECCF 0D 0A 00           1922         .db CR,LF,0
                           1923 
   ECD2 CD 70 EA      [16] 1924 FDTLP:  CALL    DATA            ; Get next statement
   ECD5 B7            [ 4] 1925         OR      A               ; End of line?
   ECD6 C2 EB EC      [ 9] 1926         JP      NZ,FANDT        ; No - See if DATA statement
   ECD9 23            [ 4] 1927         INC     HL
   ECDA 7E            [ 6] 1928         LD      A,(HL)          ; End of program?
   ECDB 23            [ 4] 1929         INC     HL
   ECDC B6            [ 6] 1930         OR      (HL)            ; 00 00 Ends program
   ECDD 1E 06         [ 6] 1931         LD      E,#OD            ; ?OD Error
   ECDF CA C1 E3      [ 9] 1932         JP      Z,ERROR         ; Yes - Out of DATA
   ECE2 23            [ 4] 1933         INC     HL
   ECE3 5E            [ 6] 1934         LD      E,(HL)          ; LSB of line number
   ECE4 23            [ 4] 1935         INC     HL
   ECE5 56            [ 6] 1936         LD      D,(HL)          ; MSB of line number
   ECE6 EB            [ 3] 1937         EX      DE,HL
   ECE7 22 C9 10      [16] 1938         LD      (DATLIN),HL     ; Set line of current DATA item
   ECEA EB            [ 3] 1939         EX      DE,HL
   ECEB CD 36 E8      [16] 1940 FANDT:  CALL    GETCHR          ; Get next character
   ECEE FE 83         [ 6] 1941         CP      #ZDATA           ; "DATA" token
   ECF0 C2 D2 EC      [ 9] 1942         JP      NZ,FDTLP        ; No "DATA" - Keep looking
   ECF3 C3 65 EC      [ 9] 1943         JP      ANTVLU          ; Found - Convert input
                           1944 
   ECF6 11 00 00      [ 9] 1945 NEXT:   LD      DE,#0            ; In case no index given
   ECF9 C4 2D EF      [16] 1946 NEXT1:  CALL    NZ,GETVAR       ; Get index address
   ECFC 22 CE 10      [16] 1947         LD      (BRKLIN),HL     ; Save code string address
   ECFF CD 56 E3      [16] 1948         CALL    BAKSTK          ; Look for "FOR" block
   ED02 C2 B3 E3      [ 9] 1949         JP      NZ,NFERR        ; No "FOR" - ?NF Error
   ED05 F9            [ 4] 1950         LD      SP,HL           ; Clear nested loops
   ED06 D5            [11] 1951         PUSH    DE              ; Save index address
   ED07 7E            [ 6] 1952         LD      A,(HL)          ; Get sign of STEP
   ED08 23            [ 4] 1953         INC     HL
   ED09 F5            [11] 1954         PUSH    AF              ; Save sign of STEP
   ED0A D5            [11] 1955         PUSH    DE              ; Save index address
   ED0B CD 51 F8      [16] 1956         CALL    PHLTFP          ; Move index value to FPREG
   ED0E E3            [16] 1957         EX      (SP),HL         ; Save address of TO value
   ED0F E5            [11] 1958         PUSH    HL              ; Save address of index
   ED10 CD BE F5      [16] 1959         CALL    ADDPHL          ; Add STEP to index value
   ED13 E1            [ 9] 1960         POP     HL              ; Restore address of index
   ED14 CD 6B F8      [16] 1961         CALL    FPTHL           ; Move value to index variable
   ED17 E1            [ 9] 1962         POP     HL              ; Restore address of TO value
   ED18 CD 62 F8      [16] 1963         CALL    LOADFP          ; Move TO value to BCDE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 37.
Hexadecimal [16-Bits]



   ED1B E5            [11] 1964         PUSH    HL              ; Save address of line of FOR
   ED1C CD 8E F8      [16] 1965         CALL    CMPNUM          ; Compare index with TO value
   ED1F E1            [ 9] 1966         POP     HL              ; Restore address of line num
   ED20 C1            [ 9] 1967         POP     BC              ; Address of sign of STEP
   ED21 90            [ 4] 1968         SUB     B               ; Compare with expected sign
   ED22 CD 62 F8      [16] 1969         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
   ED25 CA 31 ED      [ 9] 1970         JP      Z,KILFOR        ; Loop finished - Terminate it
   ED28 EB            [ 3] 1971         EX      DE,HL           ; Loop statement line number
   ED29 22 5C 10      [16] 1972         LD      (LINEAT),HL     ; Set loop line number
   ED2C 69            [ 4] 1973         LD      L,C             ; Set code string to loop
   ED2D 60            [ 4] 1974         LD      H,B
   ED2E C3 EE E7      [ 9] 1975         JP      PUTFID          ; Put back "FOR" and continue
                           1976 
   ED31 F9            [ 4] 1977 KILFOR: LD      SP,HL           ; Remove "FOR" block
   ED32 2A CE 10      [15] 1978         LD      HL,(BRKLIN)     ; Code string after "NEXT"
   ED35 7E            [ 6] 1979         LD      A,(HL)          ; Get next byte in code string
   ED36 FE 2C         [ 6] 1980         CP      #","             ; More NEXTs ?
   ED38 C2 F2 E7      [ 9] 1981         JP      NZ,#RUNCNT       ; No - Do next statement
   ED3B CD 36 E8      [16] 1982         CALL    GETCHR          ; Position to index name
   ED3E CD F9 EC      [16] 1983         CALL    NEXT1           ; Re-enter NEXT routine
                           1984 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           1985 
   ED41 CD 5A ED      [16] 1986 GETNUM: CALL    EVAL            ; Get a numeric expression
   ED44 F6                 1987 TSTNUM: .db      0x0F6            ; Clear carry (numeric)
   ED45 37            [ 3] 1988 TSTSTR: SCF                     ; Set carry (string)
   ED46 3A AD 10      [12] 1989 CHKTYP: LD      A,(TYPE)        ; Check types match
   ED49 8F            [ 4] 1990         ADC     A,A             ; Expected + actual
   ED4A B7            [ 4] 1991         OR      A               ; Clear carry , set parity
   ED4B E8            [10] 1992         RET     PE              ; Even parity - Types match
   ED4C C3 BF E3      [ 9] 1993         JP      TMERR           ; Different types - Error
                           1994 
                           1995 ; <<< NO REFERENCE TO HERE >>>
                           1996 
   ED4F CD 90 E6      [16] 1997         CALL    CHKSYN          ; Make sure "=" follows
   ED52 B4                 1998         .db      ZEQUAL          ; "="
   ED53 C3 5A ED      [ 9] 1999         JP      EVAL            ; Evaluate expression
                           2000 
   ED56 CD 90 E6      [16] 2001 OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
   ED59 28                 2002         .db      #"("
   ED5A 2B            [ 4] 2003 EVAL:   DEC     HL              ; Evaluate expression & save
   ED5B 16 00         [ 6] 2004         LD      D,#0             ; Precedence value
   ED5D D5            [11] 2005 EVAL1:  PUSH    DE              ; Save precedence
   ED5E 0E 01         [ 6] 2006         LD      C,#1
   ED60 CD 8A E3      [16] 2007         CALL    CHKSTK          ; Check for 1 level of stack
   ED63 CD D1 ED      [16] 2008         CALL    OPRND           ; Get next expression value
   ED66 22 D0 10      [16] 2009 EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
   ED69 2A D0 10      [15] 2010 EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
   ED6C C1            [ 9] 2011         POP     BC              ; Precedence value and operator
   ED6D 78            [ 4] 2012         LD      A,B             ; Get precedence value
   ED6E FE 78         [ 6] 2013         CP      #0x78             ; "AND" or "OR" ?
   ED70 D4 44 ED      [16] 2014         CALL    NC,TSTNUM       ; No - Make sure it's a number
   ED73 7E            [ 6] 2015         LD      A,(HL)          ; Get next operator / function
   ED74 16 00         [ 6] 2016         LD      D,#0             ; Clear Last relation
   ED76 D6 B3         [ 6] 2017 RLTLP:  SUB     #ZGTR            ; ">" Token
   ED78 DA 92 ED      [ 9] 2018         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 38.
Hexadecimal [16-Bits]



   ED7B FE 03         [ 6] 2019         CP      #ZLTH+1-ZGTR     ; < = >
   ED7D D2 92 ED      [ 9] 2020         JP      NC,FOPRND       ; Function - Call it
   ED80 FE 01         [ 6] 2021         CP      #ZEQUAL-ZGTR     ; "="
   ED82 17            [ 3] 2022         RLA                     ; <- Test for legal
   ED83 AA            [ 4] 2023         XOR     D               ; <- combinations of < = >
   ED84 BA            [ 4] 2024         CP      D               ; <- by combining last token
   ED85 57            [ 4] 2025         LD      D,A             ; <- with current one
   ED86 DA AD E3      [ 9] 2026         JP      C,SNERR         ; Error if "<<" "==" or ">>"
   ED89 22 C5 10      [16] 2027         LD      (CUROPR),HL     ; Save address of current token
   ED8C CD 36 E8      [16] 2028         CALL    GETCHR          ; Get next character
   ED8F C3 76 ED      [ 9] 2029         JP      RLTLP           ; Treat the two as one
                           2030 
   ED92 7A            [ 4] 2031 FOPRND: LD      A,D             ; < = > found ?
   ED93 B7            [ 4] 2032         OR      A
   ED94 C2 A8 EE      [ 9] 2033         JP      NZ,TSTRED       ; Yes - Test for reduction
   ED97 7E            [ 6] 2034         LD      A,(HL)          ; Get operator token
   ED98 22 C5 10      [16] 2035         LD      (CUROPR),HL     ; Save operator address
   ED9B D6 AC         [ 6] 2036         SUB     #ZPLUS           ; Operator or function?
   ED9D D8            [10] 2037         RET     C               ; Neither - Exit
   ED9E FE 07         [ 6] 2038         CP      #ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
   EDA0 D0            [10] 2039         RET     NC              ; No - Exit
   EDA1 5F            [ 4] 2040         LD      E,A             ; Coded operator
   EDA2 3A AD 10      [12] 2041         LD      A,(TYPE)        ; Get data type
   EDA5 3D            [ 4] 2042         DEC     A               ; FF = numeric , 00 = string
   EDA6 B3            [ 4] 2043         OR      E               ; Combine with coded operator
   EDA7 7B            [ 4] 2044         LD      A,E             ; Get coded operator
   EDA8 CA 06 F3      [ 9] 2045         JP      Z,CONCAT        ; String concatenation
   EDAB 07            [ 3] 2046         RLCA                    ; Times 2
   EDAC 83            [ 4] 2047         ADD     A,E             ; Times 3
   EDAD 5F            [ 4] 2048         LD      E,A             ; To DE (D is 0)
   EDAE 21 A4 E2      [ 9] 2049         LD      HL,#PRITAB       ; Precedence table
   EDB1 19            [ 7] 2050         ADD     HL,DE           ; To the operator concerned
   EDB2 78            [ 4] 2051         LD      A,B             ; Last operator precedence
   EDB3 56            [ 6] 2052         LD      D,(HL)          ; Get evaluation precedence
   EDB4 BA            [ 4] 2053         CP      D               ; Compare with eval precedence
   EDB5 D0            [10] 2054         RET     NC              ; Exit if higher precedence
   EDB6 23            [ 4] 2055         INC     HL              ; Point to routine address
   EDB7 CD 44 ED      [16] 2056         CALL    TSTNUM          ; Make sure it's a number
                           2057 
   EDBA C5            [11] 2058 STKTHS: PUSH    BC              ; Save last precedence & token
   EDBB 01 69 ED      [ 9] 2059         LD      BC,#EVAL3        ; Where to go on prec' break
   EDBE C5            [11] 2060         PUSH    BC              ; Save on stack for return
   EDBF 43            [ 4] 2061         LD      B,E             ; Save operator
   EDC0 4A            [ 4] 2062         LD      C,D             ; Save precedence
   EDC1 CD 44 F8      [16] 2063         CALL    STAKFP          ; Move value to stack
   EDC4 58            [ 4] 2064         LD      E,B             ; Restore operator
   EDC5 51            [ 4] 2065         LD      D,C             ; Restore precedence
   EDC6 4E            [ 6] 2066         LD      C,(HL)          ; Get LSB of routine address
   EDC7 23            [ 4] 2067         INC     HL
   EDC8 46            [ 6] 2068         LD      B,(HL)          ; Get MSB of routine address
   EDC9 23            [ 4] 2069         INC     HL
   EDCA C5            [11] 2070         PUSH    BC              ; Save routine address
   EDCB 2A C5 10      [15] 2071         LD      HL,(CUROPR)     ; Address of current operator
   EDCE C3 5D ED      [ 9] 2072         JP      EVAL1           ; Loop until prec' break
                           2073 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 39.
Hexadecimal [16-Bits]



   EDD1 AF            [ 4] 2074 OPRND:  XOR     A               ; Get operand routine
   EDD2 32 AD 10      [13] 2075         LD      (TYPE),A        ; Set numeric expected
   EDD5 CD 36 E8      [16] 2076         CALL    GETCHR          ; Get next character
   EDD8 1E 24         [ 6] 2077         LD      E,#MO            ; ?MO Error
   EDDA CA C1 E3      [ 9] 2078         JP      Z,ERROR         ; No operand - Error
   EDDD DA 1A F9      [ 9] 2079         JP      C,ASCTFP        ; Number - Get value
   EDE0 CD 77 E9      [16] 2080         CALL    CHKLTR          ; See if a letter
   EDE3 D2 22 EE      [ 9] 2081         JP      NC,CONVAR       ; Letter - Find variable
   EDE6 FE AC         [ 6] 2082         CP      #ZPLUS           ; "+" Token ?
   EDE8 CA D1 ED      [ 9] 2083         JP      Z,OPRND         ; Yes - Look for operand
   EDEB FE 2E         [ 6] 2084         CP      #"."             ; "." ?
   EDED CA 1A F9      [ 9] 2085         JP      Z,ASCTFP        ; Yes - Create FP number
   EDF0 FE AD         [ 6] 2086         CP      #ZMINUS          ; "-" Token ?
   EDF2 CA 11 EE      [ 9] 2087         JP      Z,MINUS         ; Yes - Do minus
   EDF5 FE 22         [ 6] 2088         CP      #'"'             ; Literal string ?"
   EDF7 CA CF F1      [ 9] 2089         JP      Z,QTSTR         ; Get string terminated by '"'
   EDFA FE AA         [ 6] 2090         CP      #ZNOT            ; "NOT" Token ?
   EDFC CA 08 EF      [ 9] 2091         JP      Z,EVNOT         ; Yes - Eval NOT expression
   EDFF FE A7         [ 6] 2092         CP      #ZFN             ; "FN" Token ?
   EE01 CA 33 F1      [ 9] 2093         JP      Z,DOFN          ; Yes - Do FN routine
   EE04 D6 B6         [ 6] 2094         SUB     #ZSGN            ; Is it a function?
   EE06 D2 33 EE      [ 9] 2095         JP      NC,FNOFST       ; Yes - Evaluate function
   EE09 CD 56 ED      [16] 2096 EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
   EE0C CD 90 E6      [16] 2097         CALL    CHKSYN          ; Make sure ")" follows
   EE0F 29                 2098         .db      ")"
   EE10 C9            [ 9] 2099         RET
                           2100 
   EE11 16 7D         [ 6] 2101 MINUS:  LD      D,#0x7D           ; "-" precedence
   EE13 CD 5D ED      [16] 2102         CALL    EVAL1           ; Evaluate until prec' break
   EE16 2A D0 10      [15] 2103         LD      HL,(NXTOPR)     ; Get next operator address
   EE19 E5            [11] 2104         PUSH    HL              ; Save next operator address
   EE1A CD 3C F8      [16] 2105         CALL    INVSGN          ; Negate value
   EE1D CD 44 ED      [16] 2106 RETNUM: CALL    TSTNUM          ; Make sure it's a number
   EE20 E1            [ 9] 2107         POP     HL              ; Restore next operator address
   EE21 C9            [ 9] 2108         RET
                           2109 
   EE22 CD 2D EF      [16] 2110 CONVAR: CALL    GETVAR          ; Get variable address to DE
   EE25 E5            [11] 2111 FRMEVL: PUSH    HL              ; Save code string address
   EE26 EB            [ 3] 2112         EX      DE,HL           ; Variable address to HL
   EE27 22 E4 10      [16] 2113         LD      (FPREG),HL      ; Save address of variable
   EE2A 3A AD 10      [12] 2114         LD      A,(TYPE)        ; Get type
   EE2D B7            [ 4] 2115         OR      A               ; Numeric?
   EE2E CC 51 F8      [16] 2116         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
   EE31 E1            [ 9] 2117         POP     HL              ; Restore code string address
   EE32 C9            [ 9] 2118         RET
                           2119 
   EE33 06 00         [ 6] 2120 FNOFST: LD      B,#0             ; Get address of function
   EE35 07            [ 3] 2121         RLCA                    ; Double function offset
   EE36 4F            [ 4] 2122         LD      C,A             ; BC = Offset in function table
   EE37 C5            [11] 2123         PUSH    BC              ; Save adjusted token value
   EE38 CD 36 E8      [16] 2124         CALL    GETCHR          ; Get next character
   EE3B 79            [ 4] 2125         LD      A,C             ; Get adjusted token value
   EE3C FE 22         [ 6] 2126         CP      #2*(ZPOINT-ZSGN) ; Adjusted "POINT" token?
   EE3E CA 79 FF      [ 9] 2127         JP      Z,POINTB        ; Yes - Do "POINT" (not POINTB)
   EE41 FE 2D         [ 6] 2128         CP      #2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 40.
Hexadecimal [16-Bits]



   EE43 DA 5F EE      [ 9] 2129         JP      C,FNVAL         ; No - Do function
   EE46 CD 56 ED      [16] 2130         CALL    OPNPAR          ; Evaluate expression  (X,...
   EE49 CD 90 E6      [16] 2131         CALL    CHKSYN          ; Make sure "," follows
   EE4C 2C                 2132         .db     #","
   EE4D CD 45 ED      [16] 2133         CALL    TSTSTR          ; Make sure it's a string
   EE50 EB            [ 3] 2134         EX      DE,HL           ; Save code string address
   EE51 2A E4 10      [15] 2135         LD      HL,(FPREG)      ; Get address of string
   EE54 E3            [16] 2136         EX      (SP),HL         ; Save address of string
   EE55 E5            [11] 2137         PUSH    HL              ; Save adjusted token value
   EE56 EB            [ 3] 2138         EX      DE,HL           ; Restore code string address
   EE57 CD 84 F4      [16] 2139         CALL    GETINT          ; Get integer 0-255
   EE5A EB            [ 3] 2140         EX      DE,HL           ; Save code string address
   EE5B E3            [16] 2141         EX      (SP),HL         ; Save integer,HL = adj' token
   EE5C C3 67 EE      [ 9] 2142         JP      GOFUNC          ; Jump to string function
                           2143 
   EE5F CD 09 EE      [16] 2144 FNVAL:  CALL    EVLPAR          ; Evaluate expression
   EE62 E3            [16] 2145         EX      (SP),HL         ; HL = Adjusted token value
   EE63 11 1D EE      [ 9] 2146         LD      DE,#RETNUM       ; Return number from function
   EE66 D5            [11] 2147         PUSH    DE              ; Save on stack
   EE67 01 0F E1      [ 9] 2148 GOFUNC: LD      BC,#FNCTAB       ; Function routine addresses
   EE6A 09            [ 7] 2149         ADD     HL,BC           ; Point to right address
   EE6B 4E            [ 6] 2150         LD      C,(HL)          ; Get LSB of address
   EE6C 23            [ 4] 2151         INC     HL              ;
   EE6D 66            [ 6] 2152         LD      H,(HL)          ; Get MSB of address
   EE6E 69            [ 4] 2153         LD      L,C             ; Address to HL
   EE6F E9            [ 3] 2154         JP      (HL)            ; Jump to function
                           2155 
   EE70 15            [ 4] 2156 SGNEXP: DEC     D               ; Dee to flag negative exponent
   EE71 FE AD         [ 6] 2157         CP      #ZMINUS          ; "-" token ?
   EE73 C8            [10] 2158         RET     Z               ; Yes - Return
   EE74 FE 2D         [ 6] 2159         CP      #"-"             ; "-" ASCII ?
   EE76 C8            [10] 2160         RET     Z               ; Yes - Return
   EE77 14            [ 4] 2161         INC     D               ; Inc to flag positive exponent
   EE78 FE 2B         [ 6] 2162         CP      #"+"             ; "+" ASCII ?
   EE7A C8            [10] 2163         RET     Z               ; Yes - Return
   EE7B FE AC         [ 6] 2164         CP      #ZPLUS           ; "+" token ?
   EE7D C8            [10] 2165         RET     Z               ; Yes - Return
   EE7E 2B            [ 4] 2166         DEC     HL              ; DEC 'cos GETCHR INCs
   EE7F C9            [ 9] 2167         RET                     ; Return "NZ"
                           2168 
   EE80 F6                 2169 POR:    .db      0x0F6            ; Flag "OR"
   EE81 AF            [ 4] 2170 PAND:   XOR     A               ; Flag "AND"
   EE82 F5            [11] 2171         PUSH    AF              ; Save "AND" / "OR" flag
   EE83 CD 44 ED      [16] 2172         CALL    TSTNUM          ; Make sure it's a number
   EE86 CD 8B E9      [16] 2173         CALL    DEINT           ; Get integer -32768 to 32767
   EE89 F1            [ 9] 2174         POP     AF              ; Restore "AND" / "OR" flag
   EE8A EB            [ 3] 2175         EX      DE,HL           ; <- Get last
   EE8B C1            [ 9] 2176         POP     BC              ; <-  value
   EE8C E3            [16] 2177         EX      (SP),HL         ; <-  from
   EE8D EB            [ 3] 2178         EX      DE,HL           ; <-  stack
   EE8E CD 54 F8      [16] 2179         CALL    FPBCDE          ; Move last value to FPREG
   EE91 F5            [11] 2180         PUSH    AF              ; Save "AND" / "OR" flag
   EE92 CD 8B E9      [16] 2181         CALL    DEINT           ; Get integer -32768 to 32767
   EE95 F1            [ 9] 2182         POP     AF              ; Restore "AND" / "OR" flag
   EE96 C1            [ 9] 2183         POP     BC              ; Get value
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 41.
Hexadecimal [16-Bits]



   EE97 79            [ 4] 2184         LD      A,C             ; Get LSB
   EE98 21 F1 F0      [ 9] 2185         LD      HL,#ACPASS       ; Address of save AC as current
   EE9B C2 A3 EE      [ 9] 2186         JP      NZ,POR1         ; Jump if OR
   EE9E A3            [ 4] 2187         AND     E               ; "AND" LSBs
   EE9F 4F            [ 4] 2188         LD      C,A             ; Save LSB
   EEA0 78            [ 4] 2189         LD      A,B             ; Get MBS
   EEA1 A2            [ 4] 2190         AND     D               ; "AND" MSBs
   EEA2 E9            [ 3] 2191         JP      (HL)            ; Save AC as current (ACPASS)
                           2192 
   EEA3 B3            [ 4] 2193 POR1:   OR      E               ; "OR" LSBs
   EEA4 4F            [ 4] 2194         LD      C,A             ; Save LSB
   EEA5 78            [ 4] 2195         LD      A,B             ; Get MSB
   EEA6 B2            [ 4] 2196         OR      D               ; "OR" MSBs
   EEA7 E9            [ 3] 2197         JP      (HL)            ; Save AC as current (ACPASS)
                           2198 
   EEA8 21 BA EE      [ 9] 2199 TSTRED: LD      HL,#CMPLOG       ; Logical compare routine
   EEAB 3A AD 10      [12] 2200         LD      A,(TYPE)        ; Get data type
   EEAE 1F            [ 3] 2201         RRA                     ; Carry set = string
   EEAF 7A            [ 4] 2202         LD      A,D             ; Get last precedence value
   EEB0 17            [ 3] 2203         RLA                     ; Times 2 plus carry
   EEB1 5F            [ 4] 2204         LD      E,A             ; To E
   EEB2 16 64         [ 6] 2205         LD      D,#0x64           ; Relational precedence
   EEB4 78            [ 4] 2206         LD      A,B             ; Get current precedence
   EEB5 BA            [ 4] 2207         CP      D               ; Compare with last
   EEB6 D0            [10] 2208         RET     NC              ; Eval if last was rel' or log'
   EEB7 C3 BA ED      [ 9] 2209         JP      STKTHS          ; Stack this one and get next
                           2210 
   EEBA BC EE              2211 CMPLOG: .dw      CMPLG1          ; Compare two values / strings
   EEBC 79            [ 4] 2212 CMPLG1: LD      A,C             ; Get data type
   EEBD B7            [ 4] 2213         OR      A
   EEBE 1F            [ 3] 2214         RRA
   EEBF C1            [ 9] 2215         POP     BC              ; Get last expression to BCDE
   EEC0 D1            [ 9] 2216         POP     DE
   EEC1 F5            [11] 2217         PUSH    AF              ; Save status
   EEC2 CD 46 ED      [16] 2218         CALL    CHKTYP          ; Check that types match
   EEC5 21 FE EE      [ 9] 2219         LD      HL,#CMPRES       ; Result to comparison
   EEC8 E5            [11] 2220         PUSH    HL              ; Save for RETurn
   EEC9 CA 8E F8      [ 9] 2221         JP      Z,CMPNUM        ; Compare values if numeric
   EECC AF            [ 4] 2222         XOR     A               ; Compare two strings
   EECD 32 AD 10      [13] 2223         LD      (TYPE),A        ; Set type to numeric
   EED0 D5            [11] 2224         PUSH    DE              ; Save string name
   EED1 CD 53 F3      [16] 2225         CALL    GSTRCU          ; Get current string
   EED4 7E            [ 6] 2226         LD      A,(HL)          ; Get length of string
   EED5 23            [ 4] 2227         INC     HL
   EED6 23            [ 4] 2228         INC     HL
   EED7 4E            [ 6] 2229         LD      C,(HL)          ; Get LSB of address
   EED8 23            [ 4] 2230         INC     HL
   EED9 46            [ 6] 2231         LD      B,(HL)          ; Get MSB of address
   EEDA D1            [ 9] 2232         POP     DE              ; Restore string name
   EEDB C5            [11] 2233         PUSH    BC              ; Save address of string
   EEDC F5            [11] 2234         PUSH    AF              ; Save length of string
   EEDD CD 57 F3      [16] 2235         CALL    GSTRDE          ; Get second string
   EEE0 CD 62 F8      [16] 2236         CALL    LOADFP          ; Get address of second string
   EEE3 F1            [ 9] 2237         POP     AF              ; Restore length of string 1
   EEE4 57            [ 4] 2238         LD      D,A             ; Length to D
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 42.
Hexadecimal [16-Bits]



   EEE5 E1            [ 9] 2239         POP     HL              ; Restore address of string 1
   EEE6 7B            [ 4] 2240 CMPSTR: LD      A,E             ; Bytes of string 2 to do
   EEE7 B2            [ 4] 2241         OR      D               ; Bytes of string 1 to do
   EEE8 C8            [10] 2242         RET     Z               ; Exit if all bytes compared
   EEE9 7A            [ 4] 2243         LD      A,D             ; Get bytes of string 1 to do
   EEEA D6 01         [ 6] 2244         SUB     #1
   EEEC D8            [10] 2245         RET     C               ; Exit if end of string 1
   EEED AF            [ 4] 2246         XOR     A
   EEEE BB            [ 4] 2247         CP      E               ; Bytes of string 2 to do
   EEEF 3C            [ 4] 2248         INC     A
   EEF0 D0            [10] 2249         RET     NC              ; Exit if end of string 2
   EEF1 15            [ 4] 2250         DEC     D               ; Count bytes in string 1
   EEF2 1D            [ 4] 2251         DEC     E               ; Count bytes in string 2
   EEF3 0A            [ 6] 2252         LD      A,(BC)          ; Byte in string 2
   EEF4 BE            [ 6] 2253         CP      (HL)            ; Compare to byte in string 1
   EEF5 23            [ 4] 2254         INC     HL              ; Move up string 1
   EEF6 03            [ 4] 2255         INC     BC              ; Move up string 2
   EEF7 CA E6 EE      [ 9] 2256         JP      Z,CMPSTR        ; Same - Try next bytes
   EEFA 3F            [ 3] 2257         CCF                     ; Flag difference (">" or "<")
   EEFB C3 1E F8      [ 9] 2258         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                           2259 
   EEFE 3C            [ 4] 2260 CMPRES: INC     A               ; Increment current value
   EEFF 8F            [ 4] 2261         ADC     A,A             ; Double plus carry
   EF00 C1            [ 9] 2262         POP     BC              ; Get other value
   EF01 A0            [ 4] 2263         AND     B               ; Combine them
   EF02 C6 FF         [ 6] 2264         ADD     A,#-1            ; Carry set if different
   EF04 9F            [ 4] 2265         SBC     A,A             ; 00 - Equal , FF - Different
   EF05 C3 25 F8      [ 9] 2266         JP      FLGREL          ; Set current value & continue
                           2267 
   EF08 16 5A         [ 6] 2268 EVNOT:  LD      D,#0x5A           ; Precedence value for "NOT"
   EF0A CD 5D ED      [16] 2269         CALL    EVAL1           ; Eval until precedence break
   EF0D CD 44 ED      [16] 2270         CALL    TSTNUM          ; Make sure it's a number
   EF10 CD 8B E9      [16] 2271         CALL    DEINT           ; Get integer -32768 - 32767
   EF13 7B            [ 4] 2272         LD      A,E             ; Get LSB
   EF14 2F            [ 3] 2273         CPL                     ; Invert LSB
   EF15 4F            [ 4] 2274         LD      C,A             ; Save "NOT" of LSB
   EF16 7A            [ 4] 2275         LD      A,D             ; Get MSB
   EF17 2F            [ 3] 2276         CPL                     ; Invert MSB
   EF18 CD F1 F0      [16] 2277         CALL    ACPASS          ; Save AC as current
   EF1B C1            [ 9] 2278         POP     BC              ; Clean up stack
   EF1C C3 69 ED      [ 9] 2279         JP      EVAL3           ; Continue evaluation
                           2280 
   EF1F 2B            [ 4] 2281 DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
   EF20 CD 36 E8      [16] 2282         CALL    GETCHR          ; Get next character
   EF23 C8            [10] 2283         RET     Z               ; End of DIM statement
   EF24 CD 90 E6      [16] 2284         CALL    CHKSYN          ; Make sure "," follows
   EF27 2C                 2285         .db      ","
   EF28 01 1F EF      [ 9] 2286 DIM:    LD      BC,#DIMRET       ; Return to "DIMRET"
   EF2B C5            [11] 2287         PUSH    BC              ; Save on stack
   EF2C F6                 2288         .db      0x0F6            ; Flag "Create" variable
   EF2D AF            [ 4] 2289 GETVAR: XOR     A               ; Find variable address,to DE
   EF2E 32 AC 10      [13] 2290         LD      (LCRFLG),A      ; Set locate / create flag
   EF31 46            [ 6] 2291         LD      B,(HL)          ; Get First byte of name
   EF32 CD 77 E9      [16] 2292 GTFNAM: CALL    CHKLTR          ; See if a letter
   EF35 DA AD E3      [ 9] 2293         JP      C,SNERR         ; ?SN Error if not a letter
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 43.
Hexadecimal [16-Bits]



   EF38 AF            [ 4] 2294         XOR     A
   EF39 4F            [ 4] 2295         LD      C,A             ; Clear second byte of name
   EF3A 32 AD 10      [13] 2296         LD      (TYPE),A        ; Set type to numeric
   EF3D CD 36 E8      [16] 2297         CALL    GETCHR          ; Get next character
   EF40 DA 49 EF      [ 9] 2298         JP      C,SVNAM2        ; Numeric - Save in name
   EF43 CD 77 E9      [16] 2299         CALL    CHKLTR          ; See if a letter
   EF46 DA 56 EF      [ 9] 2300         JP      C,CHARTY        ; Not a letter - Check type
   EF49 4F            [ 4] 2301 SVNAM2: LD      C,A             ; Save second byte of name
   EF4A CD 36 E8      [16] 2302 ENDNAM: CALL    GETCHR          ; Get next character
   EF4D DA 4A EF      [ 9] 2303         JP      C,ENDNAM        ; Numeric - Get another
   EF50 CD 77 E9      [16] 2304         CALL    CHKLTR          ; See if a letter
   EF53 D2 4A EF      [ 9] 2305         JP      NC,ENDNAM       ; Letter - Get another
   EF56 D6 24         [ 6] 2306 CHARTY: SUB     #"$"             ; String variable?
   EF58 C2 65 EF      [ 9] 2307         JP      NZ,NOTSTR       ; No - Numeric variable
   EF5B 3C            [ 4] 2308         INC     A               ; A = 1 (string type)
   EF5C 32 AD 10      [13] 2309         LD      (TYPE),A        ; Set type to string
   EF5F 0F            [ 3] 2310         RRCA                    ; A = 0x80 , Flag for string
   EF60 81            [ 4] 2311         ADD     A,C             ; 2nd byte of name has bit 7 on
   EF61 4F            [ 4] 2312         LD      C,A             ; Resave second byte on name
   EF62 CD 36 E8      [16] 2313         CALL    GETCHR          ; Get next character
   EF65 3A CB 10      [12] 2314 NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
   EF68 3D            [ 4] 2315         DEC     A
   EF69 CA 12 F0      [ 9] 2316         JP      Z,ARLDSV        ; Yes - Get array name
   EF6C F2 75 EF      [ 9] 2317         JP      P,NSCFOR        ; No array with "FOR" or "FN"
   EF6F 7E            [ 6] 2318         LD      A,(HL)          ; Get byte again
   EF70 D6 28         [ 6] 2319         SUB     #"("             ; Subscripted variable?
   EF72 CA EA EF      [ 9] 2320         JP      Z,SBSCPT        ; Yes - Sort out subscript
                           2321 
   EF75 AF            [ 4] 2322 NSCFOR: XOR     A               ; Simple variable
   EF76 32 CB 10      [13] 2323         LD      (FORFLG),A      ; Clear "FOR" flag
   EF79 E5            [11] 2324         PUSH    HL              ; Save code string address
   EF7A 50            [ 4] 2325         LD      D,B             ; DE = Variable name to find
   EF7B 59            [ 4] 2326         LD      E,C
   EF7C 2A DE 10      [15] 2327         LD      HL,(FNRGNM)     ; FN argument name
   EF7F CD 8A E6      [16] 2328         CALL    CPDEHL          ; Is it the FN argument?
   EF82 11 E0 10      [ 9] 2329         LD      DE,#FNARG        ; Point to argument value
   EF85 CA 54 F7      [ 9] 2330         JP      Z,POPHRT        ; Yes - Return FN argument value
   EF88 2A D8 10      [15] 2331         LD      HL,(VAREND)     ; End of variables
   EF8B EB            [ 3] 2332         EX      DE,HL           ; Address of end of search
   EF8C 2A D6 10      [15] 2333         LD      HL,(PROGND)     ; Start of variables address
   EF8F CD 8A E6      [16] 2334 FNDVAR: CALL    CPDEHL          ; End of variable list table?
   EF92 CA A8 EF      [ 9] 2335         JP      Z,CFEVAL        ; Yes - Called from EVAL?
   EF95 79            [ 4] 2336         LD      A,C             ; Get second byte of name
   EF96 96            [ 6] 2337         SUB     (HL)            ; Compare with name in list
   EF97 23            [ 4] 2338         INC     HL              ; Move on to first byte
   EF98 C2 9D EF      [ 9] 2339         JP      NZ,FNTHR        ; Different - Find another
   EF9B 78            [ 4] 2340         LD      A,B             ; Get first byte of name
   EF9C 96            [ 6] 2341         SUB     (HL)            ; Compare with name in list
   EF9D 23            [ 4] 2342 FNTHR:  INC     HL              ; Move on to LSB of value
   EF9E CA DC EF      [ 9] 2343         JP      Z,RETADR        ; Found - Return address
   EFA1 23            [ 4] 2344         INC     HL              ; <- Skip
   EFA2 23            [ 4] 2345         INC     HL              ; <- over
   EFA3 23            [ 4] 2346         INC     HL              ; <- F.P.
   EFA4 23            [ 4] 2347         INC     HL              ; <- value
   EFA5 C3 8F EF      [ 9] 2348         JP      FNDVAR          ; Keep looking
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 44.
Hexadecimal [16-Bits]



                           2349 
   EFA8 E1            [ 9] 2350 CFEVAL: POP     HL              ; Restore code string address
   EFA9 E3            [16] 2351         EX      (SP),HL         ; Get return address
   EFAA D5            [11] 2352         PUSH    DE              ; Save address of variable
   EFAB 11 25 EE      [ 9] 2353         LD      DE,#FRMEVL       ; Return address in EVAL
   EFAE CD 8A E6      [16] 2354         CALL    CPDEHL          ; Called from EVAL ?
   EFB1 D1            [ 9] 2355         POP     DE              ; Restore address of variable
   EFB2 CA DF EF      [ 9] 2356         JP      Z,RETNUL        ; Yes - Return null variable
   EFB5 E3            [16] 2357         EX      (SP),HL         ; Put back return
   EFB6 E5            [11] 2358         PUSH    HL              ; Save code string address
   EFB7 C5            [11] 2359         PUSH    BC              ; Save variable name
   EFB8 01 06 00      [ 9] 2360         LD      BC,#6            ; 2 byte name plus 4 byte data
   EFBB 2A DA 10      [15] 2361         LD      HL,(ARREND)     ; End of arrays
   EFBE E5            [11] 2362         PUSH    HL              ; Save end of arrays
   EFBF 09            [ 7] 2363         ADD     HL,BC           ; Move up 6 bytes
   EFC0 C1            [ 9] 2364         POP     BC              ; Source address in BC
   EFC1 E5            [11] 2365         PUSH    HL              ; Save new end address
   EFC2 CD 79 E3      [16] 2366         CALL    MOVUP           ; Move arrays up
   EFC5 E1            [ 9] 2367         POP     HL              ; Restore new end address
   EFC6 22 DA 10      [16] 2368         LD      (ARREND),HL     ; Set new end address
   EFC9 60            [ 4] 2369         LD      H,B             ; End of variables to HL
   EFCA 69            [ 4] 2370         LD      L,C
   EFCB 22 D8 10      [16] 2371         LD      (VAREND),HL     ; Set new end address
                           2372 
   EFCE 2B            [ 4] 2373 ZEROLP: DEC     HL              ; Back through to zero variable
   EFCF 36 00         [ 9] 2374         LD      (HL),#0          ; Zero byte in variable
   EFD1 CD 8A E6      [16] 2375         CALL    CPDEHL          ; Done them all?
   EFD4 C2 CE EF      [ 9] 2376         JP      NZ,ZEROLP       ; No - Keep on going
   EFD7 D1            [ 9] 2377         POP     DE              ; Get variable name
   EFD8 73            [ 7] 2378         LD      (HL),E          ; Store second character
   EFD9 23            [ 4] 2379         INC     HL
   EFDA 72            [ 7] 2380         LD      (HL),D          ; Store first character
   EFDB 23            [ 4] 2381         INC     HL
   EFDC EB            [ 3] 2382 RETADR: EX      DE,HL           ; Address of variable in DE
   EFDD E1            [ 9] 2383         POP     HL              ; Restore code string address
   EFDE C9            [ 9] 2384         RET
                           2385 
   EFDF 32 E7 10      [13] 2386 RETNUL: LD      (FPEXP),A       ; Set result to zero
   EFE2 21 4A E3      [ 9] 2387         LD      HL,#ZERBYT       ; Also set a null string
   EFE5 22 E4 10      [16] 2388         LD      (FPREG),HL      ; Save for EVAL
   EFE8 E1            [ 9] 2389         POP     HL              ; Restore code string address
   EFE9 C9            [ 9] 2390         RET
                           2391 
   EFEA E5            [11] 2392 SBSCPT: PUSH    HL              ; Save code string address
   EFEB 2A AC 10      [15] 2393         LD      HL,(LCRFLG)     ; Locate/Create and Type
   EFEE E3            [16] 2394         EX      (SP),HL         ; Save and get code string
   EFEF 57            [ 4] 2395         LD      D,A             ; Zero number of dimensions
   EFF0 D5            [11] 2396 SCPTLP: PUSH    DE              ; Save number of dimensions
   EFF1 C5            [11] 2397         PUSH    BC              ; Save array name
   EFF2 CD 7F E9      [16] 2398         CALL    FPSINT          ; Get subscript (0-32767)
   EFF5 C1            [ 9] 2399         POP     BC              ; Restore array name
   EFF6 F1            [ 9] 2400         POP     AF              ; Get number of dimensions
   EFF7 EB            [ 3] 2401         EX      DE,HL
   EFF8 E3            [16] 2402         EX      (SP),HL         ; Save subscript value
   EFF9 E5            [11] 2403         PUSH    HL              ; Save LCRFLG and TYPE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 45.
Hexadecimal [16-Bits]



   EFFA EB            [ 3] 2404         EX      DE,HL
   EFFB 3C            [ 4] 2405         INC     A               ; Count dimensions
   EFFC 57            [ 4] 2406         LD      D,A             ; Save in D
   EFFD 7E            [ 6] 2407         LD      A,(HL)          ; Get next byte in code string
   EFFE FE 2C         [ 6] 2408         CP      #","             ; Comma (more to come)?
   F000 CA F0 EF      [ 9] 2409         JP      Z,SCPTLP        ; Yes - More subscripts
   F003 CD 90 E6      [16] 2410         CALL    CHKSYN          ; Make sure ")" follows
   F006 29                 2411         .db     # ")"
   F007 22 D0 10      [16] 2412         LD      (NXTOPR),HL     ; Save code string address
   F00A E1            [ 9] 2413         POP     HL              ; Get LCRFLG and TYPE
   F00B 22 AC 10      [16] 2414         LD      (LCRFLG),HL     ; Restore Locate/create & type
   F00E 1E 00         [ 6] 2415         LD      E,#0             ; Flag not CSAVE* or CLOAD*
   F010 D5            [11] 2416         PUSH    DE              ; Save number of dimensions (D)
   F011 11                 2417         .db      0x11             ; Skip "PUSH HL" and "PUSH AF'
                           2418 
   F012 E5            [11] 2419 ARLDSV: PUSH    HL              ; Save code string address
   F013 F5            [11] 2420         PUSH    AF              ; A = 00 , Flags set = Z,N
   F014 2A D8 10      [15] 2421         LD      HL,(VAREND)     ; Start of arrays
   F017 3E                 2422         .db      0x3E             ; Skip "ADD HL,DE"
   F018 19            [ 7] 2423 FNDARY: ADD     HL,DE           ; Move to next array start
   F019 EB            [ 3] 2424         EX      DE,HL
   F01A 2A DA 10      [15] 2425         LD      HL,(ARREND)     ; End of arrays
   F01D EB            [ 3] 2426         EX      DE,HL           ; Current array pointer
   F01E CD 8A E6      [16] 2427         CALL    CPDEHL          ; End of arrays found?
   F021 CA 4A F0      [ 9] 2428         JP      Z,CREARY        ; Yes - Create array
   F024 7E            [ 6] 2429         LD      A,(HL)          ; Get second byte of name
   F025 B9            [ 4] 2430         CP      C               ; Compare with name given
   F026 23            [ 4] 2431         INC     HL              ; Move on
   F027 C2 2C F0      [ 9] 2432         JP      NZ,NXTARY       ; Different - Find next array
   F02A 7E            [ 6] 2433         LD      A,(HL)          ; Get first byte of name
   F02B B8            [ 4] 2434         CP      B               ; Compare with name given
   F02C 23            [ 4] 2435 NXTARY: INC     HL              ; Move on
   F02D 5E            [ 6] 2436         LD      E,(HL)          ; Get LSB of next array address
   F02E 23            [ 4] 2437         INC     HL
   F02F 56            [ 6] 2438         LD      D,(HL)          ; Get MSB of next array address
   F030 23            [ 4] 2439         INC     HL
   F031 C2 18 F0      [ 9] 2440         JP      NZ,FNDARY       ; Not found - Keep looking
   F034 3A AC 10      [12] 2441         LD      A,(LCRFLG)      ; Found Locate or Create it?
   F037 B7            [ 4] 2442         OR      A
   F038 C2 B6 E3      [ 9] 2443         JP      NZ,DDERR        ; Create - ?DD Error
   F03B F1            [ 9] 2444         POP     AF              ; Locate - Get number of dim'ns
   F03C 44            [ 4] 2445         LD      B,H             ; BC Points to array dim'ns
   F03D 4D            [ 4] 2446         LD      C,L
   F03E CA 54 F7      [ 9] 2447         JP      Z,POPHRT        ; Jump if array load/save
   F041 96            [ 6] 2448         SUB     (HL)            ; Same number of dimensions?
   F042 CA A8 F0      [ 9] 2449         JP      Z,FINDEL        ; Yes - Find element
   F045 1E 10         [ 6] 2450 BSERR:  LD      E,#BS            ; ?BS Error
   F047 C3 C1 E3      [ 9] 2451         JP      ERROR           ; Output error
                           2452 
   F04A 11 04 00      [ 9] 2453 CREARY: LD      DE,#4            ; 4 Bytes per entry
   F04D F1            [ 9] 2454         POP     AF              ; Array to save or 0 dim'ns?
   F04E CA A0 E9      [ 9] 2455         JP      Z,FCERR         ; Yes - ?FC Error
   F051 71            [ 7] 2456         LD      (HL),C          ; Save second byte of name
   F052 23            [ 4] 2457         INC     HL
   F053 70            [ 7] 2458         LD      (HL),B          ; Save first byte of name
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 46.
Hexadecimal [16-Bits]



   F054 23            [ 4] 2459         INC     HL
   F055 4F            [ 4] 2460         LD      C,A             ; Number of dimensions to C
   F056 CD 8A E3      [16] 2461         CALL    CHKSTK          ; Check if enough memory
   F059 23            [ 4] 2462         INC     HL              ; Point to number of dimensions
   F05A 23            [ 4] 2463         INC     HL
   F05B 22 C5 10      [16] 2464         LD      (CUROPR),HL     ; Save address of pointer
   F05E 71            [ 7] 2465         LD      (HL),C          ; Set number of dimensions
   F05F 23            [ 4] 2466         INC     HL
   F060 3A AC 10      [12] 2467         LD      A,(LCRFLG)      ; Locate of Create?
   F063 17            [ 3] 2468         RLA                     ; Carry set = Create
   F064 79            [ 4] 2469         LD      A,C             ; Get number of dimensions
   F065 01 0B 00      [ 9] 2470 CRARLP: LD      BC,#10+1         ; Default dimension size 10
   F068 D2 6D F0      [ 9] 2471         JP      NC,DEFSIZ       ; Locate - Set default size
   F06B C1            [ 9] 2472         POP     BC              ; Get specified dimension size
   F06C 03            [ 4] 2473         INC     BC              ; Include zero element
   F06D 71            [ 7] 2474 DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
   F06E 23            [ 4] 2475         INC     HL
   F06F 70            [ 7] 2476         LD      (HL),B          ; Save MSB of dimension size
   F070 23            [ 4] 2477         INC     HL
   F071 F5            [11] 2478         PUSH    AF              ; Save num' of dim'ns an status
   F072 E5            [11] 2479         PUSH    HL              ; Save address of dim'n size
   F073 CD FF F8      [16] 2480         CALL    MLDEBC          ; Multiply DE by BC to find
   F076 EB            [ 3] 2481         EX      DE,HL           ; amount of mem needed (to DE)
   F077 E1            [ 9] 2482         POP     HL              ; Restore address of dimension
   F078 F1            [ 9] 2483         POP     AF              ; Restore number of dimensions
   F079 3D            [ 4] 2484         DEC     A               ; Count them
   F07A C2 65 F0      [ 9] 2485         JP      NZ,CRARLP       ; Do next dimension if more
   F07D F5            [11] 2486         PUSH    AF              ; Save locate/create flag
   F07E 42            [ 4] 2487         LD      B,D             ; MSB of memory needed
   F07F 4B            [ 4] 2488         LD      C,E             ; LSB of memory needed
   F080 EB            [ 3] 2489         EX      DE,HL
   F081 19            [ 7] 2490         ADD     HL,DE           ; Add bytes to array start
   F082 DA A2 E3      [ 9] 2491         JP      C,OMERR         ; Too big - Error
   F085 CD 93 E3      [16] 2492         CALL    ENFMEM          ; See if enough memory
   F088 22 DA 10      [16] 2493         LD      (ARREND),HL     ; Save new end of array
                           2494 
   F08B 2B            [ 4] 2495 ZERARY: DEC     HL              ; Back through array data
   F08C 36 00         [ 9] 2496         LD      (HL),#0          ; Set array element to zero
   F08E CD 8A E6      [16] 2497         CALL    CPDEHL          ; All elements zeroed?
   F091 C2 8B F0      [ 9] 2498         JP      NZ,ZERARY       ; No - Keep on going
   F094 03            [ 4] 2499         INC     BC              ; Number of bytes + 1
   F095 57            [ 4] 2500         LD      D,A             ; A=0
   F096 2A C5 10      [15] 2501         LD      HL,(CUROPR)     ; Get address of array
   F099 5E            [ 6] 2502         LD      E,(HL)          ; Number of dimensions
   F09A EB            [ 3] 2503         EX      DE,HL           ; To HL
   F09B 29            [ 7] 2504         ADD     HL,HL           ; Two bytes per dimension size
   F09C 09            [ 7] 2505         ADD     HL,BC           ; Add number of bytes
   F09D EB            [ 3] 2506         EX      DE,HL           ; Bytes needed to DE
   F09E 2B            [ 4] 2507         DEC     HL
   F09F 2B            [ 4] 2508         DEC     HL
   F0A0 73            [ 7] 2509         LD      (HL),E          ; Save LSB of bytes needed
   F0A1 23            [ 4] 2510         INC     HL
   F0A2 72            [ 7] 2511         LD      (HL),D          ; Save MSB of bytes needed
   F0A3 23            [ 4] 2512         INC     HL
   F0A4 F1            [ 9] 2513         POP     AF              ; Locate / Create?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 47.
Hexadecimal [16-Bits]



   F0A5 DA CC F0      [ 9] 2514         JP      C,ENDDIM        ; A is 0 , End if create
   F0A8 47            [ 4] 2515 FINDEL: LD      B,A             ; Find array element
   F0A9 4F            [ 4] 2516         LD      C,A
   F0AA 7E            [ 6] 2517         LD      A,(HL)          ; Number of dimensions
   F0AB 23            [ 4] 2518         INC     HL
   F0AC 16                 2519         .db      0x16             ; Skip "POP HL"
   F0AD E1            [ 9] 2520 FNDELP: POP     HL              ; Address of next dim' size
   F0AE 5E            [ 6] 2521         LD      E,(HL)          ; Get LSB of dim'n size
   F0AF 23            [ 4] 2522         INC     HL
   F0B0 56            [ 6] 2523         LD      D,(HL)          ; Get MSB of dim'n size
   F0B1 23            [ 4] 2524         INC     HL
   F0B2 E3            [16] 2525         EX      (SP),HL         ; Save address - Get index
   F0B3 F5            [11] 2526         PUSH    AF              ; Save number of dim'ns
   F0B4 CD 8A E6      [16] 2527         CALL    CPDEHL          ; Dimension too large?
   F0B7 D2 45 F0      [ 9] 2528         JP      NC,BSERR        ; Yes - ?BS Error
   F0BA E5            [11] 2529         PUSH    HL              ; Save index
   F0BB CD FF F8      [16] 2530         CALL    MLDEBC          ; Multiply previous by size
   F0BE D1            [ 9] 2531         POP     DE              ; Index supplied to DE
   F0BF 19            [ 7] 2532         ADD     HL,DE           ; Add index to pointer
   F0C0 F1            [ 9] 2533         POP     AF              ; Number of dimensions
   F0C1 3D            [ 4] 2534         DEC     A               ; Count them
   F0C2 44            [ 4] 2535         LD      B,H             ; MSB of pointer
   F0C3 4D            [ 4] 2536         LD      C,L             ; LSB of pointer
   F0C4 C2 AD F0      [ 9] 2537         JP      NZ,FNDELP       ; More - Keep going
   F0C7 29            [ 7] 2538         ADD     HL,HL           ; 4 Bytes per element
   F0C8 29            [ 7] 2539         ADD     HL,HL
   F0C9 C1            [ 9] 2540         POP     BC              ; Start of array
   F0CA 09            [ 7] 2541         ADD     HL,BC           ; Point to element
   F0CB EB            [ 3] 2542         EX      DE,HL           ; Address of element to DE
   F0CC 2A D0 10      [15] 2543 ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
   F0CF C9            [ 9] 2544         RET
                           2545 
   F0D0 2A DA 10      [15] 2546 FRE:    LD      HL,(ARREND)     ; Start of free memory
   F0D3 EB            [ 3] 2547         EX      DE,HL           ; To DE
   F0D4 21 00 00      [ 9] 2548         LD      HL,#0            ; End of free memory
   F0D7 39            [ 7] 2549         ADD     HL,SP           ; Current stack value
   F0D8 3A AD 10      [12] 2550         LD      A,(TYPE)        ; Dummy argument type
   F0DB B7            [ 4] 2551         OR      A
   F0DC CA EC F0      [ 9] 2552         JP      Z,FRENUM        ; Numeric - Free variable space
   F0DF CD 53 F3      [16] 2553         CALL    GSTRCU          ; Current string to pool
   F0E2 CD 53 F2      [16] 2554         CALL    GARBGE          ; Garbage collection
   F0E5 2A 5A 10      [15] 2555         LD      HL,(STRSPC)     ; Bottom of string space in use
   F0E8 EB            [ 3] 2556         EX      DE,HL           ; To DE
   F0E9 2A C3 10      [15] 2557         LD      HL,(STRBOT)     ; Bottom of string space
   F0EC 7D            [ 4] 2558 FRENUM: LD      A,L             ; Get LSB of end
   F0ED 93            [ 4] 2559         SUB     E               ; Subtract LSB of beginning
   F0EE 4F            [ 4] 2560         LD      C,A             ; Save difference if C
   F0EF 7C            [ 4] 2561         LD      A,H             ; Get MSB of end
   F0F0 9A            [ 4] 2562         SBC     A,D             ; Subtract MSB of beginning
   F0F1 41            [ 4] 2563 ACPASS: LD      B,C             ; Return integer AC
   F0F2 50            [ 4] 2564 ABPASS: LD      D,B             ; Return integer AB
   F0F3 1E 00         [ 6] 2565         LD      E,#0
   F0F5 21 AD 10      [ 9] 2566         LD      HL,#TYPE         ; Point to type
   F0F8 73            [ 7] 2567         LD      (HL),E          ; Set type to numeric
   F0F9 06 90         [ 6] 2568         LD      B,#0x80+16        ; 16 bit integer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 48.
Hexadecimal [16-Bits]



   F0FB C3 2A F8      [ 9] 2569         JP      RETINT          ; Return the integr
                           2570 
   F0FE 3A AB 10      [12] 2571 POS:    LD      A,(CURPOS)      ; Get cursor position
   F101 47            [ 4] 2572 PASSA:  LD      B,A             ; Put A into AB
   F102 AF            [ 4] 2573         XOR     A               ; Zero A
   F103 C3 F2 F0      [ 9] 2574         JP      ABPASS          ; Return integer AB
                           2575 
   F106 CD 89 F1      [16] 2576 DEF:    CALL    CHEKFN          ; Get "FN" and name
   F109 CD 7B F1      [16] 2577         CALL    IDTEST          ; Test for illegal direct
   F10C 01 70 EA      [ 9] 2578         LD      BC,#DATA         ; To get next statement
   F10F C5            [11] 2579         PUSH    BC              ; Save address for RETurn
   F110 D5            [11] 2580         PUSH    DE              ; Save address of function ptr
   F111 CD 90 E6      [16] 2581         CALL    CHKSYN          ; Make sure "(" follows
   F114 28                 2582         .db      "("
   F115 CD 2D EF      [16] 2583         CALL    GETVAR          ; Get argument variable name
   F118 E5            [11] 2584         PUSH    HL              ; Save code string address
   F119 EB            [ 3] 2585         EX      DE,HL           ; Argument address to HL
   F11A 2B            [ 4] 2586         DEC     HL
   F11B 56            [ 6] 2587         LD      D,(HL)          ; Get first byte of arg name
   F11C 2B            [ 4] 2588         DEC     HL
   F11D 5E            [ 6] 2589         LD      E,(HL)          ; Get second byte of arg name
   F11E E1            [ 9] 2590         POP     HL              ; Restore code string address
   F11F CD 44 ED      [16] 2591         CALL    TSTNUM          ; Make sure numeric argument
   F122 CD 90 E6      [16] 2592         CALL    CHKSYN          ; Make sure ")" follows
   F125 29                 2593         .db      ")"
   F126 CD 90 E6      [16] 2594         CALL    CHKSYN          ; Make sure "=" follows
   F129 B4                 2595         .db      ZEQUAL          ; "=" token
   F12A 44            [ 4] 2596         LD      B,H             ; Code string address to BC
   F12B 4D            [ 4] 2597         LD      C,L
   F12C E3            [16] 2598         EX      (SP),HL         ; Save code str , Get FN ptr
   F12D 71            [ 7] 2599         LD      (HL),C          ; Save LSB of FN code string
   F12E 23            [ 4] 2600         INC     HL
   F12F 70            [ 7] 2601         LD      (HL),B          ; Save MSB of FN code string
   F130 C3 C8 F1      [ 9] 2602         JP      SVSTAD          ; Save address and do function
                           2603 
   F133 CD 89 F1      [16] 2604 DOFN:   CALL    CHEKFN          ; Make sure FN follows
   F136 D5            [11] 2605         PUSH    DE              ; Save function pointer address
   F137 CD 09 EE      [16] 2606         CALL    EVLPAR          ; Evaluate expression in "()"
   F13A CD 44 ED      [16] 2607         CALL    TSTNUM          ; Make sure numeric result
   F13D E3            [16] 2608         EX      (SP),HL         ; Save code str , Get FN ptr
   F13E 5E            [ 6] 2609         LD      E,(HL)          ; Get LSB of FN code string
   F13F 23            [ 4] 2610         INC     HL
   F140 56            [ 6] 2611         LD      D,(HL)          ; Get MSB of FN code string
   F141 23            [ 4] 2612         INC     HL
   F142 7A            [ 4] 2613         LD      A,D             ; And function DEFined?
   F143 B3            [ 4] 2614         OR      E
   F144 CA B9 E3      [ 9] 2615         JP      Z,UFERR         ; No - ?UF Error
   F147 7E            [ 6] 2616         LD      A,(HL)          ; Get LSB of argument address
   F148 23            [ 4] 2617         INC     HL
   F149 66            [ 6] 2618         LD      H,(HL)          ; Get MSB of argument address
   F14A 6F            [ 4] 2619         LD      L,A             ; HL = Arg variable address
   F14B E5            [11] 2620         PUSH    HL              ; Save it
   F14C 2A DE 10      [15] 2621         LD      HL,(FNRGNM)     ; Get old argument name
   F14F E3            [16] 2622         EX      (SP),HL ;       ; Save old , Get new
   F150 22 DE 10      [16] 2623         LD      (FNRGNM),HL     ; Set new argument name
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 49.
Hexadecimal [16-Bits]



   F153 2A E2 10      [15] 2624         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
   F156 E5            [11] 2625         PUSH    HL              ; Save it
   F157 2A E0 10      [15] 2626         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
   F15A E5            [11] 2627         PUSH    HL              ; Save it
   F15B 21 E0 10      [ 9] 2628         LD      HL,#FNARG        ; HL = Value of argument
   F15E D5            [11] 2629         PUSH    DE              ; Save FN code string address
   F15F CD 6B F8      [16] 2630         CALL    FPTHL           ; Move FPREG to argument
   F162 E1            [ 9] 2631         POP     HL              ; Get FN code string address
   F163 CD 41 ED      [16] 2632         CALL    GETNUM          ; Get value from function
   F166 2B            [ 4] 2633         DEC     HL              ; DEC 'cos GETCHR INCs
   F167 CD 36 E8      [16] 2634         CALL    GETCHR          ; Get next character
   F16A C2 AD E3      [ 9] 2635         JP      NZ,SNERR        ; Bad character in FN - Error
   F16D E1            [ 9] 2636         POP     HL              ; Get MSB,EXP of old arg
   F16E 22 E0 10      [16] 2637         LD      (FNARG),HL      ; Restore it
   F171 E1            [ 9] 2638         POP     HL              ; Get LSB,NLSB of old arg
   F172 22 E2 10      [16] 2639         LD      (FNARG+2),HL    ; Restore it
   F175 E1            [ 9] 2640         POP     HL              ; Get name of old arg
   F176 22 DE 10      [16] 2641         LD      (FNRGNM),HL     ; Restore it
   F179 E1            [ 9] 2642         POP     HL              ; Restore code string address
   F17A C9            [ 9] 2643         RET
                           2644 
   F17B E5            [11] 2645 IDTEST: PUSH    HL              ; Save code string address
   F17C 2A 5C 10      [15] 2646         LD      HL,(LINEAT)     ; Get current line number
   F17F 23            [ 4] 2647         INC     HL              ; -1 means direct statement
   F180 7C            [ 4] 2648         LD      A,H
   F181 B5            [ 4] 2649         OR      L
   F182 E1            [ 9] 2650         POP     HL              ; Restore code string address
   F183 C0            [10] 2651         RET     NZ              ; Return if in program
   F184 1E 16         [ 6] 2652         LD      E,#ID            ; ?ID Error
   F186 C3 C1 E3      [ 9] 2653         JP      ERROR
                           2654 
   F189 CD 90 E6      [16] 2655 CHEKFN: CALL    CHKSYN          ; Make sure FN follows
   F18C A7                 2656         .db      ZFN             ; "FN" token
   F18D 3E 80         [ 6] 2657         LD      A,#0x80
   F18F 32 CB 10      [13] 2658         LD      (FORFLG),A      ; Flag FN name to find
   F192 B6            [ 6] 2659         OR      (HL)            ; FN name has bit 7 set
   F193 47            [ 4] 2660         LD      B,A             ; in first byte of name
   F194 CD 32 EF      [16] 2661         CALL    GTFNAM          ; Get FN name
   F197 C3 44 ED      [ 9] 2662         JP      TSTNUM          ; Make sure numeric function
                           2663 
   F19A CD 44 ED      [16] 2664 STR:    CALL    TSTNUM          ; Make sure it's a number
   F19D CD B8 F9      [16] 2665         CALL    NUMASC          ; Turn number into text
   F1A0 CD CE F1      [16] 2666         CALL    CRTST           ; Create string entry for it
   F1A3 CD 53 F3      [16] 2667         CALL    GSTRCU          ; Current string to pool
   F1A6 01 AE F3      [ 9] 2668         LD      BC,#TOPOOL       ; Save in string pool
   F1A9 C5            [11] 2669         PUSH    BC              ; Save address on stack
                           2670 
   F1AA 7E            [ 6] 2671 SAVSTR: LD      A,(HL)          ; Get string length
   F1AB 23            [ 4] 2672         INC     HL
   F1AC 23            [ 4] 2673         INC     HL
   F1AD E5            [11] 2674         PUSH    HL              ; Save pointer to string
   F1AE CD 29 F2      [16] 2675         CALL    TESTR           ; See if enough string space
   F1B1 E1            [ 9] 2676         POP     HL              ; Restore pointer to string
   F1B2 4E            [ 6] 2677         LD      C,(HL)          ; Get LSB of address
   F1B3 23            [ 4] 2678         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 50.
Hexadecimal [16-Bits]



   F1B4 46            [ 6] 2679         LD      B,(HL)          ; Get MSB of address
   F1B5 CD C2 F1      [16] 2680         CALL    CRTMST          ; Create string entry
   F1B8 E5            [11] 2681         PUSH    HL              ; Save pointer to MSB of addr
   F1B9 6F            [ 4] 2682         LD      L,A             ; Length of string
   F1BA CD 46 F3      [16] 2683         CALL    TOSTRA          ; Move to string area
   F1BD D1            [ 9] 2684         POP     DE              ; Restore pointer to MSB
   F1BE C9            [ 9] 2685         RET
                           2686 
   F1BF CD 29 F2      [16] 2687 MKTMST: CALL    TESTR           ; See if enough string space
   F1C2 21 BF 10      [ 9] 2688 CRTMST: LD      HL,#TMPSTR       ; Temporary string
   F1C5 E5            [11] 2689         PUSH    HL              ; Save it
   F1C6 77            [ 7] 2690         LD      (HL),A          ; Save length of string
   F1C7 23            [ 4] 2691         INC     HL
   F1C8 23            [ 4] 2692 SVSTAD: INC     HL
   F1C9 73            [ 7] 2693         LD      (HL),E          ; Save LSB of address
   F1CA 23            [ 4] 2694         INC     HL
   F1CB 72            [ 7] 2695         LD      (HL),D          ; Save MSB of address
   F1CC E1            [ 9] 2696         POP     HL              ; Restore pointer
   F1CD C9            [ 9] 2697         RET
                           2698 
   F1CE 2B            [ 4] 2699 CRTST:  DEC     HL              ; DEC - INCed after
   F1CF 06 22         [ 6] 2700 QTSTR:  LD      B,#'"'           ; Terminating quote"
   F1D1 50            [ 4] 2701         LD      D,B             ; Quote to D
   F1D2 E5            [11] 2702 DTSTR:  PUSH    HL              ; Save start
   F1D3 0E FF         [ 6] 2703         LD      C,#-1            ; Set counter to -1
   F1D5 23            [ 4] 2704 QTSTLP: INC     HL              ; Move on
   F1D6 7E            [ 6] 2705         LD      A,(HL)          ; Get byte
   F1D7 0C            [ 4] 2706         INC     C               ; Count bytes
   F1D8 B7            [ 4] 2707         OR      A               ; End of line?
   F1D9 CA E4 F1      [ 9] 2708         JP      Z,CRTSTE        ; Yes - Create string entry
   F1DC BA            [ 4] 2709         CP      D               ; Terminator D found?
   F1DD CA E4 F1      [ 9] 2710         JP      Z,CRTSTE        ; Yes - Create string entry
   F1E0 B8            [ 4] 2711         CP      B               ; Terminator B found?
   F1E1 C2 D5 F1      [ 9] 2712         JP      NZ,QTSTLP       ; No - Keep looking
   F1E4 FE 22         [ 6] 2713 CRTSTE: CP      #'"'             ; End with '"'?
   F1E6 CC 36 E8      [16] 2714         CALL    Z,GETCHR        ; Yes - Get next character
   F1E9 E3            [16] 2715         EX      (SP),HL         ; Starting quote
   F1EA 23            [ 4] 2716         INC     HL              ; First byte of string
   F1EB EB            [ 3] 2717         EX      DE,HL           ; To DE
   F1EC 79            [ 4] 2718         LD      A,C             ; Get length
   F1ED CD C2 F1      [16] 2719         CALL    CRTMST          ; Create string entry
   F1F0 11 BF 10      [ 9] 2720 TSTOPL: LD      DE,#TMPSTR       ; Temporary string
   F1F3 2A B1 10      [15] 2721         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   F1F6 22 E4 10      [16] 2722         LD      (FPREG),HL      ; Save address of string ptr
   F1F9 3E 01         [ 6] 2723         LD      A,#1
   F1FB 32 AD 10      [13] 2724         LD      (TYPE),A        ; Set type to string
   F1FE CD 6E F8      [16] 2725         CALL    DETHL4          ; Move string to pool
   F201 CD 8A E6      [16] 2726         CALL    CPDEHL          ; Out of string pool?
   F204 22 B1 10      [16] 2727         LD      (TMSTPT),HL     ; Save new pointer
   F207 E1            [ 9] 2728         POP     HL              ; Restore code string address
   F208 7E            [ 6] 2729         LD      A,(HL)          ; Get next code byte
   F209 C0            [10] 2730         RET     NZ              ; Return if pool OK
   F20A 1E 1E         [ 6] 2731         LD      E,#ST            ; ?ST Error
   F20C C3 C1 E3      [ 9] 2732         JP      ERROR           ; String pool overflow
                           2733 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 51.
Hexadecimal [16-Bits]



   F20F 23            [ 4] 2734 PRNUMS: INC     HL              ; Skip leading space
   F210 CD CE F1      [16] 2735 PRS:    CALL    CRTST           ; Create string entry for it
   F213 CD 53 F3      [16] 2736 PRS1:   CALL    GSTRCU          ; Current string to pool
   F216 CD 62 F8      [16] 2737         CALL    LOADFP          ; Move string block to BCDE
   F219 1C            [ 4] 2738         INC     E               ; Length + 1
   F21A 1D            [ 4] 2739 PRSLP:  DEC     E               ; Count characters
   F21B C8            [10] 2740         RET     Z               ; End of string
   F21C 0A            [ 6] 2741         LD      A,(BC)          ; Get byte to output
   F21D CD 9B E6      [16] 2742         CALL    OUTC            ; Output character in A
   F220 FE 0D         [ 6] 2743         CP      #CR              ; Return?
   F222 CC 86 EB      [16] 2744         CALL    Z,DONULL        ; Yes - Do nulls
   F225 03            [ 4] 2745         INC     BC              ; Next byte in string
   F226 C3 1A F2      [ 9] 2746         JP      PRSLP           ; More characters to output
                           2747 
   F229 B7            [ 4] 2748 TESTR:  OR      A               ; Test if enough room
   F22A 0E                 2749         .db      0x0E             ; No garbage collection done
   F22B F1            [ 9] 2750 GRBDON: POP     AF              ; Garbage collection done
   F22C F5            [11] 2751         PUSH    AF              ; Save status
   F22D 2A 5A 10      [15] 2752         LD      HL,(STRSPC)     ; Bottom of string space in use
   F230 EB            [ 3] 2753         EX      DE,HL           ; To DE
   F231 2A C3 10      [15] 2754         LD      HL,(STRBOT)     ; Bottom of string area
   F234 2F            [ 3] 2755         CPL                     ; Negate length (Top down)
   F235 4F            [ 4] 2756         LD      C,A             ; -Length to BC
   F236 06 FF         [ 6] 2757         LD      B,#-1            ; BC = -ve length of string
   F238 09            [ 7] 2758         ADD     HL,BC           ; Add to bottom of space in use
   F239 23            [ 4] 2759         INC     HL              ; Plus one for 2's complement
   F23A CD 8A E6      [16] 2760         CALL    CPDEHL          ; Below string RAM area?
   F23D DA 47 F2      [ 9] 2761         JP      C,TESTOS        ; Tidy up if not done else err
   F240 22 C3 10      [16] 2762         LD      (STRBOT),HL     ; Save new bottom of area
   F243 23            [ 4] 2763         INC     HL              ; Point to first byte of string
   F244 EB            [ 3] 2764         EX      DE,HL           ; Address to DE
   F245 F1            [ 9] 2765 POPAF:  POP     AF              ; Throw away status push
   F246 C9            [ 9] 2766         RET
                           2767 
   F247 F1            [ 9] 2768 TESTOS: POP     AF              ; Garbage collect been done?
   F248 1E 1A         [ 6] 2769         LD      E,#OS            ; ?OS Error
   F24A CA C1 E3      [ 9] 2770         JP      Z,ERROR         ; Yes - Not enough string apace
   F24D BF            [ 4] 2771         CP      A               ; Flag garbage collect done
   F24E F5            [11] 2772         PUSH    AF              ; Save status
   F24F 01 2B F2      [ 9] 2773         LD      BC,#GRBDON       ; Garbage collection done
   F252 C5            [11] 2774         PUSH    BC              ; Save for RETurn
   F253 2A AF 10      [15] 2775 GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
   F256 22 C3 10      [16] 2776 GARBLP: LD      (STRBOT),HL     ; Reset string pointer
   F259 21 00 00      [ 9] 2777         LD      HL,#0
   F25C E5            [11] 2778         PUSH    HL              ; Flag no string found
   F25D 2A 5A 10      [15] 2779         LD      HL,(STRSPC)     ; Get bottom of string space
   F260 E5            [11] 2780         PUSH    HL              ; Save bottom of string space
   F261 21 B3 10      [ 9] 2781         LD      HL,#TMSTPL       ; Temporary string pool
   F264 EB            [ 3] 2782 GRBLP:  EX      DE,HL
   F265 2A B1 10      [15] 2783         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   F268 EB            [ 3] 2784         EX      DE,HL
   F269 CD 8A E6      [16] 2785         CALL    CPDEHL          ; Temporary string pool done?
   F26C 01 64 F2      [ 9] 2786         LD      BC,#GRBLP        ; Loop until string pool done
   F26F C2 B8 F2      [ 9] 2787         JP      NZ,STPOOL       ; No - See if in string area
   F272 2A D6 10      [15] 2788         LD      HL,(PROGND)     ; Start of simple variables
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 52.
Hexadecimal [16-Bits]



   F275 EB            [ 3] 2789 SMPVAR: EX      DE,HL
   F276 2A D8 10      [15] 2790         LD      HL,(VAREND)     ; End of simple variables
   F279 EB            [ 3] 2791         EX      DE,HL
   F27A CD 8A E6      [16] 2792         CALL    CPDEHL          ; All simple strings done?
   F27D CA 8B F2      [ 9] 2793         JP      Z,ARRLP         ; Yes - Do string arrays
   F280 7E            [ 6] 2794         LD      A,(HL)          ; Get type of variable
   F281 23            [ 4] 2795         INC     HL
   F282 23            [ 4] 2796         INC     HL
   F283 B7            [ 4] 2797         OR      A               ; "S" flag set if string
   F284 CD BB F2      [16] 2798         CALL    STRADD          ; See if string in string area
   F287 C3 75 F2      [ 9] 2799         JP      SMPVAR          ; Loop until simple ones done
                           2800 
   F28A C1            [ 9] 2801 GNXARY: POP     BC              ; Scrap address of this array
   F28B EB            [ 3] 2802 ARRLP:  EX      DE,HL
   F28C 2A DA 10      [15] 2803         LD      HL,(ARREND)     ; End of string arrays
   F28F EB            [ 3] 2804         EX      DE,HL
   F290 CD 8A E6      [16] 2805         CALL    CPDEHL          ; All string arrays done?
   F293 CA E1 F2      [ 9] 2806         JP      Z,SCNEND        ; Yes - Move string if found
   F296 CD 62 F8      [16] 2807         CALL    LOADFP          ; Get array name to BCDE
   F299 7B            [ 4] 2808         LD      A,E             ; Get type of array     
   F29A E5            [11] 2809         PUSH    HL              ; Save address of num of dim'ns
   F29B 09            [ 7] 2810         ADD     HL,BC           ; Start of next array
   F29C B7            [ 4] 2811         OR      A               ; Test type of array
   F29D F2 8A F2      [ 9] 2812         JP      P,GNXARY        ; Numeric array - Ignore it
   F2A0 22 C5 10      [16] 2813         LD      (CUROPR),HL     ; Save address of next array
   F2A3 E1            [ 9] 2814         POP     HL              ; Get address of num of dim'ns
   F2A4 4E            [ 6] 2815         LD      C,(HL)          ; BC = Number of dimensions
   F2A5 06 00         [ 6] 2816         LD      B,#0
   F2A7 09            [ 7] 2817         ADD     HL,BC           ; Two bytes per dimension size
   F2A8 09            [ 7] 2818         ADD     HL,BC
   F2A9 23            [ 4] 2819         INC     HL              ; Plus one for number of dim'ns
   F2AA EB            [ 3] 2820 GRBARY: EX      DE,HL
   F2AB 2A C5 10      [15] 2821         LD      HL,(CUROPR)     ; Get address of next array
   F2AE EB            [ 3] 2822         EX      DE,HL
   F2AF CD 8A E6      [16] 2823         CALL    CPDEHL          ; Is this array finished?
   F2B2 CA 8B F2      [ 9] 2824         JP      Z,ARRLP         ; Yes - Get next one
   F2B5 01 AA F2      [ 9] 2825         LD      BC,#GRBARY       ; Loop until array all done
   F2B8 C5            [11] 2826 STPOOL: PUSH    BC              ; Save return address
   F2B9 F6 80         [ 6] 2827         OR      #0x80             ; Flag string type
   F2BB 7E            [ 6] 2828 STRADD: LD      A,(HL)          ; Get string length
   F2BC 23            [ 4] 2829         INC     HL
   F2BD 23            [ 4] 2830         INC     HL
   F2BE 5E            [ 6] 2831         LD      E,(HL)          ; Get LSB of string address
   F2BF 23            [ 4] 2832         INC     HL
   F2C0 56            [ 6] 2833         LD      D,(HL)          ; Get MSB of string address
   F2C1 23            [ 4] 2834         INC     HL
   F2C2 F0            [10] 2835         RET     P               ; Not a string - Return
   F2C3 B7            [ 4] 2836         OR      A               ; Set flags on string length
   F2C4 C8            [10] 2837         RET     Z               ; Null string - Return
   F2C5 44            [ 4] 2838         LD      B,H             ; Save variable pointer
   F2C6 4D            [ 4] 2839         LD      C,L
   F2C7 2A C3 10      [15] 2840         LD      HL,(STRBOT)     ; Bottom of new area
   F2CA CD 8A E6      [16] 2841         CALL    CPDEHL          ; String been done?
   F2CD 60            [ 4] 2842         LD      H,B             ; Restore variable pointer
   F2CE 69            [ 4] 2843         LD      L,C
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 53.
Hexadecimal [16-Bits]



   F2CF D8            [10] 2844         RET     C               ; String done - Ignore
   F2D0 E1            [ 9] 2845         POP     HL              ; Return address
   F2D1 E3            [16] 2846         EX      (SP),HL         ; Lowest available string area
   F2D2 CD 8A E6      [16] 2847         CALL    CPDEHL          ; String within string area?
   F2D5 E3            [16] 2848         EX      (SP),HL         ; Lowest available string area
   F2D6 E5            [11] 2849         PUSH    HL              ; Re-save return address
   F2D7 60            [ 4] 2850         LD      H,B             ; Restore variable pointer
   F2D8 69            [ 4] 2851         LD      L,C
   F2D9 D0            [10] 2852         RET     NC              ; Outside string area - Ignore
   F2DA C1            [ 9] 2853         POP     BC              ; Get return , Throw 2 away
   F2DB F1            [ 9] 2854         POP     AF              ; 
   F2DC F1            [ 9] 2855         POP     AF              ; 
   F2DD E5            [11] 2856         PUSH    HL              ; Save variable pointer
   F2DE D5            [11] 2857         PUSH    DE              ; Save address of current
   F2DF C5            [11] 2858         PUSH    BC              ; Put back return address
   F2E0 C9            [ 9] 2859         RET                     ; Go to it
                           2860 
   F2E1 D1            [ 9] 2861 SCNEND: POP     DE              ; Addresses of strings
   F2E2 E1            [ 9] 2862         POP     HL              ; 
   F2E3 7D            [ 4] 2863         LD      A,L             ; HL = 0 if no more to do
   F2E4 B4            [ 4] 2864         OR      H
   F2E5 C8            [10] 2865         RET     Z               ; No more to do - Return
   F2E6 2B            [ 4] 2866         DEC     HL
   F2E7 46            [ 6] 2867         LD      B,(HL)          ; MSB of address of string
   F2E8 2B            [ 4] 2868         DEC     HL
   F2E9 4E            [ 6] 2869         LD      C,(HL)          ; LSB of address of string
   F2EA E5            [11] 2870         PUSH    HL              ; Save variable address
   F2EB 2B            [ 4] 2871         DEC     HL
   F2EC 2B            [ 4] 2872         DEC     HL
   F2ED 6E            [ 6] 2873         LD      L,(HL)          ; HL = Length of string
   F2EE 26 00         [ 6] 2874         LD      H,#0
   F2F0 09            [ 7] 2875         ADD     HL,BC           ; Address of end of string+1
   F2F1 50            [ 4] 2876         LD      D,B             ; String address to DE
   F2F2 59            [ 4] 2877         LD      E,C
   F2F3 2B            [ 4] 2878         DEC     HL              ; Last byte in string
   F2F4 44            [ 4] 2879         LD      B,H             ; Address to BC
   F2F5 4D            [ 4] 2880         LD      C,L
   F2F6 2A C3 10      [15] 2881         LD      HL,(STRBOT)     ; Current bottom of string area
   F2F9 CD 7C E3      [16] 2882         CALL    MOVSTR          ; Move string to new address
   F2FC E1            [ 9] 2883         POP     HL              ; Restore variable address
   F2FD 71            [ 7] 2884         LD      (HL),C          ; Save new LSB of address
   F2FE 23            [ 4] 2885         INC     HL
   F2FF 70            [ 7] 2886         LD      (HL),B          ; Save new MSB of address
   F300 69            [ 4] 2887         LD      L,C             ; Next string area+1 to HL
   F301 60            [ 4] 2888         LD      H,B
   F302 2B            [ 4] 2889         DEC     HL              ; Next string area address
   F303 C3 56 F2      [ 9] 2890         JP      GARBLP          ; Look for more strings
                           2891 
   F306 C5            [11] 2892 CONCAT: PUSH    BC              ; Save prec' opr & code string
   F307 E5            [11] 2893         PUSH    HL              ; 
   F308 2A E4 10      [15] 2894         LD      HL,(FPREG)      ; Get first string
   F30B E3            [16] 2895         EX      (SP),HL         ; Save first string
   F30C CD D1 ED      [16] 2896         CALL    OPRND           ; Get second string
   F30F E3            [16] 2897         EX      (SP),HL         ; Restore first string
   F310 CD 45 ED      [16] 2898         CALL    TSTSTR          ; Make sure it's a string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 54.
Hexadecimal [16-Bits]



   F313 7E            [ 6] 2899         LD      A,(HL)          ; Get length of second string
   F314 E5            [11] 2900         PUSH    HL              ; Save first string
   F315 2A E4 10      [15] 2901         LD      HL,(FPREG)      ; Get second string
   F318 E5            [11] 2902         PUSH    HL              ; Save second string
   F319 86            [ 6] 2903         ADD     A,(HL)          ; Add length of second string
   F31A 1E 1C         [ 6] 2904         LD      E,#LS            ; ?LS Error
   F31C DA C1 E3      [ 9] 2905         JP      C,ERROR         ; String too long - Error
   F31F CD BF F1      [16] 2906         CALL    MKTMST          ; Make temporary string
   F322 D1            [ 9] 2907         POP     DE              ; Get second string to DE
   F323 CD 57 F3      [16] 2908         CALL    GSTRDE          ; Move to string pool if needed
   F326 E3            [16] 2909         EX      (SP),HL         ; Get first string
   F327 CD 56 F3      [16] 2910         CALL    GSTRHL          ; Move to string pool if needed
   F32A E5            [11] 2911         PUSH    HL              ; Save first string
   F32B 2A C1 10      [15] 2912         LD      HL,(TMPSTR+2)   ; Temporary string address
   F32E EB            [ 3] 2913         EX      DE,HL           ; To DE
   F32F CD 3D F3      [16] 2914         CALL    SSTSA           ; First string to string area
   F332 CD 3D F3      [16] 2915         CALL    SSTSA           ; Second string to string area
   F335 21 66 ED      [ 9] 2916         LD      HL,#EVAL2        ; Return to evaluation loop
   F338 E3            [16] 2917         EX      (SP),HL         ; Save return,get code string
   F339 E5            [11] 2918         PUSH    HL              ; Save code string address
   F33A C3 F0 F1      [ 9] 2919         JP      TSTOPL          ; To temporary string to pool
                           2920 
   F33D E1            [ 9] 2921 SSTSA:  POP     HL              ; Return address
   F33E E3            [16] 2922         EX      (SP),HL         ; Get string block,save return
   F33F 7E            [ 6] 2923         LD      A,(HL)          ; Get length of string
   F340 23            [ 4] 2924         INC     HL
   F341 23            [ 4] 2925         INC     HL
   F342 4E            [ 6] 2926         LD      C,(HL)          ; Get LSB of string address
   F343 23            [ 4] 2927         INC     HL
   F344 46            [ 6] 2928         LD      B,(HL)          ; Get MSB of string address
   F345 6F            [ 4] 2929         LD      L,A             ; Length to L
   F346 2C            [ 4] 2930 TOSTRA: INC     L               ; INC - DECed after
   F347 2D            [ 4] 2931 TSALP:  DEC     L               ; Count bytes moved
   F348 C8            [10] 2932         RET     Z               ; End of string - Return
   F349 0A            [ 6] 2933         LD      A,(BC)          ; Get source
   F34A 12            [ 7] 2934         LD      (DE),A          ; Save destination
   F34B 03            [ 4] 2935         INC     BC              ; Next source
   F34C 13            [ 4] 2936         INC     DE              ; Next destination
   F34D C3 47 F3      [ 9] 2937         JP      TSALP           ; Loop until string moved
                           2938 
   F350 CD 45 ED      [16] 2939 GETSTR: CALL    TSTSTR          ; Make sure it's a string
   F353 2A E4 10      [15] 2940 GSTRCU: LD      HL,(FPREG)      ; Get current string
   F356 EB            [ 3] 2941 GSTRHL: EX      DE,HL           ; Save DE
   F357 CD 71 F3      [16] 2942 GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
   F35A EB            [ 3] 2943         EX      DE,HL           ; Restore DE
   F35B C0            [10] 2944         RET     NZ              ; No - Return
   F35C D5            [11] 2945         PUSH    DE              ; Save string
   F35D 50            [ 4] 2946         LD      D,B             ; String block address to DE
   F35E 59            [ 4] 2947         LD      E,C
   F35F 1B            [ 4] 2948         DEC     DE              ; Point to length
   F360 4E            [ 6] 2949         LD      C,(HL)          ; Get string length
   F361 2A C3 10      [15] 2950         LD      HL,(STRBOT)     ; Current bottom of string area
   F364 CD 8A E6      [16] 2951         CALL    CPDEHL          ; Last one in string area?
   F367 C2 6F F3      [ 9] 2952         JP      NZ,POPHL        ; No - Return
   F36A 47            [ 4] 2953         LD      B,A             ; Clear B (A=0)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 55.
Hexadecimal [16-Bits]



   F36B 09            [ 7] 2954         ADD     HL,BC           ; Remove string from str' area
   F36C 22 C3 10      [16] 2955         LD      (STRBOT),HL     ; Save new bottom of str' area
   F36F E1            [ 9] 2956 POPHL:  POP     HL              ; Restore string
   F370 C9            [ 9] 2957         RET
                           2958 
   F371 2A B1 10      [15] 2959 BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
   F374 2B            [ 4] 2960         DEC     HL              ; Back
   F375 46            [ 6] 2961         LD      B,(HL)          ; Get MSB of address
   F376 2B            [ 4] 2962         DEC     HL              ; Back
   F377 4E            [ 6] 2963         LD      C,(HL)          ; Get LSB of address
   F378 2B            [ 4] 2964         DEC     HL              ; Back
   F379 2B            [ 4] 2965         DEC     HL              ; Back
   F37A CD 8A E6      [16] 2966         CALL    CPDEHL          ; String last in string pool?
   F37D C0            [10] 2967         RET     NZ              ; Yes - Leave it
   F37E 22 B1 10      [16] 2968         LD      (TMSTPT),HL     ; Save new string pool top
   F381 C9            [ 9] 2969         RET
                           2970 
   F382 01 01 F1      [ 9] 2971 LEN:    LD      BC,#PASSA        ; To return integer A
   F385 C5            [11] 2972         PUSH    BC              ; Save address
   F386 CD 50 F3      [16] 2973 GETLEN: CALL    GETSTR          ; Get string and its length
   F389 AF            [ 4] 2974         XOR     A
   F38A 57            [ 4] 2975         LD      D,A             ; Clear D
   F38B 32 AD 10      [13] 2976         LD      (TYPE),A        ; Set type to numeric
   F38E 7E            [ 6] 2977         LD      A,(HL)          ; Get length of string
   F38F B7            [ 4] 2978         OR      A               ; Set status flags
   F390 C9            [ 9] 2979         RET
                           2980 
   F391 01 01 F1      [ 9] 2981 ASC:    LD      BC,#PASSA        ; To return integer A
   F394 C5            [11] 2982         PUSH    BC              ; Save address
   F395 CD 86 F3      [16] 2983 GTFLNM: CALL    GETLEN          ; Get length of string
   F398 CA A0 E9      [ 9] 2984         JP      Z,FCERR         ; Null string - Error
   F39B 23            [ 4] 2985         INC     HL
   F39C 23            [ 4] 2986         INC     HL
   F39D 5E            [ 6] 2987         LD      E,(HL)          ; Get LSB of address
   F39E 23            [ 4] 2988         INC     HL
   F39F 56            [ 6] 2989         LD      D,(HL)          ; Get MSB of address
   F3A0 1A            [ 6] 2990         LD      A,(DE)          ; Get first byte of string
   F3A1 C9            [ 9] 2991         RET
                           2992 
   F3A2 3E 01         [ 6] 2993 CHR:    LD      A,#1             ; One character string
   F3A4 CD BF F1      [16] 2994         CALL    MKTMST          ; Make a temporary string
   F3A7 CD 87 F4      [16] 2995         CALL    MAKINT          ; Make it integer A
   F3AA 2A C1 10      [15] 2996         LD      HL,(TMPSTR+2)   ; Get address of string
   F3AD 73            [ 7] 2997         LD      (HL),E          ; Save character
   F3AE C1            [ 9] 2998 TOPOOL: POP     BC              ; Clean up stack
   F3AF C3 F0 F1      [ 9] 2999         JP      TSTOPL          ; Temporary string to pool
                           3000 
   F3B2 CD 37 F4      [16] 3001 LEFT:   CALL    LFRGNM          ; Get number and ending ")"
   F3B5 AF            [ 4] 3002         XOR     A               ; Start at first byte in string
   F3B6 E3            [16] 3003 RIGHT1: EX      (SP),HL         ; Save code string,Get string
   F3B7 4F            [ 4] 3004         LD      C,A             ; Starting position in string
   F3B8 E5            [11] 3005 MID1:   PUSH    HL              ; Save string block address
   F3B9 7E            [ 6] 3006         LD      A,(HL)          ; Get length of string
   F3BA B8            [ 4] 3007         CP      B               ; Compare with number given
   F3BB DA C0 F3      [ 9] 3008         JP      C,ALLFOL        ; All following bytes required
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 56.
Hexadecimal [16-Bits]



   F3BE 78            [ 4] 3009         LD      A,B             ; Get new length
   F3BF 11                 3010         .db      0x11             ; Skip "LD C,0"
   F3C0 0E 00         [ 6] 3011 ALLFOL: LD      C,#0             ; First byte of string
   F3C2 C5            [11] 3012         PUSH    BC              ; Save position in string
   F3C3 CD 29 F2      [16] 3013         CALL    TESTR           ; See if enough string space
   F3C6 C1            [ 9] 3014         POP     BC              ; Get position in string
   F3C7 E1            [ 9] 3015         POP     HL              ; Restore string block address
   F3C8 E5            [11] 3016         PUSH    HL              ; And re-save it
   F3C9 23            [ 4] 3017         INC     HL
   F3CA 23            [ 4] 3018         INC     HL
   F3CB 46            [ 6] 3019         LD      B,(HL)          ; Get LSB of address
   F3CC 23            [ 4] 3020         INC     HL
   F3CD 66            [ 6] 3021         LD      H,(HL)          ; Get MSB of address
   F3CE 68            [ 4] 3022         LD      L,B             ; HL = address of string
   F3CF 06 00         [ 6] 3023         LD      B,#0             ; BC = starting address
   F3D1 09            [ 7] 3024         ADD     HL,BC           ; Point to that byte
   F3D2 44            [ 4] 3025         LD      B,H             ; BC = source string
   F3D3 4D            [ 4] 3026         LD      C,L
   F3D4 CD C2 F1      [16] 3027         CALL    CRTMST          ; Create a string entry
   F3D7 6F            [ 4] 3028         LD      L,A             ; Length of new string
   F3D8 CD 46 F3      [16] 3029         CALL    TOSTRA          ; Move string to string area
   F3DB D1            [ 9] 3030         POP     DE              ; Clear stack
   F3DC CD 57 F3      [16] 3031         CALL    GSTRDE          ; Move to string pool if needed
   F3DF C3 F0 F1      [ 9] 3032         JP      TSTOPL          ; Temporary string to pool
                           3033 
   F3E2 CD 37 F4      [16] 3034 RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
   F3E5 D1            [ 9] 3035         POP     DE              ; Get string length
   F3E6 D5            [11] 3036         PUSH    DE              ; And re-save
   F3E7 1A            [ 6] 3037         LD      A,(DE)          ; Get length
   F3E8 90            [ 4] 3038         SUB     B               ; Move back N bytes
   F3E9 C3 B6 F3      [ 9] 3039         JP      RIGHT1          ; Go and get sub-string
                           3040 
   F3EC EB            [ 3] 3041 MID:    EX      DE,HL           ; Get code string address
   F3ED 7E            [ 6] 3042         LD      A,(HL)          ; Get next byte "," or ")"
   F3EE CD 3C F4      [16] 3043         CALL    MIDNUM          ; Get number supplied
   F3F1 04            [ 4] 3044         INC     B               ; Is it character zero?
   F3F2 05            [ 4] 3045         DEC     B
   F3F3 CA A0 E9      [ 9] 3046         JP      Z,FCERR         ; Yes - Error
   F3F6 C5            [11] 3047         PUSH    BC              ; Save starting position
   F3F7 1E FF         [ 6] 3048         LD      E,#255           ; All of string
   F3F9 FE 29         [ 6] 3049         CP      #")"             ; Any length given?
   F3FB CA 05 F4      [ 9] 3050         JP      Z,#RSTSTR        ; No - Rest of string
   F3FE CD 90 E6      [16] 3051         CALL    CHKSYN          ; Make sure "," follows
   F401 2C                 3052         .db     ","
   F402 CD 84 F4      [16] 3053         CALL    GETINT          ; Get integer 0-255
   F405 CD 90 E6      [16] 3054 RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
   F408 29                 3055         .db     ")"
   F409 F1            [ 9] 3056         POP     AF              ; Restore starting position
   F40A E3            [16] 3057         EX      (SP),HL         ; Get string,8ave code string
   F40B 01 B8 F3      [ 9] 3058         LD      BC,#MID1         ; Continuation of MID$ routine
   F40E C5            [11] 3059         PUSH    BC              ; Save for return
   F40F 3D            [ 4] 3060         DEC     A               ; Starting position-1
   F410 BE            [ 6] 3061         CP      (HL)            ; Compare with length
   F411 06 00         [ 6] 3062         LD      B,#0             ; Zero bytes length
   F413 D0            [10] 3063         RET     NC              ; Null string if start past end
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 57.
Hexadecimal [16-Bits]



   F414 4F            [ 4] 3064         LD      C,A             ; Save starting position-1
   F415 7E            [ 6] 3065         LD      A,(HL)          ; Get length of string
   F416 91            [ 4] 3066         SUB     C               ; Subtract start
   F417 BB            [ 4] 3067         CP      E               ; Enough string for it?
   F418 47            [ 4] 3068         LD      B,A             ; Save maximum length available
   F419 D8            [10] 3069         RET     C               ; Truncate string if needed
   F41A 43            [ 4] 3070         LD      B,E             ; Set specified length
   F41B C9            [ 9] 3071         RET                     ; Go and create string
                           3072 
   F41C CD 86 F3      [16] 3073 VAL:    CALL    GETLEN          ; Get length of string
   F41F CA 33 F6      [ 9] 3074         JP      Z,RESZER        ; Result zero
   F422 5F            [ 4] 3075         LD      E,A             ; Save length
   F423 23            [ 4] 3076         INC     HL
   F424 23            [ 4] 3077         INC     HL
   F425 7E            [ 6] 3078         LD      A,(HL)          ; Get LSB of address
   F426 23            [ 4] 3079         INC     HL
   F427 66            [ 6] 3080         LD      H,(HL)          ; Get MSB of address
   F428 6F            [ 4] 3081         LD      L,A             ; HL = String address
   F429 E5            [11] 3082         PUSH    HL              ; Save string address
   F42A 19            [ 7] 3083         ADD     HL,DE
   F42B 46            [ 6] 3084         LD      B,(HL)          ; Get end of string+1 byte
   F42C 72            [ 7] 3085         LD      (HL),D          ; Zero it to terminate
   F42D E3            [16] 3086         EX      (SP),HL         ; Save string end,get start
   F42E C5            [11] 3087         PUSH    BC              ; Save end+1 byte
   F42F 7E            [ 6] 3088         LD      A,(HL)          ; Get starting byte
   F430 CD 1A F9      [16] 3089         CALL    ASCTFP          ; Convert ASCII string to FP
   F433 C1            [ 9] 3090         POP     BC              ; Restore end+1 byte
   F434 E1            [ 9] 3091         POP     HL              ; Restore end+1 address
   F435 70            [ 7] 3092         LD      (HL),B          ; Put back original byte
   F436 C9            [ 9] 3093         RET
                           3094 
   F437 EB            [ 3] 3095 LFRGNM: EX      DE,HL           ; Code string address to HL
   F438 CD 90 E6      [16] 3096         CALL    CHKSYN          ; Make sure ")" follows
   F43B 29                 3097         .db     ")"
   F43C C1            [ 9] 3098 MIDNUM: POP     BC              ; Get return address
   F43D D1            [ 9] 3099         POP     DE              ; Get number supplied
   F43E C5            [11] 3100         PUSH    BC              ; Re-save return address
   F43F 43            [ 4] 3101         LD      B,E             ; Number to B
   F440 C9            [ 9] 3102         RET
                           3103 
   F441 CD 87 F4      [16] 3104 INP:    CALL    MAKINT          ; Make it integer A
   F444 32 3F 10      [13] 3105         LD      (INPORT),A      ; Set input port
   F447 CD 3E 10      [16] 3106         CALL    INPSUB          ; Get input from port
   F44A C3 01 F1      [ 9] 3107         JP      PASSA           ; Return integer A
                           3108 
   F44D CD 71 F4      [16] 3109 POUT:   CALL    SETIO           ; Set up port number
   F450 C3 06 10      [ 9] 3110         JP      OUTSUB          ; Output data and return
                           3111 
   F453 CD 71 F4      [16] 3112 WAIT:   CALL    SETIO           ; Set up port number
   F456 F5            [11] 3113         PUSH    AF              ; Save AND mask
   F457 1E 00         [ 6] 3114         LD      E,#0             ; Assume zero if none given
   F459 2B            [ 4] 3115         DEC     HL              ; DEC 'cos GETCHR INCs
   F45A CD 36 E8      [16] 3116         CALL    GETCHR          ; Get next character
   F45D CA 67 F4      [ 9] 3117         JP      Z,NOXOR         ; No XOR byte given
   F460 CD 90 E6      [16] 3118         CALL    CHKSYN          ; Make sure "," follows
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 58.
Hexadecimal [16-Bits]



   F463 2C                 3119         .db     ","
   F464 CD 84 F4      [16] 3120         CALL    GETINT          ; Get integer 0-255 to XOR with
   F467 C1            [ 9] 3121 NOXOR:  POP     BC              ; Restore AND mask
   F468 CD 3E 10      [16] 3122 WAITLP: CALL    INPSUB          ; Get input
   F46B AB            [ 4] 3123         XOR     E               ; Flip selected bits
   F46C A0            [ 4] 3124         AND     B               ; Result non-zero?
   F46D CA 68 F4      [ 9] 3125         JP      Z,WAITLP        ; No = keep waiting
   F470 C9            [ 9] 3126         RET
                           3127 
   F471 CD 84 F4      [16] 3128 SETIO:  CALL    GETINT          ; Get integer 0-255
   F474 32 3F 10      [13] 3129         LD      (INPORT),A      ; Set input port
   F477 32 07 10      [13] 3130         LD      (OTPORT),A      ; Set output port
   F47A CD 90 E6      [16] 3131         CALL    CHKSYN          ; Make sure "," follows
   F47D 2C                 3132         .db     ","
   F47E C3 84 F4      [ 9] 3133         JP      GETINT          ; Get integer 0-255 and return
                           3134 
   F481 CD 36 E8      [16] 3135 FNDNUM: CALL    GETCHR          ; Get next character
   F484 CD 41 ED      [16] 3136 GETINT: CALL    GETNUM          ; Get a number from 0 to 255
   F487 CD 85 E9      [16] 3137 MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
   F48A 7A            [ 4] 3138         LD      A,D             ; Get MSB of number
   F48B B7            [ 4] 3139         OR      A               ; Zero?
   F48C C2 A0 E9      [ 9] 3140         JP      NZ,FCERR        ; No - Error
   F48F 2B            [ 4] 3141         DEC     HL              ; DEC 'cos GETCHR INCs
   F490 CD 36 E8      [16] 3142         CALL    GETCHR          ; Get next character
   F493 7B            [ 4] 3143         LD      A,E             ; Get number to A
   F494 C9            [ 9] 3144         RET
                           3145 
                           3146 ; << NO  REFERENCE  TO  THIS  SECTION  OF  CODE >>
                           3147 ; << Set up another program area (can be in ROM) >>
                           3148 
   F495 2A 5E 10      [15] 3149         LD      HL,(BASTXT)     ; Get start of program text
   F498 22 D6 10      [16] 3150         LD      (PROGND),HL     ; Set more variable space
   F49B 21 00 80      [ 9] 3151         LD      HL,#0x8000        ; Address of new program
   F49E 5E            [ 6] 3152         LD      E,(HL)          ; Get LSB of new RAM end
   F49F 23            [ 4] 3153         INC     HL
   F4A0 56            [ 6] 3154         LD      D,(HL)          ; Get MSB of new RAM end
   F4A1 23            [ 4] 3155         INC     HL
   F4A2 23            [ 4] 3156         INC     HL              ; Null at start of program
   F4A3 22 5E 10      [16] 3157         LD      (BASTXT),HL     ; New program text area 0x8003
   F4A6 EB            [ 3] 3158         EX      DE,HL           ; New RAM end to HL
   F4A7 22 AF 10      [16] 3159         LD      (LSTRAM),HL     ; Set new RAM end
   F4AA 22 5A 10      [16] 3160         LD      (STRSPC),HL     ; Clear string space
   F4AD 01 F2 E7      [ 9] 3161         LD      BC,#RUNCNT       ; Execution driver loop
   F4B0 C5            [11] 3162         PUSH    BC              ; Save for return
   F4B1 C3 C5 E4      [ 9] 3163         JP      RUNFST          ; Clear variables and continue
                           3164 
   F4B4 C3 56 FD      [ 9] 3165 RUART:  JP      GUART           ; Get a byte from UART
                           3166 
   F4B7 CD BA F4      [16] 3167 WUART2: CALL    WUART           ; Send 2 Bytes to UART
   F4BA F5            [11] 3168 WUART:  PUSH    AF              ; Save byte
   F4BB C5            [11] 3169         PUSH    BC              ; Save BC
   F4BC 4F            [ 4] 3170         LD      C,A             ; Byte to C
   F4BD CD 68 FD      [16] 3171         CALL    SUART           ; Send byte to UART
   F4C0 C1            [ 9] 3172         POP     BC              ; Restore BC
   F4C1 F1            [ 9] 3173         POP     AF              ; Restore byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 59.
Hexadecimal [16-Bits]



   F4C2 C9            [ 9] 3174         RET
                           3175 
   F4C3 06 01         [ 6] 3176 CSAVE:  LD      B,#1             ; Flag "CSAVE"
   F4C5 FE AE         [ 6] 3177         CP      #ZTIMES          ; "*" token? ("CSAVE*")
   F4C7 CA BB E8      [ 9] 3178         JP      Z,ARRSV1        ; Yes - Array save
   F4CA CD 5A ED      [16] 3179         CALL    EVAL            ; Evaluate expression
   F4CD E5            [11] 3180         PUSH    HL              ; Save code string address
   F4CE CD 95 F3      [16] 3181         CALL    GTFLNM          ; Get file name
   F4D1 D5            [11] 3182         PUSH    DE              ; Save file name
   F4D2 CD C8 FC      [16] 3183         CALL    CASFFW          ; Turn on motor and wait
   F4D5 D1            [ 9] 3184         POP     DE              ; Restore file name
   F4D6 3E D3         [ 6] 3185         LD      A,#0b11010011     ; Header byte
   F4D8 CD BA F4      [16] 3186         CALL    WUART           ; Send byte to UART
   F4DB CD B7 F4      [16] 3187         CALL    WUART2          ; Send byte twice more
   F4DE 1A            [ 6] 3188         LD      A,(DE)          ; Get file name
   F4DF CD BA F4      [16] 3189         CALL    WUART           ; Send it to UART
   F4E2 00            [ 3] 3190         NOP
   F4E3 00            [ 3] 3191         NOP
   F4E4 00            [ 3] 3192         NOP
   F4E5 21 D6 10      [ 9] 3193         LD      HL,#PROGND       ; Start of program information
   F4E8 22 0C 0C      [16] 3194         LD      (ARG1),HL       ; Save for monitor save routine
   F4EB 2A D6 10      [15] 3195         LD      HL,(PROGND)     ; End of program information
   F4EE 22 0E 0C      [16] 3196         LD      (ARG2),HL       ; Save for monitor save routine
   F4F1 CD 73 FE      [16] 3197         CALL    SAVE            ; Save program to tape
   F4F4 CD D8 FC      [16] 3198         CALL    ARET            ; Not much there!
   F4F7 E1            [ 9] 3199         POP     HL              ; Restore code string address
   F4F8 C9            [ 9] 3200         RET
                           3201 
   F4F9 7E            [ 6] 3202 CLOAD:  LD      A,(HL)          ; Get byte after "CLOAD"
   F4FA FE AE         [ 6] 3203         CP      #ZTIMES          ; "*" token? ("CLOAD*")
   F4FC CA B9 E8      [ 9] 3204         JP      Z,ARRLD1        ; Yes - Array load
   F4FF CD D1 FF      [16] 3205         CALL    SMOTOR          ; Start motor and get "?"
   F502 D6 9E         [ 6] 3206         SUB     #ZPRINT          ; "?" ("PRINT" token) Verify?
   F504 CA 09 F5      [ 9] 3207         JP      Z,FLGVER        ; Yes - Flag "verify"
   F507 AF            [ 4] 3208         XOR     A               ; Flag "load"
   F508 01                 3209         .db      0x01             ; Skip "CPL" and "INC HL"
   F509 2F            [ 3] 3210 FLGVER: CPL                     ; Flag "verify"
   F50A 23            [ 4] 3211         INC     HL              ; Skip over "?"
   F50B F5            [11] 3212         PUSH    AF              ; Save verify flag
   F50C 2B            [ 4] 3213         DEC     HL              ; DEC 'cos GETCHR INCs
   F50D CD 36 E8      [16] 3214         CALL    GETCHR          ; Get next character
   F510 3E 00         [ 6] 3215         LD      A,#0             ; Any file will do
   F512 CA 1C F5      [ 9] 3216         JP      Z,ANYNAM        ; No name given - Any will do
   F515 CD 5A ED      [16] 3217         CALL    EVAL            ; Evaluate expression
   F518 CD 95 F3      [16] 3218         CALL    GTFLNM          ; Get file name
   F51B 1A            [ 6] 3219         LD      A,(DE)          ; Get first byte of name
   F51C 6F            [ 4] 3220 ANYNAM: LD      L,A             ; Save name to find
   F51D F1            [ 9] 3221         POP     AF              ; Get verify flag
   F51E F5            [11] 3222         PUSH    AF              ; And re-save
   F51F B7            [ 4] 3223         OR      A               ; Verify of load?
   F520 67            [ 4] 3224         LD      H,A
   F521 22 E4 10      [16] 3225         LD      (FPREG),HL      ; Save nam of file to find
   F524 CC BA E4      [16] 3226         CALL    Z,CLRPTR        ; Load - Clear pointers
   F527 2A E4 10      [15] 3227         LD      HL,(FPREG)      ; Get name of program to find
   F52A EB            [ 3] 3228         EX      DE,HL           ; Name to DE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 60.
Hexadecimal [16-Bits]



   F52B 06 03         [ 6] 3229 CLOAD1: LD      B,#3             ; 3 Header bytes
   F52D CD B4 F4      [16] 3230 CLOAD2: CALL    RUART           ; Get a byte from UART
   F530 D6 D3         [ 6] 3231         SUB     #0b11010011       ; Header byte?
   F532 C2 2B F5      [ 9] 3232         JP      NZ,CLOAD1       ; Look for header
   F535 05            [ 4] 3233         DEC     B               ; Count header bytes
   F536 C2 2D F5      [ 9] 3234         JP      NZ,CLOAD2       ; More to find?
   F539 CD B4 F4      [16] 3235         CALL    RUART           ; Get name of file
   F53C CD 74 F5      [16] 3236         CALL    FILFND          ; Display "file X found"
   F53F 1C            [ 4] 3237         INC     E               ; Any file name given?
   F540 1D            [ 4] 3238         DEC     E
   F541 CA 48 F5      [ 9] 3239         JP      Z,THSFIL        ; No - This file will do
   F544 BB            [ 4] 3240         CP      E               ; Has file been found?
   F545 C2 2B F5      [ 9] 3241         JP      NZ,CLOAD1       ; No - Look for another
   F548 00            [ 3] 3242 THSFIL: NOP
   F549 00            [ 3] 3243         NOP
   F54A 00            [ 3] 3244         NOP
   F54B F1            [ 9] 3245         POP     AF              ; Get verify flag
   F54C B7            [ 4] 3246         OR      A               ; Load or verify?
   F54D C2 5C F5      [ 9] 3247         JP      NZ,CLOADV       ; Verify program
   F550 CD 88 FE      [16] 3248         CALL    MONLD           ; Use monitor to load program
   F553 2A D6 10      [15] 3249         LD      HL,(PROGND)     ; Get end of program
   F556 CD 93 E3      [16] 3250         CALL    ENFMEM          ; See if enough memory
   F559 C3 5F F5      [ 9] 3251         JP      CLOADE          ; "Ok" and set up pointers
                           3252 
   F55C CD AA FE      [16] 3253 CLOADV: CALL    MONVE           ; Use monitor to verify program
   F55F 21 4B E3      [ 9] 3254 CLOADE: LD      HL,#OKMSG        ; "Ok" message
   F562 CD 10 F2      [16] 3255         CALL    PRS             ; Output string
   F565 CD D8 FC      [16] 3256         CALL    ARET            ; Not a lot there!
   F568 C3 7C E4      [ 9] 3257         JP      SETPTR          ; Set up line pointers
                           3258 
   F56B 21 9D F5      [ 9] 3259 OUTBAD: LD      HL,#BAD          ; "Bad" message
   F56E CD 10 F2      [16] 3260         CALL    PRS             ; Output string
   F571 C3 E1 E3      [ 9] 3261         JP      ERRIN           ; In line message
                           3262 
   F574 C5            [11] 3263 FILFND: PUSH    BC              ; <- Save
   F575 E5            [11] 3264         PUSH    HL              ; <- all
   F576 D5            [11] 3265         PUSH    DE              ; <- the
   F577 F5            [11] 3266         PUSH    AF              ; <- registers
   F578 21 8E F5      [ 9] 3267         LD      HL,#FILE         ; "File" message
   F57B CD 10 F2      [16] 3268         CALL    PRS             ; Output string
   F57E F1            [ 9] 3269         POP     AF              ; Get file name
   F57F F5            [11] 3270         PUSH    AF              ; And re-save
   F580 CD D9 FC      [16] 3271         CALL    CONMON          ; Output file name to screen
   F583 21 94 F5      [ 9] 3272         LD      HL,#FOUND        ; "Found" message
   F586 CD 10 F2      [16] 3273         CALL    PRS             ; Output string
   F589 F1            [ 9] 3274         POP     AF              ; <- Restore
   F58A D1            [ 9] 3275         POP     DE              ; <- all
   F58B E1            [ 9] 3276         POP     HL              ; <- the
   F58C C1            [ 9] 3277         POP     BC              ; <- registers
   F58D C9            [ 9] 3278         RET
                           3279 
   F58E 46 69 6C 65 20     3280 FILE:   .ascii      "File "
   F593 00                 3281         .db 0
   F594 20 46 6F 75 6E 64  3282 FOUND:  .ascii      " Found"
   F59A 0D 0A 00           3283         .db CR,LF,0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 61.
Hexadecimal [16-Bits]



   F59D 42 61 64           3284 BAD:    .ascii      "Bad"
   F5A0 00 00 00           3285         .db 0,0,0
                           3286 
   F5A3 CD 8B E9      [16] 3287 PEEK:   CALL    DEINT           ; Get memory address
   F5A6 1A            [ 6] 3288         LD      A,(DE)          ; Get byte in memory
   F5A7 C3 01 F1      [ 9] 3289         JP      PASSA           ; Return integer A
                           3290 
   F5AA CD 41 ED      [16] 3291 POKE:   CALL    GETNUM          ; Get memory address
   F5AD CD 8B E9      [16] 3292         CALL    DEINT           ; Get integer -32768 to 3276
   F5B0 D5            [11] 3293         PUSH    DE              ; Save memory address
   F5B1 CD 90 E6      [16] 3294         CALL    CHKSYN          ; Make sure "," follows
   F5B4 2C                 3295         .db      ","
   F5B5 CD 84 F4      [16] 3296         CALL    GETINT          ; Get integer 0-255
   F5B8 D1            [ 9] 3297         POP     DE              ; Restore memory address
   F5B9 12            [ 7] 3298         LD      (DE),A          ; Load it into memory
   F5BA C9            [ 9] 3299         RET
                           3300 
   F5BB 21 91 FA      [ 9] 3301 ROUND:  LD      HL,#HALF         ; Add 0.5 to FPREG
   F5BE CD 62 F8      [16] 3302 ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
   F5C1 C3 CD F5      [ 9] 3303         JP      FPADD           ; Add BCDE to FPREG
                           3304 
   F5C4 CD 62 F8      [16] 3305 SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
   F5C7 21                 3306         .db      0x21             ; Skip "POP BC" and "POP DE"
   F5C8 C1            [ 9] 3307 PSUB:   POP     BC              ; Get FP number from stack
   F5C9 D1            [ 9] 3308         POP     DE
   F5CA CD 3C F8      [16] 3309 SUBCDE: CALL    INVSGN          ; Negate FPREG
   F5CD 78            [ 4] 3310 FPADD:  LD      A,B             ; Get FP exponent
   F5CE B7            [ 4] 3311         OR      A               ; Is number zero?
   F5CF C8            [10] 3312         RET     Z               ; Yes - Nothing to add
   F5D0 3A E7 10      [12] 3313         LD      A,(FPEXP)       ; Get FPREG exponent
   F5D3 B7            [ 4] 3314         OR      A               ; Is this number zero?
   F5D4 CA 54 F8      [ 9] 3315         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
   F5D7 90            [ 4] 3316         SUB     B               ; BCDE number larger?
   F5D8 D2 E7 F5      [ 9] 3317         JP      NC,NOSWAP       ; No - Don't swap them
   F5DB 2F            [ 3] 3318         CPL                     ; Two's complement
   F5DC 3C            [ 4] 3319         INC     A               ;  FP exponent
   F5DD EB            [ 3] 3320         EX      DE,HL
   F5DE CD 44 F8      [16] 3321         CALL    STAKFP          ; Put FPREG on stack
   F5E1 EB            [ 3] 3322         EX      DE,HL
   F5E2 CD 54 F8      [16] 3323         CALL    FPBCDE          ; Move BCDE to FPREG
   F5E5 C1            [ 9] 3324         POP     BC              ; Restore number from stack
   F5E6 D1            [ 9] 3325         POP     DE
   F5E7 FE 19         [ 6] 3326 NOSWAP: CP      #24+1            ; Second number insignificant?
   F5E9 D0            [10] 3327         RET     NC              ; Yes - First number is result
   F5EA F5            [11] 3328         PUSH    AF              ; Save number of bits to scale
   F5EB CD 79 F8      [16] 3329         CALL    SIGNS           ; Set MSBs & sign of result
   F5EE 67            [ 4] 3330         LD      H,A             ; Save sign of result
   F5EF F1            [ 9] 3331         POP     AF              ; Restore scaling factor
   F5F0 CD 92 F6      [16] 3332         CALL    SCALE           ; Scale BCDE to same exponent
   F5F3 B4            [ 4] 3333         OR      H               ; Result to be positive?
   F5F4 21 E4 10      [ 9] 3334         LD      HL,#FPREG        ; Point to FPREG
   F5F7 F2 0D F6      [ 9] 3335         JP      P,MINCDE        ; No - Subtract FPREG from CDE
   F5FA CD 72 F6      [16] 3336         CALL    PLUCDE          ; Add FPREG to CDE
   F5FD D2 53 F6      [ 9] 3337         JP      NC,RONDUP       ; No overflow - Round it up
   F600 23            [ 4] 3338         INC     HL              ; Point to exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 62.
Hexadecimal [16-Bits]



   F601 34            [10] 3339         INC     (HL)            ; Increment it
   F602 CA BC E3      [ 9] 3340         JP      Z,OVERR         ; Number overflowed - Error
   F605 2E 01         [ 6] 3341         LD      L,#1             ; 1 bit to shift right
   F607 CD A8 F6      [16] 3342         CALL    SHRT1           ; Shift result right
   F60A C3 53 F6      [ 9] 3343         JP      RONDUP          ; Round it up
                           3344 
   F60D AF            [ 4] 3345 MINCDE: XOR     A               ; Clear A and carry
   F60E 90            [ 4] 3346         SUB     B               ; Negate exponent
   F60F 47            [ 4] 3347         LD      B,A             ; Re-save exponent
   F610 7E            [ 6] 3348         LD      A,(HL)          ; Get LSB of FPREG
   F611 9B            [ 4] 3349         SBC     A, E            ; Subtract LSB of BCDE
   F612 5F            [ 4] 3350         LD      E,A             ; Save LSB of BCDE
   F613 23            [ 4] 3351         INC     HL
   F614 7E            [ 6] 3352         LD      A,(HL)          ; Get NMSB of FPREG
   F615 9A            [ 4] 3353         SBC     A,D             ; Subtract NMSB of BCDE
   F616 57            [ 4] 3354         LD      D,A             ; Save NMSB of BCDE
   F617 23            [ 4] 3355         INC     HL
   F618 7E            [ 6] 3356         LD      A,(HL)          ; Get MSB of FPREG
   F619 99            [ 4] 3357         SBC     A,C             ; Subtract MSB of BCDE
   F61A 4F            [ 4] 3358         LD      C,A             ; Save MSB of BCDE
   F61B DC 7E F6      [16] 3359 CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                           3360 
   F61E 68            [ 4] 3361 BNORM:  LD      L,B             ; L = Exponent
   F61F 63            [ 4] 3362         LD      H,E             ; H = LSB
   F620 AF            [ 4] 3363         XOR     A
   F621 47            [ 4] 3364 BNRMLP: LD      B,A             ; Save bit count
   F622 79            [ 4] 3365         LD      A,C             ; Get MSB
   F623 B7            [ 4] 3366         OR      A               ; Is it zero?
   F624 C2 40 F6      [ 9] 3367         JP      NZ,PNORM        ; No - Do it bit at a time
   F627 4A            [ 4] 3368         LD      C,D             ; MSB = NMSB
   F628 54            [ 4] 3369         LD      D,H             ; NMSB= LSB
   F629 65            [ 4] 3370         LD      H,L             ; LSB = VLSB
   F62A 6F            [ 4] 3371         LD      L,A             ; VLSB= 0
   F62B 78            [ 4] 3372         LD      A,B             ; Get exponent
   F62C D6 08         [ 6] 3373         SUB     #8               ; Count 8 bits
   F62E FE E0         [ 6] 3374         CP      #-24-8           ; Was number zero?
   F630 C2 21 F6      [ 9] 3375         JP      NZ,BNRMLP       ; No - Keep normalising
   F633 AF            [ 4] 3376 RESZER: XOR     A               ; Result is zero
   F634 32 E7 10      [13] 3377 SAVEXP: LD      (FPEXP),A       ; Save result as zero
   F637 C9            [ 9] 3378         RET
                           3379 
   F638 05            [ 4] 3380 NORMAL: DEC     B               ; Count bits
   F639 29            [ 7] 3381         ADD     HL,HL           ; Shift HL left
   F63A 7A            [ 4] 3382         LD      A,D             ; Get NMSB
   F63B 17            [ 3] 3383         RLA                     ; Shift left with last bit
   F63C 57            [ 4] 3384         LD      D,A             ; Save NMSB
   F63D 79            [ 4] 3385         LD      A,C             ; Get MSB
   F63E 8F            [ 4] 3386         ADC     A,A             ; Shift left with last bit
   F63F 4F            [ 4] 3387         LD      C,A             ; Save MSB
   F640 F2 38 F6      [ 9] 3388 PNORM:  JP      P,NORMAL        ; Not done - Keep going
   F643 78            [ 4] 3389         LD      A,B             ; Number of bits shifted
   F644 5C            [ 4] 3390         LD      E,H             ; Save HL in EB
   F645 45            [ 4] 3391         LD      B,L
   F646 B7            [ 4] 3392         OR      A               ; Any shifting done?
   F647 CA 53 F6      [ 9] 3393         JP      Z,RONDUP        ; No - Round it up
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 63.
Hexadecimal [16-Bits]



   F64A 21 E7 10      [ 9] 3394         LD      HL,#FPEXP        ; Point to exponent
   F64D 86            [ 6] 3395         ADD     A,(HL)          ; Add shifted bits
   F64E 77            [ 7] 3396         LD      (HL),A          ; Re-save exponent
   F64F D2 33 F6      [ 9] 3397         JP      NC,RESZER       ; Underflow - Result is zero
   F652 C8            [10] 3398         RET     Z               ; Result is zero
   F653 78            [ 4] 3399 RONDUP: LD      A,B             ; Get VLSB of number
   F654 21 E7 10      [ 9] 3400 RONDB:  LD      HL,#FPEXP        ; Point to exponent
   F657 B7            [ 4] 3401         OR      A               ; Any rounding?
   F658 FC 65 F6      [16] 3402         CALL    M,FPROND        ; Yes - Round number up
   F65B 46            [ 6] 3403         LD      B,(HL)          ; B = Exponent
   F65C 23            [ 4] 3404         INC     HL
   F65D 7E            [ 6] 3405         LD      A,(HL)          ; Get sign of result
   F65E E6 80         [ 6] 3406         AND     #0b10000000       ; Only bit 7 needed
   F660 A9            [ 4] 3407         XOR     C               ; Set correct sign
   F661 4F            [ 4] 3408         LD      C,A             ; Save correct sign in number
   F662 C3 54 F8      [ 9] 3409         JP      FPBCDE          ; Move BCDE to FPREG
                           3410 
   F665 1C            [ 4] 3411 FPROND: INC     E               ; Round LSB
   F666 C0            [10] 3412         RET     NZ              ; Return if ok
   F667 14            [ 4] 3413         INC     D               ; Round NMSB
   F668 C0            [10] 3414         RET     NZ              ; Return if ok
   F669 0C            [ 4] 3415         INC     C               ; Round MSB
   F66A C0            [10] 3416         RET     NZ              ; Return if ok
   F66B 0E 80         [ 6] 3417         LD      C,#0x80           ; Set normal value
   F66D 34            [10] 3418         INC     (HL)            ; Increment exponent
   F66E C0            [10] 3419         RET     NZ              ; Return if ok
   F66F C3 BC E3      [ 9] 3420         JP      OVERR           ; Overflow error
                           3421 
   F672 7E            [ 6] 3422 PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
   F673 83            [ 4] 3423         ADD     A,E             ; Add LSB of BCDE
   F674 5F            [ 4] 3424         LD      E,A             ; Save LSB of BCDE
   F675 23            [ 4] 3425         INC     HL
   F676 7E            [ 6] 3426         LD      A,(HL)          ; Get NMSB of FPREG
   F677 8A            [ 4] 3427         ADC     A,D             ; Add NMSB of BCDE
   F678 57            [ 4] 3428         LD      D,A             ; Save NMSB of BCDE
   F679 23            [ 4] 3429         INC     HL
   F67A 7E            [ 6] 3430         LD      A,(HL)          ; Get MSB of FPREG
   F67B 89            [ 4] 3431         ADC     A,C             ; Add MSB of BCDE
   F67C 4F            [ 4] 3432         LD      C,A             ; Save MSB of BCDE
   F67D C9            [ 9] 3433         RET
                           3434 
   F67E 21 E8 10      [ 9] 3435 COMPL:  LD      HL,#SGNRES       ; Sign of result
   F681 7E            [ 6] 3436         LD      A,(HL)          ; Get sign of result
   F682 2F            [ 3] 3437         CPL                     ; Negate it
   F683 77            [ 7] 3438         LD      (HL),A          ; Put it back
   F684 AF            [ 4] 3439         XOR     A
   F685 6F            [ 4] 3440         LD      L,A             ; Set L to zero
   F686 90            [ 4] 3441         SUB     B               ; Negate exponent,set carry
   F687 47            [ 4] 3442         LD      B,A             ; Re-save exponent
   F688 7D            [ 4] 3443         LD      A,L             ; Load zero
   F689 9B            [ 4] 3444         SBC     A,E             ; Negate LSB
   F68A 5F            [ 4] 3445         LD      E,A             ; Re-save LSB
   F68B 7D            [ 4] 3446         LD      A,L             ; Load zero
   F68C 9A            [ 4] 3447         SBC     A,D             ; Negate NMSB
   F68D 57            [ 4] 3448         LD      D,A             ; Re-save NMSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 64.
Hexadecimal [16-Bits]



   F68E 7D            [ 4] 3449         LD      A,L             ; Load zero
   F68F 99            [ 4] 3450         SBC     A,C             ; Negate MSB
   F690 4F            [ 4] 3451         LD      C,A             ; Re-save MSB
   F691 C9            [ 9] 3452         RET
                           3453 
   F692 06 00         [ 6] 3454 SCALE:  LD      B,#0             ; Clear underflow
   F694 D6 08         [ 6] 3455 SCALLP: SUB     #8               ; 8 bits (a whole byte)?
   F696 DA A1 F6      [ 9] 3456         JP      C,SHRITE        ; No - Shift right A bits
   F699 43            [ 4] 3457         LD      B,E             ; <- Shift
   F69A 5A            [ 4] 3458         LD      E,D             ; <- right
   F69B 51            [ 4] 3459         LD      D,C             ; <- eight
   F69C 0E 00         [ 6] 3460         LD      C,#0             ; <- bits
   F69E C3 94 F6      [ 9] 3461         JP      SCALLP          ; More bits to shift
                           3462 
   F6A1 C6 09         [ 6] 3463 SHRITE: ADD     A,#8+1           ; Adjust count
   F6A3 6F            [ 4] 3464         LD      L,A             ; Save bits to shift
   F6A4 AF            [ 4] 3465 SHRLP:  XOR     A               ; Flag for all done
   F6A5 2D            [ 4] 3466         DEC     L               ; All shifting done?
   F6A6 C8            [10] 3467         RET     Z               ; Yes - Return
   F6A7 79            [ 4] 3468         LD      A,C             ; Get MSB
   F6A8 1F            [ 3] 3469 SHRT1:  RRA                     ; Shift it right
   F6A9 4F            [ 4] 3470         LD      C,A             ; Re-save
   F6AA 7A            [ 4] 3471         LD      A,D             ; Get NMSB
   F6AB 1F            [ 3] 3472         RRA                     ; Shift right with last bit
   F6AC 57            [ 4] 3473         LD      D,A             ; Re-save it
   F6AD 7B            [ 4] 3474         LD      A,E             ; Get LSB
   F6AE 1F            [ 3] 3475         RRA                     ; Shift right with last bit
   F6AF 5F            [ 4] 3476         LD      E,A             ; Re-save it
   F6B0 78            [ 4] 3477         LD      A,B             ; Get underflow
   F6B1 1F            [ 3] 3478         RRA                     ; Shift right with last bit
   F6B2 47            [ 4] 3479         LD      B,A             ; Re-save underflow
   F6B3 C3 A4 F6      [ 9] 3480         JP      SHRLP           ; More bits to do
                           3481 
   F6B6 00 00 00 81        3482 UNITY:  .db       0x00,0x00,0x00,0x81    ; 1.00000
                           3483 
   F6BA 03                 3484 LOGTAB: .db      3                       ; Table used by LOG
   F6BB AA 56 19 80        3485         .db      0xAA,0x56,0x19,0x80     ; 0.59898
   F6BF F1 22 76 80        3486         .db      0xF1,0x22,0x76,0x80     ; 0.96147
   F6C3 45 AA 38 82        3487         .db      0x45,0xAA,0x38,0x82     ; 2.88539
                           3488 
   F6C7 CD 13 F8      [16] 3489 LOG:    CALL    TSTSGN          ; Test sign of value
   F6CA B7            [ 4] 3490         OR      A
   F6CB EA A0 E9      [ 9] 3491         JP      PE,FCERR        ; ?FC Error if <= zero
   F6CE 21 E7 10      [ 9] 3492         LD      HL,#FPEXP        ; Point to exponent
   F6D1 7E            [ 6] 3493         LD      A,(HL)          ; Get exponent
   F6D2 01 35 80      [ 9] 3494         LD      BC,#0x8035        ; BCDE = SQR(1/2)
   F6D5 11 F3 04      [ 9] 3495         LD      DE,#0x04F3
   F6D8 90            [ 4] 3496         SUB     B               ; Scale value to be < 1
   F6D9 F5            [11] 3497         PUSH    AF              ; Save scale factor
   F6DA 70            [ 7] 3498         LD      (HL),B          ; Save new exponent
   F6DB D5            [11] 3499         PUSH    DE              ; Save SQR(1/2)
   F6DC C5            [11] 3500         PUSH    BC
   F6DD CD CD F5      [16] 3501         CALL    FPADD           ; Add SQR(1/2) to value
   F6E0 C1            [ 9] 3502         POP     BC              ; Restore SQR(1/2)
   F6E1 D1            [ 9] 3503         POP     DE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 65.
Hexadecimal [16-Bits]



   F6E2 04            [ 4] 3504         INC     B               ; Make it SQR(2)
   F6E3 CD 69 F7      [16] 3505         CALL    DVBCDE          ; Divide by SQR(2)
   F6E6 21 B6 F6      [ 9] 3506         LD      HL,#UNITY        ; Point to 1.
   F6E9 CD C4 F5      [16] 3507         CALL    SUBPHL          ; Subtract FPREG from 1
   F6EC 21 BA F6      [ 9] 3508         LD      HL,#LOGTAB       ; Coefficient table
   F6EF CD 5B FB      [16] 3509         CALL    SUMSER          ; Evaluate sum of series
   F6F2 01 80 80      [ 9] 3510         LD      BC,#0x8080        ; BCDE = -0.5
   F6F5 11 00 00      [ 9] 3511         LD      DE,#0x0000
   F6F8 CD CD F5      [16] 3512         CALL    FPADD           ; Subtract 0.5 from FPREG
   F6FB F1            [ 9] 3513         POP     AF              ; Restore scale factor
   F6FC CD 8E F9      [16] 3514         CALL    RSCALE          ; Re-scale number
   F6FF 01 31 80      [ 9] 3515 MULLN2: LD      BC,#0x8031        ; BCDE = Ln(2)
   F702 11 18 72      [ 9] 3516         LD      DE,#0x7218
   F705 21                 3517         .db      0x21             ; Skip "POP BC" and "POP DE"
                           3518 
   F706 C1            [ 9] 3519 MULT:   POP     BC              ; Get number from stack
   F707 D1            [ 9] 3520         POP     DE
   F708 CD 13 F8      [16] 3521 FPMULT: CALL    TSTSGN          ; Test sign of FPREG
   F70B C8            [10] 3522         RET     Z               ; Return zero if zero
   F70C 2E 00         [ 6] 3523         LD      L,#0             ; Flag add exponents
   F70E CD D1 F7      [16] 3524         CALL    ADDEXP          ; Add exponents
   F711 79            [ 4] 3525         LD      A,C             ; Get MSB of multiplier
   F712 32 F6 10      [13] 3526         LD      (MULVAL),A      ; Save MSB of multiplier
   F715 EB            [ 3] 3527         EX      DE,HL
   F716 22 F7 10      [16] 3528         LD      (MULVAL+1),HL   ; Save rest of multiplier
   F719 01 00 00      [ 9] 3529         LD      BC,#0            ; Partial product (BCDE) = zero
   F71C 50            [ 4] 3530         LD      D,B
   F71D 58            [ 4] 3531         LD      E,B
   F71E 21 1E F6      [ 9] 3532         LD      HL,#BNORM        ; Address of normalise
   F721 E5            [11] 3533         PUSH    HL              ; Save for return
   F722 21 2A F7      [ 9] 3534         LD      HL,#MULT8        ; Address of 8 bit multiply
   F725 E5            [11] 3535         PUSH    HL              ; Save for NMSB,MSB
   F726 E5            [11] 3536         PUSH    HL              ; 
   F727 21 E4 10      [ 9] 3537         LD      HL,#FPREG        ; Point to number
   F72A 7E            [ 6] 3538 MULT8:  LD      A,(HL)          ; Get LSB of number
   F72B 23            [ 4] 3539         INC     HL              ; Point to NMSB
   F72C B7            [ 4] 3540         OR      A               ; Test LSB
   F72D CA 56 F7      [ 9] 3541         JP      Z,BYTSFT        ; Zero - shift to next byte
   F730 E5            [11] 3542         PUSH    HL              ; Save address of number
   F731 2E 08         [ 6] 3543         LD      L,#8             ; 8 bits to multiply by
   F733 1F            [ 3] 3544 MUL8LP: RRA                     ; Shift LSB right
   F734 67            [ 4] 3545         LD      H,A             ; Save LSB
   F735 79            [ 4] 3546         LD      A,C             ; Get MSB
   F736 D2 44 F7      [ 9] 3547         JP      NC,NOMADD       ; Bit was zero - Don't add
   F739 E5            [11] 3548         PUSH    HL              ; Save LSB and count
   F73A 2A F7 10      [15] 3549         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
   F73D 19            [ 7] 3550         ADD     HL,DE           ; Add NMSB and LSB
   F73E EB            [ 3] 3551         EX      DE,HL           ; Leave sum in DE
   F73F E1            [ 9] 3552         POP     HL              ; Restore MSB and count
   F740 3A F6 10      [12] 3553         LD      A,(MULVAL)      ; Get MSB of multiplier
   F743 89            [ 4] 3554         ADC     A,C             ; Add MSB
   F744 1F            [ 3] 3555 NOMADD: RRA                     ; Shift MSB right
   F745 4F            [ 4] 3556         LD      C,A             ; Re-save MSB
   F746 7A            [ 4] 3557         LD      A,D             ; Get NMSB
   F747 1F            [ 3] 3558         RRA                     ; Shift NMSB right
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 66.
Hexadecimal [16-Bits]



   F748 57            [ 4] 3559         LD      D,A             ; Re-save NMSB
   F749 7B            [ 4] 3560         LD      A,E             ; Get LSB
   F74A 1F            [ 3] 3561         RRA                     ; Shift LSB right
   F74B 5F            [ 4] 3562         LD      E,A             ; Re-save LSB
   F74C 78            [ 4] 3563         LD      A,B             ; Get VLSB
   F74D 1F            [ 3] 3564         RRA                     ; Shift VLSB right
   F74E 47            [ 4] 3565         LD      B,A             ; Re-save VLSB
   F74F 2D            [ 4] 3566         DEC     L               ; Count bits multiplied
   F750 7C            [ 4] 3567         LD      A,H             ; Get LSB of multiplier
   F751 C2 33 F7      [ 9] 3568         JP      NZ,MUL8LP       ; More - Do it
   F754 E1            [ 9] 3569 POPHRT: POP     HL              ; Restore address of number
   F755 C9            [ 9] 3570         RET
                           3571 
   F756 43            [ 4] 3572 BYTSFT: LD      B,E             ; Shift partial product left
   F757 5A            [ 4] 3573         LD      E,D
   F758 51            [ 4] 3574         LD      D,C
   F759 4F            [ 4] 3575         LD      C,A
   F75A C9            [ 9] 3576         RET
                           3577 
   F75B CD 44 F8      [16] 3578 DIV10:  CALL    STAKFP          ; Save FPREG on stack
   F75E 01 20 84      [ 9] 3579         LD      BC,#0x8420        ; BCDE = 10.
   F761 11 00 00      [ 9] 3580         LD      DE,#0x0000
   F764 CD 54 F8      [16] 3581         CALL    FPBCDE          ; Move 10 to FPREG
                           3582 
   F767 C1            [ 9] 3583 DIV:    POP     BC              ; Get number from stack
   F768 D1            [ 9] 3584         POP     DE
   F769 CD 13 F8      [16] 3585 DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
   F76C CA B0 E3      [ 9] 3586         JP      Z,DZERR         ; Error if division by zero
   F76F 2E FF         [ 6] 3587         LD      L,#-1            ; Flag subtract exponents
   F771 CD D1 F7      [16] 3588         CALL    ADDEXP          ; Subtract exponents
   F774 34            [10] 3589         INC     (HL)            ; Add 2 to exponent to adjust
   F775 34            [10] 3590         INC     (HL)
   F776 2B            [ 4] 3591         DEC     HL              ; Point to MSB
   F777 7E            [ 6] 3592         LD      A,(HL)          ; Get MSB of dividend
   F778 32 12 10      [13] 3593         LD      (DIV3),A        ; Save for subtraction
   F77B 2B            [ 4] 3594         DEC     HL
   F77C 7E            [ 6] 3595         LD      A,(HL)          ; Get NMSB of dividend
   F77D 32 0E 10      [13] 3596         LD      (DIV2),A        ; Save for subtraction
   F780 2B            [ 4] 3597         DEC     HL
   F781 7E            [ 6] 3598         LD      A,(HL)          ; Get MSB of dividend
   F782 32 0A 10      [13] 3599         LD      (DIV1),A        ; Save for subtraction
   F785 41            [ 4] 3600         LD      B,C             ; Get MSB
   F786 EB            [ 3] 3601         EX      DE,HL           ; NMSB,LSB to HL
   F787 AF            [ 4] 3602         XOR     A
   F788 4F            [ 4] 3603         LD      C,A             ; Clear MSB of quotient
   F789 57            [ 4] 3604         LD      D,A             ; Clear NMSB of quotient
   F78A 5F            [ 4] 3605         LD      E,A             ; Clear LSB of quotient
   F78B 32 15 10      [13] 3606         LD      (DIV4),A        ; Clear overflow count
   F78E E5            [11] 3607 DIVLP:  PUSH    HL              ; Save divisor
   F78F C5            [11] 3608         PUSH    BC
   F790 7D            [ 4] 3609         LD      A,L             ; Get LSB of number
   F791 CD 09 10      [16] 3610         CALL    DIVSUP          ; Subt' divisor from dividend
   F794 DE 00         [ 6] 3611         SBC     A,#0             ; Count for overflows
   F796 3F            [ 3] 3612         CCF
   F797 D2 A1 F7      [ 9] 3613         JP      NC,RESDIV       ; Restore divisor if borrow
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 67.
Hexadecimal [16-Bits]



   F79A 32 15 10      [13] 3614         LD      (DIV4),A        ; Re-save overflow count
   F79D F1            [ 9] 3615         POP     AF              ; Scrap divisor
   F79E F1            [ 9] 3616         POP     AF
   F79F 37            [ 3] 3617         SCF                     ; Set carry to
   F7A0 D2                 3618         .db      0x0D2            ; Skip "POP BC" and "POP HL"
                           3619 
   F7A1 C1            [ 9] 3620 RESDIV: POP     BC              ; Restore divisor
   F7A2 E1            [ 9] 3621         POP     HL
   F7A3 79            [ 4] 3622         LD      A,C             ; Get MSB of quotient
   F7A4 3C            [ 4] 3623         INC     A
   F7A5 3D            [ 4] 3624         DEC     A
   F7A6 1F            [ 3] 3625         RRA                     ; Bit 0 to bit 7
   F7A7 FA 54 F6      [ 9] 3626         JP      M,RONDB         ; Done - Normalise result
   F7AA 17            [ 3] 3627         RLA                     ; Restore carry
   F7AB 7B            [ 4] 3628         LD      A,E             ; Get LSB of quotient
   F7AC 17            [ 3] 3629         RLA                     ; Double it
   F7AD 5F            [ 4] 3630         LD      E,A             ; Put it back
   F7AE 7A            [ 4] 3631         LD      A,D             ; Get NMSB of quotient
   F7AF 17            [ 3] 3632         RLA                     ; Double it
   F7B0 57            [ 4] 3633         LD      D,A             ; Put it back
   F7B1 79            [ 4] 3634         LD      A,C             ; Get MSB of quotient
   F7B2 17            [ 3] 3635         RLA                     ; Double it
   F7B3 4F            [ 4] 3636         LD      C,A             ; Put it back
   F7B4 29            [ 7] 3637         ADD     HL,HL           ; Double NMSB,LSB of divisor
   F7B5 78            [ 4] 3638         LD      A,B             ; Get MSB of divisor
   F7B6 17            [ 3] 3639         RLA                     ; Double it
   F7B7 47            [ 4] 3640         LD      B,A             ; Put it back
   F7B8 3A 15 10      [12] 3641         LD      A,(DIV4)        ; Get VLSB of quotient
   F7BB 17            [ 3] 3642         RLA                     ; Double it
   F7BC 32 15 10      [13] 3643         LD      (DIV4),A        ; Put it back
   F7BF 79            [ 4] 3644         LD      A,C             ; Get MSB of quotient
   F7C0 B2            [ 4] 3645         OR      D               ; Merge NMSB
   F7C1 B3            [ 4] 3646         OR      E               ; Merge LSB
   F7C2 C2 8E F7      [ 9] 3647         JP      NZ,DIVLP        ; Not done - Keep dividing
   F7C5 E5            [11] 3648         PUSH    HL              ; Save divisor
   F7C6 21 E7 10      [ 9] 3649         LD      HL,#FPEXP        ; Point to exponent
   F7C9 35            [10] 3650         DEC     (HL)            ; Divide by 2
   F7CA E1            [ 9] 3651         POP     HL              ; Restore divisor
   F7CB C2 8E F7      [ 9] 3652         JP      NZ,DIVLP        ; Ok - Keep going
   F7CE C3 BC E3      [ 9] 3653         JP      OVERR           ; Overflow error
                           3654 
   F7D1 78            [ 4] 3655 ADDEXP: LD      A,B             ; Get exponent of dividend
   F7D2 B7            [ 4] 3656         OR      A               ; Test it
   F7D3 CA F5 F7      [ 9] 3657         JP      Z,OVTST3        ; Zero - Result zero
   F7D6 7D            [ 4] 3658         LD      A,L             ; Get add/subtract flag
   F7D7 21 E7 10      [ 9] 3659         LD      HL,#FPEXP        ; Point to exponent
   F7DA AE            [ 6] 3660         XOR     (HL)            ; Add or subtract it
   F7DB 80            [ 4] 3661         ADD     A,B             ; Add the other exponent
   F7DC 47            [ 4] 3662         LD      B,A             ; Save new exponent
   F7DD 1F            [ 3] 3663         RRA                     ; Test exponent for overflow
   F7DE A8            [ 4] 3664         XOR     B
   F7DF 78            [ 4] 3665         LD      A,B             ; Get exponent
   F7E0 F2 F4 F7      [ 9] 3666         JP      P,OVTST2        ; Positive - Test for overflow
   F7E3 C6 80         [ 6] 3667         ADD     A,#0x80           ; Add excess 128
   F7E5 77            [ 7] 3668         LD      (HL),A          ; Save new exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 68.
Hexadecimal [16-Bits]



   F7E6 CA 54 F7      [ 9] 3669         JP      Z,POPHRT        ; Zero - Result zero
   F7E9 CD 79 F8      [16] 3670         CALL    SIGNS           ; Set MSBs and sign of result
   F7EC 77            [ 7] 3671         LD      (HL),A          ; Save new exponent
   F7ED 2B            [ 4] 3672         DEC     HL              ; Point to MSB
   F7EE C9            [ 9] 3673         RET
                           3674 
   F7EF CD 13 F8      [16] 3675 OVTST1: CALL    TSTSGN          ; Test sign of FPREG
   F7F2 2F            [ 3] 3676         CPL                     ; Invert sign
   F7F3 E1            [ 9] 3677         POP     HL              ; Clean up stack
   F7F4 B7            [ 4] 3678 OVTST2: OR      A               ; Test if new exponent zero
   F7F5 E1            [ 9] 3679 OVTST3: POP     HL              ; Clear off return address
   F7F6 F2 33 F6      [ 9] 3680         JP      P,RESZER        ; Result zero
   F7F9 C3 BC E3      [ 9] 3681         JP      OVERR           ; Overflow error
                           3682 
   F7FC CD 5F F8      [16] 3683 MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
   F7FF 78            [ 4] 3684         LD      A,B             ; Get exponent
   F800 B7            [ 4] 3685         OR      A               ; Is it zero?
   F801 C8            [10] 3686         RET     Z               ; Yes - Result is zero
   F802 C6 02         [ 6] 3687         ADD     A,#2             ; Multiply by 4
   F804 DA BC E3      [ 9] 3688         JP      C,OVERR         ; Overflow - ?OV Error
   F807 47            [ 4] 3689         LD      B,A             ; Re-save exponent
   F808 CD CD F5      [16] 3690         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
   F80B 21 E7 10      [ 9] 3691         LD      HL,#FPEXP        ; Point to exponent
   F80E 34            [10] 3692         INC     (HL)            ; Double number (Times 10)
   F80F C0            [10] 3693         RET     NZ              ; Ok - Return
   F810 C3 BC E3      [ 9] 3694         JP      OVERR           ; Overflow error
                           3695 
   F813 3A E7 10      [12] 3696 TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
   F816 B7            [ 4] 3697         OR      A
   F817 C8            [10] 3698         RET     Z               ; RETurn if number is zero
   F818 3A E6 10      [12] 3699         LD      A,(FPREG+2)     ; Get MSB of FPREG
   F81B FE                 3700         .db      0x0FE            ; Test sign
   F81C 2F            [ 3] 3701 RETREL: CPL                     ; Invert sign
   F81D 17            [ 3] 3702         RLA                     ; Sign bit to carry
   F81E 9F            [ 4] 3703 FLGDIF: SBC     A,A             ; Carry to all bits of A
   F81F C0            [10] 3704         RET     NZ              ; Return -1 if negative
   F820 3C            [ 4] 3705         INC     A               ; Bump to +1
   F821 C9            [ 9] 3706         RET                     ; Positive - Return +1
                           3707 
   F822 CD 13 F8      [16] 3708 SGN:    CALL    TSTSGN          ; Test sign of FPREG
   F825 06 88         [ 6] 3709 FLGREL: LD      B,#0x80+8         ; 8 bit integer in exponent
   F827 11 00 00      [ 9] 3710         LD      DE,#0            ; Zero NMSB and LSB
   F82A 21 E7 10      [ 9] 3711 RETINT: LD      HL,#FPEXP        ; Point to exponent
   F82D 4F            [ 4] 3712         LD      C,A             ; CDE = MSB,NMSB and LSB
   F82E 70            [ 7] 3713         LD      (HL),B          ; Save exponent
   F82F 06 00         [ 6] 3714         LD      B,#0             ; CDE = integer to normalise
   F831 23            [ 4] 3715         INC     HL              ; Point to sign of result
   F832 36 80         [ 9] 3716         LD      (HL),#0x80        ; Set sign of result
   F834 17            [ 3] 3717         RLA                     ; Carry = sign of integer
   F835 C3 1B F6      [ 9] 3718         JP      CONPOS          ; Set sign of result
                           3719 
   F838 CD 13 F8      [16] 3720 ABS:    CALL    TSTSGN          ; Test sign of FPREG
   F83B F0            [10] 3721         RET     P               ; Return if positive
   F83C 21 E6 10      [ 9] 3722 INVSGN: LD      HL,#FPREG+2      ; Point to MSB
   F83F 7E            [ 6] 3723         LD      A,(HL)          ; Get sign of mantissa
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 69.
Hexadecimal [16-Bits]



   F840 EE 80         [ 6] 3724         XOR     #0x80             ; Invert sign of mantissa
   F842 77            [ 7] 3725         LD      (HL),A          ; Re-save sign of mantissa
   F843 C9            [ 9] 3726         RET
                           3727 
   F844 EB            [ 3] 3728 STAKFP: EX      DE,HL           ; Save code string address
   F845 2A E4 10      [15] 3729         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
   F848 E3            [16] 3730         EX      (SP),HL         ; Stack them,get return
   F849 E5            [11] 3731         PUSH    HL              ; Re-save return
   F84A 2A E6 10      [15] 3732         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
   F84D E3            [16] 3733         EX      (SP),HL         ; Stack them,get return
   F84E E5            [11] 3734         PUSH    HL              ; Re-save return
   F84F EB            [ 3] 3735         EX      DE,HL           ; Restore code string address
   F850 C9            [ 9] 3736         RET
                           3737 
   F851 CD 62 F8      [16] 3738 PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
   F854 EB            [ 3] 3739 FPBCDE: EX      DE,HL           ; Save code string address
   F855 22 E4 10      [16] 3740         LD      (FPREG),HL      ; Save LSB,NLSB of number
   F858 60            [ 4] 3741         LD      H,B             ; Exponent of number
   F859 69            [ 4] 3742         LD      L,C             ; MSB of number
   F85A 22 E6 10      [16] 3743         LD      (FPREG+2),HL    ; Save MSB and exponent
   F85D EB            [ 3] 3744         EX      DE,HL           ; Restore code string address
   F85E C9            [ 9] 3745         RET
                           3746 
   F85F 21 E4 10      [ 9] 3747 BCDEFP: LD      HL,#FPREG        ; Point to FPREG
   F862 5E            [ 6] 3748 LOADFP: LD      E,(HL)          ; Get LSB of number
   F863 23            [ 4] 3749         INC     HL
   F864 56            [ 6] 3750         LD      D,(HL)          ; Get NMSB of number
   F865 23            [ 4] 3751         INC     HL
   F866 4E            [ 6] 3752         LD      C,(HL)          ; Get MSB of number
   F867 23            [ 4] 3753         INC     HL
   F868 46            [ 6] 3754         LD      B,(HL)          ; Get exponent of number
   F869 23            [ 4] 3755 INCHL:  INC     HL              ; Used for conditional "INC HL"
   F86A C9            [ 9] 3756         RET
                           3757 
   F86B 11 E4 10      [ 9] 3758 FPTHL:  LD      DE,#FPREG        ; Point to FPREG
   F86E 06 04         [ 6] 3759 DETHL4: LD      B,#4             ; 4 bytes to move
   F870 1A            [ 6] 3760 DETHLB: LD      A,(DE)          ; Get source
   F871 77            [ 7] 3761         LD      (HL),A          ; Save destination
   F872 13            [ 4] 3762         INC     DE              ; Next source
   F873 23            [ 4] 3763         INC     HL              ; Next destination
   F874 05            [ 4] 3764         DEC     B               ; Count bytes
   F875 C2 70 F8      [ 9] 3765         JP      NZ,DETHLB       ; Loop if more
   F878 C9            [ 9] 3766         RET
                           3767 
   F879 21 E6 10      [ 9] 3768 SIGNS:  LD      HL,#FPREG+2      ; Point to MSB of FPREG
   F87C 7E            [ 6] 3769         LD      A,(HL)          ; Get MSB
   F87D 07            [ 3] 3770         RLCA                    ; Old sign to carry
   F87E 37            [ 3] 3771         SCF                     ; Set MSBit
   F87F 1F            [ 3] 3772         RRA                     ; Set MSBit of MSB
   F880 77            [ 7] 3773         LD      (HL),A          ; Save new MSB
   F881 3F            [ 3] 3774         CCF                     ; Complement sign
   F882 1F            [ 3] 3775         RRA                     ; Old sign to carry
   F883 23            [ 4] 3776         INC     HL
   F884 23            [ 4] 3777         INC     HL
   F885 77            [ 7] 3778         LD      (HL),A          ; Set sign of result
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 70.
Hexadecimal [16-Bits]



   F886 79            [ 4] 3779         LD      A,C             ; Get MSB
   F887 07            [ 3] 3780         RLCA                    ; Old sign to carry
   F888 37            [ 3] 3781         SCF                     ; Set MSBit
   F889 1F            [ 3] 3782         RRA                     ; Set MSBit of MSB
   F88A 4F            [ 4] 3783         LD      C,A             ; Save MSB
   F88B 1F            [ 3] 3784         RRA
   F88C AE            [ 6] 3785         XOR     (HL)            ; New sign of result
   F88D C9            [ 9] 3786         RET
                           3787 
   F88E 78            [ 4] 3788 CMPNUM: LD      A,B             ; Get exponent of number
   F88F B7            [ 4] 3789         OR      A
   F890 CA 13 F8      [ 9] 3790         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
   F893 21 1C F8      [ 9] 3791         LD      HL,#RETREL       ; Return relation routine
   F896 E5            [11] 3792         PUSH    HL              ; Save for return
   F897 CD 13 F8      [16] 3793         CALL    TSTSGN          ; Test sign of FPREG
   F89A 79            [ 4] 3794         LD      A,C             ; Get MSB of number
   F89B C8            [10] 3795         RET     Z               ; FPREG zero - Number's MSB
   F89C 21 E6 10      [ 9] 3796         LD      HL,#FPREG+2      ; MSB of FPREG
   F89F AE            [ 6] 3797         XOR     (HL)            ; Combine signs
   F8A0 79            [ 4] 3798         LD      A,C             ; Get MSB of number
   F8A1 F8            [10] 3799         RET     M               ; Exit if signs different
   F8A2 CD A8 F8      [16] 3800         CALL    CMPFP           ; Compare FP numbers
   F8A5 1F            [ 3] 3801         RRA                     ; Get carry to sign
   F8A6 A9            [ 4] 3802         XOR     C               ; Combine with MSB of number
   F8A7 C9            [ 9] 3803         RET
                           3804 
   F8A8 23            [ 4] 3805 CMPFP:  INC     HL              ; Point to exponent
   F8A9 78            [ 4] 3806         LD      A,B             ; Get exponent
   F8AA BE            [ 6] 3807         CP      (HL)            ; Compare exponents
   F8AB C0            [10] 3808         RET     NZ              ; Different
   F8AC 2B            [ 4] 3809         DEC     HL              ; Point to MBS
   F8AD 79            [ 4] 3810         LD      A,C             ; Get MSB
   F8AE BE            [ 6] 3811         CP      (HL)            ; Compare MSBs
   F8AF C0            [10] 3812         RET     NZ              ; Different
   F8B0 2B            [ 4] 3813         DEC     HL              ; Point to NMSB
   F8B1 7A            [ 4] 3814         LD      A,D             ; Get NMSB
   F8B2 BE            [ 6] 3815         CP      (HL)            ; Compare NMSBs
   F8B3 C0            [10] 3816         RET     NZ              ; Different
   F8B4 2B            [ 4] 3817         DEC     HL              ; Point to LSB
   F8B5 7B            [ 4] 3818         LD      A,E             ; Get LSB
   F8B6 96            [ 6] 3819         SUB     (HL)            ; Compare LSBs
   F8B7 C0            [10] 3820         RET     NZ              ; Different
   F8B8 E1            [ 9] 3821         POP     HL              ; Drop RETurn
   F8B9 E1            [ 9] 3822         POP     HL              ; Drop another RETurn
   F8BA C9            [ 9] 3823         RET
                           3824 
   F8BB 47            [ 4] 3825 FPINT:  LD      B,A             ; <- Move
   F8BC 4F            [ 4] 3826         LD      C,A             ; <- exponent
   F8BD 57            [ 4] 3827         LD      D,A             ; <- to all
   F8BE 5F            [ 4] 3828         LD      E,A             ; <- bits
   F8BF B7            [ 4] 3829         OR      A               ; Test exponent
   F8C0 C8            [10] 3830         RET     Z               ; Zero - Return zero
   F8C1 E5            [11] 3831         PUSH    HL              ; Save pointer to number
   F8C2 CD 5F F8      [16] 3832         CALL    BCDEFP          ; Move FPREG to BCDE
   F8C5 CD 79 F8      [16] 3833         CALL    SIGNS           ; Set MSBs & sign of result
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 71.
Hexadecimal [16-Bits]



   F8C8 AE            [ 6] 3834         XOR     (HL)            ; Combine with sign of FPREG
   F8C9 67            [ 4] 3835         LD      H,A             ; Save combined signs
   F8CA FC DF F8      [16] 3836         CALL    M,DCBCDE        ; Negative - Decrement BCDE
   F8CD 3E 98         [ 6] 3837         LD      A,#0x80+24        ; 24 bits
   F8CF 90            [ 4] 3838         SUB     B               ; Bits to shift
   F8D0 CD 92 F6      [16] 3839         CALL    SCALE           ; Shift BCDE
   F8D3 7C            [ 4] 3840         LD      A,H             ; Get combined sign
   F8D4 17            [ 3] 3841         RLA                     ; Sign to carry
   F8D5 DC 65 F6      [16] 3842         CALL    C,FPROND        ; Negative - Round number up
   F8D8 06 00         [ 6] 3843         LD      B,#0             ; Zero exponent
   F8DA DC 7E F6      [16] 3844         CALL    C,COMPL         ; If negative make positive
   F8DD E1            [ 9] 3845         POP     HL              ; Restore pointer to number
   F8DE C9            [ 9] 3846         RET
                           3847 
   F8DF 1B            [ 4] 3848 DCBCDE: DEC     DE              ; Decrement BCDE
   F8E0 7A            [ 4] 3849         LD      A,D             ; Test LSBs
   F8E1 A3            [ 4] 3850         AND     E
   F8E2 3C            [ 4] 3851         INC     A
   F8E3 C0            [10] 3852         RET     NZ              ; Exit if LSBs not FFFF
   F8E4 0B            [ 4] 3853         DEC     BC              ; Decrement MSBs
   F8E5 C9            [ 9] 3854         RET
                           3855 
   F8E6 21 E7 10      [ 9] 3856 INT:    LD      HL,#FPEXP        ; Point to exponent
   F8E9 7E            [ 6] 3857         LD      A,(HL)          ; Get exponent
   F8EA FE 98         [ 6] 3858         CP      #0x80+24          ; Integer accuracy only?
   F8EC 3A E4 10      [12] 3859         LD      A,(FPREG)       ; Get LSB
   F8EF D0            [10] 3860         RET     NC              ; Yes - Already integer
   F8F0 7E            [ 6] 3861         LD      A,(HL)          ; Get exponent
   F8F1 CD BB F8      [16] 3862         CALL    FPINT           ; F.P to integer
   F8F4 36 98         [ 9] 3863         LD      (HL),#0x80+24     ; Save 24 bit integer
   F8F6 7B            [ 4] 3864         LD      A,E             ; Get LSB of number
   F8F7 F5            [11] 3865         PUSH    AF              ; Save LSB
   F8F8 79            [ 4] 3866         LD      A,C             ; Get MSB of number
   F8F9 17            [ 3] 3867         RLA                     ; Sign to carry
   F8FA CD 1B F6      [16] 3868         CALL    CONPOS          ; Set sign of result
   F8FD F1            [ 9] 3869         POP     AF              ; Restore LSB of number
   F8FE C9            [ 9] 3870         RET
                           3871 
   F8FF 21 00 00      [ 9] 3872 MLDEBC: LD      HL,#0            ; Clear partial product
   F902 78            [ 4] 3873         LD      A,B             ; Test multiplier
   F903 B1            [ 4] 3874         OR      C
   F904 C8            [10] 3875         RET     Z               ; Return zero if zero
   F905 3E 10         [ 6] 3876         LD      A,#16            ; 16 bits
   F907 29            [ 7] 3877 MLDBLP: ADD     HL,HL           ; Shift P.P left
   F908 DA 45 F0      [ 9] 3878         JP      C,BSERR         ; ?BS Error if overflow
   F90B EB            [ 3] 3879         EX      DE,HL
   F90C 29            [ 7] 3880         ADD     HL,HL           ; Shift multiplier left
   F90D EB            [ 3] 3881         EX      DE,HL
   F90E D2 15 F9      [ 9] 3882         JP      NC,NOMLAD       ; Bit was zero - No add
   F911 09            [ 7] 3883         ADD     HL,BC           ; Add multiplicand
   F912 DA 45 F0      [ 9] 3884         JP      C,BSERR         ; ?BS Error if overflow
   F915 3D            [ 4] 3885 NOMLAD: DEC     A               ; Count bits
   F916 C2 07 F9      [ 9] 3886         JP      NZ,MLDBLP       ; More
   F919 C9            [ 9] 3887         RET
                           3888 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 72.
Hexadecimal [16-Bits]



   F91A FE 2D         [ 6] 3889 ASCTFP: CP      #"-"             ; Negative?
   F91C F5            [11] 3890         PUSH    AF              ; Save it and flags
   F91D CA 26 F9      [ 9] 3891         JP      Z,CNVNUM        ; Yes - Convert number
   F920 FE 2B         [ 6] 3892         CP      #"+"             ; Positive?
   F922 CA 26 F9      [ 9] 3893         JP      Z,CNVNUM        ; Yes - Convert number
   F925 2B            [ 4] 3894         DEC     HL              ; DEC 'cos GETCHR INCs
   F926 CD 33 F6      [16] 3895 CNVNUM: CALL    RESZER          ; Set result to zero
   F929 47            [ 4] 3896         LD      B,A             ; Digits after point counter
   F92A 57            [ 4] 3897         LD      D,A             ; Sign of exponent
   F92B 5F            [ 4] 3898         LD      E,A             ; Exponent of ten
   F92C 2F            [ 3] 3899         CPL
   F92D 4F            [ 4] 3900         LD      C,A             ; Before or after point flag
   F92E CD 36 E8      [16] 3901 MANLP:  CALL    GETCHR          ; Get next character
   F931 DA 77 F9      [ 9] 3902         JP      C,ADDIG         ; Digit - Add to number
   F934 FE 2E         [ 6] 3903         CP      #"."
   F936 CA 52 F9      [ 9] 3904         JP      Z,DPOINT        ; "." - Flag point
   F939 FE 45         [ 6] 3905         CP      #"E"
   F93B C2 56 F9      [ 9] 3906         JP      NZ,CONEXP       ; Not "E" - Scale number
   F93E CD 36 E8      [16] 3907         CALL    GETCHR          ; Get next character
   F941 CD 70 EE      [16] 3908         CALL    SGNEXP          ; Get sign of exponent
   F944 CD 36 E8      [16] 3909 EXPLP:  CALL    GETCHR          ; Get next character
   F947 DA 99 F9      [ 9] 3910         JP      C,EDIGIT        ; Digit - Add to exponent
   F94A 14            [ 4] 3911         INC     D               ; Is sign negative?
   F94B C2 56 F9      [ 9] 3912         JP      NZ,CONEXP       ; No - Scale number
   F94E AF            [ 4] 3913         XOR     A
   F94F 93            [ 4] 3914         SUB     E               ; Negate exponent
   F950 5F            [ 4] 3915         LD      E,A             ; And re-save it
   F951 0C            [ 4] 3916         INC     C               ; Flag end of number
   F952 0C            [ 4] 3917 DPOINT: INC     C               ; Flag point passed
   F953 CA 2E F9      [ 9] 3918         JP      Z,MANLP         ; Zero - Get another digit
   F956 E5            [11] 3919 CONEXP: PUSH    HL              ; Save code string address
   F957 7B            [ 4] 3920         LD      A,E             ; Get exponent
   F958 90            [ 4] 3921         SUB     B               ; Subtract digits after point
   F959 F4 6F F9      [16] 3922 SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
   F95C F2 65 F9      [ 9] 3923         JP      P,ENDCON        ; Positive - All done
   F95F F5            [11] 3924         PUSH    AF              ; Save number of times to /10
   F960 CD 5B F7      [16] 3925         CALL    DIV10           ; Divide by 10
   F963 F1            [ 9] 3926         POP     AF              ; Restore count
   F964 3C            [ 4] 3927         INC     A               ; Count divides
                           3928 
   F965 C2 59 F9      [ 9] 3929 ENDCON: JP      NZ,SCALMI       ; More to do
   F968 D1            [ 9] 3930         POP     DE              ; Restore code string address
   F969 F1            [ 9] 3931         POP     AF              ; Restore sign of number
   F96A CC 3C F8      [16] 3932         CALL    Z,INVSGN        ; Negative - Negate number
   F96D EB            [ 3] 3933         EX      DE,HL           ; Code string address to HL
   F96E C9            [ 9] 3934         RET
                           3935 
   F96F C8            [10] 3936 SCALPL: RET     Z               ; Exit if no scaling needed
   F970 F5            [11] 3937 MULTEN: PUSH    AF              ; Save count
   F971 CD FC F7      [16] 3938         CALL    MLSP10          ; Multiply number by 10
   F974 F1            [ 9] 3939         POP     AF              ; Restore count
   F975 3D            [ 4] 3940         DEC     A               ; Count multiplies
   F976 C9            [ 9] 3941         RET
                           3942 
   F977 D5            [11] 3943 ADDIG:  PUSH    DE              ; Save sign of exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 73.
Hexadecimal [16-Bits]



   F978 57            [ 4] 3944         LD      D,A             ; Save digit
   F979 78            [ 4] 3945         LD      A,B             ; Get digits after point
   F97A 89            [ 4] 3946         ADC     A,C             ; Add one if after point
   F97B 47            [ 4] 3947         LD      B,A             ; Re-save counter
   F97C C5            [11] 3948         PUSH    BC              ; Save point flags
   F97D E5            [11] 3949         PUSH    HL              ; Save code string address
   F97E D5            [11] 3950         PUSH    DE              ; Save digit
   F97F CD FC F7      [16] 3951         CALL    MLSP10          ; Multiply number by 10
   F982 F1            [ 9] 3952         POP     AF              ; Restore digit
   F983 D6 30         [ 6] 3953         SUB     #"0"             ; Make it absolute
   F985 CD 8E F9      [16] 3954         CALL    RSCALE          ; Re-scale number
   F988 E1            [ 9] 3955         POP     HL              ; Restore code string address
   F989 C1            [ 9] 3956         POP     BC              ; Restore point flags
   F98A D1            [ 9] 3957         POP     DE              ; Restore sign of exponent
   F98B C3 2E F9      [ 9] 3958         JP      MANLP           ; Get another digit
                           3959 
   F98E CD 44 F8      [16] 3960 RSCALE: CALL    STAKFP          ; Put number on stack
   F991 CD 25 F8      [16] 3961         CALL    FLGREL          ; Digit to add to FPREG
   F994 C1            [ 9] 3962 PADD:   POP     BC              ; Restore number
   F995 D1            [ 9] 3963         POP     DE
   F996 C3 CD F5      [ 9] 3964         JP      FPADD           ; Add BCDE to FPREG and return
                           3965 
   F999 7B            [ 4] 3966 EDIGIT: LD      A,E             ; Get digit
   F99A 07            [ 3] 3967         RLCA                    ; Times 2
   F99B 07            [ 3] 3968         RLCA                    ; Times 4
   F99C 83            [ 4] 3969         ADD     A,E             ; Times 5
   F99D 07            [ 3] 3970         RLCA                    ; Times 10
   F99E 86            [ 6] 3971         ADD     A,(HL)          ; Add next digit
   F99F D6 30         [ 6] 3972         SUB     #"0"             ; Make it absolute
   F9A1 5F            [ 4] 3973         LD      E,A             ; Save new digit
   F9A2 C3 44 F9      [ 9] 3974         JP      EXPLP           ; Look for another digit
                           3975 
   F9A5 E5            [11] 3976 LINEIN: PUSH    HL              ; Save code string address
   F9A6 21 46 E3      [ 9] 3977         LD      HL,#INMSG        ; Output " in "
   F9A9 CD 10 F2      [16] 3978         CALL    PRS             ; Output string at HL
   F9AC E1            [ 9] 3979         POP     HL              ; Restore code string address
   F9AD EB            [ 3] 3980 PRNTHL: EX      DE,HL           ; Code string address to DE
   F9AE AF            [ 4] 3981         XOR     A
   F9AF 06 98         [ 6] 3982         LD      B,#0x80+24        ; 24 bits
   F9B1 CD 2A F8      [16] 3983         CALL    RETINT          ; Return the integer
   F9B4 21 0F F2      [ 9] 3984         LD      HL,#PRNUMS       ; Print number string
   F9B7 E5            [11] 3985         PUSH    HL              ; Save for return
   F9B8 21 E9 10      [ 9] 3986 NUMASC: LD      HL,#PBUFF        ; Convert number to ASCII
   F9BB E5            [11] 3987         PUSH    HL              ; Save for return
   F9BC CD 13 F8      [16] 3988         CALL    TSTSGN          ; Test sign of FPREG
   F9BF 36 20         [ 9] 3989         LD      (HL),#" "        ; Space at start
   F9C1 F2 C6 F9      [ 9] 3990         JP      P,SPCFST        ; Positive - Space to start
   F9C4 36 2D         [ 9] 3991         LD      (HL),#"-"        ; "-" sign at start
   F9C6 23            [ 4] 3992 SPCFST: INC     HL              ; First byte of number
   F9C7 36 30         [ 9] 3993         LD      (HL),#"0"        ; "0" if zero
   F9C9 CA 7C FA      [ 9] 3994         JP      Z,JSTZER        ; Return "0" if zero
   F9CC E5            [11] 3995         PUSH    HL              ; Save buffer address
   F9CD FC 3C F8      [16] 3996         CALL    M,INVSGN        ; Negate FPREG if negative
   F9D0 AF            [ 4] 3997         XOR     A               ; Zero A
   F9D1 F5            [11] 3998         PUSH    AF              ; Save it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 74.
Hexadecimal [16-Bits]



   F9D2 CD 82 FA      [16] 3999         CALL    RNGTST          ; Test number is in range
   F9D5 01 43 91      [ 9] 4000 SIXDIG: LD      BC,#0x9143        ; BCDE - 99999.9
   F9D8 11 F8 4F      [ 9] 4001         LD      DE,#0x4FF8
   F9DB CD 8E F8      [16] 4002         CALL    CMPNUM          ; Compare numbers
   F9DE B7            [ 4] 4003         OR      A
   F9DF E2 F3 F9      [ 9] 4004         JP      PO,INRNG        ; > 99999.9 - Sort it out
   F9E2 F1            [ 9] 4005         POP     AF              ; Restore count
   F9E3 CD 70 F9      [16] 4006         CALL    MULTEN          ; Multiply by ten
   F9E6 F5            [11] 4007         PUSH    AF              ; Re-save count
   F9E7 C3 D5 F9      [ 9] 4008         JP      SIXDIG          ; Test it again
                           4009 
   F9EA CD 5B F7      [16] 4010 GTSIXD: CALL    DIV10           ; Divide by 10
   F9ED F1            [ 9] 4011         POP     AF              ; Get count
   F9EE 3C            [ 4] 4012         INC     A               ; Count divides
   F9EF F5            [11] 4013         PUSH    AF              ; Re-save count
   F9F0 CD 82 FA      [16] 4014         CALL    RNGTST          ; Test number is in range
   F9F3 CD BB F5      [16] 4015 INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
   F9F6 3C            [ 4] 4016         INC     A
   F9F7 CD BB F8      [16] 4017         CALL    FPINT           ; F.P to integer
   F9FA CD 54 F8      [16] 4018         CALL    FPBCDE          ; Move BCDE to FPREG
   F9FD 01 06 03      [ 9] 4019         LD      BC,#0x0306        ; 1E+06 to 1E-03 range
   FA00 F1            [ 9] 4020         POP     AF              ; Restore count
   FA01 81            [ 4] 4021         ADD     A,C             ; 6 digits before point
   FA02 3C            [ 4] 4022         INC     A               ; Add one
   FA03 FA 0F FA      [ 9] 4023         JP      M,MAKNUM        ; Do it in "E" form if < 1E-02
   FA06 FE 08         [ 6] 4024         CP      #6+1+1           ; More than 999999 ?
   FA08 D2 0F FA      [ 9] 4025         JP      NC,MAKNUM       ; Yes - Do it in "E" form
   FA0B 3C            [ 4] 4026         INC     A               ; Adjust for exponent
   FA0C 47            [ 4] 4027         LD      B,A             ; Exponent of number
   FA0D 3E 02         [ 6] 4028         LD      A,#2             ; Make it zero after
                           4029 
   FA0F 3D            [ 4] 4030 MAKNUM: DEC     A               ; Adjust for digits to do
   FA10 3D            [ 4] 4031         DEC     A
   FA11 E1            [ 9] 4032         POP     HL              ; Restore buffer address
   FA12 F5            [11] 4033         PUSH    AF              ; Save count
   FA13 11 95 FA      [ 9] 4034         LD      DE,#POWERS       ; Powers of ten
   FA16 05            [ 4] 4035         DEC     B               ; Count digits before point
   FA17 C2 20 FA      [ 9] 4036         JP      NZ,DIGTXT       ; Not zero - Do number
   FA1A 36 2E         [ 9] 4037         LD      (HL),#"."        ; Save point
   FA1C 23            [ 4] 4038         INC     HL              ; Move on
   FA1D 36 30         [ 9] 4039         LD      (HL),#"0"        ; Save zero
   FA1F 23            [ 4] 4040         INC     HL              ; Move on
   FA20 05            [ 4] 4041 DIGTXT: DEC     B               ; Count digits before point
   FA21 36 2E         [ 9] 4042         LD      (HL),#"."        ; Save point in case
   FA23 CC 69 F8      [16] 4043         CALL    Z,INCHL         ; Last digit - move on
   FA26 C5            [11] 4044         PUSH    BC              ; Save digits before point
   FA27 E5            [11] 4045         PUSH    HL              ; Save buffer address
   FA28 D5            [11] 4046         PUSH    DE              ; Save powers of ten
   FA29 CD 5F F8      [16] 4047         CALL    BCDEFP          ; Move FPREG to BCDE
   FA2C E1            [ 9] 4048         POP     HL              ; Powers of ten table
   FA2D 06 2F         [ 6] 4049         LD      B, #"0"-1        ; ASCII "0" - 1
   FA2F 04            [ 4] 4050 TRYAGN: INC     B               ; Count subtractions
   FA30 7B            [ 4] 4051         LD      A,E             ; Get LSB
   FA31 96            [ 6] 4052         SUB     (HL)            ; Subtract LSB
   FA32 5F            [ 4] 4053         LD      E,A             ; Save LSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 75.
Hexadecimal [16-Bits]



   FA33 23            [ 4] 4054         INC     HL
   FA34 7A            [ 4] 4055         LD      A,D             ; Get NMSB
   FA35 9E            [ 6] 4056         SBC     A,(HL)          ; Subtract NMSB
   FA36 57            [ 4] 4057         LD      D,A             ; Save NMSB
   FA37 23            [ 4] 4058         INC     HL
   FA38 79            [ 4] 4059         LD      A,C             ; Get MSB
   FA39 9E            [ 6] 4060         SBC     A,(HL)          ; Subtract MSB
   FA3A 4F            [ 4] 4061         LD      C,A             ; Save MSB
   FA3B 2B            [ 4] 4062         DEC     HL              ; Point back to start
   FA3C 2B            [ 4] 4063         DEC     HL
   FA3D D2 2F FA      [ 9] 4064         JP      NC,TRYAGN       ; No overflow - Try again
   FA40 CD 72 F6      [16] 4065         CALL    PLUCDE          ; Restore number
   FA43 23            [ 4] 4066         INC     HL              ; Start of next number
   FA44 CD 54 F8      [16] 4067         CALL    FPBCDE          ; Move BCDE to FPREG
   FA47 EB            [ 3] 4068         EX      DE,HL           ; Save point in table
   FA48 E1            [ 9] 4069         POP     HL              ; Restore buffer address
   FA49 70            [ 7] 4070         LD      (HL),B          ; Save digit in buffer
   FA4A 23            [ 4] 4071         INC     HL              ; And move on
   FA4B C1            [ 9] 4072         POP     BC              ; Restore digit count
   FA4C 0D            [ 4] 4073         DEC     C               ; Count digits
   FA4D C2 20 FA      [ 9] 4074         JP      NZ,DIGTXT       ; More - Do them
   FA50 05            [ 4] 4075         DEC     B               ; Any decimal part?
   FA51 CA 60 FA      [ 9] 4076         JP      Z,DOEBIT        ; No - Do "E" bit
   FA54 2B            [ 4] 4077 SUPTLZ: DEC     HL              ; Move back through buffer
   FA55 7E            [ 6] 4078         LD      A,(HL)          ; Get character
   FA56 FE 30         [ 6] 4079         CP      #"0"             ; "0" character?
   FA58 CA 54 FA      [ 9] 4080         JP      Z,SUPTLZ        ; Yes - Look back for more
   FA5B FE 2E         [ 6] 4081         CP      #"."             ; A decimal point?
   FA5D C4 69 F8      [16] 4082         CALL    NZ,INCHL        ; Move back over digit
                           4083 
   FA60 F1            [ 9] 4084 DOEBIT: POP     AF              ; Get "E" flag
   FA61 CA 7F FA      [ 9] 4085         JP      Z,NOENED        ; No "E" needed - End buffer
   FA64 36 45         [ 9] 4086         LD      (HL),#"E"        ; Put "E" in buffer
   FA66 23            [ 4] 4087         INC     HL              ; And move on
   FA67 36 2B         [ 9] 4088         LD      (HL),#"+"        ; Put '+' in buffer
   FA69 F2 70 FA      [ 9] 4089         JP      P,OUTEXP        ; Positive - Output exponent
   FA6C 36 2D         [ 9] 4090         LD      (HL),#"-"        ; Put "-" in buffer
   FA6E 2F            [ 3] 4091         CPL                     ; Negate exponent
   FA6F 3C            [ 4] 4092         INC     A
   FA70 06 2F         [ 6] 4093 OUTEXP: LD      B,#"0"-1         ; ASCII "0" - 1
   FA72 04            [ 4] 4094 EXPTEN: INC     B               ; Count subtractions
   FA73 D6 0A         [ 6] 4095         SUB     #10              ; Tens digit
   FA75 D2 72 FA      [ 9] 4096         JP      NC,EXPTEN       ; More to do
   FA78 C6 3A         [ 6] 4097         ADD     A,#"0"+10        ; Restore and make ASCII
   FA7A 23            [ 4] 4098         INC     HL              ; Move on
   FA7B 70            [ 7] 4099         LD      (HL),B          ; Save MSB of exponent
   FA7C 23            [ 4] 4100 JSTZER: INC     HL              ;
   FA7D 77            [ 7] 4101         LD      (HL),A          ; Save LSB of exponent
   FA7E 23            [ 4] 4102         INC     HL
   FA7F 71            [ 7] 4103 NOENED: LD      (HL),C          ; Mark end of buffer
   FA80 E1            [ 9] 4104         POP     HL              ; Restore code string address
   FA81 C9            [ 9] 4105         RET
                           4106 
   FA82 01 74 94      [ 9] 4107 RNGTST: LD      BC,#0x9474        ; BCDE = 999999.
   FA85 11 F7 23      [ 9] 4108         LD      DE,#0x23F7
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 76.
Hexadecimal [16-Bits]



   FA88 CD 8E F8      [16] 4109         CALL    CMPNUM          ; Compare numbers
   FA8B B7            [ 4] 4110         OR      A
   FA8C E1            [ 9] 4111         POP     HL              ; Return address to HL
   FA8D E2 EA F9      [ 9] 4112         JP      PO,GTSIXD       ; Too big - Divide by ten
   FA90 E9            [ 3] 4113         JP      (HL)            ; Otherwise return to caller
                           4114 
   FA91 00 00 00 80        4115 HALF:   .db      0x00,0x00,0x00,0x80 ; 0.5
                           4116 
   FA95 A0 86 01           4117 POWERS: .db      0xA0,0x86,0x01  ; 100000
   FA98 10 27 00           4118         .db      0x10,0x27,0x00  ;  10000
   FA9B E8 03 00           4119         .db      0xE8,0x03,0x00  ;   1000
   FA9E 64 00 00           4120         .db      0x64,0x00,0x00  ;    100
   FAA1 0A 00 00           4121         .db      0x0A,0x00,0x00  ;     10
   FAA4 01 00 00           4122         .db      0x01,0x00,0x00  ;      1
                           4123 
   FAA7 21 3C F8      [ 9] 4124 NEGAFT: LD  HL,#INVSGN           ; Negate result
   FAAA E3            [16] 4125         EX      (SP),HL         ; To be done after caller
   FAAB E9            [ 3] 4126         JP      (HL)            ; Return to caller
                           4127 
   FAAC CD 44 F8      [16] 4128 SQR:    CALL    STAKFP          ; Put value on stack
   FAAF 21 91 FA      [ 9] 4129         LD      HL,#HALF         ; Set power to 1/2
   FAB2 CD 51 F8      [16] 4130         CALL    PHLTFP          ; Move 1/2 to FPREG
                           4131 
   FAB5 C1            [ 9] 4132 POWER:  POP     BC              ; Get base
   FAB6 D1            [ 9] 4133         POP     DE
   FAB7 CD 13 F8      [16] 4134         CALL    TSTSGN          ; Test sign of power
   FABA 78            [ 4] 4135         LD      A,B             ; Get exponent of base
   FABB CA FA FA      [ 9] 4136         JP      Z,EXP           ; Make result 1 if zero
   FABE F2 C5 FA      [ 9] 4137         JP      P,POWER1        ; Positive base - Ok
   FAC1 B7            [ 4] 4138         OR      A               ; Zero to negative power?
   FAC2 CA B0 E3      [ 9] 4139         JP      Z,DZERR         ; Yes - ?/0 Error
   FAC5 B7            [ 4] 4140 POWER1: OR      A               ; Base zero?
   FAC6 CA 34 F6      [ 9] 4141         JP      Z,SAVEXP        ; Yes - Return zero
   FAC9 D5            [11] 4142         PUSH    DE              ; Save base
   FACA C5            [11] 4143         PUSH    BC
   FACB 79            [ 4] 4144         LD      A,C             ; Get MSB of base
   FACC F6 7F         [ 6] 4145         OR      #0b01111111       ; Get sign status
   FACE CD 5F F8      [16] 4146         CALL    BCDEFP          ; Move power to BCDE
   FAD1 F2 E2 FA      [ 9] 4147         JP      P,POWER2        ; Positive base - Ok
   FAD4 D5            [11] 4148         PUSH    DE              ; Save power
   FAD5 C5            [11] 4149         PUSH    BC
   FAD6 CD E6 F8      [16] 4150         CALL    INT             ; Get integer of power
   FAD9 C1            [ 9] 4151         POP     BC              ; Restore power
   FADA D1            [ 9] 4152         POP     DE
   FADB F5            [11] 4153         PUSH    AF              ; MSB of base
   FADC CD 8E F8      [16] 4154         CALL    CMPNUM          ; Power an integer?
   FADF E1            [ 9] 4155         POP     HL              ; Restore MSB of base
   FAE0 7C            [ 4] 4156         LD      A,H             ; but don't affect flags
   FAE1 1F            [ 3] 4157         RRA                     ; Exponent odd or even?
   FAE2 E1            [ 9] 4158 POWER2: POP     HL              ; Restore MSB and exponent
   FAE3 22 E6 10      [16] 4159         LD      (FPREG+2),HL    ; Save base in FPREG
   FAE6 E1            [ 9] 4160         POP     HL              ; LSBs of base
   FAE7 22 E4 10      [16] 4161         LD      (FPREG),HL      ; Save in FPREG
   FAEA DC A7 FA      [16] 4162         CALL    C,NEGAFT        ; Odd power - Negate result
   FAED CC 3C F8      [16] 4163         CALL    Z,INVSGN        ; Negative base - Negate it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 77.
Hexadecimal [16-Bits]



   FAF0 D5            [11] 4164         PUSH    DE              ; Save power
   FAF1 C5            [11] 4165         PUSH    BC
   FAF2 CD C7 F6      [16] 4166         CALL    LOG             ; Get LOG of base
   FAF5 C1            [ 9] 4167         POP     BC              ; Restore power
   FAF6 D1            [ 9] 4168         POP     DE
   FAF7 CD 08 F7      [16] 4169         CALL    FPMULT          ; Multiply LOG by power
                           4170 
   FAFA CD 44 F8      [16] 4171 EXP:    CALL    STAKFP          ; Put value on stack
   FAFD 01 38 81      [ 9] 4172         LD      BC,#0x08138       ; BCDE = 1/Ln(2)
   FB00 11 3B AA      [ 9] 4173         LD      DE,#0x0AA3B
   FB03 CD 08 F7      [16] 4174         CALL    FPMULT          ; Multiply value by 1/LN(2)
   FB06 3A E7 10      [12] 4175         LD      A,(FPEXP)       ; Get exponent
   FB09 FE 88         [ 6] 4176         CP      #0x80+8           ; Is it in range?
   FB0B D2 EF F7      [ 9] 4177         JP      NC,OVTST1       ; No - Test for overflow
   FB0E CD E6 F8      [16] 4178         CALL    INT             ; Get INT of FPREG
   FB11 C6 80         [ 6] 4179         ADD     A,#0x80           ; For excess 128
   FB13 C6 02         [ 6] 4180         ADD     A,#2             ; Exponent > 126?
   FB15 DA EF F7      [ 9] 4181         JP      C,OVTST1        ; Yes - Test for overflow
   FB18 F5            [11] 4182         PUSH    AF              ; Save scaling factor
   FB19 21 B6 F6      [ 9] 4183         LD      HL,#UNITY        ; Point to 1.
   FB1C CD BE F5      [16] 4184         CALL    ADDPHL          ; Add 1 to FPREG
   FB1F CD FF F6      [16] 4185         CALL    MULLN2          ; Multiply by LN(2)
   FB22 F1            [ 9] 4186         POP     AF              ; Restore scaling factor
   FB23 C1            [ 9] 4187         POP     BC              ; Restore exponent
   FB24 D1            [ 9] 4188         POP     DE
   FB25 F5            [11] 4189         PUSH    AF              ; Save scaling factor
   FB26 CD CA F5      [16] 4190         CALL    SUBCDE          ; Subtract exponent from FPREG
   FB29 CD 3C F8      [16] 4191         CALL    INVSGN          ; Negate result
   FB2C 21 3A FB      [ 9] 4192         LD      HL,#EXPTAB       ; Coefficient table
   FB2F CD 6A FB      [16] 4193         CALL    SMSER1          ; Sum the series
   FB32 11 00 00      [ 9] 4194         LD      DE,#0            ; Zero LSBs
   FB35 C1            [ 9] 4195         POP     BC              ; Scaling factor
   FB36 4A            [ 4] 4196         LD      C,D             ; Zero MSB
   FB37 C3 08 F7      [ 9] 4197         JP      FPMULT          ; Scale result to correct value
                           4198 
   FB3A 08                 4199 EXPTAB: .db      8                       ; Table used by EXP
   FB3B 40 2E 94 74        4200         .db      0x40,0x2E,0x94,0x74     ; -1/7! (-1/5040)
   FB3F 70 4F 2E 77        4201         .db      0x70,0x4F,0x2E,0x77     ;  1/6! ( 1/720)
   FB43 6E 02 88 7A        4202         .db      0x6E,0x02,0x88,0x7A     ; -1/5! (-1/120)
   FB47 E6 A0 2A 7C        4203         .db      0xE6,0xA0,0x2A,0x7C     ;  1/4! ( 1/24)
   FB4B 50 AA AA 7E        4204         .db      0x50,0xAA,0xAA,0x7E     ; -1/3! (-1/6)
   FB4F FF FF 7F 7F        4205         .db      0xFF,0xFF,0x7F,0x7F     ;  1/2! ( 1/2)
   FB53 00 00 80 81        4206         .db      0x00,0x00,0x80,0x81     ; -1/1! (-1/1)
   FB57 00 00 00 81        4207         .db      0x00,0x00,0x00,0x81     ;  1/0! ( 1/1)
                           4208 
   FB5B CD 44 F8      [16] 4209 SUMSER: CALL    STAKFP          ; Put FPREG on stack
   FB5E 11 06 F7      [ 9] 4210         LD      DE,#MULT         ; Multiply by "X"
   FB61 D5            [11] 4211         PUSH    DE              ; To be done after
   FB62 E5            [11] 4212         PUSH    HL              ; Save address of table
   FB63 CD 5F F8      [16] 4213         CALL    BCDEFP          ; Move FPREG to BCDE
   FB66 CD 08 F7      [16] 4214         CALL    FPMULT          ; Square the value
   FB69 E1            [ 9] 4215         POP     HL              ; Restore address of table
   FB6A CD 44 F8      [16] 4216 SMSER1: CALL    STAKFP          ; Put value on stack
   FB6D 7E            [ 6] 4217         LD      A,(HL)          ; Get number of coefficients
   FB6E 23            [ 4] 4218         INC     HL              ; Point to start of table
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 78.
Hexadecimal [16-Bits]



   FB6F CD 51 F8      [16] 4219         CALL    PHLTFP          ; Move coefficient to FPREG
   FB72 06                 4220         .db      0x06             ; Skip "POP AF"
   FB73 F1            [ 9] 4221 SUMLP:  POP     AF              ; Restore count
   FB74 C1            [ 9] 4222         POP     BC              ; Restore number
   FB75 D1            [ 9] 4223         POP     DE
   FB76 3D            [ 4] 4224         DEC     A               ; Cont coefficients
   FB77 C8            [10] 4225         RET     Z               ; All done
   FB78 D5            [11] 4226         PUSH    DE              ; Save number
   FB79 C5            [11] 4227         PUSH    BC
   FB7A F5            [11] 4228         PUSH    AF              ; Save count
   FB7B E5            [11] 4229         PUSH    HL              ; Save address in table
   FB7C CD 08 F7      [16] 4230         CALL    FPMULT          ; Multiply FPREG by BCDE
   FB7F E1            [ 9] 4231         POP     HL              ; Restore address in table
   FB80 CD 62 F8      [16] 4232         CALL    LOADFP          ; Number at HL to BCDE
   FB83 E5            [11] 4233         PUSH    HL              ; Save address in table
   FB84 CD CD F5      [16] 4234         CALL    FPADD           ; Add coefficient to FPREG
   FB87 E1            [ 9] 4235         POP     HL              ; Restore address in table
   FB88 C3 73 FB      [ 9] 4236         JP      SUMLP           ; More coefficients
                           4237 
   FB8B CD 13 F8      [16] 4238 RND:    CALL    TSTSGN          ; Test sign of FPREG
   FB8E 21 19 10      [ 9] 4239         LD      HL,#SEED+2       ; Random number seed
   FB91 FA EC FB      [ 9] 4240         JP      M,RESEED        ; Negative - Re-seed
   FB94 21 3A 10      [ 9] 4241         LD      HL,#LSTRND       ; Last random number
   FB97 CD 51 F8      [16] 4242         CALL    PHLTFP          ; Move last RND to FPREG
   FB9A 21 19 10      [ 9] 4243         LD      HL,#SEED+2       ; Random number seed
   FB9D C8            [10] 4244         RET     Z               ; Return if RND(0)
   FB9E 86            [ 6] 4245         ADD     A,(HL)          ; Add (SEED)+2)
   FB9F E6 07         [ 6] 4246         AND     #0b00000111       ; 0 to 7
   FBA1 06 00         [ 6] 4247         LD      B,#0
   FBA3 77            [ 7] 4248         LD      (HL),A          ; Re-save seed
   FBA4 23            [ 4] 4249         INC     HL              ; Move to coefficient table
   FBA5 87            [ 4] 4250         ADD     A,A             ; 4 bytes
   FBA6 87            [ 4] 4251         ADD     A,A             ; per entry
   FBA7 4F            [ 4] 4252         LD      C,A             ; BC = Offset into table
   FBA8 09            [ 7] 4253         ADD     HL,BC           ; Point to coefficient
   FBA9 CD 62 F8      [16] 4254         CALL    LOADFP          ; Coefficient to BCDE
   FBAC CD 08 F7      [16] 4255         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
   FBAF 3A 18 10      [12] 4256         LD      A,(SEED+1)      ; Get (SEED+1)
   FBB2 3C            [ 4] 4257         INC     A               ; Add 1
   FBB3 E6 03         [ 6] 4258         AND     #0b00000011       ; 0 to 3
   FBB5 06 00         [ 6] 4259         LD      B,#0
   FBB7 FE 01         [ 6] 4260         CP      #1               ; Is it zero?
   FBB9 88            [ 4] 4261         ADC     A,B             ; Yes - Make it 1
   FBBA 32 18 10      [13] 4262         LD      (SEED+1),A      ; Re-save seed
   FBBD 21 F0 FB      [ 9] 4263         LD      HL,#RNDTAB-4     ; Addition table
   FBC0 87            [ 4] 4264         ADD     A,A             ; 4 bytes
   FBC1 87            [ 4] 4265         ADD     A,A             ; per entry
   FBC2 4F            [ 4] 4266         LD      C,A             ; BC = Offset into table
   FBC3 09            [ 7] 4267         ADD     HL,BC           ; Point to value
   FBC4 CD BE F5      [16] 4268         CALL    ADDPHL          ; Add value to FPREG
   FBC7 CD 5F F8      [16] 4269 RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
   FBCA 7B            [ 4] 4270         LD      A,E             ; Get LSB
   FBCB 59            [ 4] 4271         LD      E,C             ; LSB = MSB
   FBCC EE 4F         [ 6] 4272         XOR     #0b01001111       ; Fiddle around
   FBCE 4F            [ 4] 4273         LD      C,A             ; New MSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 79.
Hexadecimal [16-Bits]



   FBCF 36 80         [ 9] 4274         LD      (HL),#0x80        ; Set exponent
   FBD1 2B            [ 4] 4275         DEC     HL              ; Point to MSB
   FBD2 46            [ 6] 4276         LD      B,(HL)          ; Get MSB
   FBD3 36 80         [ 9] 4277         LD      (HL),#0x80        ; Make value -0.5
   FBD5 21 17 10      [ 9] 4278         LD      HL,#SEED         ; Random number seed
   FBD8 34            [10] 4279         INC     (HL)            ; Count seed
   FBD9 7E            [ 6] 4280         LD      A,(HL)          ; Get seed
   FBDA D6 AB         [ 6] 4281         SUB     #171             ; Do it modulo 171
   FBDC C2 E3 FB      [ 9] 4282         JP      NZ,RND2         ; Non-zero - Ok
   FBDF 77            [ 7] 4283         LD      (HL),A          ; Zero seed
   FBE0 0C            [ 4] 4284         INC     C               ; Fillde about
   FBE1 15            [ 4] 4285         DEC     D               ; with the
   FBE2 1C            [ 4] 4286         INC     E               ; number
   FBE3 CD 1E F6      [16] 4287 RND2:   CALL    BNORM           ; Normalise number
   FBE6 21 3A 10      [ 9] 4288         LD      HL,#LSTRND       ; Save random number
   FBE9 C3 6B F8      [ 9] 4289         JP      FPTHL           ; Move FPREG to last and return
                           4290 
   FBEC 77            [ 7] 4291 RESEED: LD      (HL),A          ; Re-seed random numbers
   FBED 2B            [ 4] 4292         DEC     HL
   FBEE 77            [ 7] 4293         LD      (HL),A
   FBEF 2B            [ 4] 4294         DEC     HL
   FBF0 77            [ 7] 4295         LD      (HL),A
   FBF1 C3 C7 FB      [ 9] 4296         JP      RND1            ; Return RND seed
                           4297 
   FBF4 68 B1 46 68        4298 RNDTAB: .db      0x68,0xB1,0x46,0x68     ; Table used by RND
   FBF8 99 E9 92 69        4299         .db      0x99,0xE9,0x92,0x69
   FBFC 10 D1 75 68        4300         .db      0x10,0xD1,0x75,0x68
                           4301 
   FC00 21 4A FC      [ 9] 4302 COS:    LD      HL,#HALFPI       ; Point to PI/2
   FC03 CD BE F5      [16] 4303         CALL    ADDPHL          ; Add it to PPREG
   FC06 CD 44 F8      [16] 4304 SIN:    CALL    STAKFP          ; Put angle on stack
   FC09 01 49 83      [ 9] 4305         LD      BC,#0x8349        ; BCDE = 2 PI
   FC0C 11 DB 0F      [ 9] 4306         LD      DE,#0x0FDB
   FC0F CD 54 F8      [16] 4307         CALL    FPBCDE          ; Move 2 PI to FPREG
   FC12 C1            [ 9] 4308         POP     BC              ; Restore angle
   FC13 D1            [ 9] 4309         POP     DE
   FC14 CD 69 F7      [16] 4310         CALL    DVBCDE          ; Divide angle by 2 PI
   FC17 CD 44 F8      [16] 4311         CALL    STAKFP          ; Put it on stack
   FC1A CD E6 F8      [16] 4312         CALL    INT             ; Get INT of result
   FC1D C1            [ 9] 4313         POP     BC              ; Restore number
   FC1E D1            [ 9] 4314         POP     DE
   FC1F CD CA F5      [16] 4315         CALL    SUBCDE          ; Make it 0 <= value < 1
   FC22 21 4E FC      [ 9] 4316         LD      HL,#QUARTR       ; Point to 0.25
   FC25 CD C4 F5      [16] 4317         CALL    SUBPHL          ; Subtract value from 0.25
   FC28 CD 13 F8      [16] 4318         CALL    TSTSGN          ; Test sign of value
   FC2B 37            [ 3] 4319         SCF                     ; Flag positive
   FC2C F2 36 FC      [ 9] 4320         JP      P,SIN1          ; Positive - Ok
   FC2F CD BB F5      [16] 4321         CALL    ROUND           ; Add 0.5 to value
   FC32 CD 13 F8      [16] 4322         CALL    TSTSGN          ; Test sign of value
   FC35 B7            [ 4] 4323         OR      A               ; Flag negative
   FC36 F5            [11] 4324 SIN1:   PUSH    AF              ; Save sign
   FC37 F4 3C F8      [16] 4325         CALL    P,INVSGN        ; Negate value if positive
   FC3A 21 4E FC      [ 9] 4326         LD      HL,#QUARTR       ; Point to 0.25
   FC3D CD BE F5      [16] 4327         CALL    ADDPHL          ; Add 0.25 to value
   FC40 F1            [ 9] 4328         POP     AF              ; Restore sign
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 80.
Hexadecimal [16-Bits]



   FC41 D4 3C F8      [16] 4329         CALL    NC,INVSGN       ; Negative - Make positive
   FC44 21 52 FC      [ 9] 4330         LD      HL,#SINTAB       ; Coefficient table
   FC47 C3 5B FB      [ 9] 4331         JP      SUMSER          ; Evaluate sum of series
                           4332 
   FC4A DB 0F 49 81        4333 HALFPI: .db      0xDB,0x0F,0x49,0x81     ; 1.5708 (PI/2)
                           4334 
   FC4E 00 00 00 7F        4335 QUARTR: .db      0x00,0x00,0x00,0x7F     ; 0.25
                           4336 
   FC52 05                 4337 SINTAB: .db      5                       ; Table used by SIN
   FC53 BA D7 1E 86        4338         .db      0xBA,0xD7,0x1E,0x86     ; 39.711
   FC57 64 26 99 87        4339         .db      0x64,0x26,0x99,0x87     ;-76.575
   FC5B 58 34 23 87        4340         .db      0x58,0x34,0x23,0x87     ; 81.602
   FC5F E0 5D A5 86        4341         .db      0xE0,0x5D,0xA5,0x86     ;-41.342
   FC63 DA 0F 49 83        4342         .db      0xDA,0x0F,0x49,0x83     ;  6.2832
                           4343 
   FC67 CD 44 F8      [16] 4344 TAN:    CALL    STAKFP          ; Put angle on stack
   FC6A CD 06 FC      [16] 4345         CALL    SIN             ; Get SIN of angle
   FC6D C1            [ 9] 4346         POP     BC              ; Restore angle
   FC6E E1            [ 9] 4347         POP     HL
   FC6F CD 44 F8      [16] 4348         CALL    STAKFP          ; Save SIN of angle
   FC72 EB            [ 3] 4349         EX      DE,HL           ; BCDE = Angle
   FC73 CD 54 F8      [16] 4350         CALL    FPBCDE          ; Angle to FPREG
   FC76 CD 00 FC      [16] 4351         CALL    COS             ; Get COS of angle
   FC79 C3 67 F7      [ 9] 4352         JP      DIV             ; TAN = SIN / COS
                           4353 
   FC7C CD 13 F8      [16] 4354 ATN:    CALL    TSTSGN          ; Test sign of value
   FC7F FC A7 FA      [16] 4355         CALL    M,NEGAFT        ; Negate result after if -ve
   FC82 FC 3C F8      [16] 4356         CALL    M,INVSGN        ; Negate value if -ve
   FC85 3A E7 10      [12] 4357         LD      A,(FPEXP)       ; Get exponent
   FC88 FE 81         [ 6] 4358         CP      #0x81             ; Number less than 1?
   FC8A DA 99 FC      [ 9] 4359         JP      C,ATN1          ; Yes - Get arc tangnt
   FC8D 01 00 81      [ 9] 4360         LD      BC,#0x8100        ; BCDE = 1
   FC90 51            [ 4] 4361         LD      D,C
   FC91 59            [ 4] 4362         LD      E,C
   FC92 CD 69 F7      [16] 4363         CALL    DVBCDE          ; Get reciprocal of number
   FC95 21 C4 F5      [ 9] 4364         LD      HL,#SUBPHL       ; Sub angle from PI/2
   FC98 E5            [11] 4365         PUSH    HL              ; Save for angle > 1
   FC99 21 A3 FC      [ 9] 4366 ATN1:   LD      HL,#ATNTAB       ; Coefficient table
   FC9C CD 5B FB      [16] 4367         CALL    SUMSER          ; Evaluate sum of series
   FC9F 21 4A FC      [ 9] 4368         LD      HL,#HALFPI       ; PI/2 - angle in case > 1
   FCA2 C9            [ 9] 4369         RET                     ; Number > 1 - Sub from PI/2
                           4370 
   FCA3 09                 4371 ATNTAB: .db      9                       ; Table used by ATN
   FCA4 4A D7 3B 78        4372         .db      0x4A,0xD7,0x3B,0x78     ; 1/17
   FCA8 02 6E 84 7B        4373         .db      0x02,0x6E,0x84,0x7B     ;-1/15
   FCAC FE C1 2F 7C        4374         .db      0xFE,0xC1,0x2F,0x7C     ; 1/13
   FCB0 74 31 9A 7D        4375         .db      0x74,0x31,0x9A,0x7D     ;-1/11
   FCB4 84 3D 5A 7D        4376         .db      0x84,0x3D,0x5A,0x7D     ; 1/9
   FCB8 C8 7F 91 7E        4377         .db      0xC8,0x7F,0x91,0x7E     ;-1/7
   FCBC E4 BB 4C 7E        4378         .db      0xE4,0xBB,0x4C,0x7E     ; 1/5
   FCC0 6C AA AA 7F        4379         .db      0x6C,0xAA,0xAA,0x7F     ;-1/3
   FCC4 00 00 00 81        4380         .db      0x00,0x00,0x00,0x81     ; 1/1
                           4381 
   FCC8 CD 39 FE      [16] 4382 CASFFW: CALL    FLPLED          ; Turn on cassette
   FCCB 06 00         [ 6] 4383         LD      B,#0             ; Set 1 second delay
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 81.
Hexadecimal [16-Bits]



   FCCD CD 9B FD      [16] 4384 DELAYB: CALL    DELAY           ; Wait a bit
   FCD0 05            [ 4] 4385         DEC     B               ; Count
   FCD1 C2 CD FC      [ 9] 4386         JP      NZ,DELAYB       ; More delay needed
   FCD4 C9            [ 9] 4387         RET
                           4388 
   FCD5 C3 39 FE      [ 9] 4389 CASFF:  JP      FLPLED          ; Flip tape LED
                           4390 
   FCD8 C9            [ 9] 4391 ARET:   RET                     ; A RETurn instruction
                           4392 
   FCD9 E5            [11] 4393 CONMON: PUSH    HL              ; Output character to screen
   FCDA C5            [11] 4394         PUSH    BC              ; 
   FCDB D5            [11] 4395         PUSH    DE              ; 
   FCDC F5            [11] 4396         PUSH    AF              ; 
   FCDD CD 6D FE      [16] 4397         CALL    MONTST          ; See if NAS-SYS
   FCE0 C2 FB FC      [ 9] 4398         JP      NZ,NASOUT       ; NAS-SYS - Output ASCII
   FCE3 F1            [ 9] 4399         POP     AF              ; Get character
   FCE4 F5            [11] 4400         PUSH    AF              ; And re-save
   FCE5 FE 0A         [ 6] 4401         CP      #LF              ; ASCII Line feed?
   FCE7 CA 00 FD      [ 9] 4402         JP      Z,IGCHR         ; Yes - Ignore it
   FCEA FE 08         [ 6] 4403         CP      #BKSP            ; ASCII back space?
   FCEC C2 F1 FC      [ 9] 4404         JP      NZ,CONOT1       ; No - Test for CR
   FCEF 3E 1D         [ 6] 4405         LD      A,#TBS           ; NASBUG back space
   FCF1 FE 0D         [ 6] 4406 CONOT1: CP      #CR              ; ASCII CR?
   FCF3 C2 FD FC      [ 9] 4407         JP      NZ,OUTCHR       ; No - Output character
   FCF6 3E 1F         [ 6] 4408         LD      A,#TCR           ; NASBUG CR
   FCF8 C3 FD FC      [ 9] 4409         JP      OUTCHR          ; Output it
                           4410 
   FCFB F1            [ 9] 4411 NASOUT: POP     AF              ; Get character
   FCFC F5            [11] 4412         PUSH    AF              ; And re-save
   FCFD CD 45 FE      [16] 4413 OUTCHR: CALL    MONOUT          ; Output it
   FD00 F1            [ 9] 4414 IGCHR:  POP     AF              ; Restore character
   FD01 D1            [ 9] 4415         POP     DE              ;
   FD02 C1            [ 9] 4416         POP     BC              ;
   FD03 E1            [ 9] 4417         POP     HL              ;
   FD04 C9            [ 9] 4418         RET
                           4419 
   FD05 E5            [11] 4420 GETINP: PUSH    HL              ; Get an input character
   FD06 C5            [11] 4421         PUSH    BC              ;
   FD07 D5            [11] 4422         PUSH    DE              ;
   FD08 CD 6D FE      [16] 4423         CALL    MONTST          ; See if NAS-SYS
   FD0B CA 13 FD      [ 9] 4424         JP      Z,GETTIN        ; "T" monitor - Get input
   FD0E DF 7B              4425         .dw      _BLNK
   FD10 C3 19 FD      [ 9] 4426         JP      CONVIN          ; Convert to ASCII
                           4427 
   FD13 CD 4D 0C      [16] 4428 GETTIN: CALL    TIN             ; "T" input a character
   FD16 D2 13 FD      [ 9] 4429         JP      NC,GETTIN       ; No input - wait
   FD19 FE 1D         [ 6] 4430 CONVIN: CP      #TBS             ; NASBUG back space?
   FD1B C2 20 FD      [ 9] 4431         JP      NZ,CNVIN1       ; No - Test for break
   FD1E 3E 08         [ 6] 4432         LD      A,#BKSP          ; ASCII back space
   FD20 FE 1C         [ 6] 4433 CNVIN1: CP      #TBRK            ; NASBUG break?
   FD22 C2 27 FD      [ 9] 4434         JP      NZ,CNVIN2       ; No - Test for control Z
   FD25 3E 03         [ 6] 4435         LD      A,#CTRLC         ; Control C
   FD27 FE 1A         [ 6] 4436 CNVIN2: CP      #CTRLZ           ; ^Z?
   FD29 C2 2E FD      [ 9] 4437         JP      NZ,CNVIN3       ; No - Test for escape
   FD2C 3E 7F         [ 6] 4438         LD      A,#DEL           ; Delete
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 82.
Hexadecimal [16-Bits]



   FD2E FE 1B         [ 6] 4439 CNVIN3: CP      #ESC             ; "ESC" ?
   FD30 C2 35 FD      [ 9] 4440         JP      NZ,CNVIN4       ; No - Test for CR
   FD33 3E 03         [ 6] 4441         LD      A,#CTRLC         ; Control C
   FD35 FE 1F         [ 6] 4442 CNVIN4: CP      #TCR             ; NASBUG CR?
   FD37 C2 3C FD      [ 9] 4443         JP      NZ,CNVIN5       ; No - Return character
   FD3A 3E 0D         [ 6] 4444         LD      A,#CR            ; ASCII CR
   FD3C D1            [ 9] 4445 CNVIN5: POP     DE
   FD3D C1            [ 9] 4446         POP     BC
   FD3E E1            [ 9] 4447         POP     HL
   FD3F C9            [ 9] 4448         RET
                           4449 
   FD40 AF            [ 4] 4450 CHKBRK: XOR     A               ; Check for break
   FD41 CD 70 FD      [16] 4451         CALL    SFTENT          ; Test for shift/enter
   FD44 CA 50 FD      [ 9] 4452         JP      Z,TBRK2         ; Yes - Test for second break
   FD47 3A 4D 10      [12] 4453         LD      A,(BRKFLG)      ; Get break flag
   FD4A B7            [ 4] 4454         OR      A               ; Break flag set?
   FD4B C2 50 FD      [ 9] 4455         JP      NZ,TBRK2        ; Yes - Test for second break
   FD4E AF            [ 4] 4456         XOR     A               ; Flag no break
   FD4F C9            [ 9] 4457         RET
                           4458 
   FD50 CD 53 FE      [16] 4459 TBRK2:  CALL    BREAK2          ; Second break?
   FD53 3E FF         [ 6] 4460         LD      A,#-1            ; Flag break
   FD55 C9            [ 9] 4461         RET
                           4462 
   FD56 DB 02         [ 9] 4463 GUART:  IN      A,(UARTS)       ; Get UART status
   FD58 17            [ 3] 4464         RLA                     ; Any data ready?
   FD59 D2 56 FD      [ 9] 4465         JP      NC,GUART        ; No - wait until there is
   FD5C DB 01         [ 9] 4466         IN      A,(UARTD)       ; Get data from UART
   FD5E C9            [ 9] 4467         RET
                           4468 
   FD5F D3 01         [10] 4469 UARTOT: OUT     (UARTD),A       ; Send data to UART
   FD61 DB 02         [ 9] 4470 URTOLP: IN      A,(UARTS)       ; Get status
   FD63 87            [ 4] 4471         ADD     A,A             ; Byte sent?
   FD64 F8            [10] 4472         RET     M               ; Yes - Return
   FD65 C3 61 FD      [ 9] 4473         JP      URTOLP          ; Keep waiting
                           4474 
   FD68 F5            [11] 4475 SUART:  PUSH    AF              ; Save A
   FD69 CD 5F FD      [16] 4476         CALL    UARTOT          ; Send it to UART
   FD6C F1            [ 9] 4477         POP     AF              ; Restore A
   FD6D C9            [ 9] 4478         RET
                           4479 
   FD6E 00            [ 3] 4480         NOP
   FD6F 00            [ 3] 4481         NOP
                           4482 
   FD70 E5            [11] 4483 SFTENT: PUSH    HL              ; Test for Shift Enter from KBD
   FD71 3E 02         [ 6] 4484         LD      A,#0b00000010   ; Reset KBD counter mask
   FD73 21 00 0C      [ 9] 4485         LD      HL,#PORT0        ; Get old contents
   FD76 AE            [ 6] 4486         XOR     (HL)            ; Toggle bit
   FD77 D3 00         [10] 4487         OUT     (0),A           ; Reset KBD counter
   FD79 EE 01         [ 6] 4488         XOR     #0b00000001       ; Toggle bit
   FD7B D3 00         [10] 4489         OUT     (0),A           ; Next row
   FD7D EE 02         [ 6] 4490         XOR     #0b00000010
   FD7F D3 00         [10] 4491         OUT     (0),A           ; Clear "clear" strobe
   FD81 7E            [ 6] 4492         LD      A,(HL)          ; Get old value
   FD82 D3 00         [10] 4493         OUT     (0),A           ; Original contents
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 83.
Hexadecimal [16-Bits]



   FD84 19            [ 7] 4494         ADD     HL,DE           ; ?? WHAT ??
   FD85 E1            [ 9] 4495         POP     HL              ; Restore HL
   FD86 DB 00         [ 9] 4496         IN      A,(0)           ; Read in row
   FD88 E6 12         [ 6] 4497         AND     #0b00010010       ; Mask SHIFT and ENTER
   FD8A C9            [ 9] 4498         RET
                           4499 
   FD8B CD 6D FE      [16] 4500 CLS:    CALL    MONTST          ; See if NAS-SYS
   FD8E CA 96 FD      [ 9] 4501         JP      Z,TCLS          ; "T" CLS
   FD91 3E 0C         [ 6] 4502         LD      A,#CS            ; ASCII Clear screen
   FD93 C3 D9 FC      [ 9] 4503         JP      CONMON          ; Output character
                           4504 
   FD96 3E 1E         [ 6] 4505 TCLS:   LD      A,#TCS           ; NASBUG Clear screen
   FD98 C3 D9 FC      [ 9] 4506         JP      CONMON          ; Output character
                           4507 
   FD9B AF            [ 4] 4508 DELAY:  XOR     A               ; Delay routine
   FD9C F5            [11] 4509 DELAY1: PUSH    AF              ; PUSHes and POPs delay
   FD9D F1            [ 9] 4510         POP     AF
   FD9E F5            [11] 4511         PUSH    AF
   FD9F F1            [ 9] 4512         POP     AF
   FDA0 3D            [ 4] 4513         DEC     A               ; Count delays
   FDA1 C2 9C FD      [ 9] 4514         JP      NZ,DELAY1       ; More delay
   FDA4 C9            [ 9] 4515         RET
                           4516 
   FDA5 CD 84 F4      [16] 4517 WIDTH:  CALL    GETINT          ; Get integer 0-255
   FDA8 7B            [ 4] 4518         LD      A,E             ; Width to A
   FDA9 32 42 10      [13] 4519         LD      (LWIDTH),A      ; Set width
   FDAC C9            [ 9] 4520         RET
                           4521 
   FDAD CD 41 ED      [16] 4522 LINES:  CALL    GETNUM          ; Get a number
   FDB0 CD 8B E9      [16] 4523         CALL    DEINT           ; Get integer -32768 to 32767
   FDB3 ED 53 46 10   [19] 4524         LD      (LINESC),DE     ; Set lines counter
   FDB7 ED 53 48 10   [19] 4525         LD      (LINESN),DE     ; Set lines number
   FDBB C9            [ 9] 4526         RET
                           4527 
   FDBC CD 8B E9      [16] 4528 DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
   FDBF D5            [11] 4529         PUSH    DE              ; Save number
   FDC0 E1            [ 9] 4530         POP     HL              ; Number to HL
   FDC1 46            [ 6] 4531         LD      B,(HL)          ; Get LSB of contents
   FDC2 23            [ 4] 4532         INC     HL
   FDC3 7E            [ 6] 4533         LD      A,(HL)          ; Get MSB of contents
   FDC4 C3 F2 F0      [ 9] 4534         JP      ABPASS          ; Return integer AB
                           4535 
   FDC7 CD 41 ED      [16] 4536 DOKE:   CALL    GETNUM          ; Get a number
   FDCA CD 8B E9      [16] 4537         CALL    DEINT           ; Get integer -32768 to 32767
   FDCD D5            [11] 4538         PUSH    DE              ; Save address
   FDCE CD 90 E6      [16] 4539         CALL    CHKSYN          ; Make sure "," follows
   FDD1 2C                 4540         .db      ","
   FDD2 CD 41 ED      [16] 4541         CALL    GETNUM          ; Get a number
   FDD5 CD 8B E9      [16] 4542         CALL    DEINT           ; Get integer -32768 to 32767
   FDD8 E3            [16] 4543         EX      (SP),HL         ; Save value,get address
   FDD9 73            [ 7] 4544         LD      (HL),E          ; Save LSB of value
   FDDA 23            [ 4] 4545         INC     HL
   FDDB 72            [ 7] 4546         LD      (HL),D          ; Save MSB of value
   FDDC E1            [ 9] 4547         POP     HL              ; Restore code string address
   FDDD C9            [ 9] 4548         RET
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 84.
Hexadecimal [16-Bits]



                           4549 
   FDDE F3            [ 3] 4550 JJUMP1: DI                      ; Disable interrupts
   FDDF DD 21 FF FF   [12] 4551         LD      IX,#-1           ; Flag cold start
   FDE3 C3 12 E0      [ 9] 4552         JP      CSTART          ; Go and initialise
                           4553 
   FDE6 CD 84 F4      [16] 4554 SCREEN: CALL    GETINT          ; Get integer 0 to 255
   FDE9 F5            [11] 4555         PUSH    AF              ; Save column
   FDEA CD 90 E6      [16] 4556         CALL    CHKSYN          ; Make sure "," follows
   FDED 2C                 4557         .db      ","
   FDEE CD 84 F4      [16] 4558         CALL    GETINT          ; Get integer 0 to 255
   FDF1 C1            [ 9] 4559         POP     BC              ; Column to B
   FDF2 E5            [11] 4560         PUSH    HL              ; Save code string address
   FDF3 C5            [11] 4561         PUSH    BC              ; Save column
   FDF4 CD 11 FE      [16] 4562         CALL    SCRADR          ; Calculate screen address
   FDF7 E5            [11] 4563         PUSH    HL              ; Save screen address
   FDF8 CD 6D FE      [16] 4564         CALL    MONTST          ; See if NAS-SYS
   FDFB CA 04 FE      [ 9] 4565         JP      Z,TMNCUR        ; "T" monitor - "T" cursor
   FDFE E1            [ 9] 4566         POP     HL              ; Restore screen address
   FDFF 22 29 0C      [16] 4567         LD      (CURSOR),HL     ; Set new cursor position
   FE02 E1            [ 9] 4568         POP     HL              ; Rstore code string address
   FE03 C9            [ 9] 4569         RET
                           4570 
   FE04 2A 18 0C      [15] 4571 TMNCUR: LD      HL,(TCUR)       ; Get address or cursor
   FE07 36 20         [ 9] 4572         LD      (HL),#" "        ; Remove cursor
   FE09 E1            [ 9] 4573         POP     HL              ; Get new cursor address
   FE0A 22 18 0C      [16] 4574         LD      (TCUR),HL       ; Set new cursor
   FE0D 36 5F         [ 9] 4575         LD      (HL),#"_"        ; Put it on screen
   FE0F E1            [ 9] 4576         POP     HL              ; Restore code string address
   FE10 C9            [ 9] 4577         RET
                           4578 
   FE11 21 C9 07      [ 9] 4579 SCRADR: LD      HL,#VDU+10-65    ; SCREEN VDU address (0,0)
   FE14 06 00         [ 6] 4580         LD      B,#0
   FE16 4F            [ 4] 4581         LD      C,A             ; Line to BC
   FE17 B7            [ 4] 4582         OR      A               ; Test it
   FE18 CA A0 E9      [ 9] 4583         JP      Z,FCERR         ; Zero - ?FC Error
   FE1B FE 11         [ 6] 4584         CP      #16+1            ; 16 lines
   FE1D F2 A0 E9      [ 9] 4585         JP      P,FCERR         ; > 16 - ?FC Error
   FE20 D1            [ 9] 4586         POP     DE              ; RETurn address
   FE21 F1            [ 9] 4587         POP     AF              ; Get column
   FE22 D5            [11] 4588         PUSH    DE              ; Re-save RETurn
   FE23 16 00         [ 6] 4589         LD      D,#0
   FE25 5F            [ 4] 4590         LD      E,A             ; Column to DE
   FE26 B7            [ 4] 4591         OR      A               ; Test it
   FE27 CA A0 E9      [ 9] 4592         JP      Z,FCERR         ; Zero - ?FC Error
   FE2A FE 31         [ 6] 4593         CP      #48+1            ; 48 characters per line
   FE2C F2 A0 E9      [ 9] 4594         JP      P,FCERR         ; > 48 - ?FC Error
   FE2F 19            [ 7] 4595         ADD     HL,DE           ; Add column to address
   FE30 16 00         [ 6] 4596         LD      D,#0
   FE32 59            [ 4] 4597         LD      E,C             ; Line to DE
   FE33 06 40         [ 6] 4598         LD      B,#64            ; 64 Bytes per line
   FE35 19            [ 7] 4599 ADD64X: ADD     HL,DE           ; Add line
   FE36 10 FD         [ 9] 4600         DJNZ    ADD64X          ; SIXTY FOUR TIMES!!!
   FE38 C9            [ 9] 4601         RET
                           4602 
   FE39 CD 6D FE      [16] 4603 FLPLED: CALL    MONTST          ; See if NAS-SYS
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 85.
Hexadecimal [16-Bits]



   FE3C CA 42 FE      [ 9] 4604         JP      Z,TMFLP         ; "T" MFLP
   FE3F DF 5F              4605         .dw      _MFLP
   FE41 C9            [ 9] 4606         RET
                           4607 
   FE42 C3 51 00      [ 9] 4608 TMFLP:  JP      MFLP            ; Flip drive LED
                           4609 
   FE45 F5            [11] 4610 MONOUT: PUSH    AF              ; Save character
   FE46 CD 6D FE      [16] 4611         CALL    MONTST          ; See if NAS-SYS
   FE49 CA 4F FE      [ 9] 4612         JP      Z,TMNOUT        ; "T" output
   FE4C F1            [ 9] 4613         POP     AF              ; Restore character
   FE4D F7                 4614         .db      _ROUT           ; Output it
   FE4E C9            [ 9] 4615         RET
                           4616 
   FE4F F1            [ 9] 4617 TMNOUT: POP     AF              ; Restore character
   FE50 C3 4A 0C      [ 9] 4618         JP      TOUT            ; "T" output
                           4619 
   FE53 3A 4D 10      [12] 4620 BREAK2: LD      A,(BRKFLG)      ; Break flag set?
   FE56 C2 65 FE      [ 9] 4621         JP      NZ,RETCTC       ; Yes - Return ^C
   FE59 CD 6D FE      [16] 4622         CALL    MONTST          ; See if NAS-SYS
   FE5C CA 62 FE      [ 9] 4623         JP      Z,T0xCINP        ; Get "T" character input
   FE5F DF 62              4624         .dw      _RIN            ; Scan for a character
   FE61 C9            [ 9] 4625         RET
                           4626 
   FE62 C3 4D 0C      [ 9] 4627 T0xCINP: JP      TIN             ; "T" input a character
                           4628 
   FE65 3E 00         [ 6] 4629 RETCTC: LD      A,#0             ; Clear Break flag
   FE67 32 4D 10      [13] 4630         LD      (BRKFLG),A
   FE6A 3E 03         [ 6] 4631         LD      A,#CTRLC         ; Return ^C
   FE6C C9            [ 9] 4632         RET
                           4633 
   FE6D 3A 01 00      [12] 4634 MONTST: LD      A,(MONSTT+1)    ; "T" monitor or NAS-SYS?
   FE70 FE 33         [ 6] 4635         CP      #0x33             ; 31 00 10 / 31 33 0C
   FE72 C9            [ 9] 4636         RET
                           4637 
   FE73 CD 39 FE      [16] 4638 SAVE:   CALL    FLPLED          ; Flip tape LED
   FE76 CD 6D FE      [16] 4639         CALL    MONTST          ; See if NAS-SYS
   FE79 CA 7F FE      [ 9] 4640         JP      Z,TSAVE         ; "T" save
   FE7C DF 57              4641         .dw      _WRIT           ; Save program
   FE7E C9            [ 9] 4642         RET
                           4643 
   FE7F 3A 8D 00      [12] 4644 TSAVE:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
   FE82 CA 00 04      [ 9] 4645         JP      Z,T4WR          ; T4 Write
   FE85 C3 D1 03      [ 9] 4646         JP      T2DUMP          ; T2 Dump
                           4647 
   FE88 CD 39 FE      [16] 4648 MONLD:  CALL    FLPLED          ; Flip tape LED
   FE8B CD 6D FE      [16] 4649         CALL    MONTST          ; See if NAS-SYS
   FE8E CA 99 FE      [ 9] 4650         JP      Z,TLOAD         ; "T" load
   FE91 3E 52         [ 6] 4651         LD      A,#"R"           ; Set READ
   FE93 32 2B 0C      [13] 4652         LD      (ARGN),A
   FE96 DF 52              4653         .dw      _READ           ; Load program
   FE98 C9            [ 9] 4654         RET
                           4655 
   FE99 3A 8D 00      [12] 4656 TLOAD:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
   FE9C CA 0C 07      [ 9] 4657         JP      Z,T4READ        ; T4 Read
   FE9F C3 D1 03      [ 9] 4658         JP      T2DUMP          ; T2 Dump ??????????
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 86.
Hexadecimal [16-Bits]



                           4659 
   FEA2 CD 6D FE      [16] 4660 MONITR: CALL    MONTST          ; See if NAS-SYS
   FEA5 CA 00 00      [ 9] 4661         JP      Z,MONSTT        ; Jump to zero if "T"
   FEA8 DF 5B              4662         .dw      _MRET           ; Return to NAS-SYS
                           4663 
   FEAA CD 39 FE      [16] 4664 MONVE:  CALL    FLPLED          ; Flip tape LED
   FEAD CD 6D FE      [16] 4665         CALL    MONTST          ; See if NAS-SYS
   FEB0 CA A0 E9      [ 9] 4666         JP      Z,FCERR         ; Verify not available on "T"
   FEB3 3E 56         [ 6] 4667         LD      A,#"V"           ; Set VERIFY
   FEB5 32 2B 0C      [13] 4668         LD      (ARGN),A
   FEB8 DF 56              4669         .dw      _VRFY           ; Verify tape
   FEBA C9            [ 9] 4670         RET
                           4671 
   FEBB 3E 00         [ 6] 4672 INITST: LD      A,#0             ; Clear break flag
   FEBD 32 4D 10      [13] 4673         LD      (BRKFLG),A
   FEC0 CD 6D FE      [16] 4674         CALL    MONTST          ; See if NAS-SYS
   FEC3 CA 19 E0      [ 9] 4675         JP      Z,INIT          ; "T" - No NMI vector
   FEC6 21 DE FE      [ 9] 4676         LD      HL,#BREAK        ; Set NMI gives break
   FEC9 22 7E 0C      [16] 4677         LD      (NMI),HL
   FECC DD E5         [14] 4678         PUSH    IX              ; Get start up condition
   FECE F1            [ 9] 4679         POP     AF              ; "Z" set if cold , Else clear
   FECF B7            [ 4] 4680         OR      A               ; "Cold" or "Cool" start?
   FED0 C2 19 E0      [ 9] 4681         JP      NZ,INIT         ; "Cool" don't init NAS-SYS
   FED3 06 0F         [ 6] 4682         LD      B,#15            ; Delay for keyboard clear
   FED5 CD CD FC      [16] 4683         CALL    DELAYB          ; Allow time for key release
   FED8 CD 0D 00      [16] 4684         CALL    STMON           ; Initialise NAS-SYS
   FEDB C3 19 E0      [ 9] 4685         JP      INIT            ; Initialise BASIC
                           4686 
   FEDE F5            [11] 4687 BREAK:  PUSH    AF              ; Save character
   FEDF 3E FF         [ 6] 4688         LD      A,#-1
   FEE1 32 4D 10      [13] 4689         LD      (BRKFLG),A      ; Flag break
   FEE4 F1            [ 9] 4690         POP     AF              ; Restore character
   FEE5 ED 45         [12] 4691 ARETN:  RETN                    ; Return from NMI
                           4692 
   FEE7 00            [ 3] 4693         NOP
                           4694 
   FEE8 DF 63              4695 INLINE: .dw      _INLN           ; Get an input line
   FEEA D5            [11] 4696         PUSH    DE              ; Save cursor address
   FEEB D5            [11] 4697         PUSH    DE              ; Cursor address to HL
   FEEC E1            [ 9] 4698         POP     HL
   FEED 11 2F 00      [ 9] 4699         LD      DE,#48-1         ; Length of line-1
   FEF0 19            [ 7] 4700         ADD     HL,DE           ; Point to end of line
   FEF1 7E            [ 6] 4701 ENDLIN: LD      A,(HL)          ; Get end of line
   FEF2 FE 20         [ 6] 4702         CP      #" "             ; Space?
   FEF4 C2 02 FF      [ 9] 4703         JP      NZ,LINTBF       ; No - Copy to buffer
   FEF7 1D            [ 4] 4704         DEC     E               ; Back 1 character
   FEF8 3E 00         [ 6] 4705         LD      A,#0             ; Wasteful test on E
   FEFA B3            [ 4] 4706         OR      E
   FEFB CA 02 FF      [ 9] 4707         JP      Z,LINTBF        ; Start of line - Copy it
   FEFE 2B            [ 4] 4708         DEC     HL              ; Back 1 character
   FEFF C3 F1 FE      [ 9] 4709         JP      ENDLIN          ; Keep looking for end
                           4710 
   FF02 D5            [11] 4711 LINTBF: PUSH    DE              ; Line length to BC
   FF03 C1            [ 9] 4712         POP     BC
   FF04 03            [ 4] 4713         INC     BC              ; Length +1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 87.
Hexadecimal [16-Bits]



   FF05 11 61 10      [ 9] 4714         LD      DE,#BUFFER       ; Input buffer
   FF08 E1            [ 9] 4715         POP     HL              ; Line start
   FF09 C5            [11] 4716         PUSH    BC              ; Save length
   FF0A ED B0         [14] 4717         LDIR                    ; Move line to buffer
   FF0C 3E 00         [ 6] 4718         LD      A,#0
   FF0E 12            [ 7] 4719         LD      (DE),A          ; Mark end of buffer with 00
   FF0F C1            [ 9] 4720         POP     BC              ; Restore buffer length
   FF10 41            [ 4] 4721         LD      B,C             ; Length returned in B
   FF11 21 60 10      [ 9] 4722         LD      HL,#BUFFER-1     ; Point to start of buffer-1
   FF14 C9            [ 9] 4723         RET
                           4724 
   FF15 CD 90 E6      [16] 4725 GETXYA: CALL    CHKSYN          ; Make sure "(" follows
   FF18 28                 4726         .db      "("
   FF19 CD 41 ED      [16] 4727         CALL    GETNUM          ; Get a number
   FF1C CD 8B E9      [16] 4728         CALL    DEINT           ; Get integer -32768 to 32767
   FF1F D5            [11] 4729         PUSH    DE              ; Save "X"
   FF20 CD 90 E6      [16] 4730         CALL    CHKSYN          ; Make sure "," follows
   FF23 2C                 4731         .db      ","
   FF24 CD 41 ED      [16] 4732         CALL    GETNUM          ; Get a number
   FF27 CD 90 E6      [16] 4733         CALL    CHKSYN          ; Make sure ")" follows
   FF2A 29                 4734         .db      ")"
   FF2B CD 8B E9      [16] 4735         CALL    DEINT           ; Get integer -32768 to 32767
   FF2E E5            [11] 4736         PUSH    HL              ; Save code string address
   FF2F FD E1         [12] 4737         POP     IY              ; In IY
   FF31 CD 96 FF      [16] 4738         CALL    XYPOS           ; Address and bit mask
   FF34 F5            [11] 4739         PUSH    AF              ; Save mask
   FF35 CD C2 FF      [16] 4740         CALL    ADJCOL          ; Adjust column
   FF38 CD 11 FE      [16] 4741         CALL    SCRADR          ; Get VDU address
   FF3B F1            [ 9] 4742         POP     AF              ; Restore bit mask
   FF3C 06 C0         [ 6] 4743         LD      B,#0b11000000     ; Block graphics base
   FF3E B0            [ 4] 4744         OR      B               ; Set bits 7 & 6
   FF3F C9            [ 9] 4745         RET
                           4746 
   FF40 CD 15 FF      [16] 4747 SETB:   CALL    GETXYA          ; Get co-ords and VDU address
   FF43 F5            [11] 4748         PUSH    AF              ; Save bit mask
   FF44 7E            [ 6] 4749         LD      A,(HL)          ; Get character from screen
   FF45 FE C0         [ 6] 4750         CP      #0b11000000       ; Is it a block graphic?
   FF47 D2 50 FF      [ 9] 4751         JP      NC,#SETOR        ; Yes - OR new bit
   FF4A F1            [ 9] 4752         POP     AF              ; Restore bit mask
   FF4B 77            [ 7] 4753 PUTBIT: LD      (HL),A          ; Put character on screen
   FF4C FD E5         [14] 4754 RESCSA: PUSH    IY              ; Restore code string address
   FF4E E1            [ 9] 4755         POP     HL              ; From IY
   FF4F C9            [ 9] 4756         RET
                           4757 
   FF50 C1            [ 9] 4758 SETOR:  POP     BC              ; Restore bit mask
   FF51 B0            [ 4] 4759         OR      B               ; Merge the bits
   FF52 C3 4B FF      [ 9] 4760         JP      PUTBIT          ; Save on screen
                           4761 
   FF55 CD 15 FF      [16] 4762 RESETB: CALL    GETXYA          ; Get co-ords and VDU address
   FF58 F5            [11] 4763         PUSH    AF              ; Save bit mask
   FF59 7E            [ 6] 4764         LD      A,(HL)          ; Get byte from screen
   FF5A FE C0         [ 6] 4765         CP      #0b11000000       ; Is it a block graphic?
   FF5C DA 75 FF      [ 9] 4766         JP      C,NORES         ; No - Leave it
   FF5F 06 3F         [ 6] 4767         LD      B,#0b00111111     ; Six bits per block
   FF61 A0            [ 4] 4768         AND     B               ; Clear bits 7 & 6
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 88.
Hexadecimal [16-Bits]



   FF62 C1            [ 9] 4769         POP     BC              ; Get bit mask
   FF63 A0            [ 4] 4770         AND     B               ; Test for common bit
   FF64 CA 4C FF      [ 9] 4771         JP      Z,RESCSA        ; None - Leave it
   FF67 7E            [ 6] 4772         LD      A,(HL)          ; Get byte from screen
   FF68 E6 3F         [ 6] 4773         AND     #0b00111111       ; Isolate bit
   FF6A A8            [ 4] 4774         XOR     B               ; Clear that bit
   FF6B FE C0         [ 6] 4775         CP      #0b11000000       ; Is it a graphic blank?
   FF6D C2 4B FF      [ 9] 4776         JP      NZ,PUTBIT       ; No - Save character
   FF70 3E 20         [ 6] 4777         LD      A,#" "           ; Put a space there
   FF72 C3 4B FF      [ 9] 4778         JP      PUTBIT          ; Save the space
                           4779 
   FF75 C1            [ 9] 4780 NORES:  POP     BC              ; Drop bit mask
   FF76 C3 4C FF      [ 9] 4781         JP      RESCSA          ; Restore code string address
                           4782 
   FF79 CD 15 FF      [16] 4783 POINTB: CALL    GETXYA          ; Get co-ords and VDU address
   FF7C 46            [ 6] 4784         LD      B,(HL)          ; Get character from screen
   FF7D CD ED FF      [16] 4785         CALL    TSTBIT          ; Test if bit is set
   FF80 C2 91 FF      [ 9] 4786         JP      NZ,POINT0       ; Different - Return zero
   FF83 3E 00         [ 6] 4787         LD      A,#0
   FF85 06 01         [ 6] 4788         LD      B,#1             ; Integer AB = 1
   FF87 E1            [ 9] 4789 POINTX: POP     HL              ; Drop return
   FF88 FD E5         [14] 4790         PUSH    IY              ; PUSH code string address
   FF8A 11 1D EE      [ 9] 4791         LD      DE,#RETNUM       ; To return a number
   FF8D D5            [11] 4792         PUSH    DE              ; Save for return
   FF8E C3 F2 F0      [ 9] 4793         JP      ABPASS          ; Return integer AB
                           4794 
   FF91 06 00         [ 6] 4795 POINT0: LD      B,#0             ; Set zero
   FF93 C3 87 FF      [ 9] 4796         JP      POINTX          ; Return value
                           4797 
   FF96 C1            [ 9] 4798 XYPOS:  POP     BC              ; Get return address
   FF97 E1            [ 9] 4799         POP     HL              ; Get column
   FF98 E5            [11] 4800         PUSH    HL              ; And re-save
   FF99 C5            [11] 4801         PUSH    BC              ; Put back return address
   FF9A 7D            [ 4] 4802         LD      A,L             ; Get column
   FF9B 06 01         [ 6] 4803         LD      B,#0b00000001     ; 2 bits per character
   FF9D A0            [ 4] 4804         AND     B               ; Odd or even bit
   FF9E F5            [11] 4805         PUSH    AF              ; Save it
   FF9F D5            [11] 4806         PUSH    DE              ; Get row
   FFA0 E1            [ 9] 4807         POP     HL              ; to HL
   FFA1 11 00 00      [ 9] 4808         LD      DE,#0            ; Zero line count
   FFA4 01 03 00      [ 9] 4809         LD      BC,#3            ; 3 blocks per line
   FFA7 23            [ 4] 4810         INC     HL
   FFA8 ED 42         [10] 4811 DIV3LP: SBC     HL,BC           ; Subtract 3
   FFAA 13            [ 4] 4812         INC     DE              ; Count the subtractions
   FFAB CA B1 FF      [ 9] 4813         JP      Z,DIV3EX        ; Exactly - Exit
   FFAE F2 A8 FF      [ 9] 4814         JP      P,DIV3LP        ; More to do
                           4815 
   FFB1 09            [ 7] 4816 DIV3EX: ADD     HL,BC           ; Restore number
   FFB2 F1            [ 9] 4817         POP     AF              ; Restore column and odd/even
   FFB3 B7            [ 4] 4818         OR      A               ; Set flags (NZ or Z)
   FFB4 7D            [ 4] 4819         LD      A,L             ; Get remainder from /3
   FFB5 CA BA FF      [ 9] 4820         JP      Z,NOREMD        ; No remainder
   FFB8 C6 03         [ 6] 4821         ADD     A,#3             ; Adjust remainder
   FFBA 47            [ 4] 4822 NOREMD: LD      B,A             ; Bit number+1 to B
   FFBB 3E 01         [ 6] 4823         LD      A,#0b00000001     ; Bit to rotate
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 89.
Hexadecimal [16-Bits]



   FFBD 07            [ 3] 4824 SHFTBT: RLCA                    ; Shift bit left
   FFBE 10 FD         [ 9] 4825         DJNZ    SHFTBT          ; Count shifts
   FFC0 1F            [ 3] 4826         RRA                     ; Restore correct place
   FFC1 C9            [ 9] 4827         RET
                           4828 
   FFC2 C1            [ 9] 4829 ADJCOL: POP     BC              ; Restore return address
   FFC3 F1            [ 9] 4830         POP     AF              ; Get bit mask
   FFC4 E1            [ 9] 4831         POP     HL              ; Get column
   FFC5 F5            [11] 4832         PUSH    AF              ; Re-save but mask
   FFC6 7D            [ 4] 4833         LD      A,L             ; Get column
   FFC7 1F            [ 3] 4834         RRA                     ; Divide by 2
   FFC8 C6 01         [ 6] 4835         ADD     A,#1             ; Start at column 1
   FFCA E6 3F         [ 6] 4836         AND     #0b00111111       ; 0 to 63
   FFCC 67            [ 4] 4837         LD      H,A             ; Save column in H
   FFCD E5            [11] 4838         PUSH    HL              ; Re-save column
   FFCE C5            [11] 4839         PUSH    BC              ; Put back return
   FFCF 7B            [ 4] 4840         LD      A,E             ; Get row
   FFD0 C9            [ 9] 4841         RET
                           4842 
   FFD1 CD D5 FC      [16] 4843 SMOTOR: CALL    CASFF           ; Flip tape drive
   FFD4 7E            [ 6] 4844         LD      A,(HL)          ; Get byte
   FFD5 C9            [ 9] 4845         RET
                           4846 
   FFD6 3A CE 10      [12] 4847 JPLDSV: LD      A,(BRKLIN)      ; CLOAD or CSAVE?
   FFD9 FE FF         [ 6] 4848         CP      #-1
   FFDB C2 06 E9      [ 9] 4849         JP      NZ,SNDHDR       ; CSAVE - Send header
   FFDE C3 10 E9      [ 9] 4850         JP      GETHDR          ; CLOAD - Get header
                           4851 
   FFE1 CD 81 EB      [16] 4852 CRLIN1: CALL    PRNTCR          ; Output CRLF
   FFE4 C3 F2 E5      [ 9] 4853         JP      GETLIN          ; Get an input line
                           4854 
   FFE7 CD 81 EB      [16] 4855 CRLIN:  CALL    PRNTCR          ; Output CRLF
   FFEA C3 F2 E5      [ 9] 4856         JP      GETLIN          ; Get an input line
                           4857 
   FFED F5            [11] 4858 TSTBIT: PUSH    AF              ; Save bit mask
   FFEE A0            [ 4] 4859         AND     B               ; Get common bits
   FFEF C1            [ 9] 4860         POP     BC              ; Restore bit mask
   FFF0 B8            [ 4] 4861         CP      B               ; Same bit set?
   FFF1 3E 00         [ 6] 4862         LD      A,#0             ; Return 0 in A
   FFF3 C9            [ 9] 4863         RET
                           4864 
   FFF4 CD 9B E6      [16] 4865 OUTNCR: CALL    OUTC            ; Output character in A
   FFF7 C3 81 EB      [ 9] 4866         JP      PRNTCR          ; Output CRLF
                           4867 
   FFFA C3 DE FD      [ 9] 4868 JJUMP:  JP      JJUMP1          ; "Cool" start
                           4869 
   FFFD C3 B1 E0      [ 9] 4870 ZJUMP:  JP      BRKRET          ; Warm start
                           4871         
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 90.
Hexadecimal [16-Bits]

Symbol Table

    .__.$$$.=  2710 L   |     .__.ABS.=  0000 G   |     .__.CPU.=  0001 L
    .__.H$L.=  0000 L   |   2 ABPASS     F0F2 R   |   2 ABS        F838 R
  2 ACCSUM     E940 R   |   2 ACPASS     F0F1 R   |   2 ADD64X     FE35 R
  2 ADDEXP     F7D1 R   |   2 ADDIG      F977 R   |   2 ADDPHL     F5BE R
  2 ADJCOL     FFC2 R   |   2 ALLFOL     F3C0 R   |   2 ANTVLU     EC65 R
  2 ANYNAM     F51C R   |   2 ARET       FCD8 R   |   2 ARETN      FEE5 R
    ARG1    =  0C0C     |     ARG2    =  0C0E     |     ARGN    =  0C2B 
  2 ARLDSV     F012 R   |     ARREND  =  10DA     |   2 ARRLD1     E8B9 R
  2 ARRLP      F28B R   |   2 ARRSV1     E8BB R   |   2 ARYLP      E920 R
  2 ASC        F391 R   |   2 ASCTFP     F91A R   |   2 ASPCS      EBC7 R
  2 ATN        FC7C R   |   2 ATN1       FC99 R   |   2 ATNTAB     FCA3 R
  2 ATOH       E9A5 R   |   2 BAD        F59D R   |   2 BADINP     EBEC R
  2 BAKSTK     E356 R   |   2 BAKTMP     F371 R   |     BASTXT  =  105E 
  2 BCDEFP     F85F R   |   2 BFREE      E0B7 R   |     BKSP    =  0008 
  2 BNORM      F61E R   |   2 BNRMLP     F621 R   |   2 BREAK      FEDE R
  2 BREAK2     FE53 R   |     BRKFLG  =  104D     |     BRKLIN  =  10CE 
  2 BRKMSG     E350 R   |   2 BRKRET     E0B1 R   |     BS      =  0010 
  2 BSERR      F045 R   |     BUFFER  =  1061     |   2 BYTSFT     F756 R
  2 CASFF      FCD5 R   |   2 CASFFW     FCC8 R   |   2 CFEVAL     EFA8 R
  2 CHARTY     EF56 R   |   2 CHEKFN     F189 R   |   2 CHKBRK     FD40 R
  2 CHKLTR     E977 R   |   2 CHKSTK     E38A R   |     CHKSUM  =  104A 
  2 CHKSYN     E690 R   |   2 CHKTYP     ED46 R   |   2 CHR        F3A2 R
  2 CHSUMS     E960 R   |     CIN     =  0C75     |   2 CLEAR      E9CA R
  2 CLOAD      F4F9 R   |   2 CLOAD1     F52B R   |   2 CLOAD2     F52D R
  2 CLOADE     F55F R   |   2 CLOADV     F55C R   |   2 CLOTST     E6CC R
  2 CLREG      E4DF R   |   2 CLRPTR     E4BA R   |   2 CLS        FD8B R
  2 CMPFP      F8A8 R   |   2 CMPLG1     EEBC R   |   2 CMPLOG     EEBA R
  2 CMPNUM     F88E R   |   2 CMPRES     EEFE R   |   2 CMPSTR     EEE6 R
    CN      =  0020     |   2 CNVIN1     FD20 R   |   2 CNVIN2     FD27 R
  2 CNVIN3     FD2E R   |   2 CNVIN4     FD35 R   |   2 CNVIN5     FD3C R
  2 CNVNUM     F926 R   |     COMMAN  =  1043     |   2 COMPL      F67E R
  2 CONCAT     F306 R   |   2 CONEXP     F956 R   |   2 CONMON     FCD9 R
  2 CONOT1     FCF1 R   |   2 CONPOS     F61B R   |   2 CONT       E89E R
    CONTAD  =  10D4     |   2 CONVAR     EE22 R   |   2 CONVIN     FD19 R
  2 COPY       E021 R   |   2 COS        FC00 R   |   2 COUNT      E746 R
  2 CPDEHL     E68A R   |   2 CPYLIT     E5B1 R   |     CR      =  000D 
  2 CRARLP     F065 R   |   2 CREARY     F04A R   |   2 CRESTR     EAC9 R
  2 CRLIN      FFE7 R   |   2 CRLIN1     FFE1 R   |   2 CRNCLP     E512 R
  2 CRTMST     F1C2 R   |   2 CRTST      F1CE R   |   2 CRTSTE     F1E4 R
  2 CRUNCH     E509 R   |     CS      =  000C     |   2 CSAVE      F4C3 R
  2 CSTART     E012 R   |     CTLOFG  =  1045     |     CTRLC   =  0003 
    CTRLG   =  0007     |     CTRLO   =  000F     |     CTRLR   =  0012 
    CTRLS   =  0013     |     CTRLU   =  0015     |     CTRLZ   =  001A 
    CUROPR  =  10C5     |     CURPOS  =  10AB     |     CURSOR  =  0C29 
  2 DATA       EA70 R   |     DATFLG  =  10AE     |     DATLIN  =  10C9 
  2 DATSNR     E3A7 R   |   2 DCBCDE     F8DF R   |     DD      =  0012 
  2 DDERR      E3B6 R   |   2 DEEK       FDBC R   |   2 DEF        F106 R
  2 DEFSIZ     F06D R   |   2 DEINT      E98B R   |     DEL     =  007F 
  2 DELAY      FD9B R   |   2 DELAY1     FD9C R   |   2 DELAYB     FCCD R
  2 DELCHR     E5E1 R   |   2 DEPINT     E985 R   |   2 DETHL4     F86E R
  2 DETHLB     F870 R   |   2 DIGTXT     FA20 R   |   2 DIM        EF28 R
  2 DIMRET     EF1F R   |   2 DINPOS     E6BF R   |   2 DIV        F767 R
    DIV1    =  100A     |   2 DIV10      F75B R   |     DIV2    =  100E 
    DIV3    =  1012     |   2 DIV3EX     FFB1 R   |   2 DIV3LP     FFA8 R
    DIV4    =  1015     |   2 DIVLP      F78E R   |     DIVSUP  =  1009 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 91.
Hexadecimal [16-Bits]

Symbol Table

  2 DOAGN      E4F8 R   |   2 DOCOM      EB98 R   |   2 DODEL      E5C1 R
  2 DOEBIT     FA60 R   |   2 DOFN       F133 R   |   2 DOKE       FDC7 R
  2 DONULL     EB86 R   |   2 DOSPC      EBC2 R   |   2 DOSUM      E94D R
  2 DOTAB      EBAF R   |   2 DPOINT     F952 R   |   2 DTSTR      F1D2 R
  2 DVBCDE     F769 R   |     DZ      =  0014     |   2 DZERR      E3B0 R
  2 ECHDEL     E5D5 R   |   2 EDIGIT     F999 R   |   2 ENDBUF     E5B8 R
  2 ENDCON     F965 R   |   2 ENDDIM     F0CC R   |   2 ENDINP     EB7C R
  2 ENDLIN     FEF1 R   |   2 ENDNAM     EF4A R   |   2 ENDPRG     E87A R
  2 ENFMEM     E393 R   |   2 ERRIN      E3E1 R   |     ERRLIN  =  10D2 
  2 ERRMSG     E33F R   |   2 ERROR      E3C1 R   |   2 ERRORS     E2B9 R
    ESC     =  001B     |   2 EVAL       ED5A R   |   2 EVAL1      ED5D R
  2 EVAL2      ED66 R   |   2 EVAL3      ED69 R   |   2 EVLPAR     EE09 R
  2 EVNOT      EF08 R   |   2 EXCUTE     E816 R   |   2 EXP        FAFA R
  2 EXPLP      F944 R   |   2 EXPTAB     FB3A R   |   2 EXPTEN     FA72 R
  2 EXTIG      ECC1 R   |   2 FANDT      ECEB R   |     FC      =  0008 
  2 FCERR      E9A0 R   |   2 FDTLP      ECD2 R   |   2 FILE       F58E R
  2 FILFND     F574 R   |   2 FINDEL     F0A8 R   |   2 FLGDIF     F81E R
  2 FLGREL     F825 R   |   2 FLGVER     F509 R   |   2 FLPLED     FE39 R
    FNARG   =  10E0     |   2 FNCTAB     E10F R   |   2 FNDARY     F018 R
  2 FNDELP     F0AD R   |   2 FNDEND     E48D R   |   2 FNDNUM     F481 R
  2 FNDTOK     E71B R   |   2 FNDVAR     EF8F R   |   2 FNDWRD     E53C R
  2 FNOFST     EE33 R   |     FNRGNM  =  10DE     |   2 FNTHR      EF9D R
  2 FNVAL      EE5F R   |   2 FOPRND     ED92 R   |   2 FOR        E779 R
    FORFLG  =  10CB     |   2 FORFND     E7A9 R   |   2 FORSLP     E78D R
  2 FOUND      F594 R   |   2 FPADD      F5CD R   |   2 FPBCDE     F854 R
    FPEXP   =  10E7     |   2 FPINT      F8BB R   |   2 FPMULT     F708 R
    FPREG   =  10E4     |   2 FPROND     F665 R   |   2 FPSINT     E97F R
  2 FPTHL      F86B R   |   2 FRE        F0D0 R   |   2 FRENUM     F0EC R
  2 FRMEVL     EE25 R   |   2 GARBGE     F253 R   |   2 GARBLP     F256 R
  2 GETCHR     E836 R   |   2 GETCMD     E405 R   |   2 GETHDR     E910 R
  2 GETINP     FD05 R   |   2 GETINT     F484 R   |   2 GETLEN     F386 R
  2 GETLIN     E5F2 R   |   2 GETLN      E9A6 R   |   2 GETNUM     ED41 R
  2 GETNXT     E557 R   |   2 GETSTR     F350 R   |   2 GETTIN     FD13 R
  2 GETVAR     EF2D R   |   2 GETXYA     FF15 R   |   2 GNXARY     F28A R
  2 GOFUNC     EE67 R   |   2 GOSUB      EA1C R   |   2 GOTO       EA2D R
  2 GRBARY     F2AA R   |   2 GRBDON     F22B R   |   2 GRBLP      F264 R
  2 GSTRCU     F353 R   |   2 GSTRDE     F357 R   |   2 GSTRHL     F356 R
  2 GTFLNM     F395 R   |   2 GTFNAM     EF32 R   |   2 GTLNLP     E9A9 R
  2 GTSIXD     F9EA R   |   2 GTVLUS     EC3D R   |   2 GUART      FD56 R
  2 HALF       FA91 R   |   2 HALFPI     FC4A R   |   2 HDRLP      E912 R
    ID      =  0016     |   2 IDTEST     F17B R   |   2 IF         EAFF R
  2 IFGO       EB0D R   |   2 IFJMP      E81D R   |   2 IGCHR      FD00 R
  2 INCHL      F869 R   |   2 INCLEN     E6BB R   |   2 INDFND     E370 R
  2 INEWLN     E455 R   |   2 INIT       E019 R   |   2 INITAB     E2DF R
  2 INITBE     E33F R   |   2 INITST     FEBB R   |   2 INLINE     FEE8 R
  2 INMSG      E346 R   |   2 INP        F441 R   |   2 INPBIN     EC8F R
  2 INPBRK     E877 R   |     INPORT  =  103F     |     INPSUB  =  103E 
  2 INPUT      EBFD R   |   2 INRNG      F9F3 R   |   2 INT        F8E6 R
  2 INTVAR     E4C9 R   |   2 INVSGN     F83C R   |   2 ITMSEP     EC80 R
  2 JJUMP      FFFA R   |   2 JJUMP1     FDDE R   |   2 JPLDSV     FFD6 R
  2 JSTZER     FA7C R   |   2 KILFOR     ED31 R   |   2 KILIN      E5EC R
    LCRFLG  =  10AC     |   2 LDNMI1     E73C R   |   2 LEFT       F3B2 R
  2 LEN        F382 R   |   2 LET        EA87 R   |   2 LETNUM     EADA R
  2 LETSTR     EAA2 R   |     LF      =  000A     |   2 LFRGNM     F437 R
    LINEAT  =  105C     |   2 LINEIN     F9A5 R   |   2 LINES      FDAD R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 92.
Hexadecimal [16-Bits]

Symbol Table

    LINESC  =  1046     |     LINESN  =  1048     |   2 LINFND     E43E R
  2 LINTBF     FF02 R   |   2 LIST       E6DD R   |   2 LISTLP     E6E9 R
  2 LOADFP     F862 R   |   2 LOG        F6C7 R   |   2 LOGTAB     F6BA R
  2 LOKFOR     E35A R   |     LOOPST  =  10C7     |     LS      =  001C 
    LSTBIN  =  10CC     |   2 LSTLP2     E709 R   |   2 LSTLP3     E70C R
    LSTRAM  =  10AF     |     LSTRND  =  103A     |   2 LTSTND     EC9A R
    LWIDTH  =  1042     |   2 MAKINT     F487 R   |   2 MAKNUM     FA0F R
  2 MANLP      F92E R   |   2 MATCH      E589 R   |   2 MEMMSG     E103 R
    MFLP    =  0051     |   2 MID        F3EC R   |   2 MID1       F3B8 R
  2 MIDNUM     F43C R   |   2 MINCDE     F60D R   |   2 MINUS      EE11 R
  2 MKTMST     F1BF R   |   2 MLDBLP     F907 R   |   2 MLDEBC     F8FF R
  2 MLOOP      E049 R   |   2 MLSP10     F7FC R   |     MO      =  0024 
  2 MONITR     FEA2 R   |   2 MONLD      FE88 R   |   2 MONOUT     FE45 R
    MONSTT  =  0000     |   2 MONTST     FE6D R   |     MONTYP  =  008D 
  2 MONVE      FEAA R   |   2 MORDT      ECA6 R   |   2 MORINP     E610 R
  2 MOVBUF     E474 R   |   2 MOVDIR     E591 R   |   2 MOVLP      E37F R
  2 MOVSTR     E37C R   |   2 MOVUP      E379 R   |   2 MRPRNT     EB1F R
  2 MSIZE      E036 R   |   2 MUL8LP     F733 R   |   2 MULLN2     F6FF R
  2 MULT       F706 R   |   2 MULT8      F72A R   |   2 MULTEN     F970 R
    MULVAL  =  10F6     |   2 MVSTPT     EAD1 R   |   2 NASOUT     FCFB R
  2 NEDMOR     EC39 R   |   2 NEGAFT     FAA7 R   |   2 NEW        E4B9 R
  2 NEXITM     EBD2 R   |   2 NEXT       ECF6 R   |   2 NEXT1      ECF9 R
    NF      =  0000     |   2 NFERR      E3B3 R   |     NMI     =  0C7E 
    NMIFLG  =  104C     |   2 NOCHNG     E581 R   |   2 NOENED     FA7F R
  2 NOLIN      E88D R   |   2 NOMADD     F744 R   |   2 NOMLAD     F915 R
  2 NOPMPT     EC17 R   |   2 NOREMD     FFBA R   |   2 NORES      FF75 R
  2 NORMAL     F638 R   |   2 NOSPC      E578 R   |   2 NOSWAP     F5E7 R
  2 NOTSTR     EF65 R   |   2 NOXOR      F467 R   |   2 NSCFOR     EF75 R
    NULFLG  =  1044     |   2 NULL       E8B1 R   |   2 NULLP      EB8D R
    NULLS   =  1041     |   2 NUMASC     F9B8 R   |   2 NXTARY     F02C R
  2 NXTBYT     E567 R   |   2 NXTCHR     E5A8 R   |     NXTDAT  =  10DC 
  2 NXTDTA     EA6F R   |   2 NXTITM     EC31 R   |     NXTOPR  =  10D0 
  2 NXTSTL     EA76 R   |   2 NXTSTT     EA79 R   |     OD      =  0006 
  2 OKMSG      E34B R   |     OM      =  000C     |   2 OMERR      E3A2 R
  2 ON         EAE1 R   |   2 ONGO       EAF0 R   |   2 ONGOLP     EAF1 R
  2 ONJMP      E81E R   |   2 OPNPAR     ED56 R   |   2 OPRND      EDD1 R
    OS      =  001A     |   2 OTKLN      E5E9 R   |     OTPORT  =  1007 
  2 OUTBAD     F56B R   |   2 OUTC       E69B R   |   2 OUTCHR     FCFD R
  2 OUTEXP     FA70 R   |   2 OUTIT      E67C R   |   2 OUTNBS     E682 R
  2 OUTNCR     FFF4 R   |     OUTSUB  =  1006     |   2 OUTWRD     E725 R
    OV      =  000A     |   2 OVERR      E3BC R   |   2 OVTST1     F7EF R
  2 OVTST2     F7F4 R   |   2 OVTST3     F7F5 R   |   2 PADD       F994 R
  2 PAND       EE81 R   |   2 PASSA      F101 R   |     PBUFF   =  10E9 
  2 PEEK       F5A3 R   |   2 PEND       E872 R   |   2 PHLTFP     F851 R
  2 PLUCDE     F672 R   |   2 PNORM      F640 R   |     POINT   =  1051 
  2 POINT0     FF91 R   |   2 POINTB     FF79 R   |   2 POINTX     FF87 R
  2 POKE       F5AA R   |   2 POPAF      F245 R   |   2 POPHL      F36F R
  2 POPHRT     F754 R   |   2 POPNOK     E3F7 R   |   2 POR        EE80 R
  2 POR1       EEA3 R   |     PORT0   =  0C00     |   2 POS        F0FE R
  2 POSINT     E982 R   |   2 POUT       F44D R   |   2 POWER      FAB5 R
  2 POWER1     FAC5 R   |   2 POWER2     FAE2 R   |   2 POWERS     FA95 R
  2 PRINT      EB23 R   |   2 PRITAB     E2A4 R   |   2 PRNTCR     EB81 R
  2 PRNTHL     F9AD R   |   2 PRNTLP     EB26 R   |   2 PRNTNB     EB69 R
  2 PRNTOK     E3F8 R   |   2 PRNTST     EB6D R   |   2 PRNUMS     F20F R
  2 PROCES     E629 R   |     PROGND  =  10D6     |     PROGST  =  10F9 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 93.
Hexadecimal [16-Bits]

Symbol Table

  2 PROMPT     E4FC R   |   2 PRS        F210 R   |   2 PRS1       F213 R
  2 PRSLP      F21A R   |     PSET    =  1054     |   2 PSUB       F5C8 R
  2 PTRLP      E481 R   |   2 PUTBIT     FF4B R   |   2 PUTBUF     E668 R
  2 PUTCTL     E66D R   |   2 PUTFID     E7EE R   |   2 QTSTLP     F1D5 R
  2 QTSTR      F1CF R   |   2 QUARTR     FC4E R   |   2 READ       EC2C R
    READFG  =  10CD     |   2 REDO       EBD9 R   |   2 REM        EA72 R
  2 RESCSA     FF4C R   |   2 RESDIV     F7A1 R   |   2 RESEED     FBEC R
    RESET   =  1057     |   2 RESETB     FF55 R   |   2 RESTNL     E85B R
  2 RESTOR     E846 R   |   2 RESZER     F633 R   |   2 RETADR     EFDC R
  2 RETCTC     FE65 R   |   2 RETINT     F82A R   |   2 RETLIN     EA6A R
  2 RETNAD     E58D R   |   2 RETNUL     EFDF R   |   2 RETNUM     EE1D R
  2 RETREL     F81C R   |   2 RETURN     EA4B R   |     RG      =  0004 
  2 RIGHT      F3E2 R   |   2 RIGHT1     F3B6 R   |     RINPUT  =  104E 
  2 RLTLP      ED76 R   |   2 RND        FB8B R   |   2 RND1       FBC7 R
  2 RND2       FBE3 R   |   2 RNDTAB     FBF4 R   |   2 RNGTST     FA82 R
  2 RONDB      F654 R   |   2 RONDUP     F653 R   |   2 ROUND      F5BB R
  2 RSCALE     F98E R   |   2 RSLNBK     E770 R   |   2 RSTSTR     F405 R
  2 RUART      F4B4 R   |   2 RUN        EA10 R   |   2 RUNCNT     E7F2 R
  2 RUNFST     E4C5 R   |   2 RUNLIN     EA2C R   |   2 SAVE       FE73 R
  2 SAVEXP     F634 R   |   2 SAVSTP     E7E5 R   |   2 SAVSTR     F1AA R
  2 SBSCPT     EFEA R   |   2 SCALE      F692 R   |   2 SCALLP     F694 R
  2 SCALMI     F959 R   |   2 SCALPL     F96F R   |   2 SCNEND     F2E1 R
  2 SCPTLP     EFF0 R   |   2 SCRADR     FE11 R   |   2 SCREEN     FDE6 R
  2 SEARCH     E555 R   |     SEED    =  1017     |   2 SETB       FF40 R
  2 SETIO      F471 R   |   2 SETLIN     E733 R   |   2 SETLIT     E59F R
  2 SETOR      FF50 R   |   2 SETPTR     E47C R   |   2 SETTOP     E06D R
  2 SFTENT     FD70 R   |   2 SFTPRG     E446 R   |   2 SGN        F822 R
  2 SGNEXP     EE70 R   |     SGNRES  =  10E8     |   2 SHFTBT     FFBD R
  2 SHRITE     F6A1 R   |   2 SHRLP      F6A4 R   |   2 SHRT1      F6A8 R
  2 SIGNON     E0C5 R   |   2 SIGNS      F879 R   |   2 SIN        FC06 R
  2 SIN1       FC36 R   |   2 SINTAB     FC52 R   |   2 SIXDIG     F9D5 R
  2 SMOTOR     FFD1 R   |   2 SMPVAR     F275 R   |   2 SMSER1     FB6A R
    SN      =  0002     |   2 SNDARY     E91D R   |   2 SNDHDR     E906 R
  2 SNERR      E3AD R   |   2 SPCFST     F9C6 R   |   2 SPCLP      EBCB R
  2 SQR        FAAC R   |   2 SRCHLN     E499 R   |   2 SRCHLP     E49C R
  2 SSTSA      F33D R   |     ST      =  001E     |     STACK   =  1066 
  2 STAKFP     F844 R   |   2 STALL      E866 R   |   2 START      E000 R
  2 STARTB     E003 R   |   2 STKTHS     EDBA R   |     STLOOK  =  115D 
    STMON   =  000D     |   2 STOP       E870 R   |   2 STORED     E9ED R
  2 STPOOL     F2B8 R   |   2 STR        F19A R   |   2 STRADD     F2BB R
    STRBOT  =  10C3     |   2 STRENT     EC83 R   |     STRSPC  =  105A 
  2 STTLIN     EB74 R   |   2 SUART      FD68 R   |   2 SUBCDE     F5CA R
  2 SUBPHL     F5C4 R   |   2 SUMLP      FB73 R   |   2 SUMOFF     E937 R
  2 SUMSER     FB5B R   |   2 SUPTLZ     FA54 R   |   2 SVNAM2     EF49 R
  2 SVSTAD     F1C8 R   |   2 T0xCINP    FE62 R   |     T2DUMP  =  03D1 
    T4READ  =  070C     |     T4WR    =  0400     |   2 TAN        FC67 R
    TBRK    =  001C     |   2 TBRK2      FD50 R   |     TBS     =  001D 
  2 TCLS       FD96 R   |     TCR     =  001F     |     TCS     =  001E 
    TCUR    =  0C18     |   2 TESTOS     F247 R   |   2 TESTR      F229 R
  2 THSFIL     F548 R   |     TIN     =  0C4D     |   2 TLOAD      FE99 R
    TM      =  0018     |   2 TMERR      E3BF R   |   2 TMFLP      FE42 R
  2 TMNCUR     FE04 R   |   2 TMNOUT     FE4F R   |     TMPSTR  =  10BF 
    TMSTPL  =  10B3     |     TMSTPT  =  10B1     |   2 TOPOOL     F3AE R
  2 TOSTRA     F346 R   |     TOUT    =  0C4A     |   2 TRYAGN     FA2F R
  2 TSALP      F347 R   |   2 TSAVE      FE7F R   |   2 TSTBIT     FFED R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 94.
Hexadecimal [16-Bits]

Symbol Table

  2 TSTBRK     E861 R   |   2 TSTMEM     E05B R   |   2 TSTNUM     ED44 R
  2 TSTOPL     F1F0 R   |   2 TSTRED     EEA8 R   |   2 TSTREM     E5A2 R
  2 TSTSGN     F813 R   |   2 TSTSTR     ED45 R   |   2 TTYLIN     E607 R
    TYPE    =  10AD     |     UARTD   =  0001     |   2 UARTOT     FD5F R
    UARTS   =  0002     |     UF      =  0022     |   2 UFERR      E3B9 R
    UL      =  000E     |   2 ULERR      EA46 R   |   2 UNITY      F6B6 R
  2 UPDATA     E85C R   |   2 URTOLP     FD61 R   |     USR     =  1003 
  2 VAL        F41C R   |     VAREND  =  10D8     |     VDU     =  0800 
  2 WAIT       F453 R   |   2 WAITLP     F468 R   |   2 WARMST     E0AE R
  2 WIDTH      FDA5 R   |   2 WORDS      E143 R   |   2 WORDTB     E25A R
    WRKSPC  =  1000     |   2 WUART      F4BA R   |   2 WUART2     F4B7 R
  2 XYPOS      FF96 R   |     ZDATA   =  0083     |     ZDIV    =  00AF 
    ZEND    =  0080     |     ZEQUAL  =  00B4     |   2 ZERARY     F08B R
  2 ZERBYT     E34A R   |   2 ZEROLP     EFCE R   |     ZFN     =  00A7 
    ZFOR    =  0081     |     ZGOSUB  =  008C     |     ZGOTO   =  0088 
    ZGTR    =  00B3     |   2 ZJUMP      FFFD R   |     ZLEFT   =  00CD 
    ZLTH    =  00B5     |     ZMINUS  =  00AD     |     ZNEW    =  00A4 
    ZNOT    =  00AA     |   2 ZONELP     EBA6 R   |     ZOR     =  00B2 
    ZPLUS   =  00AC     |     ZPOINT  =  00C7     |     ZPRINT  =  009E 
    ZREM    =  008E     |     ZSGN    =  00B6     |     ZSPC    =  00A8 
    ZSTEP   =  00AB     |     ZTAB    =  00A5     |     ZTHEN   =  00A9 
    ZTIMES  =  00AE     |     ZTO     =  00A6     |     _BLNK   =  7BDF 
    _INLN   =  63DF     |     _MFLP   =  5FDF     |     _MRET   =  5BDF 
    _READ   =  52DF     |     _RIN    =  62DF     |     _ROUT   =  00F7 
    _VRFY   =  56DF     |     _WRIT   =  57DF 

ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 95.
Hexadecimal [16-Bits]

Area Table

   0 _CODE      size    0   flags    0
   1 CODE       size    0   flags    8
   2 CODE0      size 2000   flags    8

