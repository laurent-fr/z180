ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 1.
Hexadecimal [16-Bits]



                              1 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                              2 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                              3 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                              4 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                              5 ; the original ROM code (checksum 0xA934). PA
                              6 
                              7 .z180
                              8 
                              9 .area CODE (ABS)
                             10 
                             11 
                             12 ; MONITOR EQUATES (RESTART INSTRUCTIONS)
                             13 
                     00F7    14 _ROUT   .equ     0xF7            ; ROUT - Output char in A
                     7BDF    15 _BLNK   .equ     0x7BDF          ; SCAL BLINK - Get input char in A
                     63DF    16 _INLN   .equ     0x63DF          ; SCAL INLIN - Get input line
                     5FDF    17 _MFLP   .equ     0x5FDF          ; SCAL MFLP - Toggle tape drv LED
                     5BDF    18 _MRET   .equ     0x5BDF          ; SCAL MRET - Return to monitor
                     52DF    19 _READ   .equ     0x52DF          ; SCAL READ
                     62DF    20 _RIN    .equ     0x62DF          ; SCAL RIN - Scan for input char
                     56DF    21 _VRFY   .equ     0x56DF          ; SCAL VERIFY
                     57DF    22 _WRIT   .equ     0x57DF          ; SCAL WRITE
                             23 
                             24 ; GENERAL .equATES
                             25 
                     0001    26 UARTD   .equ     0x01             ; UART data port
                     0002    27 UARTS   .equ     0x02             ; UART status port
                     0003    28 CTRLC   .equ     0x03             ; Control "C"
                     0007    29 CTRLG   .equ     0x07             ; Control "G"
                     0008    30 BKSP    .equ     0x08             ; Back space
                     000A    31 LF      .equ     0x0A             ; Line feed
                     000C    32 CS      .equ     0x0C             ; Clear screen
                     000D    33 CR      .equ     0x0D             ; Carriage return
                     000F    34 CTRLO   .equ     0x0F             ; Control "O"
                     0012    35 CTRLR   .equ     0x12             ; Control "R"
                     0013    36 CTRLS   .equ     0x13             ; Control "S"
                     0015    37 CTRLU   .equ     0x15             ; Control "U"
                     001A    38 CTRLZ   .equ     0x1A             ; Control "Z"
                     001B    39 ESC     .equ     0x1B             ; Escape
                     001C    40 TBRK    .equ     0x1C             ; "T" monitor break
                     001D    41 TBS     .equ     0x1D             ; "T" monitor back space
                     001E    42 TCS     .equ     0x1E             ; "T" monitor clear screen
                     001F    43 TCR     .equ     0x1F             ; "T" monitor carriage return
                     007F    44 DEL     .equ     0x7F             ; Delete
                             45 
                             46 ; MONITOR LOCATIONS
                             47 
                     0000    48 MONSTT  .equ     0x0000           ; Start of monitor
                     000D    49 STMON   .equ     0x000D           ; NAS-SYS initialisation
                     0051    50 MFLP    .equ     0x0051           ; Flip tape LED ("T")
                     008D    51 MONTYP  .equ     0x008D           ; Type of "T" monitor
                     03D1    52 T2DUMP  .equ     0x03D1           ; "T2" Dump routine
                     0400    53 T4WR    .equ     0x0400           ; "T4" Write routine
                     070C    54 T4READ  .equ     0x070C           ; "T4" Read routine
                     0800    55 VDU     .equ     0x0800           ; NASCOM Video RAM base
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 2.
Hexadecimal [16-Bits]



                             56 
                             57 ; MONITOR WORK SPACE LOCATIONS
                             58 
                     0C00    59 PORT0   .equ     0x0C00           ; Copy of output port 0
                     0C0C    60 ARG1    .equ     0x0C0C           ; Argument 1
                     0C0E    61 ARG2    .equ     0x0C0E           ; Argument 2
                     0C18    62 TCUR    .equ     0x0C18           ; "T" monitor cursor
                     0C29    63 CURSOR  .equ     0x0C29           ; NAS-SYS Cursor
                     0C2B    64 ARGN    .equ     0x0C2B           ; Number of ARGS
                     0C4A    65 TOUT    .equ     0x0C4A           ; "T" Output reflection
                     0C4D    66 TIN     .equ     0x0C4D           ; "T" Input reflection
                     0C75    67 CIN     .equ     0x0C75           ; NAS-SYS Input table
                     0C7E    68 NMI     .equ     0x0C7E           ; NAS-SYS NMI Jump
                             69 
                             70 ; BASIC WORK SPACE LOCATIONS
                             71 
                     1000    72 WRKSPC  .equ     0x1000           ; BASIC Work space
                     1003    73 USR     .equ     0x1003           ; "USR (x)" jump
                     1006    74 OUTSUB  .equ     0x1006           ; "OUT p,n"
                     1007    75 OTPORT  .equ     0x1007           ; Port (p)
                     1009    76 DIVSUP  .equ     0x1009           ; Division support routine
                     100A    77 DIV1    .equ     0x100A           ; <- Values
                     100E    78 DIV2    .equ     0x100E           ; <-   to
                     1012    79 DIV3    .equ     0x1012           ; <-   be
                     1015    80 DIV4    .equ     0x1015           ; <-inserted
                     1017    81 SEED    .equ     0x1017           ; Random number seed
                     103A    82 LSTRND  .equ     0x103A           ; Last random number
                     103E    83 INPSUB  .equ     0x103E           ; #INP (x)" Routine
                     103F    84 INPORT  .equ     0x103F           ; PORT (x)
                     1041    85 NULLS   .equ     0x1041           ; Number of nulls
                     1042    86 LWIDTH  .equ     0x1042           ; Terminal width
                     1043    87 COMMAN  .equ     0x1043           ; Width for commas
                     1044    88 NULFLG  .equ     0x1044           ; Null after input byte flag
                     1045    89 CTLOFG  .equ     0x1045           ; Control "O" flag
                     1046    90 LINESC  .equ     0x1046           ; Lines counter
                     1048    91 LINESN  .equ     0x1048           ; Lines number
                     104A    92 CHKSUM  .equ     0x104A           ; Array load/save check sum
                     104C    93 NMIFLG  .equ     0x104C           ; Flag for NMI break routine
                     104D    94 BRKFLG  .equ     0x104D           ; Break flag
                     104E    95 RINPUT  .equ     0x104E           ; Input reflection
                     1051    96 POINT   .equ     0x1051           ; "POINT" reflection (unused)
                     1054    97 PSET    .equ     0x1054           ; "SET"   reflection
                     1057    98 RESET   .equ     0x1057           ; "RESET" reflection
                     105A    99 STRSPC  .equ     0x105A           ; Bottom of string space
                     105C   100 LINEAT  .equ     0x105C           ; Current line number
                     105E   101 BASTXT  .equ     0x105E           ; Pointer to start of program
                     1061   102 BUFFER  .equ     0x1061           ; Input buffer
                     1066   103 STACK   .equ     0x1066           ; Initial stack
                     10AB   104 CURPOS  .equ     0x10AB           ; Character position on line
                     10AC   105 LCRFLG  .equ     0x10AC           ; Locate/Create flag
                     10AD   106 TYPE    .equ     0x10AD           ; Data type flag
                     10AE   107 DATFLG  .equ     0x10AE           ; Literal statement flag
                     10AF   108 LSTRAM  .equ     0x10AF           ; Last available RAM
                     10B1   109 TMSTPT  .equ     0x10B1           ; Temporary string pointer
                     10B3   110 TMSTPL  .equ     0x10B3           ; Temporary string pool
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 3.
Hexadecimal [16-Bits]



                     10BF   111 TMPSTR  .equ     0x10BF           ; Temporary string
                     10C3   112 STRBOT  .equ     0x10C3           ; Bottom of string space
                     10C5   113 CUROPR  .equ     0x10C5           ; Current operator in EVAL
                     10C7   114 LOOPST  .equ     0x10C7           ; First statement of loop
                     10C9   115 DATLIN  .equ     0x10C9           ; Line of current DATA item
                     10CB   116 FORFLG  .equ     0x10CB           ; "FOR" loop flag
                     10CC   117 LSTBIN  .equ     0x10CC           ; Last byte entered
                     10CD   118 READFG  .equ     0x10CD           ; Read/Input flag
                     10CE   119 BRKLIN  .equ     0x10CE           ; Line of break
                     10D0   120 NXTOPR  .equ     0x10D0           ; Next operator in EVAL
                     10D2   121 ERRLIN  .equ     0x10D2           ; Line of error
                     10D4   122 CONTAD  .equ     0x10D4           ; Where to CONTinue
                     10D6   123 PROGND  .equ     0x10D6           ; End of program
                     10D8   124 VAREND  .equ     0x10D8           ; End of variables
                     10DA   125 ARREND  .equ     0x10DA           ; End of arrays
                     10DC   126 NXTDAT  .equ     0x10DC           ; Next data item
                     10DE   127 FNRGNM  .equ     0x10DE           ; Name of FN argument
                     10E0   128 FNARG   .equ     0x10E0           ; FN argument value
                     10E4   129 FPREG   .equ     0x10E4           ; Floating point register
                     10E7   130 FPEXP   .equ     FPREG+3         ; Floating point exponent
                     10E8   131 SGNRES  .equ     0x10E8           ; Sign of result
                     10E9   132 PBUFF   .equ     0x10E9           ; Number print buffer
                     10F6   133 MULVAL  .equ     0x10F6           ; Multiplier
                     10F9   134 PROGST  .equ     0x10F9           ; Start of program text area
                     115D   135 STLOOK  .equ     0x115D           ; Start of memory test
                            136 
                            137 ; BASIC ERROR CODE VALUES
                            138 
                     0000   139 NF      .equ     0x00             ; NEXT without FOR
                     0002   140 SN      .equ     0x02             ; Syntax error
                     0004   141 RG      .equ     0x04             ; RETURN without GOSUB
                     0006   142 OD      .equ     0x06             ; Out of DATA
                     0008   143 FC      .equ     0x08             ; Function call error
                     000A   144 OV      .equ     0x0A             ; Overflow
                     000C   145 OM      .equ     0x0C             ; Out of memory
                     000E   146 UL      .equ     0x0E             ; Undefined line number
                     0010   147 BS      .equ     0x10             ; Bad subscript
                     0012   148 DD      .equ     0x12             ; Re-DIMensioned array
                     0014   149 DZ      .equ     0x14             ; Division by zero (/0)
                     0016   150 ID      .equ     0x16             ; Illegal direct
                     0018   151 TM      .equ     0x18             ; Type miss-match
                     001A   152 OS      .equ     0x1A             ; Out of string space
                     001C   153 LS      .equ     0x1C             ; String too long
                     001E   154 ST      .equ     0x1E             ; String formula too complex
                     0020   155 CN      .equ     0x20             ; Can't CONTinue
                     0022   156 UF      .equ     0x22             ; UnDEFined FN function
                     0024   157 MO      .equ     0x24             ; Missing operand
                            158 
   E000                     159         .org     0xE000
                            160 
   E000 C3 03 E0      [ 9]  161 START:  JP      STARTB          ; Jump for restart jump
   E003 F3            [ 3]  162 STARTB: DI                      ; No interrupts
   E004 DD 21 00 00   [12]  163         LD      IX,#0            ; Flag cold start
   E008 C3 12 E0      [ 9]  164         JP      CSTART          ; Jump to initialise
                            165 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 4.
Hexadecimal [16-Bits]



   E00B 8D E9               166         .dw      DEINT           ; Get integer -32768 to 32767
   E00D F4 F0               167         .dw      ABPASS          ; Return integer in AB
                            168 
   E00F C3 3E E7      [ 9]  169         JP      LDNMI1          ; << NO REFERENCE TO HERE >>
                            170 
   E012 21 00 10      [ 9]  171 CSTART: LD      HL,#WRKSPC       ; Start of workspace RAM
   E015 F9            [ 4]  172         LD      SP,HL           ; Set up a temporary stack
   E016 C3 BD FE      [ 9]  173         JP      INITST          ; Go to initialise
                            174 
   E019 11 DF E2      [ 9]  175 INIT:   LD      DE,#INITAB       ; Initialise workspace
   E01C 06 63         [ 6]  176         LD      B,#INITBE-#INITAB+#3; Bytes to copy
   E01E 21 00 10      [ 9]  177         LD      HL,#WRKSPC       ; Into workspace RAM
   E021 1A            [ 6]  178 COPY:   LD      A,(DE)          ; Get source
   E022 77            [ 7]  179         LD      (HL),A          ; To destination
   E023 23            [ 4]  180         INC     HL              ; Next destination
   E024 13            [ 4]  181         INC     DE              ; Next source
   E025 05            [ 4]  182         DEC     B               ; Count bytes
   E026 C2 21 E0      [ 9]  183         JP      NZ,#COPY         ; More to move
   E029 F9            [ 4]  184         LD      SP,HL           ; Temporary stack
   E02A CD E1 E4      [16]  185         CALL    CLREG           ; Clear registers and stack
   E02D CD 83 EB      [16]  186         CALL    PRNTCR          ; Output CRLF
   E030 32 AA 10      [13]  187         LD      (BUFFER+72+1),A ; Mark end of buffer
   E033 32 F9 10      [13]  188         LD      (PROGST),A      ; Initialise program area
   E036 21 03 E1      [ 9]  189 MSIZE:  LD      HL,#MEMMSG       ; Point to message
   E039 CD 12 F2      [16]  190         CALL    PRS             ; Output "Memory size"
   E03C CD FE E4      [16]  191         CALL    PROMPT          ; Get input with "?"
   E03F CD 38 E8      [16]  192         CALL    GETCHR          ; Get next character
   E042 B7            [ 4]  193         OR      A               ; Set flags
   E043 C2 5B E0      [ 9]  194         JP      NZ,TSTMEM       ; If number - Test if RAM there
   E046 21 5D 11      [ 9]  195         LD      HL,#STLOOK       ; Point to start of RAM
   E049 23            [ 4]  196 MLOOP:  INC     HL              ; Next byte
   E04A 7C            [ 4]  197         LD      A,H             ; Above address FFFF ?
   E04B B5            [ 4]  198         OR      L
   E04C CA 6D E0      [ 9]  199         JP      Z,SETTOP        ; Yes - 64K RAM
   E04F 7E            [ 6]  200         LD      A,(HL)          ; Get contents
   E050 47            [ 4]  201         LD      B,A             ; Save it
   E051 2F            [ 3]  202         CPL                     ; Flip all bits
   E052 77            [ 7]  203         LD      (HL),A          ; Put it back
   E053 BE            [ 6]  204         CP      (HL)            ; RAM there if same
   E054 70            [ 7]  205         LD      (HL),B          ; Restore old contents
   E055 CA 49 E0      [ 9]  206         JP      Z,MLOOP         ; If RAM - test next byte
   E058 C3 6D E0      [ 9]  207         JP      SETTOP          ; Top of RAM found
                            208 
   E05B CD A7 E9      [16]  209 TSTMEM: CALL    ATOH            ; Get high memory into DE
   E05E B7            [ 4]  210         OR      A               ; Set flags on last byte
   E05F C2 AF E3      [ 9]  211         JP      NZ,SNERR        ; ?SN Error if bad character
   E062 EB            [ 3]  212         EX      DE,HL           ; Address into HL
   E063 2B            [ 4]  213         DEC     HL              ; Back one byte
   E064 3E D9         [ 6]  214         LD      A,#0b11011001     ; Test byte
   E066 46            [ 6]  215         LD      B,(HL)          ; Get old contents
   E067 77            [ 7]  216         LD      (HL),A          ; Load test byte
   E068 BE            [ 6]  217         CP      (HL)            ; RAM there if same
   E069 70            [ 7]  218         LD      (HL),B          ; Restore old contents
   E06A C2 36 E0      [ 9]  219         JP      NZ,MSIZE        ; Ask again if no RAM
                            220 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 5.
Hexadecimal [16-Bits]



   E06D 2B            [ 4]  221 SETTOP: DEC     HL              ; Back one byte
   E06E 11 5C 11      [ 9]  222         LD      DE,#STLOOK-1     ; See if enough RAM
   E071 CD 8C E6      [16]  223         CALL    CPDEHL          ; Compare DE with HL
   E074 DA 36 E0      [ 9]  224         JP      C,MSIZE         ; Ask again if not enough RAM
   E077 00            [ 3]  225         NOP
   E078 00            [ 3]  226         NOP
   E079 00            [ 3]  227         NOP
   E07A 00            [ 3]  228         NOP
   E07B 00            [ 3]  229         NOP
   E07C 00            [ 3]  230         NOP
   E07D 00            [ 3]  231         NOP
   E07E 00            [ 3]  232         NOP
   E07F 00            [ 3]  233         NOP
   E080 11 CE FF      [ 9]  234         LD      DE,#0-50         ; 50 Bytes string space
   E083 22 AF 10      [16]  235         LD      (LSTRAM),HL     ; Save last available RAM
   E086 19            [ 7]  236         ADD     HL,DE           ; Allocate string space
   E087 22 5A 10      [16]  237         LD      (STRSPC),HL     ; Save string space
   E08A CD BC E4      [16]  238         CALL    CLRPTR          ; Clear program area
   E08D 2A 5A 10      [15]  239         LD      HL,(STRSPC)     ; Get end of memory
   E090 11 EF FF      [ 9]  240         LD      DE,#0-17         ; Offset for free bytes
   E093 19            [ 7]  241         ADD     HL,DE           ; Adjust HL
   E094 11 F9 10      [ 9]  242         LD      DE,#PROGST       ; Start of program text
   E097 7D            [ 4]  243         LD      A,L             ; Get LSB
   E098 93            [ 4]  244         SUB     E               ; Adjust it
   E099 6F            [ 4]  245         LD      L,A             ; Re-save
   E09A 7C            [ 4]  246         LD      A,H             ; Get MSB
   E09B 9A            [ 4]  247         SBC     A,D             ; Adjust it
   E09C 67            [ 4]  248         LD      H,A             ; Re-save
   E09D E5            [11]  249         PUSH    HL              ; Save bytes free
   E09E 21 C5 E0      [ 9]  250         LD      HL,#SIGNON       ; Sign-on message
   E0A1 CD 12 F2      [16]  251         CALL    PRS             ; Output string
   E0A4 E1            [ 9]  252         POP     HL              ; Get bytes free back
   E0A5 CD AF F9      [16]  253         CALL    PRNTHL          ; Output amount of free memory
   E0A8 21 B7 E0      [ 9]  254         LD      HL,#BFREE        ; " Bytes free" message
   E0AB CD 12 F2      [16]  255         CALL    PRS             ; Output string
                            256 
   E0AE 31 66 10      [ 9]  257 WARMST: LD      SP,#STACK        ; Temporary stack
   E0B1 CD E1 E4      [16]  258 BRKRET: CALL    CLREG           ; Clear registers and stack
   E0B4 C3 FA E3      [ 9]  259         JP      PRNTOK          ; Go to get command line
                            260 
   E0B7 20 42 79 74 65 73   261 BFREE:  .ascii      " Bytes free"
        20 66 72 65 65
   E0C2 0D 00 00            262         .db         CR,0,0
                            263 
   E0C5 4E 41 53 43 4F 4D   264 SIGNON: .ascii      "NASCOM ROM BASIC Ver 4.7   "
        20 52 4F 4D 20 42
        41 53 49 43 20 56
        65 72 20 34 2E 37
        20 20 20
   E0E0 0D                  265         .db CR
   E0E1 43 6F 70 79 72 69   266         .ascii      "Copyright (C) 1978 by Microsoft"
        67 68 74 20 28 43
        29 20 31 39 37 38
        20 62 79 20 4D 69
        63 72 6F 73 6F 66
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 6.
Hexadecimal [16-Bits]



        74
   E100 0D 00 00            267         .db CR,0,0
                            268 
   E103 4D 65 6D 6F 72 79   269 MEMMSG: .ascii      "Memory size"
        20 73 69 7A 65
   E10E 00                  270         .db 0
                            271 
                            272 ; FUNCTION ADDRESS TABLE
                            273 
   E10F 24 F8               274 FNCTAB: .dw      SGN
   E111 E8 F8               275         .dw      INT
   E113 3A F8               276         .dw      ABS
   E115 03 10               277         .dw      USR
   E117 D2 F0               278         .dw      FRE
   E119 43 F4               279         .dw      INP
   E11B 00 F1               280         .dw      POS
   E11D AE FA               281         .dw      SQR
   E11F 8D FB               282         .dw      RND
   E121 C9 F6               283         .dw      LOG
   E123 FC FA               284         .dw      EXP
   E125 02 FC               285         .dw      COS
   E127 08 FC               286         .dw      SIN
   E129 69 FC               287         .dw      TAN
   E12B 7E FC               288         .dw      ATN
   E12D A5 F5               289         .dw      PEEK
   E12F BE FD               290         .dw      DEEK
   E131 51 10               291         .dw      POINT
   E133 84 F3               292         .dw      LEN
   E135 9C F1               293         .dw      STR
   E137 1E F4               294         .dw      VAL
   E139 93 F3               295         .dw      ASC
   E13B 0D 00               296         .dw      CR
   E13D B4 F3               297         .dw      LEFT
   E13F E4 F3               298         .dw      RIGHT
   E141 EE F3               299         .dw      MID
                            300 
                            301 ; RESERVED WORD LIST
                            302 
   E143 C5 4E 44            303 WORDS:  .db      "E"+0x80,"N","D"
   E146 C6 4F 52            304         .db      "F"+0x80,"O","R"
   E149 CE 45 58 54         305         .db      "N"+0x80,"E","X","T"
   E14D C4 41 54 41         306         .db      "D"+0x80,"A","T","A"
   E151 C9 4E 50 55 54      307         .db      "I"+0x80,"N","P","U","T"
   E156 C4 49 4D            308         .db      "D"+0x80,"I","M"
   E159 D2 45 41 44         309         .db      "R"+0x80,"E","A","D"
   E15D CC 45 54            310         .db      "L"+0x80,"E","T"
   E160 C7 4F 54 4F         311         .db      "G"+0x80,"O","T","O"
   E164 D2 55 4E            312         .db      "R"+0x80,"U","N"
   E167 C9 46               313         .db      "I"+0x80,"F"
   E169 D2 45 53 54 4F 52   314         .db      "R"+0x80,"E","S","T","O","R","E"
        45
   E170 C7 4F 53 55 42      315         .db      "G"+0x80,"O","S","U","B"
   E175 D2 45 54 55 52 4E   316         .db      "R"+0x80,"E","T","U","R","N"
   E17B D2 45 4D            317         .db      "R"+0x80,"E","M"
   E17E D3 54 4F 50         318         .db      "S"+0x80,"T","O","P"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 7.
Hexadecimal [16-Bits]



   E182 CF 55 54            319         .db      "O"+0x80,"U","T"
   E185 CF 4E               320         .db      "O"+0x80,"N"
   E187 CE 55 4C 4C         321         .db      "N"+0x80,"U","L","L"
   E18B D7 41 49 54         322         .db      "W"+0x80,"A","I","T"
   E18F C4 45 46            323         .db      "D"+0x80,"E","F"
   E192 D0 4F 4B 45         324         .db      "P"+0x80,"O","K","E"
   E196 C4 4F 4B 45         325         .db      "D"+0x80,"O","K","E"
   E19A D3 43 52 45 45 4E   326         .db      "S"+0x80,"C","R","E","E","N"
   E1A0 CC 49 4E 45 53      327         .db      "L"+0x80,"I","N","E","S"
   E1A5 C3 4C 53            328         .db      "C"+0x80,"L","S"
   E1A8 D7 49 44 54 48      329         .db      "W"+0x80,"I","D","T","H"
   E1AD CD 4F 4E 49 54 4F   330         .db      "M"+0x80,"O","N","I","T","O","R"
        52
   E1B4 D3 45 54            331         .db      "S"+0x80,"E","T"
   E1B7 D2 45 53 45 54      332         .db      "R"+0x80,"E","S","E","T"
   E1BC D0 52 49 4E 54      333         .db      "P"+0x80,"R","I","N","T"
   E1C1 C3 4F 4E 54         334         .db      "C"+0x80,"O","N","T"
   E1C5 CC 49 53 54         335         .db      "L"+0x80,"I","S","T"
   E1C9 C3 4C 45 41 52      336         .db      "C"+0x80,"L","E","A","R"
   E1CE C3 4C 4F 41 44      337         .db      "C"+0x80,"L","O","A","D"
   E1D3 C3 53 41 56 45      338         .db      "C"+0x80,"S","A","V","E"
   E1D8 CE 45 57            339         .db      "N"+0x80,"E","W"
   E1DB D4 41 42 28         340         .db      "T"+0x80,"A","B","("
   E1DF D4 4F               341         .db      "T"+0x80,"O"
   E1E1 C6 4E               342         .db      "F"+0x80,"N"
   E1E3 D3 50 43 28         343         .db      "S"+0x80,"P","C","("
   E1E7 D4 48 45 4E         344         .db      "T"+0x80,"H","E","N"
   E1EB CE 4F 54            345         .db      "N"+0x80,"O","T"
   E1EE D3 54 45 50         346         .db      "S"+0x80,"T","E","P"
                            347 
   E1F2 AB                  348         .db      "+"+0x80
   E1F3 AD                  349         .db      "-"+0x80
   E1F4 AA                  350         .db      "*"+0x80
   E1F5 AF                  351         .db      "/"+0x80
   E1F6 DE                  352         .db      "^"+0x80
   E1F7 C1 4E 44            353         .db      "A"+0x80,"N","D"
   E1FA CF 52               354         .db      "O"+0x80,"R"
   E1FC BE                  355         .db      ">"+0x80
   E1FD BD                  356         .db      "="+0x80
   E1FE BC                  357         .db      "<"+0x80
                            358 
   E1FF D3 47 4E            359         .db      "S"+0x80,"G","N"
   E202 C9 4E 54            360         .db      "I"+0x80,"N","T"
   E205 C1 42 53            361         .db      "A"+0x80,"B","S"
   E208 D5 53 52            362         .db      "U"+0x80,"S","R"
   E20B C6 52 45            363         .db      "F"+0x80,"R","E"
   E20E C9 4E 50            364         .db      "I"+0x80,"N","P"
   E211 D0 4F 53            365         .db      "P"+0x80,"O","S"
   E214 D3 51 52            366         .db      "S"+0x80,"Q","R"
   E217 D2 4E 44            367         .db      "R"+0x80,"N","D"
   E21A CC 4F 47            368         .db      "L"+0x80,"O","G"
   E21D C5 58 50            369         .db      "E"+0x80,"X","P"
   E220 C3 4F 53            370         .db      "C"+0x80,"O","S"
   E223 D3 49 4E            371         .db      "S"+0x80,"I","N"
   E226 D4 41 4E            372         .db      "T"+0x80,"A","N"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 8.
Hexadecimal [16-Bits]



   E229 C1 54 4E            373         .db      "A"+0x80,"T","N"
   E22C D0 45 45 4B         374         .db      "P"+0x80,"E","E","K"
   E230 C4 45 45 4B         375         .db      "D"+0x80,"E","E","K"
   E234 D0 4F 49 4E 54      376         .db      "P"+0x80,"O","I","N","T"
   E239 CC 45 4E            377         .db      "L"+0x80,"E","N"
   E23C D3 54 52 24         378         .db      "S"+0x80,"T","R","$"
   E240 D6 41 4C            379         .db      "V"+0x80,"A","L"
   E243 C1 53 43            380         .db      "A"+0x80,"S","C"
   E246 C3 48 52 24         381         .db      "C"+0x80,"H","R","$"
   E24A CC 45 46 54 24      382         .db      "L"+0x80,"E","F","T","$"
   E24F D2 49 47 48 54 24   383         .db      "R"+0x80,"I","G","H","T","$"
   E255 CD 49 44 24         384         .db      "M"+0x80,"I","D","$"
   E259 80                  385         .db      0x80             ; End of list marker
                            386 
                            387 ; KEYWORD ADDRESS TABLE
                            388 
   E25A 74 E8               389 WORDTB: .dw      PEND
   E25C 7B E7               390         .dw      FOR
   E25E F8 EC               391         .dw      NEXT
   E260 72 EA               392         .dw      DATA
   E262 FF EB               393         .dw      INPUT
   E264 2A EF               394         .dw      DIM
   E266 2E EC               395         .dw      READ
   E268 89 EA               396         .dw      LET
   E26A 2F EA               397         .dw      GOTO
   E26C 12 EA               398         .dw      RUN
   E26E 01 EB               399         .dw      IF
   E270 48 E8               400         .dw      RESTOR
   E272 1E EA               401         .dw      GOSUB
   E274 4D EA               402         .dw      RETURN
   E276 74 EA               403         .dw      REM
   E278 72 E8               404         .dw      STOP
   E27A 4F F4               405         .dw      POUT
   E27C E3 EA               406         .dw      ON
   E27E B3 E8               407         .dw      NULL
   E280 55 F4               408         .dw      WAIT
   E282 08 F1               409         .dw      DEF
   E284 AC F5               410         .dw      POKE
   E286 C9 FD               411         .dw      DOKE
   E288 E8 FD               412         .dw      SCREEN
   E28A AF FD               413         .dw      LINES
   E28C 8D FD               414         .dw      CLS
   E28E A7 FD               415         .dw      WIDTH
   E290 A4 FE               416         .dw      MONITR
   E292 54 10               417         .dw      PSET
   E294 57 10               418         .dw      RESET
   E296 25 EB               419         .dw      PRINT
   E298 A0 E8               420         .dw      CONT
   E29A DF E6               421         .dw      LIST
   E29C CC E9               422         .dw      CLEAR
   E29E FB F4               423         .dw      CLOAD
   E2A0 C5 F4               424         .dw      CSAVE
   E2A2 BB E4               425         .dw      NEW
                            426 
                            427 ; RESERVED WORD TOKEN VALUES
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 9.
Hexadecimal [16-Bits]



                            428 
                     0080   429 ZEND    .equ     0x080            ; END
                     0081   430 ZFOR    .equ     0x081            ; FOR
                     0083   431 ZDATA   .equ     0x083            ; DATA
                     0088   432 ZGOTO   .equ     0x088            ; GOTO
                     008C   433 ZGOSUB  .equ     0x08C            ; GOSUB
                     008E   434 ZREM    .equ     0x08E            ; REM
                     009E   435 ZPRINT  .equ     0x09E            ; PRINT
                     00A4   436 ZNEW    .equ     0x0A4            ; NEW
                            437 
                     00A5   438 ZTAB    .equ     0x0A5            ; TAB
                     00A6   439 ZTO     .equ     0x0A6            ; TO
                     00A7   440 ZFN     .equ     0x0A7            ; FN
                     00A8   441 ZSPC    .equ     0x0A8            ; SPC
                     00A9   442 ZTHEN   .equ     0x0A9            ; THEN
                     00AA   443 ZNOT    .equ     0x0AA            ; NOT
                     00AB   444 ZSTEP   .equ     0x0AB            ; STEP
                            445 
                     00AC   446 ZPLUS   .equ     0x0AC            ; +
                     00AD   447 ZMINUS  .equ     0x0AD            ; -
                     00AE   448 ZTIMES  .equ     0x0AE            ; *
                     00AF   449 ZDIV    .equ     0x0AF            ; /
                     00B2   450 ZOR     .equ     0x0B2            ; OR
                     00B3   451 ZGTR    .equ     0x0B3            ; >
                     00B4   452 ZEQUAL  .equ     0x0B4            ; M
                     00B5   453 ZLTH    .equ     0x0B5            ; <
                     00B6   454 ZSGN    .equ     0x0B6            ; SGN
                     00C7   455 ZPOINT  .equ     0x0C7            ; POINT
                     00CD   456 ZLEFT   .equ     0x0CD            ; LEFT$
                            457 
                            458 ; ARITHMETIC PRECEDENCE TABLE
                            459 
   E2A4 79                  460 PRITAB: .db      0x79             ; Precedence value
   E2A5 96 F9               461         .dw      PADD            ; FPREG = <last> + FPREG
                            462 
   E2A7 79                  463         .db      0x79             ; Precedence value
   E2A8 CA F5               464         .dw      PSUB            ; FPREG = <last> - FPREG
                            465 
   E2AA 7C                  466         .db      0x7C             ; Precedence value
   E2AB 08 F7               467         .dw      MULT            ; PPREG = <last> * FPREG
                            468 
   E2AD 7C                  469         .db      0x7C             ; Precedence value
   E2AE 69 F7               470         .dw      DIV             ; FPREG = <last> / FPREG
                            471 
   E2B0 7F                  472         .db      0x7F             ; Precedence value
   E2B1 B7 FA               473         .dw      POWER           ; FPREG = <last> ^ FPREG
                            474 
   E2B3 50                  475         .db      0x50             ; Precedence value
   E2B4 83 EE               476         .dw      PAND            ; FPREG = <last> AND FPREG
                            477 
   E2B6 46                  478         .db      0x46             ; Precedence value
   E2B7 82 EE               479         .dw      POR             ; FPREG = <last> OR FPREG
                            480 
                            481 ; BASIC ERROR CODE LIST
                            482 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 10.
Hexadecimal [16-Bits]



   E2B9 4E 46               483 ERRORS: .db      "N","F"            ; NEXT without FOR
   E2BB 53 4E               484         .db      "S","N"            ; Syntax error
   E2BD 52 47               485         .db      "R","G"            ; RETURN without GOSUB
   E2BF 4F 44               486         .db      "O","D"            ; Out of DATA
   E2C1 46 43               487         .db      "F","C"            ; Illegal function call
   E2C3 4F 56               488         .db      "O","V"            ; Overflow error
   E2C5 4F 4D               489         .db      "O","M"            ; Out of memory
   E2C7 55 4C               490         .db      "U","L"            ; Undefined line
   E2C9 42 53               491         .db      "B","S"            ; Bad subscript
   E2CB 44 44               492         .db      "D","D"            ; Re-DIMensioned array
   E2CD 2F 30               493         .db      "/","0"            ; Division by zero
   E2CF 49 44               494         .db      "I","D"            ; Illegal direct
   E2D1 54 4D               495         .db      "T","M"            ; Type mis-match
   E2D3 4F 53               496         .db      "O","S"            ; Out of string space
   E2D5 4C 53               497         .db      "L","S"            ; String too long
   E2D7 53 54               498         .db      "S","T"            ; String formula too complex
   E2D9 43 4E               499         .db      "C","N"            ; Can't CONTinue
   E2DB 55 46               500         .db      "U","F"            ; Undefined FN function
   E2DD 4D 4F               501         .db      "M","O"            ; Missing operand
                            502 
                            503 ; INITIALISATION TABLE
                            504 
   E2DF C3 AE E0      [ 9]  505 INITAB: JP      WARMST          ; Warm start jump
   E2E2 C3 A2 E9      [ 9]  506         JP      FCERR           ; "USR (X)" jump (Set to Error)
                            507 
   E2E5 D3 00         [10]  508         OUT     (0),A           ; "OUT p,n" skeleton
   E2E7 C9            [ 9]  509         RET
                            510 
   E2E8 D6 00         [ 6]  511         SUB     #0               ; Division support routine
   E2EA 6F            [ 4]  512         LD      L,A
   E2EB 7C            [ 4]  513         LD      A,H
   E2EC DE 00         [ 6]  514         SBC     A,#0
   E2EE 67            [ 4]  515         LD      H,A
   E2EF 78            [ 4]  516         LD      A,B
   E2F0 DE 00         [ 6]  517         SBC     A,#0
   E2F2 47            [ 4]  518         LD      B,A
   E2F3 3E 00         [ 6]  519         LD      A,#0
   E2F5 C9            [ 9]  520         RET
                            521 
   E2F6 00 00 00            522         .db      0,0,0                   ; Random number seed
                            523                                         ; Table used by RND
   E2F9 35 4A CA 99         524         .db      0x35,0x4A,0xCA,0x99     ;-2.65145E+07
   E2FD 39 1C 76 98         525         .db      0x39,0x1C,0x76,0x98     ; 1.61291E+07
   E301 22 95 B3 98         526         .db      0x22,0x95,0xB3,0x98     ;-1.17691E+07
   E305 0A DD 47 98         527         .db      0x0A,0xDD,0x47,0x98     ; 1.30983E+07
   E309 53 D1 99 99         528         .db      0x53,0xD1,0x99,0x99     ;-2-01612E+07
   E30D 0A 1A 9F 98         529         .db      0x0A,0x1A,0x9F,0x98     ;-1.04269E+07
   E311 65 BC CD 98         530         .db      0x65,0xBC,0xCD,0x98     ;-1.34831E+07
   E315 D6 77 3E 98         531         .db      0xD6,0x77,0x3E,0x98     ; 1.24825E+07
   E319 52 C7 4F 80         532         .db      0x52,0xC7,0x4F,0x80     ; Last random number
                            533 
   E31D DB 00         [ 9]  534         IN      A,(0)           ; INP (x) skeleton
   E31F C9            [ 9]  535         RET
                            536 
   E320 01                  537         .db      1               ; POS (x) number (1)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 11.
Hexadecimal [16-Bits]



   E321 2F                  538         .db      47              ; Terminal width (47)
   E322 1C                  539         .db      28              ; Width for commas (3 columns)
   E323 00                  540         .db      0               ; No nulls after input bytes
   E324 00                  541         .db      0               ; Output enabled (^O off)
                            542 
   E325 05 00               543         .dw      5               ; Initial lines counter
   E327 05 00               544         .dw      5               ; Initial lines number
   E329 00 00               545         .dw      0               ; Array load/save check sum
                            546 
   E32B 00                  547         .db      0               ; Break not by NMI
   E32C 00                  548         .db      0               ; Break flag
                            549 
   E32D C3 09 E6      [ 9]  550         JP      TTYLIN          ; Input reflection (set to TTY)
   E330 C3 7B FF      [ 9]  551         JP      POINTB          ; POINT reflection unused
   E333 C3 42 FF      [ 9]  552         JP      SETB            ; SET reflection
   E336 C3 57 FF      [ 9]  553         JP      RESETB          ; RESET reflection
                            554 
   E339 5D 11               555         .dw      STLOOK          ; Temp string space
   E33B FE FF               556         .dw      -2              ; Current line number (cold)
   E33D FA 10               557         .dw      PROGST+1        ; Start of program text
   E33F                     558 INITBE:                         ; END OF INITIALISATION TABLE
                            559 
   E33F 20 45 72 72 6F 72   560 ERRMSG: .ascii      " Error"
   E345 00                  561         .db 0
   E346 20 69 6E 20         562 INMSG:  .ascii      " in "
   E34A 00                  563         .db 0
   E34B 00 00               564 ZERBYT:  .dw     0             ; A zero byte
   E34D 4F 6B               565 OKMSG:  .ascii     "Ok"
   E34F 0D 00 00            566         .db     CR,0,0
   E352 42 72 65 61 6B      567 BRKMSG: .ascii      "Break"
   E357 00                  568         .db 0
                            569 
   E358 21 04 00      [ 9]  570 BAKSTK: LD      HL,#4            ; Look for "FOR" block with
   E35B 39            [ 7]  571         ADD     HL,SP           ; same index as specified
   E35C 7E            [ 6]  572 LOKFOR: LD      A,(HL)          ; Get block ID
   E35D 23            [ 4]  573         INC     HL              ; Point to index address
   E35E FE 81         [ 6]  574         CP      #ZFOR            ; Is it a "FOR" token
   E360 C0            [10]  575         RET     NZ              ; No - exit
   E361 4E            [ 6]  576         LD      C,(HL)          ; BC = Address of "FOR" index
   E362 23            [ 4]  577         INC     HL
   E363 46            [ 6]  578         LD      B,(HL)
   E364 23            [ 4]  579         INC     HL              ; Point to sign of STEP
   E365 E5            [11]  580         PUSH    HL              ; Save pointer to sign
   E366 69            [ 4]  581         LD      L,C             ; HL = address of "FOR" index
   E367 60            [ 4]  582         LD      H,B
   E368 7A            [ 4]  583         LD      A,D             ; See if an index was specified
   E369 B3            [ 4]  584         OR      E               ; DE = 0 if no index specified
   E36A EB            [ 3]  585         EX      DE,HL           ; Specified index into HL
   E36B CA 72 E3      [ 9]  586         JP      Z,INDFND        ; Skip if no index given
   E36E EB            [ 3]  587         EX      DE,HL           ; Index back into DE
   E36F CD 8C E6      [16]  588         CALL    CPDEHL          ; Compare index with one given
   E372 01 0D 00      [ 9]  589 INDFND: LD      BC,#16-3         ; Offset to next block
   E375 E1            [ 9]  590         POP     HL              ; Restore pointer to sign
   E376 C8            [10]  591         RET     Z               ; Return if block found
   E377 09            [ 7]  592         ADD     HL,BC           ; Point to next block
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 12.
Hexadecimal [16-Bits]



   E378 C3 5C E3      [ 9]  593         JP      LOKFOR          ; Keep on looking
                            594 
   E37B CD 95 E3      [16]  595 MOVUP:  CALL    ENFMEM          ; See if enough memory
   E37E C5            [11]  596 MOVSTR: PUSH    BC              ; Save end of source
   E37F E3            [16]  597         EX      (SP),HL         ; Swap source and dest" end
   E380 C1            [ 9]  598         POP     BC              ; Get end of destination
   E381 CD 8C E6      [16]  599 MOVLP:  CALL    CPDEHL          ; See if list moved
   E384 7E            [ 6]  600         LD      A,(HL)          ; Get byte
   E385 02            [ 7]  601         LD      (BC),A          ; Move it
   E386 C8            [10]  602         RET     Z               ; Exit if all done
   E387 0B            [ 4]  603         DEC     BC              ; Next byte to move to
   E388 2B            [ 4]  604         DEC     HL              ; Next byte to move
   E389 C3 81 E3      [ 9]  605         JP      MOVLP           ; Loop until all bytes moved
                            606 
   E38C E5            [11]  607 CHKSTK: PUSH    HL              ; Save code string address
   E38D 2A DA 10      [15]  608         LD      HL,(ARREND)     ; Lowest free memory
   E390 06 00         [ 6]  609         LD      B,#0             ; BC = Number of levels to test
   E392 09            [ 7]  610         ADD     HL,BC           ; 2 Bytes for each level
   E393 09            [ 7]  611         ADD     HL,BC
   E394 3E                  612         .db      0x3E             ; Skip "PUSH HL"
   E395 E5            [11]  613 ENFMEM: PUSH    HL              ; Save code string address
   E396 3E D0         [ 6]  614         LD      A,#-48   ;TODO   ; 48 Bytes minimum RAM
   E398 95            [ 4]  615         SUB     L
   E399 6F            [ 4]  616         LD      L,A
   E39A 3E D0         [ 6]  617         LD      A,#-48   ;TODO   ; 48 Bytes minimum RAM
   E39C 9C            [ 4]  618         SBC     A,H
   E39D DA A4 E3      [ 9]  619         JP      C,OMERR         ; Not enough - ?OM Error
   E3A0 67            [ 4]  620         LD      H,A
   E3A1 39            [ 7]  621         ADD     HL,SP           ; Test if stack is overflowed
   E3A2 E1            [ 9]  622         POP     HL              ; Restore code string address
   E3A3 D8            [10]  623         RET     C               ; Return if enough mmory
   E3A4 1E 0C         [ 6]  624 OMERR:  LD      E,#OM            ; ?OM Error
   E3A6 C3 C3 E3      [ 9]  625         JP      ERROR
                            626 
   E3A9 2A C9 10      [15]  627 DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
   E3AC 22 5C 10      [16]  628         LD      (LINEAT),HL     ; Save as current line
   E3AF 1E 02         [ 6]  629 SNERR:  LD      E,#SN            ; ?SN Error
   E3B1 01                  630         .db      0x01             ; Skip "LD E,DZ"
   E3B2 1E 14         [ 6]  631 DZERR:  LD      E,#DZ            ; ?/0 Error
   E3B4 01                  632         .db      0x01             ; Skip "LD E,NF"
   E3B5 1E 00         [ 6]  633 NFERR:  LD      E,#NF            ; ?NF Error
   E3B7 01                  634         .db      0x01             ; Skip "LD E,DD"
   E3B8 1E 12         [ 6]  635 DDERR:  LD      E,#DD            ; ?DD Error
   E3BA 01                  636         .db      0x01             ; Skip "LD E,UF"
   E3BB 1E 22         [ 6]  637 UFERR:  LD      E,#UF            ; ?UF Error
   E3BD 01                  638         .db      0x01             ; Skip "LD E,OV
   E3BE 1E 0A         [ 6]  639 OVERR:  LD      E,#OV            ; ?OV Error
   E3C0 01                  640         .db      0x01             ; Skip "LD E,TM"
   E3C1 1E 18         [ 6]  641 TMERR:  LD      E,#TM            ; ?TM Error
                            642 
   E3C3 CD E1 E4      [16]  643 ERROR:  CALL    CLREG           ; Clear registers and stack
   E3C6 32 45 10      [13]  644         LD      (CTLOFG),A      ; Enable output (A is 0)
   E3C9 CD 76 EB      [16]  645         CALL    STTLIN          ; Start new line
   E3CC 21 B9 E2      [ 9]  646         LD      HL,#ERRORS       ; Point to error codes
   E3CF 57            [ 4]  647         LD      D,A             ; D = 0 (A is 0)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 13.
Hexadecimal [16-Bits]



   E3D0 3E 3F         [ 6]  648         LD      A,#"?"
   E3D2 CD 9D E6      [16]  649         CALL    OUTC            ; Output "?"
   E3D5 19            [ 7]  650         ADD     HL,DE           ; Offset to correct error code
   E3D6 7E            [ 6]  651         LD      A,(HL)          ; First character
   E3D7 CD 9D E6      [16]  652         CALL    OUTC            ; Output it
   E3DA CD 38 E8      [16]  653         CALL    GETCHR          ; Get next character
   E3DD CD 9D E6      [16]  654         CALL    OUTC            ; Output it
   E3E0 21 3F E3      [ 9]  655         LD      HL,#ERRMSG       ; "Error" message
   E3E3 CD 12 F2      [16]  656 ERRIN:  CALL    PRS             ; Output message
   E3E6 2A 5C 10      [15]  657         LD      HL,(LINEAT)     ; Get line of error
   E3E9 11 FE FF      [ 9]  658         LD      DE,#-2           ; Cold start error if -2
   E3EC CD 8C E6      [16]  659         CALL    CPDEHL          ; See if cold start error
   E3EF CA 12 E0      [ 9]  660         JP      Z,CSTART        ; Cold start error - Restart
   E3F2 7C            [ 4]  661         LD      A,H             ; Was it a direct error?
   E3F3 A5            [ 4]  662         AND     L               ; Line = -1 if direct error
   E3F4 3C            [ 4]  663         INC     A
   E3F5 C4 A7 F9      [16]  664         CALL    NZ,LINEIN       ; No - output line of error
   E3F8 3E                  665         .db      0x3E             ; Skip "POP BC"
   E3F9 C1            [ 9]  666 POPNOK: POP     BC              ; Drop address in input buffer
                            667 
   E3FA AF            [ 4]  668 PRNTOK: XOR     A               ; Output "Ok" and get command
   E3FB 32 45 10      [13]  669         LD      (CTLOFG),A      ; Enable output
   E3FE CD 76 EB      [16]  670         CALL    STTLIN          ; Start new line
   E401 21 4D E3      [ 9]  671         LD      HL,#OKMSG        ; "Ok" message
   E404 CD 12 F2      [16]  672         CALL    PRS             ; Output "Ok"
   E407 21 FF FF      [ 9]  673 GETCMD: LD      HL,#-1           ; Flag direct mode
   E40A 22 5C 10      [16]  674         LD      (LINEAT),HL     ; Save as current line
   E40D CD F4 E5      [16]  675         CALL    GETLIN          ; Get an input line
   E410 DA 07 E4      [ 9]  676         JP      C,GETCMD        ; Get line again if break
   E413 CD 38 E8      [16]  677         CALL    GETCHR          ; Get first character
   E416 3C            [ 4]  678         INC     A               ; Test if end of line
   E417 3D            [ 4]  679         DEC     A               ; Without affecting Carry
   E418 CA 07 E4      [ 9]  680         JP      Z,GETCMD        ; Nothing entered - Get another
   E41B F5            [11]  681         PUSH    AF              ; Save Carry status
   E41C CD A7 E9      [16]  682         CALL    ATOH            ; Get line number into DE
   E41F D5            [11]  683         PUSH    DE              ; Save line number
   E420 CD 0B E5      [16]  684         CALL    CRUN0xC          ; Tokenise rest of line
   E423 47            [ 4]  685         LD      B,A             ; Length of tokenised line
   E424 D1            [ 9]  686         POP     DE              ; Restore line number
   E425 F1            [ 9]  687         POP     AF              ; Restore Carry
   E426 D2 18 E8      [ 9]  688         JP      NC,EXCUTE       ; No line number - Direct mode
   E429 D5            [11]  689         PUSH    DE              ; Save line number
   E42A C5            [11]  690         PUSH    BC              ; Save length of tokenised line
   E42B AF            [ 4]  691         XOR     A
   E42C 32 CC 10      [13]  692         LD      (LSTBIN),A      ; Clear last byte input
   E42F CD 38 E8      [16]  693         CALL    GETCHR          ; Get next character
   E432 B7            [ 4]  694         OR      A               ; Set flags
   E433 F5            [11]  695         PUSH    AF              ; And save them
   E434 CD 9B E4      [16]  696         CALL    SRCHLN          ; Search for line number in DE
   E437 DA 40 E4      [ 9]  697         JP      C,LINFND        ; Jump if line found
   E43A F1            [ 9]  698         POP     AF              ; Get status
   E43B F5            [11]  699         PUSH    AF              ; And re-save
   E43C CA 48 EA      [ 9]  700         JP      Z,ULERR         ; Nothing after number - Error
   E43F B7            [ 4]  701         OR      A               ; Clear Carry
   E440 C5            [11]  702 LINFND: PUSH    BC              ; Save address of line in prog
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 14.
Hexadecimal [16-Bits]



   E441 D2 57 E4      [ 9]  703         JP      NC,INEWLN       ; Line not found - Insert new
   E444 EB            [ 3]  704         EX      DE,HL           ; Next line address in DE
   E445 2A D6 10      [15]  705         LD      HL,(PROGND)     ; End of program
   E448 1A            [ 6]  706 SFTPRG: LD      A,(DE)          ; Shift rest of program down
   E449 02            [ 7]  707         LD      (BC),A
   E44A 03            [ 4]  708         INC     BC              ; Next destination
   E44B 13            [ 4]  709         INC     DE              ; Next source
   E44C CD 8C E6      [16]  710         CALL    CPDEHL          ; All done?
   E44F C2 48 E4      [ 9]  711         JP      NZ,SFTPRG       ; More to do
   E452 60            [ 4]  712         LD      H,B             ; HL - New end of program
   E453 69            [ 4]  713         LD      L,C
   E454 22 D6 10      [16]  714         LD      (PROGND),HL     ; Update end of program
                            715 
   E457 D1            [ 9]  716 INEWLN: POP     DE              ; Get address of line,
   E458 F1            [ 9]  717         POP     AF              ; Get status
   E459 CA 7E E4      [ 9]  718         JP      Z,SETPTR        ; No text - Set up pointers
   E45C 2A D6 10      [15]  719         LD      HL,(PROGND)     ; Get end of program
   E45F E3            [16]  720         EX      (SP),HL         ; Get length of input line
   E460 C1            [ 9]  721         POP     BC              ; End of program to BC
   E461 09            [ 7]  722         ADD     HL,BC           ; Find new end
   E462 E5            [11]  723         PUSH    HL              ; Save new end
   E463 CD 7B E3      [16]  724         CALL    MOVUP           ; Make space for line
   E466 E1            [ 9]  725         POP     HL              ; Restore new end
   E467 22 D6 10      [16]  726         LD      (PROGND),HL     ; Update end of program pointer
   E46A EB            [ 3]  727         EX      DE,HL           ; Get line to move up in HL
   E46B 74            [ 7]  728         LD      (HL),H          ; Save MSB
   E46C D1            [ 9]  729         POP     DE              ; Get new line number
   E46D 23            [ 4]  730         INC     HL              ; Skip pointer
   E46E 23            [ 4]  731         INC     HL
   E46F 73            [ 7]  732         LD      (HL),E          ; Save LSB of line number
   E470 23            [ 4]  733         INC     HL
   E471 72            [ 7]  734         LD      (HL),D          ; Save MSB of line number
   E472 23            [ 4]  735         INC     HL              ; To first byte in line
   E473 11 61 10      [ 9]  736         LD      DE,#BUFFER       ; Copy buffer to program
   E476 1A            [ 6]  737 MOVBUF: LD      A,(DE)          ; Get source
   E477 77            [ 7]  738         LD      (HL),A          ; Save destinations
   E478 23            [ 4]  739         INC     HL              ; Next source
   E479 13            [ 4]  740         INC     DE              ; Next destination
   E47A B7            [ 4]  741         OR      A               ; Done?
   E47B C2 76 E4      [ 9]  742         JP      NZ,MOVBUF       ; No - Repeat
   E47E CD C7 E4      [16]  743 SETPTR: CALL    RUNFST          ; Set line pointers
   E481 23            [ 4]  744         INC     HL              ; To LSB of pointer
   E482 EB            [ 3]  745         EX      DE,HL           ; Address to DE
   E483 62            [ 4]  746 PTRLP:  LD      H,D             ; Address to HL
   E484 6B            [ 4]  747         LD      L,E
   E485 7E            [ 6]  748         LD      A,(HL)          ; Get LSB of pointer
   E486 23            [ 4]  749         INC     HL              ; To MSB of pointer
   E487 B6            [ 6]  750         OR      (HL)            ; Compare with MSB pointer
   E488 CA 07 E4      [ 9]  751         JP      Z,GETCMD        ; Get command line if end
   E48B 23            [ 4]  752         INC     HL              ; To LSB of line number
   E48C 23            [ 4]  753         INC     HL              ; Skip line number
   E48D 23            [ 4]  754         INC     HL              ; Point to first byte in line
   E48E AF            [ 4]  755         XOR     A               ; Looking for 00 byte
   E48F BE            [ 6]  756 FNDEND: CP      (HL)            ; Found end of line?
   E490 23            [ 4]  757         INC     HL              ; Move to next byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 15.
Hexadecimal [16-Bits]



   E491 C2 8F E4      [ 9]  758         JP      NZ,FNDEND       ; No - Keep looking
   E494 EB            [ 3]  759         EX      DE,HL           ; Next line address to HL
   E495 73            [ 7]  760         LD      (HL),E          ; Save LSB of pointer
   E496 23            [ 4]  761         INC     HL
   E497 72            [ 7]  762         LD      (HL),D          ; Save MSB of pointer
   E498 C3 83 E4      [ 9]  763         JP      PTRLP           ; Do next line
                            764 
   E49B 2A 5E 10      [15]  765 SRCHLN: LD      HL,(BASTXT)     ; Start of program text
   E49E 44            [ 4]  766 SRCHLP: LD      B,H             ; BC = Address to look at
   E49F 4D            [ 4]  767         LD      C,L
   E4A0 7E            [ 6]  768         LD      A,(HL)          ; Get address of next line
   E4A1 23            [ 4]  769         INC     HL
   E4A2 B6            [ 6]  770         OR      (HL)            ; End of program found?
   E4A3 2B            [ 4]  771         DEC     HL
   E4A4 C8            [10]  772         RET     Z               ; Yes - Line not found
   E4A5 23            [ 4]  773         INC     HL
   E4A6 23            [ 4]  774         INC     HL
   E4A7 7E            [ 6]  775         LD      A,(HL)          ; Get LSB of line number
   E4A8 23            [ 4]  776         INC     HL
   E4A9 66            [ 6]  777         LD      H,(HL)          ; Get MSB of line number
   E4AA 6F            [ 4]  778         LD      L,A
   E4AB CD 8C E6      [16]  779         CALL    CPDEHL          ; Compare with line in DE
   E4AE 60            [ 4]  780         LD      H,B             ; HL = Start of this line
   E4AF 69            [ 4]  781         LD      L,C
   E4B0 7E            [ 6]  782         LD      A,(HL)          ; Get LSB of next line address
   E4B1 23            [ 4]  783         INC     HL
   E4B2 66            [ 6]  784         LD      H,(HL)          ; Get MSB of next line address
   E4B3 6F            [ 4]  785         LD      L,A             ; Next line to HL
   E4B4 3F            [ 3]  786         CCF
   E4B5 C8            [10]  787         RET     Z               ; Lines found - Exit
   E4B6 3F            [ 3]  788         CCF
   E4B7 D0            [10]  789         RET     NC              ; Line not found,at line after
   E4B8 C3 9E E4      [ 9]  790         JP      SRCHLP          ; Keep looking
                            791 
   E4BB C0            [10]  792 NEW:    RET     NZ              ; Return if any more on line
   E4BC 2A 5E 10      [15]  793 CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
   E4BF AF            [ 4]  794         XOR     A               ; Set program area to empty
   E4C0 77            [ 7]  795         LD      (HL),A          ; Save LSB = 00
   E4C1 23            [ 4]  796         INC     HL
   E4C2 77            [ 7]  797         LD      (HL),A          ; Save MSB = 00
   E4C3 23            [ 4]  798         INC     HL
   E4C4 22 D6 10      [16]  799         LD      (PROGND),HL     ; Set program end
                            800 
   E4C7 2A 5E 10      [15]  801 RUNFST: LD      HL,(BASTXT)     ; Clear all variables
   E4CA 2B            [ 4]  802         DEC     HL
                            803 
   E4CB 22 CE 10      [16]  804 INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
   E4CE 2A AF 10      [15]  805         LD      HL,(LSTRAM)     ; Get end of RAM
   E4D1 22 C3 10      [16]  806         LD      (STRBOT),HL     ; Clear string space
   E4D4 AF            [ 4]  807         XOR     A
   E4D5 CD 48 E8      [16]  808         CALL    RESTOR          ; Reset DATA pointers
   E4D8 2A D6 10      [15]  809         LD      HL,(PROGND)     ; Get end of program
   E4DB 22 D8 10      [16]  810         LD      (VAREND),HL     ; Clear variables
   E4DE 22 DA 10      [16]  811         LD      (ARREND),HL     ; Clear arrays
                            812 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 16.
Hexadecimal [16-Bits]



   E4E1 C1            [ 9]  813 CLREG:  POP     BC              ; Save return address
   E4E2 2A 5A 10      [15]  814         LD      HL,(STRSPC)     ; Get end of working RAN
   E4E5 F9            [ 4]  815         LD      SP,HL           ; Set stack
   E4E6 21 B3 10      [ 9]  816         LD      HL,#TMSTPL       ; Temporary string pool
   E4E9 22 B1 10      [16]  817         LD      (TMSTPT),HL     ; Reset temporary string ptr
   E4EC AF            [ 4]  818         XOR     A               ; A = 00
   E4ED 6F            [ 4]  819         LD      L,A             ; HL = 0000
   E4EE 67            [ 4]  820         LD      H,A
   E4EF 22 D4 10      [16]  821         LD      (CONTAD),HL     ; No CONTinue
   E4F2 32 CB 10      [13]  822         LD      (FORFLG),A      ; Clear FOR flag
   E4F5 22 DE 10      [16]  823         LD      (FNRGNM),HL     ; Clear FN argument
   E4F8 E5            [11]  824         PUSH    HL              ; HL = 0000
   E4F9 C5            [11]  825         PUSH    BC              ; Put back return
   E4FA 2A CE 10      [15]  826 DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
   E4FD C9            [ 9]  827         RET                     ; Return to execution driver
                            828 
   E4FE 3E 3F         [ 6]  829 PROMPT: LD      A,#"?"           ; "?"
   E500 CD 9D E6      [16]  830         CALL    OUTC            ; Output character
   E503 3E 20         [ 6]  831         LD      A,#" "           ; Space
   E505 CD 9D E6      [16]  832         CALL    OUTC            ; Output character
   E508 C3 4E 10      [ 9]  833         JP      RINPUT          ; Get input line
                            834 
   E50B AF            [ 4]  835 CRUN0xC: XOR     A               ; Tokenise line @ HL to BUFFER
   E50C 32 AE 10      [13]  836         LD      (DATFLG),A      ; Reset literal flag
   E50F 0E 05         [ 6]  837         LD      C,#2+3           ; 2 byte number and 3 nulls
   E511 11 61 10      [ 9]  838         LD      DE,#BUFFER       ; Start of input buffer
   E514 7E            [ 6]  839 CRNCLP: LD      A,(HL)          ; Get byte
   E515 FE 20         [ 6]  840         CP      #" "             ; Is it a space?
   E517 CA 93 E5      [ 9]  841         JP      Z,MOVDIR        ; Yes - Copy direct
   E51A 47            [ 4]  842         LD      B,A             ; Save character
   E51B FE 22         [ 6]  843         CP      #'"'             ; Is it a quote?"
   E51D CA B3 E5      [ 9]  844         JP      Z,CPYLIT        ; Yes - Copy literal string
   E520 B7            [ 4]  845         OR      A               ; Is it end of buffer?
   E521 CA BA E5      [ 9]  846         JP      Z,ENDBUF        ; Yes - End buffer
   E524 3A AE 10      [12]  847         LD      A,(DATFLG)      ; Get data type
   E527 B7            [ 4]  848         OR      A               ; Literal?
   E528 7E            [ 6]  849         LD      A,(HL)          ; Get byte to copy
   E529 C2 93 E5      [ 9]  850         JP      NZ,MOVDIR       ; Literal - Copy direct
   E52C FE 3F         [ 6]  851         CP      #"?"             ; Is it "?" short for PRINT
   E52E 3E 9E         [ 6]  852         LD      A,#ZPRINT        ; "PRINT" token
   E530 CA 93 E5      [ 9]  853         JP      Z,MOVDIR        ; Yes - replace it
   E533 7E            [ 6]  854         LD      A,(HL)          ; Get byte again
   E534 FE 30         [ 6]  855         CP      #"0"             ; Is it less than "0"
   E536 DA 3E E5      [ 9]  856         JP      C,FNDWRD        ; Yes - Look for reserved words
   E539 FE 3C         [ 6]  857         CP      #";"+1           ; Is it "0123456789:;" ?
   E53B DA 93 E5      [ 9]  858         JP      C,MOVDIR        ; Yes - copy it direct
   E53E D5            [11]  859 FNDWRD: PUSH    DE              ; Look for reserved words
   E53F 11 42 E1      [ 9]  860         LD      DE,#WORDS-1      ; Point to table
   E542 C5            [11]  861         PUSH    BC              ; Save count
   E543 01 8F E5      [ 9]  862         LD      BC,#RETNAD       ; Where to return to
   E546 C5            [11]  863         PUSH    BC              ; Save return address
   E547 06 7F         [ 6]  864         LD      B,#ZEND-1        ; First token value -1
   E549 7E            [ 6]  865         LD      A,(HL)          ; Get byte
   E54A FE 61         [ 6]  866         CP      #"a"             ; Less than "a" ?
   E54C DA 57 E5      [ 9]  867         JP      C,SEARCH        ; Yes - search for words
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 17.
Hexadecimal [16-Bits]



   E54F FE 7B         [ 6]  868         CP      #"z"+1           ; Greater than "z" ?
   E551 D2 57 E5      [ 9]  869         JP      NC,SEARCH       ; Yes - search for words
   E554 E6 5F         [ 6]  870         AND     #0b01011111       ; Force upper case
   E556 77            [ 7]  871         LD      (HL),A          ; Replace byte
   E557 4E            [ 6]  872 SEARCH: LD      C,(HL)          ; Search for a word
   E558 EB            [ 3]  873         EX      DE,HL
   E559 23            [ 4]  874 GETNXT: INC     HL              ; Get next reserved word
   E55A B6            [ 6]  875         OR      (HL)            ; Start of word?
   E55B F2 59 E5      [ 9]  876         JP      P,GETNXT        ; No - move on
   E55E 04            [ 4]  877         INC     B               ; Increment token value
   E55F 7E            [ 6]  878         LD      A, (HL)         ; Get byte from table
   E560 E6 7F         [ 6]  879         AND     #0b01111111       ; Strip bit 7
   E562 C8            [10]  880         RET     Z               ; Return if end of list
   E563 B9            [ 4]  881         CP      C               ; Same character as in buffer?
   E564 C2 59 E5      [ 9]  882         JP      NZ,GETNXT       ; No - get next word
   E567 EB            [ 3]  883         EX      DE,HL
   E568 E5            [11]  884         PUSH    HL              ; Save start of word
                            885 
   E569 13            [ 4]  886 NXTBYT: INC     DE              ; Look through rest of word
   E56A 1A            [ 6]  887         LD      A,(DE)          ; Get byte from table
   E56B B7            [ 4]  888         OR      A               ; End of word ?
   E56C FA 8B E5      [ 9]  889         JP      M,#MATCH         ; Yes - Match found
   E56F 4F            [ 4]  890         LD      C,A             ; Save it
   E570 78            [ 4]  891         LD      A,B             ; Get token value
   E571 FE 88         [ 6]  892         CP      #ZGOTO           ; Is it "GOTO" token ?
   E573 C2 7A E5      [ 9]  893         JP      NZ,NOSPC        ; No - Don't allow spaces
   E576 CD 38 E8      [16]  894         CALL    GETCHR          ; Get next character
   E579 2B            [ 4]  895         DEC     HL              ; Cancel increment from GETCHR
   E57A 23            [ 4]  896 NOSPC:  INC     HL              ; Next byte
   E57B 7E            [ 6]  897         LD      A,(HL)          ; Get byte
   E57C FE 61         [ 6]  898         CP      #"a"             ; Less than "a" ?
   E57E DA 83 E5      [ 9]  899         JP      C,NOCHNG        ; Yes - don't change
   E581 E6 5F         [ 6]  900         AND     #0b01011111       ; Make upper case
   E583 B9            [ 4]  901 NOCHNG: CP      C               ; Same as in buffer ?
   E584 CA 69 E5      [ 9]  902         JP      Z,NXTBYT        ; Yes - keep testing
   E587 E1            [ 9]  903         POP     HL              ; Get back start of word
   E588 C3 57 E5      [ 9]  904         JP      SEARCH          ; Look at next word
                            905 
   E58B 48            [ 4]  906 MATCH:  LD      C,B             ; Word found - Save token value
   E58C F1            [ 9]  907         POP     AF              ; Throw away return
   E58D EB            [ 3]  908         EX      DE,HL
   E58E C9            [ 9]  909         RET                     ; Return to "RETNAD"
   E58F EB            [ 3]  910 RETNAD: EX      DE,HL           ; Get address in string
   E590 79            [ 4]  911         LD      A,C             ; Get token value
   E591 C1            [ 9]  912         POP     BC              ; Restore buffer length
   E592 D1            [ 9]  913         POP     DE              ; Get destination address
   E593 23            [ 4]  914 MOVDIR: INC     HL              ; Next source in buffer
   E594 12            [ 7]  915         LD      (DE),A          ; Put byte in buffer
   E595 13            [ 4]  916         INC     DE              ; Move up buffer
   E596 0C            [ 4]  917         INC     C               ; Increment length of buffer
   E597 D6 3A         [ 6]  918         SUB     #":"             ; End of statement?
   E599 CA A1 E5      [ 9]  919         JP      Z,SETLIT        ; Jump if multi-statement line
   E59C FE 49         [ 6]  920         CP      #ZDATA-0x3A       ; Is it DATA statement ?
   E59E C2 A4 E5      [ 9]  921         JP      NZ,TSTREM       ; No - see if REM
   E5A1 32 AE 10      [13]  922 SETLIT: LD      (DATFLG),A      ; Set literal flag
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 18.
Hexadecimal [16-Bits]



   E5A4 D6 54         [ 6]  923 TSTREM: SUB     #ZREM-0x3A        ; Is it REM?
   E5A6 C2 14 E5      [ 9]  924         JP      NZ,CRNCLP       ; No - Leave flag
   E5A9 47            [ 4]  925         LD      B,A             ; Copy rest of buffer
   E5AA 7E            [ 6]  926 NXTCHR: LD      A,(HL)          ; Get byte
   E5AB B7            [ 4]  927         OR      A               ; End of line ?
   E5AC CA BA E5      [ 9]  928         JP      Z,ENDBUF        ; Yes - Terminate buffer
   E5AF B8            [ 4]  929         CP      B               ; End of statement ?
   E5B0 CA 93 E5      [ 9]  930         JP      Z,MOVDIR        ; Yes - Get next one
   E5B3 23            [ 4]  931 CPYLIT: INC     HL              ; Move up source string
   E5B4 12            [ 7]  932         LD      (DE),A          ; Save in destination
   E5B5 0C            [ 4]  933         INC     C               ; Increment length
   E5B6 13            [ 4]  934         INC     DE              ; Move up destination
   E5B7 C3 AA E5      [ 9]  935         JP      NXTCHR          ; Repeat
                            936 
   E5BA 21 60 10      [ 9]  937 ENDBUF: LD      HL,#BUFFER-1     ; Point to start of buffer
   E5BD 12            [ 7]  938         LD      (DE),A          ; Mark end of buffer (A = 00)
   E5BE 13            [ 4]  939         INC     DE
   E5BF 12            [ 7]  940         LD      (DE),A          ; A = 00
   E5C0 13            [ 4]  941         INC     DE
   E5C1 12            [ 7]  942         LD      (DE),A          ; A = 00
   E5C2 C9            [ 9]  943         RET
                            944 
   E5C3 3A 44 10      [12]  945 DODEL:  LD      A,(NULFLG)      ; Get null flag status
   E5C6 B7            [ 4]  946         OR      A               ; Is it zero?
   E5C7 3E 00         [ 6]  947         LD      A,#0             ; Zero A - Leave flags
   E5C9 32 44 10      [13]  948         LD      (NULFLG),A      ; Zero null flag
   E5CC C2 D7 E5      [ 9]  949         JP      NZ,ECHDEL       ; Set - Echo it
   E5CF 05            [ 4]  950         DEC     B               ; Decrement length
   E5D0 CA F4 E5      [ 9]  951         JP      Z,GETLIN        ; Get line again if empty
   E5D3 CD 9D E6      [16]  952         CALL    OUTC            ; Output null character
   E5D6 3E                  953         .db      0x3E             ; Skip "DEC B"
   E5D7 05            [ 4]  954 ECHDEL: DEC     B               ; Count bytes in buffer
   E5D8 2B            [ 4]  955         DEC     HL              ; Back space buffer
   E5D9 CA EB E5      [ 9]  956         JP      Z,OTKLN         ; No buffer - Try again
   E5DC 7E            [ 6]  957         LD      A,(HL)          ; Get deleted byte
   E5DD CD 9D E6      [16]  958         CALL    OUTC            ; Echo it
   E5E0 C3 12 E6      [ 9]  959         JP      MORINP          ; Get more input
                            960 
   E5E3 05            [ 4]  961 DELCHR: DEC     B               ; Count bytes in buffer
   E5E4 2B            [ 4]  962         DEC     HL              ; Back space buffer
   E5E5 CD 9D E6      [16]  963         CALL    OUTC            ; Output character in A
   E5E8 C2 12 E6      [ 9]  964         JP      NZ,MORINP       ; Not end - Get more
   E5EB CD 9D E6      [16]  965 OTKLN:  CALL    OUTC            ; Output character in A
   E5EE CD 83 EB      [16]  966 KILIN:  CALL    PRNTCR          ; Output CRLF
   E5F1 C3 09 E6      [ 9]  967         JP      TTYLIN          ; Get line again
                            968 
   E5F4 CD 6F FE      [16]  969 GETLIN: CALL    MONTST          ; Is it NAS-SYS?
   E5F7 CA 09 E6      [ 9]  970         JP      Z,TTYLIN        ; No - Character input
   E5FA 2A 75 0C      [15]  971         LD      HL,(CIN)        ; Point to NAS-SYS input table
   E5FD 7E            [ 6]  972         LD      A,(HL)          ; Get input mode
   E5FE FE 74         [ 6]  973         CP      #0x74             ; Is it "X" mode?
   E600 CA 09 E6      [ 9]  974         JP      Z,TTYLIN        ; Yes - Teletype line input
   E603 CD EA FE      [16]  975         CALL    INLINE          ; Get a line from NAS-SYS
   E606 C3 88 EB      [ 9]  976         JP      DONULL          ; POS(X)=0 and do nulls
                            977 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 19.
Hexadecimal [16-Bits]



   E609 21 61 10      [ 9]  978 TTYLIN: LD      HL,#BUFFER       ; Get a line by character
   E60C 06 01         [ 6]  979         LD      B,#1             ; Set buffer as empty
   E60E AF            [ 4]  980         XOR     A
   E60F 32 44 10      [13]  981         LD      (NULFLG),A      ; Clear null flag
   E612 CD CE E6      [16]  982 MORINP: CALL    CLOTST          ; Get character and test ^O
   E615 4F            [ 4]  983         LD      C,A             ; Save character in C
   E616 FE 7F         [ 6]  984         CP      #DEL             ; Delete character?
   E618 CA C3 E5      [ 9]  985         JP      Z,DODEL         ; Yes - Process it
   E61B 3A 44 10      [12]  986         LD      A,(NULFLG)      ; Get null flag
   E61E B7            [ 4]  987         OR      A               ; Test null flag status
   E61F CA 2B E6      [ 9]  988         JP      Z,PROCES        ; Reset - Process character
   E622 3E 00         [ 6]  989         LD      A,#0             ; Set a null
   E624 CD 9D E6      [16]  990         CALL    OUTC            ; Output null
   E627 AF            [ 4]  991         XOR     A               ; Clear A
   E628 32 44 10      [13]  992         LD      (NULFLG),A      ; Reset null flag
   E62B 79            [ 4]  993 PROCES: LD      A,C             ; Get character
   E62C FE 07         [ 6]  994         CP      #CTRLG           ; Bell?
   E62E CA 6F E6      [ 9]  995         JP      Z,PUTCTL        ; Yes - Save it
   E631 FE 03         [ 6]  996         CP      #CTRLC           ; Is it control "C"?
   E633 CC 83 EB      [16]  997         CALL    Z,PRNTCR        ; Yes - Output CRLF
   E636 37            [ 3]  998         SCF                     ; Flag break
   E637 C8            [10]  999         RET     Z               ; Return if control "C"
   E638 FE 0D         [ 6] 1000         CP      #CR              ; Is it enter?
   E63A CA 7E EB      [ 9] 1001         JP      Z,ENDINP        ; Yes - Terminate input
   E63D FE 15         [ 6] 1002         CP      #CTRLU           ; Is it control "U"?
   E63F CA EE E5      [ 9] 1003         JP      Z,KILIN         ; Yes - Get another line
   E642 FE 40         [ 6] 1004         CP      #"@"             ; Is it "kill line"?
   E644 CA EB E5      [ 9] 1005         JP      Z,OTKLN         ; Yes - Kill line
   E647 FE 5F         [ 6] 1006         CP      #"_"             ; Is it delete?
   E649 CA E3 E5      [ 9] 1007         JP      Z,DELCHR        ; Yes - Delete character
   E64C FE 08         [ 6] 1008         CP      #BKSP            ; Is it backspace?
   E64E CA E3 E5      [ 9] 1009         JP      Z,DELCHR        ; Yes - Delete character
   E651 FE 12         [ 6] 1010         CP      #CTRLR           ; Is it control "R"?
   E653 C2 6A E6      [ 9] 1011         JP      NZ,PUTBUF       ; No - Put in buffer
   E656 C5            [11] 1012         PUSH    BC              ; Save buffer length
   E657 D5            [11] 1013         PUSH    DE              ; Save DE
   E658 E5            [11] 1014         PUSH    HL              ; Save buffer address
   E659 36 00         [ 9] 1015         LD      (HL),#0          ; Mark end of buffer
   E65B CD F6 FF      [16] 1016         CALL    OUTNCR          ; Output and do CRLF
   E65E 21 61 10      [ 9] 1017         LD      HL,#BUFFER       ; Point to buffer start
   E661 CD 12 F2      [16] 1018         CALL    PRS             ; Output buffer
   E664 E1            [ 9] 1019         POP     HL              ; Restore buffer address
   E665 D1            [ 9] 1020         POP     DE              ; Restore DE
   E666 C1            [ 9] 1021         POP     BC              ; Restore buffer length
   E667 C3 12 E6      [ 9] 1022         JP      MORINP          ; Get another character
                           1023 
   E66A FE 20         [ 6] 1024 PUTBUF: CP      #" "             ; Is it a control code?
   E66C DA 12 E6      [ 9] 1025         JP      C,MORINP        ; Yes - Ignore
   E66F 78            [ 4] 1026 PUTCTL: LD      A,B             ; Get number of bytes in buffer
   E670 FE 49         [ 6] 1027         CP      #72+1            ; Test for line overflow
   E672 3E 07         [ 6] 1028         LD      A,#CTRLG         ; Set a bell
   E674 D2 84 E6      [ 9] 1029         JP      NC,OUTNBS       ; Ring bell if buffer full
   E677 79            [ 4] 1030         LD      A,C             ; Get character
   E678 71            [ 7] 1031         LD      (HL),C          ; Save in buffer
   E679 32 CC 10      [13] 1032         LD      (LSTBIN),A      ; Save last input byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 20.
Hexadecimal [16-Bits]



   E67C 23            [ 4] 1033         INC     HL              ; Move up buffer
   E67D 04            [ 4] 1034         INC     B               ; Increment length
   E67E CD 9D E6      [16] 1035 OUTIT:  CALL    OUTC            ; Output the character entered
   E681 C3 12 E6      [ 9] 1036         JP      MORINP          ; Get another character
                           1037 
   E684 CD 9D E6      [16] 1038 OUTNBS: CALL    OUTC            ; Output bell and back over it
   E687 3E 08         [ 6] 1039         LD      A,#BKSP          ; Set back space
   E689 C3 7E E6      [ 9] 1040         JP      OUTIT           ; Output it and get more
                           1041 
   E68C 7C            [ 4] 1042 CPDEHL: LD      A,H             ; Get H
   E68D 92            [ 4] 1043         SUB     D               ; Compare with D
   E68E C0            [10] 1044         RET     NZ              ; Different - Exit
   E68F 7D            [ 4] 1045         LD      A,L             ; Get L
   E690 93            [ 4] 1046         SUB     E               ; Compare with E
   E691 C9            [ 9] 1047         RET                     ; Return status
                           1048 
   E692 7E            [ 6] 1049 CHKSYN: LD      A,(HL)          ; Check syntax of character
   E693 E3            [16] 1050         EX      (SP),HL         ; Address of test byte
   E694 BE            [ 6] 1051         CP      (HL)            ; Same as in code string?
   E695 23            [ 4] 1052         INC     HL              ; Return address
   E696 E3            [16] 1053         EX      (SP),HL         ; Put it back
   E697 CA 38 E8      [ 9] 1054         JP      Z,GETCHR        ; Yes - Get next character
   E69A C3 AF E3      [ 9] 1055         JP      SNERR           ; Different - ?SN Error
                           1056 
   E69D F5            [11] 1057 OUTC:   PUSH    AF              ; Save character
   E69E 3A 45 10      [12] 1058         LD      A,(CTLOFG)      ; Get control "O" flag
   E6A1 B7            [ 4] 1059         OR      A               ; Is it set?
   E6A2 C2 47 F2      [ 9] 1060         JP      NZ,POPAF        ; Yes - don't output
   E6A5 F1            [ 9] 1061         POP     AF              ; Restore character
   E6A6 C5            [11] 1062         PUSH    BC              ; Save buffer length
   E6A7 F5            [11] 1063         PUSH    AF              ; Save character
   E6A8 FE 20         [ 6] 1064         CP      #" "             ; Is it a control code?
   E6AA DA C1 E6      [ 9] 1065         JP      C,DINPOS        ; Yes - Don't INC POS(X)
   E6AD 3A 42 10      [12] 1066         LD      A,(LWIDTH)      ; Get line width
   E6B0 47            [ 4] 1067         LD      B,A             ; To B
   E6B1 3A AB 10      [12] 1068         LD      A,(CURPOS)      ; Get cursor position
   E6B4 04            [ 4] 1069         INC     B               ; Width 255?
   E6B5 CA BD E6      [ 9] 1070         JP      Z,INCLEN        ; Yes - No width limit
   E6B8 05            [ 4] 1071         DEC     B               ; Restore width
   E6B9 B8            [ 4] 1072         CP      B               ; At end of line?
   E6BA CC 83 EB      [16] 1073         CALL    Z,PRNTCR        ; Yes - output CRLF
   E6BD 3C            [ 4] 1074 INCLEN: INC     A               ; Move on one character
   E6BE 32 AB 10      [13] 1075         LD      (CURPOS),A      ; Save new position
   E6C1 F1            [ 9] 1076 DINPOS: POP     AF              ; Restore character
   E6C2 C1            [ 9] 1077         POP     BC              ; Restore buffer length
   E6C3 F5            [11] 1078         PUSH    AF              ; << This sequence >>
   E6C4 F1            [ 9] 1079         POP     AF              ; << is not needed >>
   E6C5 F5            [11] 1080         PUSH    AF              ; Save character
   E6C6 C5            [11] 1081         PUSH    BC              ; Save buffer length
   E6C7 4F            [ 4] 1082         LD      C,A             ; Character to C
   E6C8 CD DB FC      [16] 1083         CALL    CONMON          ; Send it
   E6CB C1            [ 9] 1084         POP     BC              ; Restore buffer length
   E6CC F1            [ 9] 1085         POP     AF              ; Restore character
   E6CD C9            [ 9] 1086         RET
                           1087 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 21.
Hexadecimal [16-Bits]



   E6CE CD 07 FD      [16] 1088 CLOTST: CALL    GETINP          ; Get input character
   E6D1 E6 7F         [ 6] 1089         AND     #0b01111111       ; Strip bit 7
   E6D3 FE 0F         [ 6] 1090         CP      #CTRLO           ; Is it control "O"?
   E6D5 C0            [10] 1091         RET     NZ              ; No don't flip flag
   E6D6 3A 45 10      [12] 1092         LD      A,(CTLOFG)      ; Get flag
   E6D9 2F            [ 3] 1093         CPL                     ; Flip it
   E6DA 32 45 10      [13] 1094         LD      (CTLOFG),A      ; Put it back
   E6DD AF            [ 4] 1095         XOR     A               ; Null character
   E6DE C9            [ 9] 1096         RET
                           1097 
   E6DF CD A7 E9      [16] 1098 LIST:   CALL    ATOH            ; ASCII number to DE
   E6E2 C0            [10] 1099         RET     NZ              ; Return if anything extra
   E6E3 C1            [ 9] 1100         POP     BC              ; Rubbish - Not needed
   E6E4 CD 9B E4      [16] 1101         CALL    SRCHLN          ; Search for line number in DE
   E6E7 C5            [11] 1102         PUSH    BC              ; Save address of line
   E6E8 CD 35 E7      [16] 1103         CALL    SETLIN          ; Set up lines counter
   E6EB E1            [ 9] 1104 LISTLP: POP     HL              ; Restore address of line
   E6EC 4E            [ 6] 1105         LD      C,(HL)          ; Get LSB of next line
   E6ED 23            [ 4] 1106         INC     HL
   E6EE 46            [ 6] 1107         LD      B,(HL)          ; Get MSB of next line
   E6EF 23            [ 4] 1108         INC     HL
   E6F0 78            [ 4] 1109         LD      A,B             ; BC = 0 (End of program)?
   E6F1 B1            [ 4] 1110         OR      C
   E6F2 CA FA E3      [ 9] 1111         JP      Z,PRNTOK        ; Yes - Go to command mode
   E6F5 CD 48 E7      [16] 1112         CALL    COUNT           ; Count lines
   E6F8 CD 63 E8      [16] 1113         CALL    TSTBRK          ; Test for break key
   E6FB C5            [11] 1114         PUSH    BC              ; Save address of next line
   E6FC CD 83 EB      [16] 1115         CALL    PRNTCR          ; Output CRLF
   E6FF 5E            [ 6] 1116         LD      E,(HL)          ; Get LSB of line number
   E700 23            [ 4] 1117         INC     HL
   E701 56            [ 6] 1118         LD      D,(HL)          ; Get MSB of line number
   E702 23            [ 4] 1119         INC     HL
   E703 E5            [11] 1120         PUSH    HL              ; Save address of line start
   E704 EB            [ 3] 1121         EX      DE,HL           ; Line number to HL
   E705 CD AF F9      [16] 1122         CALL    PRNTHL          ; Output line number in decimal
   E708 3E 20         [ 6] 1123         LD      A,#" "           ; Space after line number
   E70A E1            [ 9] 1124         POP     HL              ; Restore start of line address
   E70B CD 9D E6      [16] 1125 LSTLP2: CALL    OUTC            ; Output character in A
   E70E 7E            [ 6] 1126 LSTLP3: LD      A,(HL)          ; Get next byte in line
   E70F B7            [ 4] 1127         OR      A               ; End of line?
   E710 23            [ 4] 1128         INC     HL              ; To next byte in line
   E711 CA EB E6      [ 9] 1129         JP      Z,LISTLP        ; Yes - get next line
   E714 F2 0B E7      [ 9] 1130         JP      P,LSTLP2        ; No token - output it
   E717 D6 7F         [ 6] 1131         SUB     #ZEND-1          ; Find and output word
   E719 4F            [ 4] 1132         LD      C,A             ; Token offset+1 to C
   E71A 11 43 E1      [ 9] 1133         LD      DE,#WORDS        ; Reserved word list
   E71D 1A            [ 6] 1134 FNDTOK: LD      A,(DE)          ; Get character in list
   E71E 13            [ 4] 1135         INC     DE              ; Move on to next
   E71F B7            [ 4] 1136         OR      A               ; Is it start of word?
   E720 F2 1D E7      [ 9] 1137         JP      P,FNDTOK        ; No - Keep looking for word
   E723 0D            [ 4] 1138         DEC     C               ; Count words
   E724 C2 1D E7      [ 9] 1139         JP      NZ,FNDTOK       ; Not there - keep looking
   E727 E6 7F         [ 6] 1140 OUTWRD: AND     #0b01111111       ; Strip bit 7
   E729 CD 9D E6      [16] 1141         CALL    OUTC            ; Output first character
   E72C 1A            [ 6] 1142         LD      A,(DE)          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 22.
Hexadecimal [16-Bits]



   E72D 13            [ 4] 1143         INC     DE              ; Move on to next
   E72E B7            [ 4] 1144         OR      A               ; Is it end of word?
   E72F F2 27 E7      [ 9] 1145         JP      P,OUTWRD        ; No - output the rest
   E732 C3 0E E7      [ 9] 1146         JP      LSTLP3          ; Next byte in line
                           1147 
   E735 E5            [11] 1148 SETLIN: PUSH    HL              ; Set up LINES counter
   E736 2A 48 10      [15] 1149         LD      HL,(LINESN)     ; Get LINES number
   E739 22 46 10      [16] 1150         LD      (LINESC),HL     ; Save in LINES counter
   E73C E1            [ 9] 1151         POP     HL
   E73D C9            [ 9] 1152         RET
                           1153 
   E73E 21 E0 FE      [ 9] 1154 LDNMI1: LD      HL,#BREAK        ; Break routine
   E741 22 7E 0C      [16] 1155         LD      (NMI),HL        ; NMI forces break
   E744 C3 FA E3      [ 9] 1156         JP      PRNTOK          ; Go to command mode
                           1157 
   E747 FE                 1158         .db      0x0FE            ; <<< NO REFERENCE TO HERE >>>
                           1159 
   E748 E5            [11] 1160 COUNT:  PUSH    HL              ; Save code string address
   E749 D5            [11] 1161         PUSH    DE
   E74A 2A 46 10      [15] 1162         LD      HL,(LINESC)     ; Get LINES counter
   E74D 11 FF FF      [ 9] 1163         LD      DE,#-1
   E750 ED 5A         [10] 1164         ADC     HL,DE           ; Decrement
   E752 22 46 10      [16] 1165         LD      (LINESC),HL     ; Put it back
   E755 D1            [ 9] 1166         POP     DE
   E756 E1            [ 9] 1167         POP     HL              ; Restore code string address
   E757 F0            [10] 1168         RET     P               ; Return if more lines to go
   E758 E5            [11] 1169         PUSH    HL              ; Save code string address
   E759 2A 48 10      [15] 1170         LD      HL,(LINESN)     ; Get LINES number
   E75C 22 46 10      [16] 1171         LD      (LINESC),HL     ; Reset LINES counter
   E75F 3A 4C 10      [12] 1172         LD      A,(NMIFLG)      ; Break by NMI?
   E762 B7            [ 4] 1173         OR      A
   E763 C2 E7 FE      [ 9] 1174         JP      NZ,ARETN        ; Yes - "RETN"
   E766 CD 07 FD      [16] 1175         CALL    GETINP          ; Get input character
   E769 FE 03         [ 6] 1176         CP      #CTRLC           ; Is it control "C"?
   E76B CA 72 E7      [ 9] 1177         JP      Z,RSLNBK        ; Yes - Reset LINES an break
   E76E E1            [ 9] 1178         POP     HL              ; Restore code string address
   E76F C3 48 E7      [ 9] 1179         JP      COUNT           ; Keep on counting
                           1180 
   E772 2A 48 10      [15] 1181 RSLNBK: LD      HL,(LINESN)     ; Get LINES number
   E775 22 46 10      [16] 1182         LD      (LINESC),HL     ; Reset LINES counter
   E778 C3 B1 E0      [ 9] 1183         JP      BRKRET          ; Go and output "Break"
                           1184 
   E77B 3E 64         [ 6] 1185 FOR:    LD      A,#0x64           ; Flag "FOR" assignment
   E77D 32 CB 10      [13] 1186         LD      (FORFLG),A      ; Save "FOR" flag
   E780 CD 89 EA      [16] 1187         CALL    LET             ; Set up initial index
   E783 C1            [ 9] 1188         POP     BC              ; Drop RETurn address
   E784 E5            [11] 1189         PUSH    HL              ; Save code string address
   E785 CD 72 EA      [16] 1190         CALL    DATA            ; Get next statement address
   E788 22 C7 10      [16] 1191         LD      (LOOPST),HL     ; Save it for start of lo6p
   E78B 21 02 00      [ 9] 1192         LD      HL,#2            ; Offset for "FOR" block
   E78E 39            [ 7] 1193         ADD     HL,SP           ; Point to it
   E78F CD 5C E3      [16] 1194 FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
   E792 D1            [ 9] 1195         POP     DE              ; Get code string address
   E793 C2 AB E7      [ 9] 1196         JP      NZ,FORFND       ; No nesting found
   E796 09            [ 7] 1197         ADD     HL,BC           ; Move into "FOR" block
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 23.
Hexadecimal [16-Bits]



   E797 D5            [11] 1198         PUSH    DE              ; Save code string address
   E798 2B            [ 4] 1199         DEC     HL
   E799 56            [ 6] 1200         LD      D,(HL)          ; Get MSB of loop statement
   E79A 2B            [ 4] 1201         DEC     HL
   E79B 5E            [ 6] 1202         LD      E,(HL)          ; Get LSB of loop statement
   E79C 23            [ 4] 1203         INC     HL
   E79D 23            [ 4] 1204         INC     HL
   E79E E5            [11] 1205         PUSH    HL              ; Save block address
   E79F 2A C7 10      [15] 1206         LD      HL,(LOOPST)     ; Get address of loop statement
   E7A2 CD 8C E6      [16] 1207         CALL    CPDEHL          ; Compare the FOR loops
   E7A5 E1            [ 9] 1208         POP     HL              ; Restore block address
   E7A6 C2 8F E7      [ 9] 1209         JP      NZ,FORSLP       ; Different FORs - Find another
   E7A9 D1            [ 9] 1210         POP     DE              ; Restore code string address
   E7AA F9            [ 4] 1211         LD      SP,HL           ; Remove all nested loops
                           1212 
   E7AB EB            [ 3] 1213 FORFND: EX      DE,HL           ; Code string address to HL
   E7AC 0E 08         [ 6] 1214         LD      C,#8
   E7AE CD 8C E3      [16] 1215         CALL    CHKSTK          ; Check for 8 levels of stack
   E7B1 E5            [11] 1216         PUSH    HL              ; Save code string address
   E7B2 2A C7 10      [15] 1217         LD      HL,(LOOPST)     ; Get first statement of loop
   E7B5 E3            [16] 1218         EX      (SP),HL         ; Save and restore code string
   E7B6 E5            [11] 1219         PUSH    HL              ; Re-save code string address
   E7B7 2A 5C 10      [15] 1220         LD      HL,(LINEAT)     ; Get current line number
   E7BA E3            [16] 1221         EX      (SP),HL         ; Save and restore code string
   E7BB CD 46 ED      [16] 1222         CALL    TSTNUM          ; Make sure it's a number
   E7BE CD 92 E6      [16] 1223         CALL    CHKSYN          ; Make sure "TO" is next
   E7C1 A6                 1224         .db      ZTO             ; "TO" token
   E7C2 CD 43 ED      [16] 1225         CALL    GETNUM          ; Get "TO" expression value
   E7C5 E5            [11] 1226         PUSH    HL              ; Save code string address
   E7C6 CD 61 F8      [16] 1227         CALL    BCDEFP          ; Move "TO" value to BCDE
   E7C9 E1            [ 9] 1228         POP     HL              ; Restore code string address
   E7CA C5            [11] 1229         PUSH    BC              ; Save "TO" value in block
   E7CB D5            [11] 1230         PUSH    DE
   E7CC 01 00 81      [ 9] 1231         LD      BC,#0x8100        ; BCDE - 1 (default STEP)
   E7CF 51            [ 4] 1232         LD      D,C             ; C=0
   E7D0 5A            [ 4] 1233         LD      E,D             ; D=0
   E7D1 7E            [ 6] 1234         LD      A,(HL)          ; Get next byte in code string
   E7D2 FE AB         [ 6] 1235         CP      #ZSTEP           ; See if "STEP" is stated
   E7D4 3E 01         [ 6] 1236         LD      A,#1             ; Sign of step = 1
   E7D6 C2 E7 E7      [ 9] 1237         JP      NZ,SAVSTP       ; No STEP given - Default to 1
   E7D9 CD 38 E8      [16] 1238         CALL    GETCHR          ; Jump over "STEP" token
   E7DC CD 43 ED      [16] 1239         CALL    GETNUM          ; Get step value
   E7DF E5            [11] 1240         PUSH    HL              ; Save code string address
   E7E0 CD 61 F8      [16] 1241         CALL    BCDEFP          ; Move STEP to BCDE
   E7E3 CD 15 F8      [16] 1242         CALL    TSTSGN          ; Test sign of FPREG
   E7E6 E1            [ 9] 1243         POP     HL              ; Restore code string address
   E7E7 C5            [11] 1244 SAVSTP: PUSH    BC              ; Save the STEP value in block
   E7E8 D5            [11] 1245         PUSH    DE
   E7E9 F5            [11] 1246         PUSH    AF              ; Save sign of STEP
   E7EA 33            [ 4] 1247         INC     SP              ; Don't save flags
   E7EB E5            [11] 1248         PUSH    HL              ; Save code string address
   E7EC 2A CE 10      [15] 1249         LD      HL,(BRKLIN)     ; Get address of index variable
   E7EF E3            [16] 1250         EX      (SP),HL         ; Save and restore code string
   E7F0 06 81         [ 6] 1251 PUTFID: LD      B,#ZFOR          ; "FOR" block marker
   E7F2 C5            [11] 1252         PUSH    BC              ; Save it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 24.
Hexadecimal [16-Bits]



   E7F3 33            [ 4] 1253         INC     SP              ; Don't save C
                           1254 
   E7F4 CD 42 FD      [16] 1255 RUNCNT: CALL    CHKBRK          ; Execution driver - Test break
   E7F7 B7            [ 4] 1256         OR      A               ; Break key hit?
   E7F8 C4 68 E8      [16] 1257         CALL    NZ,STALL        ; Yes - Pause for a key
   E7FB 22 CE 10      [16] 1258         LD      (BRKLIN),HL     ; Save code address for break
   E7FE 7E            [ 6] 1259         LD      A,(HL)          ; Get next byte in code string
   E7FF FE 3A         [ 6] 1260         CP      #":"             ; Multi statement line?
   E801 CA 18 E8      [ 9] 1261         JP      Z,EXCUTE        ; Yes - Execute it
   E804 B7            [ 4] 1262         OR      A               ; End of line?
   E805 C2 AF E3      [ 9] 1263         JP      NZ,SNERR        ; No - Syntax error
   E808 23            [ 4] 1264         INC     HL              ; Point to address of next line
   E809 7E            [ 6] 1265         LD      A,(HL)          ; Get LSB of line pointer
   E80A 23            [ 4] 1266         INC     HL
   E80B B6            [ 6] 1267         OR      (HL)            ; Is it zero (End of prog)?
   E80C CA 7C E8      [ 9] 1268         JP      Z,ENDPRG        ; Yes - Terminate execution
   E80F 23            [ 4] 1269         INC     HL              ; Point to line number
   E810 5E            [ 6] 1270         LD      E,(HL)          ; Get LSB of line number
   E811 23            [ 4] 1271         INC     HL
   E812 56            [ 6] 1272         LD      D,(HL)          ; Get MSB of line number
   E813 EB            [ 3] 1273         EX      DE,HL           ; Line number to HL
   E814 22 5C 10      [16] 1274         LD      (LINEAT),HL     ; Save as current line number
   E817 EB            [ 3] 1275         EX      DE,HL           ; Line number back to DE
   E818 CD 38 E8      [16] 1276 EXCUTE: CALL    GETCHR          ; Get key word
   E81B 11 F4 E7      [ 9] 1277         LD      DE,#RUNCNT       ; Where to RETurn to
   E81E D5            [11] 1278         PUSH    DE              ; Save for RETurn
   E81F C8            [10] 1279 IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
   E820 D6 80         [ 6] 1280 ONJMP:  SUB     #ZEND            ; Is it a token?
   E822 DA 89 EA      [ 9] 1281         JP      C,LET           ; No - try to assign it
   E825 FE 25         [ 6] 1282         CP      #ZNEW+1-ZEND     ; END to NEW ?
   E827 D2 AF E3      [ 9] 1283         JP      NC,SNERR        ; Not a key word - ?SN Error
   E82A 07            [ 3] 1284         RLCA                    ; Double it
   E82B 4F            [ 4] 1285         LD      C,A             ; BC = Offset into table
   E82C 06 00         [ 6] 1286         LD      B,#0
   E82E EB            [ 3] 1287         EX      DE,HL           ; Save code string address
   E82F 21 5A E2      [ 9] 1288         LD      HL,#WORDTB       ; Keyword address table
   E832 09            [ 7] 1289         ADD     HL,BC           ; Point to routine address
   E833 4E            [ 6] 1290         LD      C,(HL)          ; Get LSB of routine address
   E834 23            [ 4] 1291         INC     HL
   E835 46            [ 6] 1292         LD      B,(HL)          ; Get MSB of routine address
   E836 C5            [11] 1293         PUSH    BC              ; Save routine address
   E837 EB            [ 3] 1294         EX      DE,HL           ; Restore code string address
                           1295 
   E838 23            [ 4] 1296 GETCHR: INC     HL              ; Point to next character
   E839 7E            [ 6] 1297         LD      A,(HL)          ; Get next code string byte
   E83A FE 3A         [ 6] 1298         CP      #":"             ; Z if ":"
   E83C D0            [10] 1299         RET     NC              ; NC if > "9"
   E83D FE 20         [ 6] 1300         CP      #" "
   E83F CA 38 E8      [ 9] 1301         JP      Z,GETCHR        ; Skip over spaces
   E842 FE 30         [ 6] 1302         CP      #"0"
   E844 3F            [ 3] 1303         CCF                     ; NC if < "0"
   E845 3C            [ 4] 1304         INC     A               ; Test for zero - Leave carry
   E846 3D            [ 4] 1305         DEC     A               ; Z if Null
   E847 C9            [ 9] 1306         RET
                           1307 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 25.
Hexadecimal [16-Bits]



   E848 EB            [ 3] 1308 RESTOR: EX      DE,HL           ; Save code string address
   E849 2A 5E 10      [15] 1309         LD      HL,(BASTXT)     ; Point to start of program
   E84C CA 5D E8      [ 9] 1310         JP      Z,RESTNL        ; Just RESTORE - reset pointer
   E84F EB            [ 3] 1311         EX      DE,HL           ; Restore code string address
   E850 CD A7 E9      [16] 1312         CALL    ATOH            ; Get line number to DE
   E853 E5            [11] 1313         PUSH    HL              ; Save code string address
   E854 CD 9B E4      [16] 1314         CALL    SRCHLN          ; Search for line number in DE
   E857 60            [ 4] 1315         LD      H,B             ; HL = Address of line
   E858 69            [ 4] 1316         LD      L,C
   E859 D1            [ 9] 1317         POP     DE              ; Restore code string address
   E85A D2 48 EA      [ 9] 1318         JP      NC,ULERR        ; ?UL Error if not found
   E85D 2B            [ 4] 1319 RESTNL: DEC     HL              ; Byte before DATA statement
   E85E 22 DC 10      [16] 1320 UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
   E861 EB            [ 3] 1321         EX      DE,HL           ; Restore code string address
   E862 C9            [ 9] 1322         RET
                           1323 
   E863 CD 42 FD      [16] 1324 TSTBRK: CALL    CHKBRK          ; Test for interrupts
   E866 B7            [ 4] 1325         OR      A
   E867 C8            [10] 1326         RET     Z               ; Return if no key pressed
   E868 CD CE E6      [16] 1327 STALL:  CALL    CLOTST          ; Get input and test for ^O
   E86B FE 13         [ 6] 1328         CP      #CTRLS           ; Is it control "S"
   E86D CC CE E6      [16] 1329         CALL    Z,CLOTST        ; Yes - Get another character
   E870 FE 03         [ 6] 1330         CP      #CTRLC           ; Return if not control "C"
   E872 C0            [10] 1331 STOP:   RET     NZ              ; Exit if anything else
   E873 F6                 1332         .db      0x0F6            ; Flag "STOP"
   E874 C0            [10] 1333 PEND:   RET     NZ              ; Exit if anything else
   E875 22 CE 10      [16] 1334         LD      (BRKLIN),HL     ; Save point of break
   E878 21                 1335         .db      0x21             ; Skip "OR 11111111B"
   E879 F6 FF         [ 6] 1336 INPBRK: OR      #0b11111111       ; Flag "Break" wanted
   E87B C1            [ 9] 1337         POP     BC              ; Return not needed and more
   E87C 2A 5C 10      [15] 1338 ENDPRG: LD      HL,(LINEAT)     ; Get current line number
   E87F F5            [11] 1339         PUSH    AF              ; Save STOP / END status
   E880 7D            [ 4] 1340         LD      A,L             ; Is it direct break?
   E881 A4            [ 4] 1341         AND     H
   E882 3C            [ 4] 1342         INC     A               ; Line is -1 if direct break
   E883 CA 8F E8      [ 9] 1343         JP      Z,NOLIN         ; Yes - No line number
   E886 22 D2 10      [16] 1344         LD      (ERRLIN),HL     ; Save line of break
   E889 2A CE 10      [15] 1345         LD      HL,(BRKLIN)     ; Get point of break
   E88C 22 D4 10      [16] 1346         LD      (CONTAD),HL     ; Save point to CONTinue
   E88F AF            [ 4] 1347 NOLIN:  XOR     A
   E890 32 45 10      [13] 1348         LD      (CTLOFG),A      ; Enable output
   E893 CD 76 EB      [16] 1349         CALL    STTLIN          ; Start a new line
   E896 F1            [ 9] 1350         POP     AF              ; Restore STOP / END status
   E897 21 52 E3      [ 9] 1351         LD      HL,#BRKMSG       ; "Break" message
   E89A C2 E3 E3      [ 9] 1352         JP      NZ,ERRIN        ; "in line" wanted?
   E89D C3 FA E3      [ 9] 1353         JP      PRNTOK          ; Go to command mode
                           1354 
   E8A0 2A D4 10      [15] 1355 CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
   E8A3 7C            [ 4] 1356         LD      A,H             ; Is it zero?
   E8A4 B5            [ 4] 1357         OR      L
   E8A5 1E 20         [ 6] 1358         LD      E,#CN            ; ?CN Error
   E8A7 CA C3 E3      [ 9] 1359         JP      Z,ERROR         ; Yes - output "?CN Error"
   E8AA EB            [ 3] 1360         EX      DE,HL           ; Save code string address
   E8AB 2A D2 10      [15] 1361         LD      HL,(ERRLIN)     ; Get line of last break
   E8AE 22 5C 10      [16] 1362         LD      (LINEAT),HL     ; Set up current line number
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 26.
Hexadecimal [16-Bits]



   E8B1 EB            [ 3] 1363         EX      DE,HL           ; Restore code string address
   E8B2 C9            [ 9] 1364         RET                     ; CONTinue where left off
                           1365 
   E8B3 CD 86 F4      [16] 1366 NULL:   CALL    GETINT          ; Get integer 0-255
   E8B6 C0            [10] 1367         RET     NZ              ; Return if bad value
   E8B7 32 41 10      [13] 1368         LD      (NULLS),A       ; Set nulls number
   E8BA C9            [ 9] 1369         RET
                           1370 
   E8BB 06 FF         [ 6] 1371 ARRLD1: LD      B,#-1            ; Flag array load
   E8BD CD 38 E8      [16] 1372 ARRSV1: CALL    GETCHR          ; Skip "*"
   E8C0 78            [ 4] 1373         LD      A,B             ; CLOAD* or CSAVE*
   E8C1 32 CE 10      [13] 1374         LD      (BRKLIN),A      ; Save it
   E8C4 3E 01         [ 6] 1375         LD      A,#1             ; It's an array
   E8C6 32 CB 10      [13] 1376         LD      (FORFLG),A      ; Flag array name
   E8C9 CD 2F EF      [16] 1377         CALL    GETVAR          ; Get address of array name
   E8CC E5            [11] 1378         PUSH    HL              ; Save code string address
   E8CD 32 CB 10      [13] 1379         LD      (FORFLG),A      ; Clear flag
   E8D0 60            [ 4] 1380         LD      H,B             ; Address of array to HL
   E8D1 69            [ 4] 1381         LD      L,C
   E8D2 0B            [ 4] 1382         DEC     BC              ; Back space
   E8D3 0B            [ 4] 1383         DEC     BC              ;  to point
   E8D4 0B            [ 4] 1384         DEC     BC              ;  to the
   E8D5 0B            [ 4] 1385         DEC     BC              ; array name
   E8D6 3A CE 10      [12] 1386         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8D9 B7            [ 4] 1387         OR      A
   E8DA F5            [11] 1388         PUSH    AF              ; Save CLOAD* / CSAVE* status
   E8DB EB            [ 3] 1389         EX      DE,HL           ; Array data length
   E8DC 19            [ 7] 1390         ADD     HL,DE           ; End of data
   E8DD EB            [ 3] 1391         EX      DE,HL           ; To DE
   E8DE 4E            [ 6] 1392         LD      C,(HL)          ; Get dimension bytes
   E8DF 06 00         [ 6] 1393         LD      B,#0
   E8E1 09            [ 7] 1394         ADD     HL,BC           ; 2 Bytes each dimension
   E8E2 09            [ 7] 1395         ADD     HL,BC
   E8E3 23            [ 4] 1396         INC     HL              ; Over number of dimensions
   E8E4 E5            [11] 1397         PUSH    HL              ; Address of array data
   E8E5 D5            [11] 1398         PUSH    DE              ; End of array data
   E8E6 C5            [11] 1399         PUSH    BC              ; Number of dimensions
   E8E7 3A CE 10      [12] 1400         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8EA FE FF         [ 6] 1401         CP      #-1
   E8EC CC D7 FC      [16] 1402         CALL    Z,CASFF         ; CLOAD* - Cassette on
   E8EF 3A CE 10      [12] 1403         LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E8F2 FE FF         [ 6] 1404         CP      #-1
   E8F4 C4 CA FC      [16] 1405         CALL    NZ,CASFFW       ; CSAVE* - Cassette on and wait
   E8F7 00            [ 3] 1406         NOP
   E8F8 00            [ 3] 1407         NOP
   E8F9 00            [ 3] 1408         NOP
   E8FA 21 00 00      [ 9] 1409         LD      HL,#0
   E8FD 22 4A 10      [16] 1410         LD      (CHKSUM),HL     ; Zero check sum
   E900 C1            [ 9] 1411         POP     BC              ; Number of dimensions
   E901 D1            [ 9] 1412         POP     DE              ; End of array data
   E902 E1            [ 9] 1413         POP     HL              ; Address of array data
   E903 06 D2         [ 6] 1414         LD      B,#0b11010010     ; Header byte
   E905 C3 D8 FF      [ 9] 1415         JP      JPLDSV          ; CSAVE-SNDHDR , CLOAD-GETHDR
                           1416 
   E908 78            [ 4] 1417 SNDHDR: LD      A,B             ; Get header byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 27.
Hexadecimal [16-Bits]



   E909 CD B9 F4      [16] 1418         CALL    WUART2          ; Send 2 bytes to UART
   E90C CD B9 F4      [16] 1419         CALL    WUART2          ; Send 2 bytes to UART
   E90F C3 1F E9      [ 9] 1420         JP      SNDARY          ; Send array data
                           1421 
   E912 0E 04         [ 6] 1422 GETHDR: LD      C,#4             ; 4 Bytes to check
   E914 CD B6 F4      [16] 1423 HDRLP:  CALL    RUART           ; Read byte from UART
   E917 B8            [ 4] 1424         CP      B               ; Same as header?
   E918 C2 12 E9      [ 9] 1425         JP      NZ,GETHDR       ; No - Wait for another
   E91B 0D            [ 4] 1426         DEC     C               ; Count bytes
   E91C C2 14 E9      [ 9] 1427         JP      NZ,HDRLP        ; More needed
   E91F CD 46 ED      [16] 1428 SNDARY: CALL    TSTNUM          ; Check it's a numerical array
   E922 CD 8C E6      [16] 1429 ARYLP:  CALL    CPDEHL          ; All array data done
   E925 CA 39 E9      [ 9] 1430         JP      Z,SUMOFF        ; Yes - Do check sum
   E928 F1            [ 9] 1431         POP     AF              ; CLOAD* or CSAVE* ?
   E929 F5            [11] 1432         PUSH    AF              ; Re-save flags
   E92A 7E            [ 6] 1433         LD      A,(HL)          ; Get byte
   E92B F4 BC F4      [16] 1434         CALL    P,WUART         ; CSAVE* - Write byte
   E92E FC B6 F4      [16] 1435         CALL    M,RUART         ; CLOAD* - Read byte
   E931 77            [ 7] 1436         LD      (HL),A          ; Save byte in case of CLOAD*
   E932 CD 42 E9      [16] 1437         CALL    ACCSUM          ; Accumulate check sum
   E935 23            [ 4] 1438         INC     HL              ; Next byte
   E936 C3 22 E9      [ 9] 1439         JP      ARYLP           ; Repeat
                           1440 
   E939 CD 4F E9      [16] 1441 SUMOFF: CALL    DOSUM           ; Do check sum
   E93C CD D7 FC      [16] 1442         CALL    CASFF           ; Cassette off
   E93F F1            [ 9] 1443         POP     AF              ; Not needed any more
   E940 E1            [ 9] 1444         POP     HL              ; Restore code string address
   E941 C9            [ 9] 1445         RET
                           1446 
   E942 E5            [11] 1447 ACCSUM: PUSH    HL              ; Save address in array
   E943 2A 4A 10      [15] 1448         LD      HL,(CHKSUM)     ; Get check sum
   E946 06 00         [ 6] 1449         LD      B,#0             ; BC - Value of byte
   E948 4F            [ 4] 1450         LD      C,A
   E949 09            [ 7] 1451         ADD     HL,BC           ; Add byte to check sum
   E94A 22 4A 10      [16] 1452         LD      (CHKSUM),HL     ; Re-save check sum
   E94D E1            [ 9] 1453         POP     HL              ; Restore address in array
   E94E C9            [ 9] 1454         RET
                           1455 
   E94F 3A CE 10      [12] 1456 DOSUM:  LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
   E952 B7            [ 4] 1457         OR      A
   E953 FA 62 E9      [ 9] 1458         JP      M,CHSUMS        ; CLOAD* - Check if sums match
   E956 3A 4A 10      [12] 1459         LD      A,(CHKSUM)      ; Get LSB of check sum
   E959 CD BC F4      [16] 1460         CALL    WUART           ; Write to UART
   E95C 3A 4B 10      [12] 1461         LD      A,(CHKSUM+1)    ; Get MSB of check sum
   E95F C3 BC F4      [ 9] 1462         JP      WUART           ; Write to UART and return
                           1463 
   E962 CD B6 F4      [16] 1464 CHSUMS: CALL    RUART           ; Read LSB of check sum
   E965 F5            [11] 1465         PUSH    AF              ; Save it
   E966 CD B6 F4      [16] 1466         CALL    RUART           ; Read MSB of check sum
   E969 C1            [ 9] 1467         POP     BC              ; LSB to B
   E96A 58            [ 4] 1468         LD      E,B             ; LSB to E
   E96B 57            [ 4] 1469         LD      D,A             ; MSB to D
   E96C 2A 4A 10      [15] 1470         LD      HL,(CHKSUM)     ; Get accumulated check sum
   E96F CD 8C E6      [16] 1471         CALL    CPDEHL          ; Are they the same?
   E972 C8            [10] 1472         RET     Z               ; Yes - End CLOAD*
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 28.
Hexadecimal [16-Bits]



   E973 CD D7 FC      [16] 1473         CALL    CASFF           ; Cassette off
   E976 C3 6D F5      [ 9] 1474         JP      OUTBAD          ; Different - Output "Bad"
                           1475 
   E979 7E            [ 6] 1476 CHKLTR: LD      A,(HL)          ; Get byte
   E97A FE 41         [ 6] 1477         CP      #"A"             ; < "A" ?
   E97C D8            [10] 1478         RET     C               ; Carry set if not letter
   E97D FE 5B         [ 6] 1479         CP      #"Z"+1           ; > "Z" ?
   E97F 3F            [ 3] 1480         CCF
   E980 C9            [ 9] 1481         RET                     ; Carry set if not letter
                           1482 
   E981 CD 38 E8      [16] 1483 FPSINT: CALL    GETCHR          ; Get next character
   E984 CD 43 ED      [16] 1484 POSINT: CALL    GETNUM          ; Get integer 0 to 32767
   E987 CD 15 F8      [16] 1485 DEPINT: CALL    TSTSGN          ; Test sign of FPREG
   E98A FA A2 E9      [ 9] 1486         JP      M,FCERR         ; Negative - ?FC Error
   E98D 3A E7 10      [12] 1487 DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
   E990 FE 90         [ 6] 1488         CP      #0x80+16          ; Exponent in range (16 bits)?
   E992 DA BD F8      [ 9] 1489         JP      C,FPINT         ; Yes - convert it
   E995 01 80 90      [ 9] 1490         LD      BC,#0x9080        ; BCDE = -32768
   E998 11 00 00      [ 9] 1491         LD      DE,#0000
   E99B E5            [11] 1492         PUSH    HL              ; Save code string address
   E99C CD 90 F8      [16] 1493         CALL    CMPNUM          ; Compare FPREG with BCDE
   E99F E1            [ 9] 1494         POP     HL              ; Restore code string address
   E9A0 51            [ 4] 1495         LD      D,C             ; MSB to D
   E9A1 C8            [10] 1496         RET     Z               ; Return if in range
   E9A2 1E 08         [ 6] 1497 FCERR:  LD      E,#FC            ; ?FC Error
   E9A4 C3 C3 E3      [ 9] 1498         JP      ERROR           ; Output error-
                           1499 
   E9A7 2B            [ 4] 1500 ATOH:   DEC     HL              ; ASCII number to DE binary
   E9A8 11 00 00      [ 9] 1501 GETLN:  LD      DE,#0            ; Get number to DE
   E9AB CD 38 E8      [16] 1502 GTLNLP: CALL    GETCHR          ; Get next character
   E9AE D0            [10] 1503         RET     NC              ; Exit if not a digit
   E9AF E5            [11] 1504         PUSH    HL              ; Save code string address
   E9B0 F5            [11] 1505         PUSH    AF              ; Save digit
   E9B1 21 98 19      [ 9] 1506         LD      HL,#65529/10     ; Largest number 65529
   E9B4 CD 8C E6      [16] 1507         CALL    CPDEHL          ; Number in range?
   E9B7 DA AF E3      [ 9] 1508         JP      C,SNERR         ; No - ?SN Error
   E9BA 62            [ 4] 1509         LD      H,D             ; HL = Number
   E9BB 6B            [ 4] 1510         LD      L,E
   E9BC 19            [ 7] 1511         ADD     HL,DE           ; Times 2
   E9BD 29            [ 7] 1512         ADD     HL,HL           ; Times 4
   E9BE 19            [ 7] 1513         ADD     HL,DE           ; Times 5
   E9BF 29            [ 7] 1514         ADD     HL,HL           ; Times 10
   E9C0 F1            [ 9] 1515         POP     AF              ; Restore digit
   E9C1 D6 30         [ 6] 1516         SUB     #"0"             ; Make it 0 to 9
   E9C3 5F            [ 4] 1517         LD      E,A             ; DE = Value of digit
   E9C4 16 00         [ 6] 1518         LD      D,#0
   E9C6 19            [ 7] 1519         ADD     HL,DE           ; Add to number
   E9C7 EB            [ 3] 1520         EX      DE,HL           ; Number to DE
   E9C8 E1            [ 9] 1521         POP     HL              ; Restore code string address
   E9C9 C3 AB E9      [ 9] 1522         JP      GTLNLP          ; Go to next character
                           1523 
   E9CC CA CB E4      [ 9] 1524 CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
   E9CF CD 84 E9      [16] 1525         CALL    POSINT          ; Get integer 0 to 32767 to DE
   E9D2 2B            [ 4] 1526         DEC     HL              ; Cancel increment
   E9D3 CD 38 E8      [16] 1527         CALL    GETCHR          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 29.
Hexadecimal [16-Bits]



   E9D6 E5            [11] 1528         PUSH    HL              ; Save code string address
   E9D7 2A AF 10      [15] 1529         LD      HL,(LSTRAM)     ; Get end of RAM
   E9DA CA EF E9      [ 9] 1530         JP      Z,STORED        ; No value given - Use stored
   E9DD E1            [ 9] 1531         POP     HL              ; Restore code string address
   E9DE CD 92 E6      [16] 1532         CALL    CHKSYN          ; Check for comma
   E9E1 2C                 1533         .db      ","
   E9E2 D5            [11] 1534         PUSH    DE              ; Save number
   E9E3 CD 84 E9      [16] 1535         CALL    POSINT          ; Get integer 0 to 32767
   E9E6 2B            [ 4] 1536         DEC     HL              ; Cancel increment
   E9E7 CD 38 E8      [16] 1537         CALL    GETCHR          ; Get next character
   E9EA C2 AF E3      [ 9] 1538         JP      NZ,SNERR        ; ?SN Error if more on line
   E9ED E3            [16] 1539         EX      (SP),HL         ; Save code string address
   E9EE EB            [ 3] 1540         EX      DE,HL           ; Number to DE
   E9EF 7D            [ 4] 1541 STORED: LD      A,L             ; Get LSB of new RAM top
   E9F0 93            [ 4] 1542         SUB     E               ; Subtract LSB of string space
   E9F1 5F            [ 4] 1543         LD      E,A             ; Save LSB
   E9F2 7C            [ 4] 1544         LD      A,H             ; Get MSB of new RAM top
   E9F3 9A            [ 4] 1545         SBC     A,D             ; Subtract MSB of string space
   E9F4 57            [ 4] 1546         LD      D,A             ; Save MSB
   E9F5 DA A4 E3      [ 9] 1547         JP      C,OMERR         ; ?OM Error if not enough mem
   E9F8 E5            [11] 1548         PUSH    HL              ; Save RAM top
   E9F9 2A D6 10      [15] 1549         LD      HL,(PROGND)     ; Get program end
   E9FC 01 28 00      [ 9] 1550         LD      BC,#40           ; 40 Bytes minimum working RAM
   E9FF 09            [ 7] 1551         ADD     HL,BC           ; Get lowest address
   EA00 CD 8C E6      [16] 1552         CALL    CPDEHL          ; Enough memory?
   EA03 D2 A4 E3      [ 9] 1553         JP      NC,OMERR        ; No - ?OM Error
   EA06 EB            [ 3] 1554         EX      DE,HL           ; RAM top to HL
   EA07 22 5A 10      [16] 1555         LD      (STRSPC),HL     ; Set new string space
   EA0A E1            [ 9] 1556         POP     HL              ; End of memory to use
   EA0B 22 AF 10      [16] 1557         LD      (LSTRAM),HL     ; Set new top of RAM
   EA0E E1            [ 9] 1558         POP     HL              ; Restore code string address
   EA0F C3 CB E4      [ 9] 1559         JP      INTVAR          ; Initialise variables
                           1560 
   EA12 CA C7 E4      [ 9] 1561 RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
   EA15 CD CB E4      [16] 1562         CALL    INTVAR          ; Initialise variables
   EA18 01 F4 E7      [ 9] 1563         LD      BC,#RUNCNT       ; Execution driver loop
   EA1B C3 2E EA      [ 9] 1564         JP      RUNLIN          ; RUN from line number
                           1565 
   EA1E 0E 03         [ 6] 1566 GOSUB:  LD      C,#3             ; 3 Levels of stack needed
   EA20 CD 8C E3      [16] 1567         CALL    CHKSTK          ; Check for 3 levels of stack
   EA23 C1            [ 9] 1568         POP     BC              ; Get return address
   EA24 E5            [11] 1569         PUSH    HL              ; Save code string for RETURN
   EA25 E5            [11] 1570         PUSH    HL              ; And for GOSUB routine
   EA26 2A 5C 10      [15] 1571         LD      HL,(LINEAT)     ; Get current line
   EA29 E3            [16] 1572         EX      (SP),HL         ; Into stack - Code string out
   EA2A 3E 8C         [ 6] 1573         LD      A,#ZGOSUB        ; "GOSUB" token
   EA2C F5            [11] 1574         PUSH    AF              ; Save token
   EA2D 33            [ 4] 1575         INC     SP              ; Don't save flags
                           1576 
   EA2E C5            [11] 1577 RUNLIN: PUSH    BC              ; Save return address
   EA2F CD A7 E9      [16] 1578 GOTO:   CALL    ATOH            ; ASCII number to DE binary
   EA32 CD 74 EA      [16] 1579         CALL    REM             ; Get end of line
   EA35 E5            [11] 1580         PUSH    HL              ; Save end of line
   EA36 2A 5C 10      [15] 1581         LD      HL,(LINEAT)     ; Get current line
   EA39 CD 8C E6      [16] 1582         CALL    CPDEHL          ; Line after current?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 30.
Hexadecimal [16-Bits]



   EA3C E1            [ 9] 1583         POP     HL              ; Restore end of line
   EA3D 23            [ 4] 1584         INC     HL              ; Start of next line
   EA3E DC 9E E4      [16] 1585         CALL    C,SRCHLP        ; Line is after current line
   EA41 D4 9B E4      [16] 1586         CALL    NC,SRCHLN       ; Line is before current line
   EA44 60            [ 4] 1587         LD      H,B             ; Set up code string address
   EA45 69            [ 4] 1588         LD      L,C
   EA46 2B            [ 4] 1589         DEC     HL              ; Incremented after
   EA47 D8            [10] 1590         RET     C               ; Line found
   EA48 1E 0E         [ 6] 1591 ULERR:  LD      E,#UL            ; ?UL Error
   EA4A C3 C3 E3      [ 9] 1592         JP      ERROR           ; Output error message
                           1593 
   EA4D C0            [10] 1594 RETURN: RET     NZ              ; Return if not just RETURN
   EA4E 16 FF         [ 6] 1595         LD      D,#-1            ; Flag "GOSUB" search
   EA50 CD 58 E3      [16] 1596         CALL    BAKSTK          ; Look "GOSUB" block
   EA53 F9            [ 4] 1597         LD      SP,HL           ; Kill all FORs in subroutine
   EA54 FE 8C         [ 6] 1598         CP      #ZGOSUB          ; Test for "GOSUB" token
   EA56 1E 04         [ 6] 1599         LD      E,#RG            ; ?RG Error
   EA58 C2 C3 E3      [ 9] 1600         JP      NZ,ERROR        ; Error if no "GOSUB" found
   EA5B E1            [ 9] 1601         POP     HL              ; Get RETURN line number
   EA5C 22 5C 10      [16] 1602         LD      (LINEAT),HL     ; Save as current
   EA5F 23            [ 4] 1603         INC     HL              ; Was it from direct statement?
   EA60 7C            [ 4] 1604         LD      A,H
   EA61 B5            [ 4] 1605         OR      L               ; Return to line
   EA62 C2 6C EA      [ 9] 1606         JP      NZ,RETLIN       ; No - Return to line
   EA65 3A CC 10      [12] 1607         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
   EA68 B7            [ 4] 1608         OR      A               ; If so buffer is corrupted
   EA69 C2 F9 E3      [ 9] 1609         JP      NZ,POPNOK       ; Yes - Go to command mode
   EA6C 21 F4 E7      [ 9] 1610 RETLIN: LD      HL,#RUNCNT       ; Execution driver loop
   EA6F E3            [16] 1611         EX      (SP),HL         ; Into stack - Code string out
   EA70 3E                 1612         .db      0x3E             ; Skip "POP HL"
   EA71 E1            [ 9] 1613 NXTDTA: POP     HL              ; Restore code string address
                           1614 
   EA72 01 3A              1615 DATA:   .db      0x01,0x3A         ; ":" End of statement
   EA74 0E 00         [ 6] 1616 REM:    LD      C,#0             ; 00  End of statement
   EA76 06 00         [ 6] 1617         LD      B,#0
   EA78 79            [ 4] 1618 NXTSTL: LD      A,C             ; Statement and byte
   EA79 48            [ 4] 1619         LD      C,B
   EA7A 47            [ 4] 1620         LD      B,A             ; Statement end byte
   EA7B 7E            [ 6] 1621 NXTSTT: LD      A,(HL)          ; Get byte
   EA7C B7            [ 4] 1622         OR      A               ; End of line?
   EA7D C8            [10] 1623         RET     Z               ; Yes - Exit
   EA7E B8            [ 4] 1624         CP      B               ; End of statement?
   EA7F C8            [10] 1625         RET     Z               ; Yes - Exit
   EA80 23            [ 4] 1626         INC     HL              ; Next byte
   EA81 FE 22         [ 6] 1627         CP      #'"'             ; Literal string?"
   EA83 CA 78 EA      [ 9] 1628         JP      Z,NXTSTL        ; Yes - Look for another '"'
   EA86 C3 7B EA      [ 9] 1629         JP      NXTSTT          ; Keep looking
                           1630 
   EA89 CD 2F EF      [16] 1631 LET:    CALL    GETVAR          ; Get variable name
   EA8C CD 92 E6      [16] 1632         CALL    CHKSYN          ; Make sure "=" follows
   EA8F B4                 1633         .db      ZEQUAL          ; "=" token
   EA90 D5            [11] 1634         PUSH    DE              ; Save address of variable
   EA91 3A AD 10      [12] 1635         LD      A,(TYPE)        ; Get data type
   EA94 F5            [11] 1636         PUSH    AF              ; Save type
   EA95 CD 5C ED      [16] 1637         CALL    EVAL            ; Evaluate expression
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 31.
Hexadecimal [16-Bits]



   EA98 F1            [ 9] 1638         POP     AF              ; Restore type
   EA99 E3            [16] 1639         EX      (SP),HL         ; Save code - Get var addr
   EA9A 22 CE 10      [16] 1640         LD      (BRKLIN),HL     ; Save address of variable
   EA9D 1F            [ 3] 1641         RRA                     ; Adjust type
   EA9E CD 48 ED      [16] 1642         CALL    CHKTYP          ; Check types are the same
   EAA1 CA DC EA      [ 9] 1643         JP      Z,LETNUM        ; Numeric - Move value
   EAA4 E5            [11] 1644 LETSTR: PUSH    HL              ; Save address of string var
   EAA5 2A E4 10      [15] 1645         LD      HL,(FPREG)      ; Pointer to string entry
   EAA8 E5            [11] 1646         PUSH    HL              ; Save it on stack
   EAA9 23            [ 4] 1647         INC     HL              ; Skip over length
   EAAA 23            [ 4] 1648         INC     HL
   EAAB 5E            [ 6] 1649         LD      E,(HL)          ; LSB of string address
   EAAC 23            [ 4] 1650         INC     HL
   EAAD 56            [ 6] 1651         LD      D,(HL)          ; MSB of string address
   EAAE 2A 5E 10      [15] 1652         LD      HL,(BASTXT)     ; Point to start of program
   EAB1 CD 8C E6      [16] 1653         CALL    CPDEHL          ; Is string before program?
   EAB4 D2 CB EA      [ 9] 1654         JP      NC,CRESTR       ; Yes - Create string entry
   EAB7 2A 5A 10      [15] 1655         LD      HL,(STRSPC)     ; Point to string space
   EABA CD 8C E6      [16] 1656         CALL    CPDEHL          ; Is string literal in program?
   EABD D1            [ 9] 1657         POP     DE              ; Restore address of string
   EABE D2 D3 EA      [ 9] 1658         JP      NC,MVSTPT       ; Yes - Set up pointer
   EAC1 21 BF 10      [ 9] 1659         LD      HL,#TMPSTR       ; Temporary string pool
   EAC4 CD 8C E6      [16] 1660         CALL    CPDEHL          ; Is string in temporary pool?
   EAC7 D2 D3 EA      [ 9] 1661         JP      NC,MVSTPT       ; No - Set up pointer
   EACA 3E                 1662         .db      0x3E             ; Skip "POP DE"
   EACB D1            [ 9] 1663 CRESTR: POP     DE              ; Restore address of string
   EACC CD 73 F3      [16] 1664         CALL    BAKTMP          ; Back to last tmp-str entry
   EACF EB            [ 3] 1665         EX      DE,HL           ; Address of string entry
   EAD0 CD AC F1      [16] 1666         CALL    SAVSTR          ; Save string in string area
   EAD3 CD 73 F3      [16] 1667 MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
   EAD6 E1            [ 9] 1668         POP     HL              ; Get string pointer
   EAD7 CD 70 F8      [16] 1669         CALL    DETHL4          ; Move string pointer to var
   EADA E1            [ 9] 1670         POP     HL              ; Restore code string address
   EADB C9            [ 9] 1671         RET
                           1672 
   EADC E5            [11] 1673 LETNUM: PUSH    HL              ; Save address of variable
   EADD CD 6D F8      [16] 1674         CALL    FPTHL           ; Move value to variable
   EAE0 D1            [ 9] 1675         POP     DE              ; Restore address of variable
   EAE1 E1            [ 9] 1676         POP     HL              ; Restore code string address
   EAE2 C9            [ 9] 1677         RET
                           1678 
   EAE3 CD 86 F4      [16] 1679 ON:     CALL    GETINT          ; Get integer 0-255
   EAE6 7E            [ 6] 1680         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
   EAE7 47            [ 4] 1681         LD      B,A             ; Save in B
   EAE8 FE 8C         [ 6] 1682         CP      #ZGOSUB          ; "GOSUB" token?
   EAEA CA F2 EA      [ 9] 1683         JP      Z,ONGO          ; Yes - Find line number
   EAED CD 92 E6      [16] 1684         CALL    CHKSYN          ; Make sure it's "GOTO"
   EAF0 88                 1685         .db      ZGOTO           ; "GOTO" token
   EAF1 2B            [ 4] 1686         DEC     HL              ; Cancel increment
   EAF2 4B            [ 4] 1687 ONGO:   LD      C,E             ; Integer of branch value
   EAF3 0D            [ 4] 1688 ONGOLP: DEC     C               ; Count branches
   EAF4 78            [ 4] 1689         LD      A,B             ; Get "GOTO" or "GOSUB" token
   EAF5 CA 20 E8      [ 9] 1690         JP      Z,ONJMP         ; Go to that line if right one
   EAF8 CD A8 E9      [16] 1691         CALL    GETLN           ; Get line number to DE
   EAFB FE 2C         [ 6] 1692         CP      #","             ; Another line number?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 32.
Hexadecimal [16-Bits]



   EAFD C0            [10] 1693         RET     NZ              ; No - Drop through
   EAFE C3 F3 EA      [ 9] 1694         JP      ONGOLP          ; Yes - loop
                           1695 
   EB01 CD 5C ED      [16] 1696 IF:     CALL    EVAL            ; Evaluate expression
   EB04 7E            [ 6] 1697         LD      A,(HL)          ; Get token
   EB05 FE 88         [ 6] 1698         CP      #ZGOTO           ; "GOTO" token?
   EB07 CA 0F EB      [ 9] 1699         JP      Z,IFGO          ; Yes - Get line
   EB0A CD 92 E6      [16] 1700         CALL    CHKSYN          ; Make sure it's "THEN"
   EB0D A9                 1701         .db      ZTHEN           ; "THEN" token
   EB0E 2B            [ 4] 1702         DEC     HL              ; Cancel increment
   EB0F CD 46 ED      [16] 1703 IFGO:   CALL    TSTNUM          ; Make sure it's numeric
   EB12 CD 15 F8      [16] 1704         CALL    TSTSGN          ; Test state of expression
   EB15 CA 74 EA      [ 9] 1705         JP      Z,REM           ; False - Drop through
   EB18 CD 38 E8      [16] 1706         CALL    GETCHR          ; Get next character
   EB1B DA 2F EA      [ 9] 1707         JP      C,GOTO          ; Number - GOTO that line
   EB1E C3 1F E8      [ 9] 1708         JP      IFJMP           ; Otherwise do statement
                           1709 
   EB21 2B            [ 4] 1710 MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
   EB22 CD 38 E8      [16] 1711         CALL    GETCHR          ; Get next character
   EB25 CA 83 EB      [ 9] 1712 PRINT:  JP      Z,PRNTCR        ; CRLF if just PRINT
   EB28 C8            [10] 1713 PRNTLP: RET     Z               ; End of list - Exit
   EB29 FE A5         [ 6] 1714         CP      #ZTAB            ; "TAB(" token?
   EB2B CA B1 EB      [ 9] 1715         JP      Z,DOTAB         ; Yes - Do TAB routine
   EB2E FE A8         [ 6] 1716         CP      #ZSPC            ; "SPC(" token?
   EB30 CA B1 EB      [ 9] 1717         JP      Z,DOTAB         ; Yes - Do SPC routine
   EB33 E5            [11] 1718         PUSH    HL              ; Save code string address
   EB34 FE 2C         [ 6] 1719         CP      #","             ; Comma?
   EB36 CA 9A EB      [ 9] 1720         JP      Z,DOCOM         ; Yes - Move to next zone
   EB39 FE 3B         [ 6] 1721         CP      #";"             ; Semi-colon?
   EB3B CA D4 EB      [ 9] 1722         JP      Z,NEXITM        ; Do semi-colon routine
   EB3E C1            [ 9] 1723         POP     BC              ; Code string address to BC
   EB3F CD 5C ED      [16] 1724         CALL    EVAL            ; Evaluate expression
   EB42 E5            [11] 1725         PUSH    HL              ; Save code string address
   EB43 3A AD 10      [12] 1726         LD      A,(TYPE)        ; Get variable type
   EB46 B7            [ 4] 1727         OR      A               ; Is it a string variable?
   EB47 C2 6F EB      [ 9] 1728         JP      NZ,PRNTST       ; Yes - Output string contents
   EB4A CD BA F9      [16] 1729         CALL    NUMASC          ; Convert number to text
   EB4D CD D0 F1      [16] 1730         CALL    CRTST           ; Create temporary string
   EB50 36 20         [ 9] 1731         LD      (HL),#" "        ; Followed by a space
   EB52 2A E4 10      [15] 1732         LD      HL,(FPREG)      ; Get length of output
   EB55 34            [10] 1733         INC     (HL)            ; Plus 1 for the space
   EB56 2A E4 10      [15] 1734         LD      HL,(FPREG)      ; < Not needed >
   EB59 3A 42 10      [12] 1735         LD      A,(LWIDTH)      ; Get width of line
   EB5C 47            [ 4] 1736         LD      B,A             ; To B
   EB5D 04            [ 4] 1737         INC     B               ; Width 255 (No limit)?
   EB5E CA 6B EB      [ 9] 1738         JP      Z,PRNTNB        ; Yes - Output number string
   EB61 04            [ 4] 1739         INC     B               ; Adjust it
   EB62 3A AB 10      [12] 1740         LD      A,(CURPOS)      ; Get cursor position
   EB65 86            [ 6] 1741         ADD     A,(HL)          ; Add length of string
   EB66 3D            [ 4] 1742         DEC     A               ; Adjust it
   EB67 B8            [ 4] 1743         CP      B               ; Will output fit on this line?
   EB68 D4 83 EB      [16] 1744         CALL    NC,PRNTCR       ; No - CRLF first
   EB6B CD 15 F2      [16] 1745 PRNTNB: CALL    PRS1            ; Output string at (HL)
   EB6E AF            [ 4] 1746         XOR     A               ; Skip CALL by setting "Z" flag
   EB6F C4 15 F2      [16] 1747 PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 33.
Hexadecimal [16-Bits]



   EB72 E1            [ 9] 1748         POP     HL              ; Restore code string address
   EB73 C3 21 EB      [ 9] 1749         JP      MRPRNT          ; See if more to PRINT
                           1750 
   EB76 3A AB 10      [12] 1751 STTLIN: LD      A,(CURPOS)      ; Make sure on new line
   EB79 B7            [ 4] 1752         OR      A               ; Already at start?
   EB7A C8            [10] 1753         RET     Z               ; Yes - Do nothing
   EB7B C3 83 EB      [ 9] 1754         JP      PRNTCR          ; Start a new line
                           1755 
   EB7E 36 00         [ 9] 1756 ENDINP: LD      (HL),#0          ; Mark end of buffer
   EB80 21 60 10      [ 9] 1757         LD      HL,#BUFFER-1     ; Point to buffer
   EB83 3E 0D         [ 6] 1758 PRNTCR: LD      A,#CR            ; Load a CR
   EB85 CD 9D E6      [16] 1759         CALL    OUTC            ; Output character
   EB88 AF            [ 4] 1760 DONULL: XOR     A               ; Set to position 0
   EB89 32 AB 10      [13] 1761         LD      (CURPOS),A      ; Store it
   EB8C 3A 41 10      [12] 1762         LD      A,(NULLS)       ; Get number of nulls
   EB8F 3D            [ 4] 1763 NULLP:  DEC     A               ; Count them
   EB90 C8            [10] 1764         RET     Z               ; Return if done
   EB91 F5            [11] 1765         PUSH    AF              ; Save count
   EB92 AF            [ 4] 1766         XOR     A               ; Load a null
   EB93 CD 9D E6      [16] 1767         CALL    OUTC            ; Output it
   EB96 F1            [ 9] 1768         POP     AF              ; Restore count
   EB97 C3 8F EB      [ 9] 1769         JP      NULLP           ; Keep counting
                           1770 
   EB9A 3A 43 10      [12] 1771 DOCOM:  LD      A,(COMMAN)      ; Get comma width
   EB9D 47            [ 4] 1772         LD      B,A             ; Save in B
   EB9E 3A AB 10      [12] 1773         LD      A,(CURPOS)      ; Get current position
   EBA1 B8            [ 4] 1774         CP      B               ; Within the limit?
   EBA2 D4 83 EB      [16] 1775         CALL    NC,PRNTCR       ; No - output CRLF
   EBA5 D2 D4 EB      [ 9] 1776         JP      NC,NEXITM       ; Get next item
   EBA8 D6 0E         [ 6] 1777 ZONELP: SUB     #14              ; Next zone of 14 characters
   EBAA D2 A8 EB      [ 9] 1778         JP      NC,ZONELP       ; Repeat if more zones
   EBAD 2F            [ 3] 1779         CPL                     ; Number of spaces to output
   EBAE C3 C9 EB      [ 9] 1780         JP      ASPCS           ; Output them
                           1781 
   EBB1 F5            [11] 1782 DOTAB:  PUSH    AF              ; Save token
   EBB2 CD 83 F4      [16] 1783         CALL    FNDNUM          ; Evaluate expression
   EBB5 CD 92 E6      [16] 1784         CALL    CHKSYN          ; Make sure ")" follows
   EBB8 29                 1785         .db      ")"
   EBB9 2B            [ 4] 1786         DEC     HL              ; Back space on to ")"
   EBBA F1            [ 9] 1787         POP     AF              ; Restore token
   EBBB D6 A8         [ 6] 1788         SUB     #ZSPC            ; Was it "SPC(" ?
   EBBD E5            [11] 1789         PUSH    HL              ; Save code string address
   EBBE CA C4 EB      [ 9] 1790         JP      Z,DOSPC         ; Yes - Do "E" spaces
   EBC1 3A AB 10      [12] 1791         LD      A,(CURPOS)      ; Get current position
   EBC4 2F            [ 3] 1792 DOSPC:  CPL                     ; Number of spaces to print to
   EBC5 83            [ 4] 1793         ADD     A,E             ; Total number to print
   EBC6 D2 D4 EB      [ 9] 1794         JP      NC,NEXITM       ; TAB < Current POS(X)
   EBC9 3C            [ 4] 1795 ASPCS:  INC     A               ; Output A spaces
   EBCA 47            [ 4] 1796         LD      B,A             ; Save number to print
   EBCB 3E 20         [ 6] 1797         LD      A,#" "           ; Space
   EBCD CD 9D E6      [16] 1798 SPCLP:  CALL    OUTC            ; Output character in A
   EBD0 05            [ 4] 1799         DEC     B               ; Count them
   EBD1 C2 CD EB      [ 9] 1800         JP      NZ,SPCLP        ; Repeat if more
   EBD4 E1            [ 9] 1801 NEXITM: POP     HL              ; Restore code string address
   EBD5 CD 38 E8      [16] 1802         CALL    GETCHR          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 34.
Hexadecimal [16-Bits]



   EBD8 C3 28 EB      [ 9] 1803         JP      PRNTLP          ; More to print
                           1804 
   EBDB 3F 52 65 64 6F 20  1805 REDO:   .ascii      "?Redo from start"
        66 72 6F 6D 20 73
        74 61 72 74
   EBEB 0D 0A 00           1806         .db CR,LF,0
                           1807 
   EBEE 3A CD 10      [12] 1808 BADINP: LD      A,(READFG)      ; READ or INPUT?
   EBF1 B7            [ 4] 1809         OR      A
   EBF2 C2 A9 E3      [ 9] 1810         JP      NZ,DATSNR       ; READ - ?SN Error
   EBF5 C1            [ 9] 1811         POP     BC              ; Throw away code string addr
   EBF6 21 DB EB      [ 9] 1812         LD      HL,#REDO         ; "Redo from start" message
   EBF9 CD 12 F2      [16] 1813         CALL    PRS             ; Output string
   EBFC C3 FA E4      [ 9] 1814         JP      DOAGN           ; Do last INPUT again
                           1815 
   EBFF CD 7D F1      [16] 1816 INPUT:  CALL    IDTEST          ; Test for illegal direct
   EC02 7E            [ 6] 1817         LD      A,(HL)          ; Get character after "INPUT"
   EC03 FE 22         [ 6] 1818         CP      #'"'             ; Is there a prompt string?"
   EC05 3E 00         [ 6] 1819         LD      A,#0             ; Clear A and leave flags
   EC07 32 45 10      [13] 1820         LD      (CTLOFG),A      ; Enable output
   EC0A C2 19 EC      [ 9] 1821         JP      NZ,NOPMPT       ; No prompt - get input
   EC0D CD D1 F1      [16] 1822         CALL    QTSTR           ; Get string terminated by '"'
   EC10 CD 92 E6      [16] 1823         CALL    CHKSYN          ; Check for ";" after prompt
   EC13 3B                 1824         .db      ";"
   EC14 E5            [11] 1825         PUSH    HL              ; Save code string address
   EC15 CD 15 F2      [16] 1826         CALL    PRS1            ; Output prompt string
   EC18 3E                 1827         .db      0x3E             ; Skip "PUSH HL"
   EC19 E5            [11] 1828 NOPMPT: PUSH    HL              ; Save code string address
   EC1A CD FE E4      [16] 1829         CALL    PROMPT          ; Get input with "? " prompt
   EC1D C1            [ 9] 1830         POP     BC              ; Restore code string address
   EC1E DA 79 E8      [ 9] 1831         JP      C,INPBRK        ; Break pressed - Exit
   EC21 23            [ 4] 1832         INC     HL              ; Next byte
   EC22 7E            [ 6] 1833         LD      A,(HL)          ; Get it
   EC23 B7            [ 4] 1834         OR      A               ; End of line?
   EC24 2B            [ 4] 1835         DEC     HL              ; Back again
   EC25 C5            [11] 1836         PUSH    BC              ; Re-save code string address
   EC26 CA 71 EA      [ 9] 1837         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
   EC29 36 2C         [ 9] 1838         LD      (HL),#","        ; Store comma as separator
   EC2B C3 33 EC      [ 9] 1839         JP      NXTITM          ; Get next item
                           1840 
   EC2E E5            [11] 1841 READ:   PUSH    HL              ; Save code string address
   EC2F 2A DC 10      [15] 1842         LD      HL,(NXTDAT)     ; Next DATA statement
   EC32 F6                 1843         .db      0x0F6            ; Flag "READ"
   EC33 AF            [ 4] 1844 NXTITM: XOR     A               ; Flag "INPUT"
   EC34 32 CD 10      [13] 1845         LD      (READFG),A      ; Save "READ"/"INPUT" flag
   EC37 E3            [16] 1846         EX      (SP),HL         ; Get code str' , Save pointer
   EC38 C3 3F EC      [ 9] 1847         JP      GTVLUS          ; Get values
                           1848 
   EC3B CD 92 E6      [16] 1849 NEDMOR: CALL    CHKSYN          ; Check for comma between items
   EC3E 2C                 1850         .db      ","
   EC3F CD 2F EF      [16] 1851 GTVLUS: CALL    GETVAR          ; Get variable name
   EC42 E3            [16] 1852         EX      (SP),HL         ; Save code str" , Get pointer
   EC43 D5            [11] 1853         PUSH    DE              ; Save variable address
   EC44 7E            [ 6] 1854         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
   EC45 FE 2C         [ 6] 1855         CP      #","             ; Comma?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 35.
Hexadecimal [16-Bits]



   EC47 CA 67 EC      [ 9] 1856         JP      Z,ANTVLU        ; Yes - Get another value
   EC4A 3A CD 10      [12] 1857         LD      A,(READFG)      ; Is it READ?
   EC4D B7            [ 4] 1858         OR      A
   EC4E C2 D4 EC      [ 9] 1859         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
   EC51 3E 3F         [ 6] 1860         LD      A,#"?"           ; More INPUT needed
   EC53 CD 9D E6      [16] 1861         CALL    OUTC            ; Output character
   EC56 CD FE E4      [16] 1862         CALL    PROMPT          ; Get INPUT with prompt
   EC59 D1            [ 9] 1863         POP     DE              ; Variable address
   EC5A C1            [ 9] 1864         POP     BC              ; Code string address
   EC5B DA 79 E8      [ 9] 1865         JP      C,INPBRK        ; Break pressed
   EC5E 23            [ 4] 1866         INC     HL              ; Point to next DATA byte
   EC5F 7E            [ 6] 1867         LD      A,(HL)          ; Get byte
   EC60 B7            [ 4] 1868         OR      A               ; Is it zero (No input) ?
   EC61 2B            [ 4] 1869         DEC     HL              ; Back space INPUT pointer
   EC62 C5            [11] 1870         PUSH    BC              ; Save code string address
   EC63 CA 71 EA      [ 9] 1871         JP      Z,NXTDTA        ; Find end of buffer
   EC66 D5            [11] 1872         PUSH    DE              ; Save variable address
   EC67 3A AD 10      [12] 1873 ANTVLU: LD      A,(TYPE)        ; Check data type
   EC6A B7            [ 4] 1874         OR      A               ; Is it numeric?
   EC6B CA 91 EC      [ 9] 1875         JP      Z,INPBIN        ; Yes - Convert to binary
   EC6E CD 38 E8      [16] 1876         CALL    GETCHR          ; Get next character
   EC71 57            [ 4] 1877         LD      D,A             ; Save input character
   EC72 47            [ 4] 1878         LD      B,A             ; Again
   EC73 FE 22         [ 6] 1879         CP      #'"'             ; Start of literal sting?"
   EC75 CA 85 EC      [ 9] 1880         JP      Z,STRENT        ; Yes - Create string entry
   EC78 3A CD 10      [12] 1881         LD      A,(READFG)      ; "READ" or "INPUT" ?
   EC7B B7            [ 4] 1882         OR      A
   EC7C 57            [ 4] 1883         LD      D,A             ; Save 00 if "INPUT"
   EC7D CA 82 EC      [ 9] 1884         JP      Z,ITMSEP        ; "INPUT" - End with 00
   EC80 16 3A         [ 6] 1885         LD      D,#":"           ; "DATA" - End with 00 or ":"
   EC82 06 2C         [ 6] 1886 ITMSEP: LD      B,#","           ; Item separator
   EC84 2B            [ 4] 1887         DEC     HL              ; Back space for DTSTR
   EC85 CD D4 F1      [16] 1888 STRENT: CALL    DTSTR           ; Get string terminated by D
   EC88 EB            [ 3] 1889         EX      DE,HL           ; String address to DE
   EC89 21 9C EC      [ 9] 1890         LD      HL,#LTSTND       ; Where to go after LETSTR
   EC8C E3            [16] 1891         EX      (SP),HL         ; Save HL , get input pointer
   EC8D D5            [11] 1892         PUSH    DE              ; Save address of string
   EC8E C3 A4 EA      [ 9] 1893         JP      LETSTR          ; Assign string to variable
                           1894 
   EC91 CD 38 E8      [16] 1895 INPBIN: CALL    GETCHR          ; Get next character
   EC94 CD 1C F9      [16] 1896         CALL    ASCTFP          ; Convert ASCII to FP number
   EC97 E3            [16] 1897         EX      (SP),HL         ; Save input ptr, Get var addr
   EC98 CD 6D F8      [16] 1898         CALL    FPTHL           ; Move FPREG to variable
   EC9B E1            [ 9] 1899         POP     HL              ; Restore input pointer
   EC9C 2B            [ 4] 1900 LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
   EC9D CD 38 E8      [16] 1901         CALL    GETCHR          ; Get next character
   ECA0 CA A8 EC      [ 9] 1902         JP      Z,MORDT         ; End of line - More needed?
   ECA3 FE 2C         [ 6] 1903         CP      #","             ; Another value?
   ECA5 C2 EE EB      [ 9] 1904         JP      NZ,BADINP       ; No - Bad input
   ECA8 E3            [16] 1905 MORDT:  EX      (SP),HL         ; Get code string address
   ECA9 2B            [ 4] 1906         DEC     HL              ; DEC 'cos GETCHR INCs
   ECAA CD 38 E8      [16] 1907         CALL    GETCHR          ; Get next character
   ECAD C2 3B EC      [ 9] 1908         JP      NZ,NEDMOR       ; More needed - Get it
   ECB0 D1            [ 9] 1909         POP     DE              ; Restore DATA pointer
   ECB1 3A CD 10      [12] 1910         LD      A,(READFG)      ; "READ" or "INPUT" ?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 36.
Hexadecimal [16-Bits]



   ECB4 B7            [ 4] 1911         OR      A
   ECB5 EB            [ 3] 1912         EX      DE,HL           ; DATA pointer to HL
   ECB6 C2 5E E8      [ 9] 1913         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
   ECB9 D5            [11] 1914         PUSH    DE              ; Save code string address
   ECBA B6            [ 6] 1915         OR      (HL)            ; More input given?
   ECBB 21 C3 EC      [ 9] 1916         LD      HL,#EXTIG        ; "?Extra ignored" message
   ECBE C4 12 F2      [16] 1917         CALL    NZ,PRS          ; Output string if extra given
   ECC1 E1            [ 9] 1918         POP     HL              ; Restore code string address
   ECC2 C9            [ 9] 1919         RET
                           1920 
   ECC3 3F 45 78 74 72 61  1921 EXTIG:  .ascii      "?Extra ignored"
        20 69 67 6E 6F 72
        65 64
   ECD1 0D 0A 00           1922         .db CR,LF,0
                           1923 
   ECD4 CD 72 EA      [16] 1924 FDTLP:  CALL    DATA            ; Get next statement
   ECD7 B7            [ 4] 1925         OR      A               ; End of line?
   ECD8 C2 ED EC      [ 9] 1926         JP      NZ,FANDT        ; No - See if DATA statement
   ECDB 23            [ 4] 1927         INC     HL
   ECDC 7E            [ 6] 1928         LD      A,(HL)          ; End of program?
   ECDD 23            [ 4] 1929         INC     HL
   ECDE B6            [ 6] 1930         OR      (HL)            ; 00 00 Ends program
   ECDF 1E 06         [ 6] 1931         LD      E,#OD            ; ?OD Error
   ECE1 CA C3 E3      [ 9] 1932         JP      Z,ERROR         ; Yes - Out of DATA
   ECE4 23            [ 4] 1933         INC     HL
   ECE5 5E            [ 6] 1934         LD      E,(HL)          ; LSB of line number
   ECE6 23            [ 4] 1935         INC     HL
   ECE7 56            [ 6] 1936         LD      D,(HL)          ; MSB of line number
   ECE8 EB            [ 3] 1937         EX      DE,HL
   ECE9 22 C9 10      [16] 1938         LD      (DATLIN),HL     ; Set line of current DATA item
   ECEC EB            [ 3] 1939         EX      DE,HL
   ECED CD 38 E8      [16] 1940 FANDT:  CALL    GETCHR          ; Get next character
   ECF0 FE 83         [ 6] 1941         CP      #ZDATA           ; "DATA" token
   ECF2 C2 D4 EC      [ 9] 1942         JP      NZ,FDTLP        ; No "DATA" - Keep looking
   ECF5 C3 67 EC      [ 9] 1943         JP      ANTVLU          ; Found - Convert input
                           1944 
   ECF8 11 00 00      [ 9] 1945 NEXT:   LD      DE,#0            ; In case no index given
   ECFB C4 2F EF      [16] 1946 NEXT1:  CALL    NZ,GETVAR       ; Get index address
   ECFE 22 CE 10      [16] 1947         LD      (BRKLIN),HL     ; Save code string address
   ED01 CD 58 E3      [16] 1948         CALL    BAKSTK          ; Look for "FOR" block
   ED04 C2 B5 E3      [ 9] 1949         JP      NZ,NFERR        ; No "FOR" - ?NF Error
   ED07 F9            [ 4] 1950         LD      SP,HL           ; Clear nested loops
   ED08 D5            [11] 1951         PUSH    DE              ; Save index address
   ED09 7E            [ 6] 1952         LD      A,(HL)          ; Get sign of STEP
   ED0A 23            [ 4] 1953         INC     HL
   ED0B F5            [11] 1954         PUSH    AF              ; Save sign of STEP
   ED0C D5            [11] 1955         PUSH    DE              ; Save index address
   ED0D CD 53 F8      [16] 1956         CALL    PHLTFP          ; Move index value to FPREG
   ED10 E3            [16] 1957         EX      (SP),HL         ; Save address of TO value
   ED11 E5            [11] 1958         PUSH    HL              ; Save address of index
   ED12 CD C0 F5      [16] 1959         CALL    ADDPHL          ; Add STEP to index value
   ED15 E1            [ 9] 1960         POP     HL              ; Restore address of index
   ED16 CD 6D F8      [16] 1961         CALL    FPTHL           ; Move value to index variable
   ED19 E1            [ 9] 1962         POP     HL              ; Restore address of TO value
   ED1A CD 64 F8      [16] 1963         CALL    LOADFP          ; Move TO value to BCDE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 37.
Hexadecimal [16-Bits]



   ED1D E5            [11] 1964         PUSH    HL              ; Save address of line of FOR
   ED1E CD 90 F8      [16] 1965         CALL    CMPNUM          ; Compare index with TO value
   ED21 E1            [ 9] 1966         POP     HL              ; Restore address of line num
   ED22 C1            [ 9] 1967         POP     BC              ; Address of sign of STEP
   ED23 90            [ 4] 1968         SUB     B               ; Compare with expected sign
   ED24 CD 64 F8      [16] 1969         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
   ED27 CA 33 ED      [ 9] 1970         JP      Z,KILFOR        ; Loop finished - Terminate it
   ED2A EB            [ 3] 1971         EX      DE,HL           ; Loop statement line number
   ED2B 22 5C 10      [16] 1972         LD      (LINEAT),HL     ; Set loop line number
   ED2E 69            [ 4] 1973         LD      L,C             ; Set code string to loop
   ED2F 60            [ 4] 1974         LD      H,B
   ED30 C3 F0 E7      [ 9] 1975         JP      PUTFID          ; Put back "FOR" and continue
                           1976 
   ED33 F9            [ 4] 1977 KILFOR: LD      SP,HL           ; Remove "FOR" block
   ED34 2A CE 10      [15] 1978         LD      HL,(BRKLIN)     ; Code string after "NEXT"
   ED37 7E            [ 6] 1979         LD      A,(HL)          ; Get next byte in code string
   ED38 FE 2C         [ 6] 1980         CP      #","             ; More NEXTs ?
   ED3A C2 F4 E7      [ 9] 1981         JP      NZ,#RUNCNT       ; No - Do next statement
   ED3D CD 38 E8      [16] 1982         CALL    GETCHR          ; Position to index name
   ED40 CD FB EC      [16] 1983         CALL    NEXT1           ; Re-enter NEXT routine
                           1984 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                           1985 
   ED43 CD 5C ED      [16] 1986 GETNUM: CALL    EVAL            ; Get a numeric expression
   ED46 F6                 1987 TSTNUM: .db      0x0F6            ; Clear carry (numeric)
   ED47 37            [ 3] 1988 TSTSTR: SCF                     ; Set carry (string)
   ED48 3A AD 10      [12] 1989 CHKTYP: LD      A,(TYPE)        ; Check types match
   ED4B 8F            [ 4] 1990         ADC     A,A             ; Expected + actual
   ED4C B7            [ 4] 1991         OR      A               ; Clear carry , set parity
   ED4D E8            [10] 1992         RET     PE              ; Even parity - Types match
   ED4E C3 C1 E3      [ 9] 1993         JP      TMERR           ; Different types - Error
                           1994 
                           1995 ; <<< NO REFERENCE TO HERE >>>
                           1996 
   ED51 CD 92 E6      [16] 1997         CALL    CHKSYN          ; Make sure "=" follows
   ED54 B4                 1998         .db      ZEQUAL          ; "="
   ED55 C3 5C ED      [ 9] 1999         JP      EVAL            ; Evaluate expression
                           2000 
   ED58 CD 92 E6      [16] 2001 OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
   ED5B 28                 2002         .db      #"("
   ED5C 2B            [ 4] 2003 EVAL:   DEC     HL              ; Evaluate expression & save
   ED5D 16 00         [ 6] 2004         LD      D,#0             ; Precedence value
   ED5F D5            [11] 2005 EVAL1:  PUSH    DE              ; Save precedence
   ED60 0E 01         [ 6] 2006         LD      C,#1
   ED62 CD 8C E3      [16] 2007         CALL    CHKSTK          ; Check for 1 level of stack
   ED65 CD D3 ED      [16] 2008         CALL    OPRND           ; Get next expression value
   ED68 22 D0 10      [16] 2009 EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
   ED6B 2A D0 10      [15] 2010 EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
   ED6E C1            [ 9] 2011         POP     BC              ; Precedence value and operator
   ED6F 78            [ 4] 2012         LD      A,B             ; Get precedence value
   ED70 FE 78         [ 6] 2013         CP      #0x78             ; "AND" or "OR" ?
   ED72 D4 46 ED      [16] 2014         CALL    NC,TSTNUM       ; No - Make sure it's a number
   ED75 7E            [ 6] 2015         LD      A,(HL)          ; Get next operator / function
   ED76 16 00         [ 6] 2016         LD      D,#0             ; Clear Last relation
   ED78 D6 B3         [ 6] 2017 RLTLP:  SUB     #ZGTR            ; ">" Token
   ED7A DA 94 ED      [ 9] 2018         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 38.
Hexadecimal [16-Bits]



   ED7D FE 03         [ 6] 2019         CP      #ZLTH+1-ZGTR     ; < = >
   ED7F D2 94 ED      [ 9] 2020         JP      NC,FOPRND       ; Function - Call it
   ED82 FE 01         [ 6] 2021         CP      #ZEQUAL-ZGTR     ; "="
   ED84 17            [ 3] 2022         RLA                     ; <- Test for legal
   ED85 AA            [ 4] 2023         XOR     D               ; <- combinations of < = >
   ED86 BA            [ 4] 2024         CP      D               ; <- by combining last token
   ED87 57            [ 4] 2025         LD      D,A             ; <- with current one
   ED88 DA AF E3      [ 9] 2026         JP      C,SNERR         ; Error if "<<" "==" or ">>"
   ED8B 22 C5 10      [16] 2027         LD      (CUROPR),HL     ; Save address of current token
   ED8E CD 38 E8      [16] 2028         CALL    GETCHR          ; Get next character
   ED91 C3 78 ED      [ 9] 2029         JP      RLTLP           ; Treat the two as one
                           2030 
   ED94 7A            [ 4] 2031 FOPRND: LD      A,D             ; < = > found ?
   ED95 B7            [ 4] 2032         OR      A
   ED96 C2 AA EE      [ 9] 2033         JP      NZ,TSTRED       ; Yes - Test for reduction
   ED99 7E            [ 6] 2034         LD      A,(HL)          ; Get operator token
   ED9A 22 C5 10      [16] 2035         LD      (CUROPR),HL     ; Save operator address
   ED9D D6 AC         [ 6] 2036         SUB     #ZPLUS           ; Operator or function?
   ED9F D8            [10] 2037         RET     C               ; Neither - Exit
   EDA0 FE 07         [ 6] 2038         CP      #ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
   EDA2 D0            [10] 2039         RET     NC              ; No - Exit
   EDA3 5F            [ 4] 2040         LD      E,A             ; Coded operator
   EDA4 3A AD 10      [12] 2041         LD      A,(TYPE)        ; Get data type
   EDA7 3D            [ 4] 2042         DEC     A               ; FF = numeric , 00 = string
   EDA8 B3            [ 4] 2043         OR      E               ; Combine with coded operator
   EDA9 7B            [ 4] 2044         LD      A,E             ; Get coded operator
   EDAA CA 08 F3      [ 9] 2045         JP      Z,CONCAT        ; String concatenation
   EDAD 07            [ 3] 2046         RLCA                    ; Times 2
   EDAE 83            [ 4] 2047         ADD     A,E             ; Times 3
   EDAF 5F            [ 4] 2048         LD      E,A             ; To DE (D is 0)
   EDB0 21 A4 E2      [ 9] 2049         LD      HL,#PRITAB       ; Precedence table
   EDB3 19            [ 7] 2050         ADD     HL,DE           ; To the operator concerned
   EDB4 78            [ 4] 2051         LD      A,B             ; Last operator precedence
   EDB5 56            [ 6] 2052         LD      D,(HL)          ; Get evaluation precedence
   EDB6 BA            [ 4] 2053         CP      D               ; Compare with eval precedence
   EDB7 D0            [10] 2054         RET     NC              ; Exit if higher precedence
   EDB8 23            [ 4] 2055         INC     HL              ; Point to routine address
   EDB9 CD 46 ED      [16] 2056         CALL    TSTNUM          ; Make sure it's a number
                           2057 
   EDBC C5            [11] 2058 STKTHS: PUSH    BC              ; Save last precedence & token
   EDBD 01 6B ED      [ 9] 2059         LD      BC,#EVAL3        ; Where to go on prec' break
   EDC0 C5            [11] 2060         PUSH    BC              ; Save on stack for return
   EDC1 43            [ 4] 2061         LD      B,E             ; Save operator
   EDC2 4A            [ 4] 2062         LD      C,D             ; Save precedence
   EDC3 CD 46 F8      [16] 2063         CALL    STAKFP          ; Move value to stack
   EDC6 58            [ 4] 2064         LD      E,B             ; Restore operator
   EDC7 51            [ 4] 2065         LD      D,C             ; Restore precedence
   EDC8 4E            [ 6] 2066         LD      C,(HL)          ; Get LSB of routine address
   EDC9 23            [ 4] 2067         INC     HL
   EDCA 46            [ 6] 2068         LD      B,(HL)          ; Get MSB of routine address
   EDCB 23            [ 4] 2069         INC     HL
   EDCC C5            [11] 2070         PUSH    BC              ; Save routine address
   EDCD 2A C5 10      [15] 2071         LD      HL,(CUROPR)     ; Address of current operator
   EDD0 C3 5F ED      [ 9] 2072         JP      EVAL1           ; Loop until prec' break
                           2073 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 39.
Hexadecimal [16-Bits]



   EDD3 AF            [ 4] 2074 OPRND:  XOR     A               ; Get operand routine
   EDD4 32 AD 10      [13] 2075         LD      (TYPE),A        ; Set numeric expected
   EDD7 CD 38 E8      [16] 2076         CALL    GETCHR          ; Get next character
   EDDA 1E 24         [ 6] 2077         LD      E,#MO            ; ?MO Error
   EDDC CA C3 E3      [ 9] 2078         JP      Z,ERROR         ; No operand - Error
   EDDF DA 1C F9      [ 9] 2079         JP      C,ASCTFP        ; Number - Get value
   EDE2 CD 79 E9      [16] 2080         CALL    CHKLTR          ; See if a letter
   EDE5 D2 24 EE      [ 9] 2081         JP      NC,CONVAR       ; Letter - Find variable
   EDE8 FE AC         [ 6] 2082         CP      #ZPLUS           ; "+" Token ?
   EDEA CA D3 ED      [ 9] 2083         JP      Z,OPRND         ; Yes - Look for operand
   EDED FE 2E         [ 6] 2084         CP      #"."             ; "." ?
   EDEF CA 1C F9      [ 9] 2085         JP      Z,ASCTFP        ; Yes - Create FP number
   EDF2 FE AD         [ 6] 2086         CP      #ZMINUS          ; "-" Token ?
   EDF4 CA 13 EE      [ 9] 2087         JP      Z,MINUS         ; Yes - Do minus
   EDF7 FE 22         [ 6] 2088         CP      #'"'             ; Literal string ?"
   EDF9 CA D1 F1      [ 9] 2089         JP      Z,QTSTR         ; Get string terminated by '"'
   EDFC FE AA         [ 6] 2090         CP      #ZNOT            ; "NOT" Token ?
   EDFE CA 0A EF      [ 9] 2091         JP      Z,EVNOT         ; Yes - Eval NOT expression
   EE01 FE A7         [ 6] 2092         CP      #ZFN             ; "FN" Token ?
   EE03 CA 35 F1      [ 9] 2093         JP      Z,DOFN          ; Yes - Do FN routine
   EE06 D6 B6         [ 6] 2094         SUB     #ZSGN            ; Is it a function?
   EE08 D2 35 EE      [ 9] 2095         JP      NC,FNOFST       ; Yes - Evaluate function
   EE0B CD 58 ED      [16] 2096 EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
   EE0E CD 92 E6      [16] 2097         CALL    CHKSYN          ; Make sure ")" follows
   EE11 29                 2098         .db      ")"
   EE12 C9            [ 9] 2099         RET
                           2100 
   EE13 16 7D         [ 6] 2101 MINUS:  LD      D,#0x7D           ; "-" precedence
   EE15 CD 5F ED      [16] 2102         CALL    EVAL1           ; Evaluate until prec' break
   EE18 2A D0 10      [15] 2103         LD      HL,(NXTOPR)     ; Get next operator address
   EE1B E5            [11] 2104         PUSH    HL              ; Save next operator address
   EE1C CD 3E F8      [16] 2105         CALL    INVSGN          ; Negate value
   EE1F CD 46 ED      [16] 2106 RETNUM: CALL    TSTNUM          ; Make sure it's a number
   EE22 E1            [ 9] 2107         POP     HL              ; Restore next operator address
   EE23 C9            [ 9] 2108         RET
                           2109 
   EE24 CD 2F EF      [16] 2110 CONVAR: CALL    GETVAR          ; Get variable address to DE
   EE27 E5            [11] 2111 FRMEVL: PUSH    HL              ; Save code string address
   EE28 EB            [ 3] 2112         EX      DE,HL           ; Variable address to HL
   EE29 22 E4 10      [16] 2113         LD      (FPREG),HL      ; Save address of variable
   EE2C 3A AD 10      [12] 2114         LD      A,(TYPE)        ; Get type
   EE2F B7            [ 4] 2115         OR      A               ; Numeric?
   EE30 CC 53 F8      [16] 2116         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
   EE33 E1            [ 9] 2117         POP     HL              ; Restore code string address
   EE34 C9            [ 9] 2118         RET
                           2119 
   EE35 06 00         [ 6] 2120 FNOFST: LD      B,#0             ; Get address of function
   EE37 07            [ 3] 2121         RLCA                    ; Double function offset
   EE38 4F            [ 4] 2122         LD      C,A             ; BC = Offset in function table
   EE39 C5            [11] 2123         PUSH    BC              ; Save adjusted token value
   EE3A CD 38 E8      [16] 2124         CALL    GETCHR          ; Get next character
   EE3D 79            [ 4] 2125         LD      A,C             ; Get adjusted token value
   EE3E FE 22         [ 6] 2126         CP      #2*(ZPOINT-ZSGN) ; Adjusted "POINT" token?
   EE40 CA 7B FF      [ 9] 2127         JP      Z,POINTB        ; Yes - Do "POINT" (not POINTB)
   EE43 FE 2D         [ 6] 2128         CP      #2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 40.
Hexadecimal [16-Bits]



   EE45 DA 61 EE      [ 9] 2129         JP      C,FNVAL         ; No - Do function
   EE48 CD 58 ED      [16] 2130         CALL    OPNPAR          ; Evaluate expression  (X,...
   EE4B CD 92 E6      [16] 2131         CALL    CHKSYN          ; Make sure "," follows
   EE4E 2C                 2132         .db     #","
   EE4F CD 47 ED      [16] 2133         CALL    TSTSTR          ; Make sure it's a string
   EE52 EB            [ 3] 2134         EX      DE,HL           ; Save code string address
   EE53 2A E4 10      [15] 2135         LD      HL,(FPREG)      ; Get address of string
   EE56 E3            [16] 2136         EX      (SP),HL         ; Save address of string
   EE57 E5            [11] 2137         PUSH    HL              ; Save adjusted token value
   EE58 EB            [ 3] 2138         EX      DE,HL           ; Restore code string address
   EE59 CD 86 F4      [16] 2139         CALL    GETINT          ; Get integer 0-255
   EE5C EB            [ 3] 2140         EX      DE,HL           ; Save code string address
   EE5D E3            [16] 2141         EX      (SP),HL         ; Save integer,HL = adj' token
   EE5E C3 69 EE      [ 9] 2142         JP      GOFUNC          ; Jump to string function
                           2143 
   EE61 CD 0B EE      [16] 2144 FNVAL:  CALL    EVLPAR          ; Evaluate expression
   EE64 E3            [16] 2145         EX      (SP),HL         ; HL = Adjusted token value
   EE65 11 1F EE      [ 9] 2146         LD      DE,#RETNUM       ; Return number from function
   EE68 D5            [11] 2147         PUSH    DE              ; Save on stack
   EE69 01 0F E1      [ 9] 2148 GOFUNC: LD      BC,#FNCTAB       ; Function routine addresses
   EE6C 09            [ 7] 2149         ADD     HL,BC           ; Point to right address
   EE6D 4E            [ 6] 2150         LD      C,(HL)          ; Get LSB of address
   EE6E 23            [ 4] 2151         INC     HL              ;
   EE6F 66            [ 6] 2152         LD      H,(HL)          ; Get MSB of address
   EE70 69            [ 4] 2153         LD      L,C             ; Address to HL
   EE71 E9            [ 3] 2154         JP      (HL)            ; Jump to function
                           2155 
   EE72 15            [ 4] 2156 SGNEXP: DEC     D               ; Dee to flag negative exponent
   EE73 FE AD         [ 6] 2157         CP      #ZMINUS          ; "-" token ?
   EE75 C8            [10] 2158         RET     Z               ; Yes - Return
   EE76 FE 2D         [ 6] 2159         CP      #"-"             ; "-" ASCII ?
   EE78 C8            [10] 2160         RET     Z               ; Yes - Return
   EE79 14            [ 4] 2161         INC     D               ; Inc to flag positive exponent
   EE7A FE 2B         [ 6] 2162         CP      #"+"             ; "+" ASCII ?
   EE7C C8            [10] 2163         RET     Z               ; Yes - Return
   EE7D FE AC         [ 6] 2164         CP      #ZPLUS           ; "+" token ?
   EE7F C8            [10] 2165         RET     Z               ; Yes - Return
   EE80 2B            [ 4] 2166         DEC     HL              ; DEC 'cos GETCHR INCs
   EE81 C9            [ 9] 2167         RET                     ; Return "NZ"
                           2168 
   EE82 F6                 2169 POR:    .db      0x0F6            ; Flag "OR"
   EE83 AF            [ 4] 2170 PAND:   XOR     A               ; Flag "AND"
   EE84 F5            [11] 2171         PUSH    AF              ; Save "AND" / "OR" flag
   EE85 CD 46 ED      [16] 2172         CALL    TSTNUM          ; Make sure it's a number
   EE88 CD 8D E9      [16] 2173         CALL    DEINT           ; Get integer -32768 to 32767
   EE8B F1            [ 9] 2174         POP     AF              ; Restore "AND" / "OR" flag
   EE8C EB            [ 3] 2175         EX      DE,HL           ; <- Get last
   EE8D C1            [ 9] 2176         POP     BC              ; <-  value
   EE8E E3            [16] 2177         EX      (SP),HL         ; <-  from
   EE8F EB            [ 3] 2178         EX      DE,HL           ; <-  stack
   EE90 CD 56 F8      [16] 2179         CALL    FPBCDE          ; Move last value to FPREG
   EE93 F5            [11] 2180         PUSH    AF              ; Save "AND" / "OR" flag
   EE94 CD 8D E9      [16] 2181         CALL    DEINT           ; Get integer -32768 to 32767
   EE97 F1            [ 9] 2182         POP     AF              ; Restore "AND" / "OR" flag
   EE98 C1            [ 9] 2183         POP     BC              ; Get value
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 41.
Hexadecimal [16-Bits]



   EE99 79            [ 4] 2184         LD      A,C             ; Get LSB
   EE9A 21 F3 F0      [ 9] 2185         LD      HL,#ACPASS       ; Address of save AC as current
   EE9D C2 A5 EE      [ 9] 2186         JP      NZ,POR1         ; Jump if OR
   EEA0 A3            [ 4] 2187         AND     E               ; "AND" LSBs
   EEA1 4F            [ 4] 2188         LD      C,A             ; Save LSB
   EEA2 78            [ 4] 2189         LD      A,B             ; Get MBS
   EEA3 A2            [ 4] 2190         AND     D               ; "AND" MSBs
   EEA4 E9            [ 3] 2191         JP      (HL)            ; Save AC as current (ACPASS)
                           2192 
   EEA5 B3            [ 4] 2193 POR1:   OR      E               ; "OR" LSBs
   EEA6 4F            [ 4] 2194         LD      C,A             ; Save LSB
   EEA7 78            [ 4] 2195         LD      A,B             ; Get MSB
   EEA8 B2            [ 4] 2196         OR      D               ; "OR" MSBs
   EEA9 E9            [ 3] 2197         JP      (HL)            ; Save AC as current (ACPASS)
                           2198 
   EEAA 21 BC EE      [ 9] 2199 TSTRED: LD      HL,#CMPLOG       ; Logical compare routine
   EEAD 3A AD 10      [12] 2200         LD      A,(TYPE)        ; Get data type
   EEB0 1F            [ 3] 2201         RRA                     ; Carry set = string
   EEB1 7A            [ 4] 2202         LD      A,D             ; Get last precedence value
   EEB2 17            [ 3] 2203         RLA                     ; Times 2 plus carry
   EEB3 5F            [ 4] 2204         LD      E,A             ; To E
   EEB4 16 64         [ 6] 2205         LD      D,#0x64           ; Relational precedence
   EEB6 78            [ 4] 2206         LD      A,B             ; Get current precedence
   EEB7 BA            [ 4] 2207         CP      D               ; Compare with last
   EEB8 D0            [10] 2208         RET     NC              ; Eval if last was rel' or log'
   EEB9 C3 BC ED      [ 9] 2209         JP      STKTHS          ; Stack this one and get next
                           2210 
   EEBC BE EE              2211 CMPLOG: .dw      CMPLG1          ; Compare two values / strings
   EEBE 79            [ 4] 2212 CMPLG1: LD      A,C             ; Get data type
   EEBF B7            [ 4] 2213         OR      A
   EEC0 1F            [ 3] 2214         RRA
   EEC1 C1            [ 9] 2215         POP     BC              ; Get last expression to BCDE
   EEC2 D1            [ 9] 2216         POP     DE
   EEC3 F5            [11] 2217         PUSH    AF              ; Save status
   EEC4 CD 48 ED      [16] 2218         CALL    CHKTYP          ; Check that types match
   EEC7 21 00 EF      [ 9] 2219         LD      HL,#CMPRES       ; Result to comparison
   EECA E5            [11] 2220         PUSH    HL              ; Save for RETurn
   EECB CA 90 F8      [ 9] 2221         JP      Z,CMPNUM        ; Compare values if numeric
   EECE AF            [ 4] 2222         XOR     A               ; Compare two strings
   EECF 32 AD 10      [13] 2223         LD      (TYPE),A        ; Set type to numeric
   EED2 D5            [11] 2224         PUSH    DE              ; Save string name
   EED3 CD 55 F3      [16] 2225         CALL    GSTRCU          ; Get current string
   EED6 7E            [ 6] 2226         LD      A,(HL)          ; Get length of string
   EED7 23            [ 4] 2227         INC     HL
   EED8 23            [ 4] 2228         INC     HL
   EED9 4E            [ 6] 2229         LD      C,(HL)          ; Get LSB of address
   EEDA 23            [ 4] 2230         INC     HL
   EEDB 46            [ 6] 2231         LD      B,(HL)          ; Get MSB of address
   EEDC D1            [ 9] 2232         POP     DE              ; Restore string name
   EEDD C5            [11] 2233         PUSH    BC              ; Save address of string
   EEDE F5            [11] 2234         PUSH    AF              ; Save length of string
   EEDF CD 59 F3      [16] 2235         CALL    GSTRDE          ; Get second string
   EEE2 CD 64 F8      [16] 2236         CALL    LOADFP          ; Get address of second string
   EEE5 F1            [ 9] 2237         POP     AF              ; Restore length of string 1
   EEE6 57            [ 4] 2238         LD      D,A             ; Length to D
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 42.
Hexadecimal [16-Bits]



   EEE7 E1            [ 9] 2239         POP     HL              ; Restore address of string 1
   EEE8 7B            [ 4] 2240 CMPSTR: LD      A,E             ; Bytes of string 2 to do
   EEE9 B2            [ 4] 2241         OR      D               ; Bytes of string 1 to do
   EEEA C8            [10] 2242         RET     Z               ; Exit if all bytes compared
   EEEB 7A            [ 4] 2243         LD      A,D             ; Get bytes of string 1 to do
   EEEC D6 01         [ 6] 2244         SUB     #1
   EEEE D8            [10] 2245         RET     C               ; Exit if end of string 1
   EEEF AF            [ 4] 2246         XOR     A
   EEF0 BB            [ 4] 2247         CP      E               ; Bytes of string 2 to do
   EEF1 3C            [ 4] 2248         INC     A
   EEF2 D0            [10] 2249         RET     NC              ; Exit if end of string 2
   EEF3 15            [ 4] 2250         DEC     D               ; Count bytes in string 1
   EEF4 1D            [ 4] 2251         DEC     E               ; Count bytes in string 2
   EEF5 0A            [ 6] 2252         LD      A,(BC)          ; Byte in string 2
   EEF6 BE            [ 6] 2253         CP      (HL)            ; Compare to byte in string 1
   EEF7 23            [ 4] 2254         INC     HL              ; Move up string 1
   EEF8 03            [ 4] 2255         INC     BC              ; Move up string 2
   EEF9 CA E8 EE      [ 9] 2256         JP      Z,CMPSTR        ; Same - Try next bytes
   EEFC 3F            [ 3] 2257         CCF                     ; Flag difference (">" or "<")
   EEFD C3 20 F8      [ 9] 2258         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                           2259 
   EF00 3C            [ 4] 2260 CMPRES: INC     A               ; Increment current value
   EF01 8F            [ 4] 2261         ADC     A,A             ; Double plus carry
   EF02 C1            [ 9] 2262         POP     BC              ; Get other value
   EF03 A0            [ 4] 2263         AND     B               ; Combine them
   EF04 C6 FF         [ 6] 2264         ADD     A,#-1            ; Carry set if different
   EF06 9F            [ 4] 2265         SBC     A,A             ; 00 - Equal , FF - Different
   EF07 C3 27 F8      [ 9] 2266         JP      FLGREL          ; Set current value & continue
                           2267 
   EF0A 16 5A         [ 6] 2268 EVNOT:  LD      D,#0x5A           ; Precedence value for "NOT"
   EF0C CD 5F ED      [16] 2269         CALL    EVAL1           ; Eval until precedence break
   EF0F CD 46 ED      [16] 2270         CALL    TSTNUM          ; Make sure it's a number
   EF12 CD 8D E9      [16] 2271         CALL    DEINT           ; Get integer -32768 - 32767
   EF15 7B            [ 4] 2272         LD      A,E             ; Get LSB
   EF16 2F            [ 3] 2273         CPL                     ; Invert LSB
   EF17 4F            [ 4] 2274         LD      C,A             ; Save "NOT" of LSB
   EF18 7A            [ 4] 2275         LD      A,D             ; Get MSB
   EF19 2F            [ 3] 2276         CPL                     ; Invert MSB
   EF1A CD F3 F0      [16] 2277         CALL    ACPASS          ; Save AC as current
   EF1D C1            [ 9] 2278         POP     BC              ; Clean up stack
   EF1E C3 6B ED      [ 9] 2279         JP      EVAL3           ; Continue evaluation
                           2280 
   EF21 2B            [ 4] 2281 DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
   EF22 CD 38 E8      [16] 2282         CALL    GETCHR          ; Get next character
   EF25 C8            [10] 2283         RET     Z               ; End of DIM statement
   EF26 CD 92 E6      [16] 2284         CALL    CHKSYN          ; Make sure "," follows
   EF29 2C                 2285         .db      ","
   EF2A 01 21 EF      [ 9] 2286 DIM:    LD      BC,#DIMRET       ; Return to "DIMRET"
   EF2D C5            [11] 2287         PUSH    BC              ; Save on stack
   EF2E F6                 2288         .db      0x0F6            ; Flag "Create" variable
   EF2F AF            [ 4] 2289 GETVAR: XOR     A               ; Find variable address,to DE
   EF30 32 AC 10      [13] 2290         LD      (LCRFLG),A      ; Set locate / create flag
   EF33 46            [ 6] 2291         LD      B,(HL)          ; Get First byte of name
   EF34 CD 79 E9      [16] 2292 GTFNAM: CALL    CHKLTR          ; See if a letter
   EF37 DA AF E3      [ 9] 2293         JP      C,SNERR         ; ?SN Error if not a letter
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 43.
Hexadecimal [16-Bits]



   EF3A AF            [ 4] 2294         XOR     A
   EF3B 4F            [ 4] 2295         LD      C,A             ; Clear second byte of name
   EF3C 32 AD 10      [13] 2296         LD      (TYPE),A        ; Set type to numeric
   EF3F CD 38 E8      [16] 2297         CALL    GETCHR          ; Get next character
   EF42 DA 4B EF      [ 9] 2298         JP      C,SVNAM2        ; Numeric - Save in name
   EF45 CD 79 E9      [16] 2299         CALL    CHKLTR          ; See if a letter
   EF48 DA 58 EF      [ 9] 2300         JP      C,CHARTY        ; Not a letter - Check type
   EF4B 4F            [ 4] 2301 SVNAM2: LD      C,A             ; Save second byte of name
   EF4C CD 38 E8      [16] 2302 ENDNAM: CALL    GETCHR          ; Get next character
   EF4F DA 4C EF      [ 9] 2303         JP      C,ENDNAM        ; Numeric - Get another
   EF52 CD 79 E9      [16] 2304         CALL    CHKLTR          ; See if a letter
   EF55 D2 4C EF      [ 9] 2305         JP      NC,ENDNAM       ; Letter - Get another
   EF58 D6 24         [ 6] 2306 CHARTY: SUB     #"$"             ; String variable?
   EF5A C2 67 EF      [ 9] 2307         JP      NZ,NOTSTR       ; No - Numeric variable
   EF5D 3C            [ 4] 2308         INC     A               ; A = 1 (string type)
   EF5E 32 AD 10      [13] 2309         LD      (TYPE),A        ; Set type to string
   EF61 0F            [ 3] 2310         RRCA                    ; A = 0x80 , Flag for string
   EF62 81            [ 4] 2311         ADD     A,C             ; 2nd byte of name has bit 7 on
   EF63 4F            [ 4] 2312         LD      C,A             ; Resave second byte on name
   EF64 CD 38 E8      [16] 2313         CALL    GETCHR          ; Get next character
   EF67 3A CB 10      [12] 2314 NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
   EF6A 3D            [ 4] 2315         DEC     A
   EF6B CA 14 F0      [ 9] 2316         JP      Z,ARLDSV        ; Yes - Get array name
   EF6E F2 77 EF      [ 9] 2317         JP      P,NSCFOR        ; No array with "FOR" or "FN"
   EF71 7E            [ 6] 2318         LD      A,(HL)          ; Get byte again
   EF72 D6 28         [ 6] 2319         SUB     #"("             ; Subscripted variable?
   EF74 CA EC EF      [ 9] 2320         JP      Z,SBSCPT        ; Yes - Sort out subscript
                           2321 
   EF77 AF            [ 4] 2322 NSCFOR: XOR     A               ; Simple variable
   EF78 32 CB 10      [13] 2323         LD      (FORFLG),A      ; Clear "FOR" flag
   EF7B E5            [11] 2324         PUSH    HL              ; Save code string address
   EF7C 50            [ 4] 2325         LD      D,B             ; DE = Variable name to find
   EF7D 59            [ 4] 2326         LD      E,C
   EF7E 2A DE 10      [15] 2327         LD      HL,(FNRGNM)     ; FN argument name
   EF81 CD 8C E6      [16] 2328         CALL    CPDEHL          ; Is it the FN argument?
   EF84 11 E0 10      [ 9] 2329         LD      DE,#FNARG        ; Point to argument value
   EF87 CA 56 F7      [ 9] 2330         JP      Z,POPHRT        ; Yes - Return FN argument value
   EF8A 2A D8 10      [15] 2331         LD      HL,(VAREND)     ; End of variables
   EF8D EB            [ 3] 2332         EX      DE,HL           ; Address of end of search
   EF8E 2A D6 10      [15] 2333         LD      HL,(PROGND)     ; Start of variables address
   EF91 CD 8C E6      [16] 2334 FNDVAR: CALL    CPDEHL          ; End of variable list table?
   EF94 CA AA EF      [ 9] 2335         JP      Z,CFEVAL        ; Yes - Called from EVAL?
   EF97 79            [ 4] 2336         LD      A,C             ; Get second byte of name
   EF98 96            [ 6] 2337         SUB     (HL)            ; Compare with name in list
   EF99 23            [ 4] 2338         INC     HL              ; Move on to first byte
   EF9A C2 9F EF      [ 9] 2339         JP      NZ,FNTHR        ; Different - Find another
   EF9D 78            [ 4] 2340         LD      A,B             ; Get first byte of name
   EF9E 96            [ 6] 2341         SUB     (HL)            ; Compare with name in list
   EF9F 23            [ 4] 2342 FNTHR:  INC     HL              ; Move on to LSB of value
   EFA0 CA DE EF      [ 9] 2343         JP      Z,RETADR        ; Found - Return address
   EFA3 23            [ 4] 2344         INC     HL              ; <- Skip
   EFA4 23            [ 4] 2345         INC     HL              ; <- over
   EFA5 23            [ 4] 2346         INC     HL              ; <- F.P.
   EFA6 23            [ 4] 2347         INC     HL              ; <- value
   EFA7 C3 91 EF      [ 9] 2348         JP      FNDVAR          ; Keep looking
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 44.
Hexadecimal [16-Bits]



                           2349 
   EFAA E1            [ 9] 2350 CFEVAL: POP     HL              ; Restore code string address
   EFAB E3            [16] 2351         EX      (SP),HL         ; Get return address
   EFAC D5            [11] 2352         PUSH    DE              ; Save address of variable
   EFAD 11 27 EE      [ 9] 2353         LD      DE,#FRMEVL       ; Return address in EVAL
   EFB0 CD 8C E6      [16] 2354         CALL    CPDEHL          ; Called from EVAL ?
   EFB3 D1            [ 9] 2355         POP     DE              ; Restore address of variable
   EFB4 CA E1 EF      [ 9] 2356         JP      Z,RETNUL        ; Yes - Return null variable
   EFB7 E3            [16] 2357         EX      (SP),HL         ; Put back return
   EFB8 E5            [11] 2358         PUSH    HL              ; Save code string address
   EFB9 C5            [11] 2359         PUSH    BC              ; Save variable name
   EFBA 01 06 00      [ 9] 2360         LD      BC,#6            ; 2 byte name plus 4 byte data
   EFBD 2A DA 10      [15] 2361         LD      HL,(ARREND)     ; End of arrays
   EFC0 E5            [11] 2362         PUSH    HL              ; Save end of arrays
   EFC1 09            [ 7] 2363         ADD     HL,BC           ; Move up 6 bytes
   EFC2 C1            [ 9] 2364         POP     BC              ; Source address in BC
   EFC3 E5            [11] 2365         PUSH    HL              ; Save new end address
   EFC4 CD 7B E3      [16] 2366         CALL    MOVUP           ; Move arrays up
   EFC7 E1            [ 9] 2367         POP     HL              ; Restore new end address
   EFC8 22 DA 10      [16] 2368         LD      (ARREND),HL     ; Set new end address
   EFCB 60            [ 4] 2369         LD      H,B             ; End of variables to HL
   EFCC 69            [ 4] 2370         LD      L,C
   EFCD 22 D8 10      [16] 2371         LD      (VAREND),HL     ; Set new end address
                           2372 
   EFD0 2B            [ 4] 2373 ZEROLP: DEC     HL              ; Back through to zero variable
   EFD1 36 00         [ 9] 2374         LD      (HL),#0          ; Zero byte in variable
   EFD3 CD 8C E6      [16] 2375         CALL    CPDEHL          ; Done them all?
   EFD6 C2 D0 EF      [ 9] 2376         JP      NZ,ZEROLP       ; No - Keep on going
   EFD9 D1            [ 9] 2377         POP     DE              ; Get variable name
   EFDA 73            [ 7] 2378         LD      (HL),E          ; Store second character
   EFDB 23            [ 4] 2379         INC     HL
   EFDC 72            [ 7] 2380         LD      (HL),D          ; Store first character
   EFDD 23            [ 4] 2381         INC     HL
   EFDE EB            [ 3] 2382 RETADR: EX      DE,HL           ; Address of variable in DE
   EFDF E1            [ 9] 2383         POP     HL              ; Restore code string address
   EFE0 C9            [ 9] 2384         RET
                           2385 
   EFE1 32 E7 10      [13] 2386 RETNUL: LD      (FPEXP),A       ; Set result to zero
   EFE4 21 4B E3      [ 9] 2387         LD      HL,#ZERBYT       ; Also set a null string
   EFE7 22 E4 10      [16] 2388         LD      (FPREG),HL      ; Save for EVAL
   EFEA E1            [ 9] 2389         POP     HL              ; Restore code string address
   EFEB C9            [ 9] 2390         RET
                           2391 
   EFEC E5            [11] 2392 SBSCPT: PUSH    HL              ; Save code string address
   EFED 2A AC 10      [15] 2393         LD      HL,(LCRFLG)     ; Locate/Create and Type
   EFF0 E3            [16] 2394         EX      (SP),HL         ; Save and get code string
   EFF1 57            [ 4] 2395         LD      D,A             ; Zero number of dimensions
   EFF2 D5            [11] 2396 SCPTLP: PUSH    DE              ; Save number of dimensions
   EFF3 C5            [11] 2397         PUSH    BC              ; Save array name
   EFF4 CD 81 E9      [16] 2398         CALL    FPSINT          ; Get subscript (0-32767)
   EFF7 C1            [ 9] 2399         POP     BC              ; Restore array name
   EFF8 F1            [ 9] 2400         POP     AF              ; Get number of dimensions
   EFF9 EB            [ 3] 2401         EX      DE,HL
   EFFA E3            [16] 2402         EX      (SP),HL         ; Save subscript value
   EFFB E5            [11] 2403         PUSH    HL              ; Save LCRFLG and TYPE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 45.
Hexadecimal [16-Bits]



   EFFC EB            [ 3] 2404         EX      DE,HL
   EFFD 3C            [ 4] 2405         INC     A               ; Count dimensions
   EFFE 57            [ 4] 2406         LD      D,A             ; Save in D
   EFFF 7E            [ 6] 2407         LD      A,(HL)          ; Get next byte in code string
   F000 FE 2C         [ 6] 2408         CP      #","             ; Comma (more to come)?
   F002 CA F2 EF      [ 9] 2409         JP      Z,SCPTLP        ; Yes - More subscripts
   F005 CD 92 E6      [16] 2410         CALL    CHKSYN          ; Make sure ")" follows
   F008 29                 2411         .db     # ")"
   F009 22 D0 10      [16] 2412         LD      (NXTOPR),HL     ; Save code string address
   F00C E1            [ 9] 2413         POP     HL              ; Get LCRFLG and TYPE
   F00D 22 AC 10      [16] 2414         LD      (LCRFLG),HL     ; Restore Locate/create & type
   F010 1E 00         [ 6] 2415         LD      E,#0             ; Flag not CSAVE* or CLOAD*
   F012 D5            [11] 2416         PUSH    DE              ; Save number of dimensions (D)
   F013 11                 2417         .db      0x11             ; Skip "PUSH HL" and "PUSH AF'
                           2418 
   F014 E5            [11] 2419 ARLDSV: PUSH    HL              ; Save code string address
   F015 F5            [11] 2420         PUSH    AF              ; A = 00 , Flags set = Z,N
   F016 2A D8 10      [15] 2421         LD      HL,(VAREND)     ; Start of arrays
   F019 3E                 2422         .db      0x3E             ; Skip "ADD HL,DE"
   F01A 19            [ 7] 2423 FNDARY: ADD     HL,DE           ; Move to next array start
   F01B EB            [ 3] 2424         EX      DE,HL
   F01C 2A DA 10      [15] 2425         LD      HL,(ARREND)     ; End of arrays
   F01F EB            [ 3] 2426         EX      DE,HL           ; Current array pointer
   F020 CD 8C E6      [16] 2427         CALL    CPDEHL          ; End of arrays found?
   F023 CA 4C F0      [ 9] 2428         JP      Z,CREARY        ; Yes - Create array
   F026 7E            [ 6] 2429         LD      A,(HL)          ; Get second byte of name
   F027 B9            [ 4] 2430         CP      C               ; Compare with name given
   F028 23            [ 4] 2431         INC     HL              ; Move on
   F029 C2 2E F0      [ 9] 2432         JP      NZ,NXTARY       ; Different - Find next array
   F02C 7E            [ 6] 2433         LD      A,(HL)          ; Get first byte of name
   F02D B8            [ 4] 2434         CP      B               ; Compare with name given
   F02E 23            [ 4] 2435 NXTARY: INC     HL              ; Move on
   F02F 5E            [ 6] 2436         LD      E,(HL)          ; Get LSB of next array address
   F030 23            [ 4] 2437         INC     HL
   F031 56            [ 6] 2438         LD      D,(HL)          ; Get MSB of next array address
   F032 23            [ 4] 2439         INC     HL
   F033 C2 1A F0      [ 9] 2440         JP      NZ,FNDARY       ; Not found - Keep looking
   F036 3A AC 10      [12] 2441         LD      A,(LCRFLG)      ; Found Locate or Create it?
   F039 B7            [ 4] 2442         OR      A
   F03A C2 B8 E3      [ 9] 2443         JP      NZ,DDERR        ; Create - ?DD Error
   F03D F1            [ 9] 2444         POP     AF              ; Locate - Get number of dim'ns
   F03E 44            [ 4] 2445         LD      B,H             ; BC Points to array dim'ns
   F03F 4D            [ 4] 2446         LD      C,L
   F040 CA 56 F7      [ 9] 2447         JP      Z,POPHRT        ; Jump if array load/save
   F043 96            [ 6] 2448         SUB     (HL)            ; Same number of dimensions?
   F044 CA AA F0      [ 9] 2449         JP      Z,FINDEL        ; Yes - Find element
   F047 1E 10         [ 6] 2450 BSERR:  LD      E,#BS            ; ?BS Error
   F049 C3 C3 E3      [ 9] 2451         JP      ERROR           ; Output error
                           2452 
   F04C 11 04 00      [ 9] 2453 CREARY: LD      DE,#4            ; 4 Bytes per entry
   F04F F1            [ 9] 2454         POP     AF              ; Array to save or 0 dim'ns?
   F050 CA A2 E9      [ 9] 2455         JP      Z,FCERR         ; Yes - ?FC Error
   F053 71            [ 7] 2456         LD      (HL),C          ; Save second byte of name
   F054 23            [ 4] 2457         INC     HL
   F055 70            [ 7] 2458         LD      (HL),B          ; Save first byte of name
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 46.
Hexadecimal [16-Bits]



   F056 23            [ 4] 2459         INC     HL
   F057 4F            [ 4] 2460         LD      C,A             ; Number of dimensions to C
   F058 CD 8C E3      [16] 2461         CALL    CHKSTK          ; Check if enough memory
   F05B 23            [ 4] 2462         INC     HL              ; Point to number of dimensions
   F05C 23            [ 4] 2463         INC     HL
   F05D 22 C5 10      [16] 2464         LD      (CUROPR),HL     ; Save address of pointer
   F060 71            [ 7] 2465         LD      (HL),C          ; Set number of dimensions
   F061 23            [ 4] 2466         INC     HL
   F062 3A AC 10      [12] 2467         LD      A,(LCRFLG)      ; Locate of Create?
   F065 17            [ 3] 2468         RLA                     ; Carry set = Create
   F066 79            [ 4] 2469         LD      A,C             ; Get number of dimensions
   F067 01 0B 00      [ 9] 2470 CRARLP: LD      BC,#10+1         ; Default dimension size 10
   F06A D2 6F F0      [ 9] 2471         JP      NC,DEFSIZ       ; Locate - Set default size
   F06D C1            [ 9] 2472         POP     BC              ; Get specified dimension size
   F06E 03            [ 4] 2473         INC     BC              ; Include zero element
   F06F 71            [ 7] 2474 DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
   F070 23            [ 4] 2475         INC     HL
   F071 70            [ 7] 2476         LD      (HL),B          ; Save MSB of dimension size
   F072 23            [ 4] 2477         INC     HL
   F073 F5            [11] 2478         PUSH    AF              ; Save num' of dim'ns an status
   F074 E5            [11] 2479         PUSH    HL              ; Save address of dim'n size
   F075 CD 01 F9      [16] 2480         CALL    MLDEBC          ; Multiply DE by BC to find
   F078 EB            [ 3] 2481         EX      DE,HL           ; amount of mem needed (to DE)
   F079 E1            [ 9] 2482         POP     HL              ; Restore address of dimension
   F07A F1            [ 9] 2483         POP     AF              ; Restore number of dimensions
   F07B 3D            [ 4] 2484         DEC     A               ; Count them
   F07C C2 67 F0      [ 9] 2485         JP      NZ,CRARLP       ; Do next dimension if more
   F07F F5            [11] 2486         PUSH    AF              ; Save locate/create flag
   F080 42            [ 4] 2487         LD      B,D             ; MSB of memory needed
   F081 4B            [ 4] 2488         LD      C,E             ; LSB of memory needed
   F082 EB            [ 3] 2489         EX      DE,HL
   F083 19            [ 7] 2490         ADD     HL,DE           ; Add bytes to array start
   F084 DA A4 E3      [ 9] 2491         JP      C,OMERR         ; Too big - Error
   F087 CD 95 E3      [16] 2492         CALL    ENFMEM          ; See if enough memory
   F08A 22 DA 10      [16] 2493         LD      (ARREND),HL     ; Save new end of array
                           2494 
   F08D 2B            [ 4] 2495 ZERARY: DEC     HL              ; Back through array data
   F08E 36 00         [ 9] 2496         LD      (HL),#0          ; Set array element to zero
   F090 CD 8C E6      [16] 2497         CALL    CPDEHL          ; All elements zeroed?
   F093 C2 8D F0      [ 9] 2498         JP      NZ,ZERARY       ; No - Keep on going
   F096 03            [ 4] 2499         INC     BC              ; Number of bytes + 1
   F097 57            [ 4] 2500         LD      D,A             ; A=0
   F098 2A C5 10      [15] 2501         LD      HL,(CUROPR)     ; Get address of array
   F09B 5E            [ 6] 2502         LD      E,(HL)          ; Number of dimensions
   F09C EB            [ 3] 2503         EX      DE,HL           ; To HL
   F09D 29            [ 7] 2504         ADD     HL,HL           ; Two bytes per dimension size
   F09E 09            [ 7] 2505         ADD     HL,BC           ; Add number of bytes
   F09F EB            [ 3] 2506         EX      DE,HL           ; Bytes needed to DE
   F0A0 2B            [ 4] 2507         DEC     HL
   F0A1 2B            [ 4] 2508         DEC     HL
   F0A2 73            [ 7] 2509         LD      (HL),E          ; Save LSB of bytes needed
   F0A3 23            [ 4] 2510         INC     HL
   F0A4 72            [ 7] 2511         LD      (HL),D          ; Save MSB of bytes needed
   F0A5 23            [ 4] 2512         INC     HL
   F0A6 F1            [ 9] 2513         POP     AF              ; Locate / Create?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 47.
Hexadecimal [16-Bits]



   F0A7 DA CE F0      [ 9] 2514         JP      C,ENDDIM        ; A is 0 , End if create
   F0AA 47            [ 4] 2515 FINDEL: LD      B,A             ; Find array element
   F0AB 4F            [ 4] 2516         LD      C,A
   F0AC 7E            [ 6] 2517         LD      A,(HL)          ; Number of dimensions
   F0AD 23            [ 4] 2518         INC     HL
   F0AE 16                 2519         .db      0x16             ; Skip "POP HL"
   F0AF E1            [ 9] 2520 FNDELP: POP     HL              ; Address of next dim' size
   F0B0 5E            [ 6] 2521         LD      E,(HL)          ; Get LSB of dim'n size
   F0B1 23            [ 4] 2522         INC     HL
   F0B2 56            [ 6] 2523         LD      D,(HL)          ; Get MSB of dim'n size
   F0B3 23            [ 4] 2524         INC     HL
   F0B4 E3            [16] 2525         EX      (SP),HL         ; Save address - Get index
   F0B5 F5            [11] 2526         PUSH    AF              ; Save number of dim'ns
   F0B6 CD 8C E6      [16] 2527         CALL    CPDEHL          ; Dimension too large?
   F0B9 D2 47 F0      [ 9] 2528         JP      NC,BSERR        ; Yes - ?BS Error
   F0BC E5            [11] 2529         PUSH    HL              ; Save index
   F0BD CD 01 F9      [16] 2530         CALL    MLDEBC          ; Multiply previous by size
   F0C0 D1            [ 9] 2531         POP     DE              ; Index supplied to DE
   F0C1 19            [ 7] 2532         ADD     HL,DE           ; Add index to pointer
   F0C2 F1            [ 9] 2533         POP     AF              ; Number of dimensions
   F0C3 3D            [ 4] 2534         DEC     A               ; Count them
   F0C4 44            [ 4] 2535         LD      B,H             ; MSB of pointer
   F0C5 4D            [ 4] 2536         LD      C,L             ; LSB of pointer
   F0C6 C2 AF F0      [ 9] 2537         JP      NZ,FNDELP       ; More - Keep going
   F0C9 29            [ 7] 2538         ADD     HL,HL           ; 4 Bytes per element
   F0CA 29            [ 7] 2539         ADD     HL,HL
   F0CB C1            [ 9] 2540         POP     BC              ; Start of array
   F0CC 09            [ 7] 2541         ADD     HL,BC           ; Point to element
   F0CD EB            [ 3] 2542         EX      DE,HL           ; Address of element to DE
   F0CE 2A D0 10      [15] 2543 ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
   F0D1 C9            [ 9] 2544         RET
                           2545 
   F0D2 2A DA 10      [15] 2546 FRE:    LD      HL,(ARREND)     ; Start of free memory
   F0D5 EB            [ 3] 2547         EX      DE,HL           ; To DE
   F0D6 21 00 00      [ 9] 2548         LD      HL,#0            ; End of free memory
   F0D9 39            [ 7] 2549         ADD     HL,SP           ; Current stack value
   F0DA 3A AD 10      [12] 2550         LD      A,(TYPE)        ; Dummy argument type
   F0DD B7            [ 4] 2551         OR      A
   F0DE CA EE F0      [ 9] 2552         JP      Z,FRENUM        ; Numeric - Free variable space
   F0E1 CD 55 F3      [16] 2553         CALL    GSTRCU          ; Current string to pool
   F0E4 CD 55 F2      [16] 2554         CALL    GARBGE          ; Garbage collection
   F0E7 2A 5A 10      [15] 2555         LD      HL,(STRSPC)     ; Bottom of string space in use
   F0EA EB            [ 3] 2556         EX      DE,HL           ; To DE
   F0EB 2A C3 10      [15] 2557         LD      HL,(STRBOT)     ; Bottom of string space
   F0EE 7D            [ 4] 2558 FRENUM: LD      A,L             ; Get LSB of end
   F0EF 93            [ 4] 2559         SUB     E               ; Subtract LSB of beginning
   F0F0 4F            [ 4] 2560         LD      C,A             ; Save difference if C
   F0F1 7C            [ 4] 2561         LD      A,H             ; Get MSB of end
   F0F2 9A            [ 4] 2562         SBC     A,D             ; Subtract MSB of beginning
   F0F3 41            [ 4] 2563 ACPASS: LD      B,C             ; Return integer AC
   F0F4 50            [ 4] 2564 ABPASS: LD      D,B             ; Return integer AB
   F0F5 1E 00         [ 6] 2565         LD      E,#0
   F0F7 21 AD 10      [ 9] 2566         LD      HL,#TYPE         ; Point to type
   F0FA 73            [ 7] 2567         LD      (HL),E          ; Set type to numeric
   F0FB 06 90         [ 6] 2568         LD      B,#0x80+16        ; 16 bit integer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 48.
Hexadecimal [16-Bits]



   F0FD C3 2C F8      [ 9] 2569         JP      RETINT          ; Return the integr
                           2570 
   F100 3A AB 10      [12] 2571 POS:    LD      A,(CURPOS)      ; Get cursor position
   F103 47            [ 4] 2572 PASSA:  LD      B,A             ; Put A into AB
   F104 AF            [ 4] 2573         XOR     A               ; Zero A
   F105 C3 F4 F0      [ 9] 2574         JP      ABPASS          ; Return integer AB
                           2575 
   F108 CD 8B F1      [16] 2576 DEF:    CALL    CHEKFN          ; Get "FN" and name
   F10B CD 7D F1      [16] 2577         CALL    IDTEST          ; Test for illegal direct
   F10E 01 72 EA      [ 9] 2578         LD      BC,#DATA         ; To get next statement
   F111 C5            [11] 2579         PUSH    BC              ; Save address for RETurn
   F112 D5            [11] 2580         PUSH    DE              ; Save address of function ptr
   F113 CD 92 E6      [16] 2581         CALL    CHKSYN          ; Make sure "(" follows
   F116 28                 2582         .db      "("
   F117 CD 2F EF      [16] 2583         CALL    GETVAR          ; Get argument variable name
   F11A E5            [11] 2584         PUSH    HL              ; Save code string address
   F11B EB            [ 3] 2585         EX      DE,HL           ; Argument address to HL
   F11C 2B            [ 4] 2586         DEC     HL
   F11D 56            [ 6] 2587         LD      D,(HL)          ; Get first byte of arg name
   F11E 2B            [ 4] 2588         DEC     HL
   F11F 5E            [ 6] 2589         LD      E,(HL)          ; Get second byte of arg name
   F120 E1            [ 9] 2590         POP     HL              ; Restore code string address
   F121 CD 46 ED      [16] 2591         CALL    TSTNUM          ; Make sure numeric argument
   F124 CD 92 E6      [16] 2592         CALL    CHKSYN          ; Make sure ")" follows
   F127 29                 2593         .db      ")"
   F128 CD 92 E6      [16] 2594         CALL    CHKSYN          ; Make sure "=" follows
   F12B B4                 2595         .db      ZEQUAL          ; "=" token
   F12C 44            [ 4] 2596         LD      B,H             ; Code string address to BC
   F12D 4D            [ 4] 2597         LD      C,L
   F12E E3            [16] 2598         EX      (SP),HL         ; Save code str , Get FN ptr
   F12F 71            [ 7] 2599         LD      (HL),C          ; Save LSB of FN code string
   F130 23            [ 4] 2600         INC     HL
   F131 70            [ 7] 2601         LD      (HL),B          ; Save MSB of FN code string
   F132 C3 CA F1      [ 9] 2602         JP      SVSTAD          ; Save address and do function
                           2603 
   F135 CD 8B F1      [16] 2604 DOFN:   CALL    CHEKFN          ; Make sure FN follows
   F138 D5            [11] 2605         PUSH    DE              ; Save function pointer address
   F139 CD 0B EE      [16] 2606         CALL    EVLPAR          ; Evaluate expression in "()"
   F13C CD 46 ED      [16] 2607         CALL    TSTNUM          ; Make sure numeric result
   F13F E3            [16] 2608         EX      (SP),HL         ; Save code str , Get FN ptr
   F140 5E            [ 6] 2609         LD      E,(HL)          ; Get LSB of FN code string
   F141 23            [ 4] 2610         INC     HL
   F142 56            [ 6] 2611         LD      D,(HL)          ; Get MSB of FN code string
   F143 23            [ 4] 2612         INC     HL
   F144 7A            [ 4] 2613         LD      A,D             ; And function DEFined?
   F145 B3            [ 4] 2614         OR      E
   F146 CA BB E3      [ 9] 2615         JP      Z,UFERR         ; No - ?UF Error
   F149 7E            [ 6] 2616         LD      A,(HL)          ; Get LSB of argument address
   F14A 23            [ 4] 2617         INC     HL
   F14B 66            [ 6] 2618         LD      H,(HL)          ; Get MSB of argument address
   F14C 6F            [ 4] 2619         LD      L,A             ; HL = Arg variable address
   F14D E5            [11] 2620         PUSH    HL              ; Save it
   F14E 2A DE 10      [15] 2621         LD      HL,(FNRGNM)     ; Get old argument name
   F151 E3            [16] 2622         EX      (SP),HL ;       ; Save old , Get new
   F152 22 DE 10      [16] 2623         LD      (FNRGNM),HL     ; Set new argument name
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 49.
Hexadecimal [16-Bits]



   F155 2A E2 10      [15] 2624         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
   F158 E5            [11] 2625         PUSH    HL              ; Save it
   F159 2A E0 10      [15] 2626         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
   F15C E5            [11] 2627         PUSH    HL              ; Save it
   F15D 21 E0 10      [ 9] 2628         LD      HL,#FNARG        ; HL = Value of argument
   F160 D5            [11] 2629         PUSH    DE              ; Save FN code string address
   F161 CD 6D F8      [16] 2630         CALL    FPTHL           ; Move FPREG to argument
   F164 E1            [ 9] 2631         POP     HL              ; Get FN code string address
   F165 CD 43 ED      [16] 2632         CALL    GETNUM          ; Get value from function
   F168 2B            [ 4] 2633         DEC     HL              ; DEC 'cos GETCHR INCs
   F169 CD 38 E8      [16] 2634         CALL    GETCHR          ; Get next character
   F16C C2 AF E3      [ 9] 2635         JP      NZ,SNERR        ; Bad character in FN - Error
   F16F E1            [ 9] 2636         POP     HL              ; Get MSB,EXP of old arg
   F170 22 E0 10      [16] 2637         LD      (FNARG),HL      ; Restore it
   F173 E1            [ 9] 2638         POP     HL              ; Get LSB,NLSB of old arg
   F174 22 E2 10      [16] 2639         LD      (FNARG+2),HL    ; Restore it
   F177 E1            [ 9] 2640         POP     HL              ; Get name of old arg
   F178 22 DE 10      [16] 2641         LD      (FNRGNM),HL     ; Restore it
   F17B E1            [ 9] 2642         POP     HL              ; Restore code string address
   F17C C9            [ 9] 2643         RET
                           2644 
   F17D E5            [11] 2645 IDTEST: PUSH    HL              ; Save code string address
   F17E 2A 5C 10      [15] 2646         LD      HL,(LINEAT)     ; Get current line number
   F181 23            [ 4] 2647         INC     HL              ; -1 means direct statement
   F182 7C            [ 4] 2648         LD      A,H
   F183 B5            [ 4] 2649         OR      L
   F184 E1            [ 9] 2650         POP     HL              ; Restore code string address
   F185 C0            [10] 2651         RET     NZ              ; Return if in program
   F186 1E 16         [ 6] 2652         LD      E,#ID            ; ?ID Error
   F188 C3 C3 E3      [ 9] 2653         JP      ERROR
                           2654 
   F18B CD 92 E6      [16] 2655 CHEKFN: CALL    CHKSYN          ; Make sure FN follows
   F18E A7                 2656         .db      ZFN             ; "FN" token
   F18F 3E 80         [ 6] 2657         LD      A,#0x80
   F191 32 CB 10      [13] 2658         LD      (FORFLG),A      ; Flag FN name to find
   F194 B6            [ 6] 2659         OR      (HL)            ; FN name has bit 7 set
   F195 47            [ 4] 2660         LD      B,A             ; in first byte of name
   F196 CD 34 EF      [16] 2661         CALL    GTFNAM          ; Get FN name
   F199 C3 46 ED      [ 9] 2662         JP      TSTNUM          ; Make sure numeric function
                           2663 
   F19C CD 46 ED      [16] 2664 STR:    CALL    TSTNUM          ; Make sure it's a number
   F19F CD BA F9      [16] 2665         CALL    NUMASC          ; Turn number into text
   F1A2 CD D0 F1      [16] 2666         CALL    CRTST           ; Create string entry for it
   F1A5 CD 55 F3      [16] 2667         CALL    GSTRCU          ; Current string to pool
   F1A8 01 B0 F3      [ 9] 2668         LD      BC,#TOPOOL       ; Save in string pool
   F1AB C5            [11] 2669         PUSH    BC              ; Save address on stack
                           2670 
   F1AC 7E            [ 6] 2671 SAVSTR: LD      A,(HL)          ; Get string length
   F1AD 23            [ 4] 2672         INC     HL
   F1AE 23            [ 4] 2673         INC     HL
   F1AF E5            [11] 2674         PUSH    HL              ; Save pointer to string
   F1B0 CD 2B F2      [16] 2675         CALL    TESTR           ; See if enough string space
   F1B3 E1            [ 9] 2676         POP     HL              ; Restore pointer to string
   F1B4 4E            [ 6] 2677         LD      C,(HL)          ; Get LSB of address
   F1B5 23            [ 4] 2678         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 50.
Hexadecimal [16-Bits]



   F1B6 46            [ 6] 2679         LD      B,(HL)          ; Get MSB of address
   F1B7 CD C4 F1      [16] 2680         CALL    CRTMST          ; Create string entry
   F1BA E5            [11] 2681         PUSH    HL              ; Save pointer to MSB of addr
   F1BB 6F            [ 4] 2682         LD      L,A             ; Length of string
   F1BC CD 48 F3      [16] 2683         CALL    TOSTRA          ; Move to string area
   F1BF D1            [ 9] 2684         POP     DE              ; Restore pointer to MSB
   F1C0 C9            [ 9] 2685         RET
                           2686 
   F1C1 CD 2B F2      [16] 2687 MKTMST: CALL    TESTR           ; See if enough string space
   F1C4 21 BF 10      [ 9] 2688 CRTMST: LD      HL,#TMPSTR       ; Temporary string
   F1C7 E5            [11] 2689         PUSH    HL              ; Save it
   F1C8 77            [ 7] 2690         LD      (HL),A          ; Save length of string
   F1C9 23            [ 4] 2691         INC     HL
   F1CA 23            [ 4] 2692 SVSTAD: INC     HL
   F1CB 73            [ 7] 2693         LD      (HL),E          ; Save LSB of address
   F1CC 23            [ 4] 2694         INC     HL
   F1CD 72            [ 7] 2695         LD      (HL),D          ; Save MSB of address
   F1CE E1            [ 9] 2696         POP     HL              ; Restore pointer
   F1CF C9            [ 9] 2697         RET
                           2698 
   F1D0 2B            [ 4] 2699 CRTST:  DEC     HL              ; DEC - INCed after
   F1D1 06 22         [ 6] 2700 QTSTR:  LD      B,#'"'           ; Terminating quote"
   F1D3 50            [ 4] 2701         LD      D,B             ; Quote to D
   F1D4 E5            [11] 2702 DTSTR:  PUSH    HL              ; Save start
   F1D5 0E FF         [ 6] 2703         LD      C,#-1            ; Set counter to -1
   F1D7 23            [ 4] 2704 QTSTLP: INC     HL              ; Move on
   F1D8 7E            [ 6] 2705         LD      A,(HL)          ; Get byte
   F1D9 0C            [ 4] 2706         INC     C               ; Count bytes
   F1DA B7            [ 4] 2707         OR      A               ; End of line?
   F1DB CA E6 F1      [ 9] 2708         JP      Z,CRTSTE        ; Yes - Create string entry
   F1DE BA            [ 4] 2709         CP      D               ; Terminator D found?
   F1DF CA E6 F1      [ 9] 2710         JP      Z,CRTSTE        ; Yes - Create string entry
   F1E2 B8            [ 4] 2711         CP      B               ; Terminator B found?
   F1E3 C2 D7 F1      [ 9] 2712         JP      NZ,QTSTLP       ; No - Keep looking
   F1E6 FE 22         [ 6] 2713 CRTSTE: CP      #'"'             ; End with '"'?
   F1E8 CC 38 E8      [16] 2714         CALL    Z,GETCHR        ; Yes - Get next character
   F1EB E3            [16] 2715         EX      (SP),HL         ; Starting quote
   F1EC 23            [ 4] 2716         INC     HL              ; First byte of string
   F1ED EB            [ 3] 2717         EX      DE,HL           ; To DE
   F1EE 79            [ 4] 2718         LD      A,C             ; Get length
   F1EF CD C4 F1      [16] 2719         CALL    CRTMST          ; Create string entry
   F1F2 11 BF 10      [ 9] 2720 TSTOPL: LD      DE,#TMPSTR       ; Temporary string
   F1F5 2A B1 10      [15] 2721         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   F1F8 22 E4 10      [16] 2722         LD      (FPREG),HL      ; Save address of string ptr
   F1FB 3E 01         [ 6] 2723         LD      A,#1
   F1FD 32 AD 10      [13] 2724         LD      (TYPE),A        ; Set type to string
   F200 CD 70 F8      [16] 2725         CALL    DETHL4          ; Move string to pool
   F203 CD 8C E6      [16] 2726         CALL    CPDEHL          ; Out of string pool?
   F206 22 B1 10      [16] 2727         LD      (TMSTPT),HL     ; Save new pointer
   F209 E1            [ 9] 2728         POP     HL              ; Restore code string address
   F20A 7E            [ 6] 2729         LD      A,(HL)          ; Get next code byte
   F20B C0            [10] 2730         RET     NZ              ; Return if pool OK
   F20C 1E 1E         [ 6] 2731         LD      E,#ST            ; ?ST Error
   F20E C3 C3 E3      [ 9] 2732         JP      ERROR           ; String pool overflow
                           2733 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 51.
Hexadecimal [16-Bits]



   F211 23            [ 4] 2734 PRNUMS: INC     HL              ; Skip leading space
   F212 CD D0 F1      [16] 2735 PRS:    CALL    CRTST           ; Create string entry for it
   F215 CD 55 F3      [16] 2736 PRS1:   CALL    GSTRCU          ; Current string to pool
   F218 CD 64 F8      [16] 2737         CALL    LOADFP          ; Move string block to BCDE
   F21B 1C            [ 4] 2738         INC     E               ; Length + 1
   F21C 1D            [ 4] 2739 PRSLP:  DEC     E               ; Count characters
   F21D C8            [10] 2740         RET     Z               ; End of string
   F21E 0A            [ 6] 2741         LD      A,(BC)          ; Get byte to output
   F21F CD 9D E6      [16] 2742         CALL    OUTC            ; Output character in A
   F222 FE 0D         [ 6] 2743         CP      #CR              ; Return?
   F224 CC 88 EB      [16] 2744         CALL    Z,DONULL        ; Yes - Do nulls
   F227 03            [ 4] 2745         INC     BC              ; Next byte in string
   F228 C3 1C F2      [ 9] 2746         JP      PRSLP           ; More characters to output
                           2747 
   F22B B7            [ 4] 2748 TESTR:  OR      A               ; Test if enough room
   F22C 0E                 2749         .db      0x0E             ; No garbage collection done
   F22D F1            [ 9] 2750 GRBDON: POP     AF              ; Garbage collection done
   F22E F5            [11] 2751         PUSH    AF              ; Save status
   F22F 2A 5A 10      [15] 2752         LD      HL,(STRSPC)     ; Bottom of string space in use
   F232 EB            [ 3] 2753         EX      DE,HL           ; To DE
   F233 2A C3 10      [15] 2754         LD      HL,(STRBOT)     ; Bottom of string area
   F236 2F            [ 3] 2755         CPL                     ; Negate length (Top down)
   F237 4F            [ 4] 2756         LD      C,A             ; -Length to BC
   F238 06 FF         [ 6] 2757         LD      B,#-1            ; BC = -ve length of string
   F23A 09            [ 7] 2758         ADD     HL,BC           ; Add to bottom of space in use
   F23B 23            [ 4] 2759         INC     HL              ; Plus one for 2's complement
   F23C CD 8C E6      [16] 2760         CALL    CPDEHL          ; Below string RAM area?
   F23F DA 49 F2      [ 9] 2761         JP      C,TESTOS        ; Tidy up if not done else err
   F242 22 C3 10      [16] 2762         LD      (STRBOT),HL     ; Save new bottom of area
   F245 23            [ 4] 2763         INC     HL              ; Point to first byte of string
   F246 EB            [ 3] 2764         EX      DE,HL           ; Address to DE
   F247 F1            [ 9] 2765 POPAF:  POP     AF              ; Throw away status push
   F248 C9            [ 9] 2766         RET
                           2767 
   F249 F1            [ 9] 2768 TESTOS: POP     AF              ; Garbage collect been done?
   F24A 1E 1A         [ 6] 2769         LD      E,#OS            ; ?OS Error
   F24C CA C3 E3      [ 9] 2770         JP      Z,ERROR         ; Yes - Not enough string apace
   F24F BF            [ 4] 2771         CP      A               ; Flag garbage collect done
   F250 F5            [11] 2772         PUSH    AF              ; Save status
   F251 01 2D F2      [ 9] 2773         LD      BC,#GRBDON       ; Garbage collection done
   F254 C5            [11] 2774         PUSH    BC              ; Save for RETurn
   F255 2A AF 10      [15] 2775 GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
   F258 22 C3 10      [16] 2776 GARBLP: LD      (STRBOT),HL     ; Reset string pointer
   F25B 21 00 00      [ 9] 2777         LD      HL,#0
   F25E E5            [11] 2778         PUSH    HL              ; Flag no string found
   F25F 2A 5A 10      [15] 2779         LD      HL,(STRSPC)     ; Get bottom of string space
   F262 E5            [11] 2780         PUSH    HL              ; Save bottom of string space
   F263 21 B3 10      [ 9] 2781         LD      HL,#TMSTPL       ; Temporary string pool
   F266 EB            [ 3] 2782 GRBLP:  EX      DE,HL
   F267 2A B1 10      [15] 2783         LD      HL,(TMSTPT)     ; Temporary string pool pointer
   F26A EB            [ 3] 2784         EX      DE,HL
   F26B CD 8C E6      [16] 2785         CALL    CPDEHL          ; Temporary string pool done?
   F26E 01 66 F2      [ 9] 2786         LD      BC,#GRBLP        ; Loop until string pool done
   F271 C2 BA F2      [ 9] 2787         JP      NZ,STPOOL       ; No - See if in string area
   F274 2A D6 10      [15] 2788         LD      HL,(PROGND)     ; Start of simple variables
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 52.
Hexadecimal [16-Bits]



   F277 EB            [ 3] 2789 SMPVAR: EX      DE,HL
   F278 2A D8 10      [15] 2790         LD      HL,(VAREND)     ; End of simple variables
   F27B EB            [ 3] 2791         EX      DE,HL
   F27C CD 8C E6      [16] 2792         CALL    CPDEHL          ; All simple strings done?
   F27F CA 8D F2      [ 9] 2793         JP      Z,ARRLP         ; Yes - Do string arrays
   F282 7E            [ 6] 2794         LD      A,(HL)          ; Get type of variable
   F283 23            [ 4] 2795         INC     HL
   F284 23            [ 4] 2796         INC     HL
   F285 B7            [ 4] 2797         OR      A               ; "S" flag set if string
   F286 CD BD F2      [16] 2798         CALL    STRADD          ; See if string in string area
   F289 C3 77 F2      [ 9] 2799         JP      SMPVAR          ; Loop until simple ones done
                           2800 
   F28C C1            [ 9] 2801 GNXARY: POP     BC              ; Scrap address of this array
   F28D EB            [ 3] 2802 ARRLP:  EX      DE,HL
   F28E 2A DA 10      [15] 2803         LD      HL,(ARREND)     ; End of string arrays
   F291 EB            [ 3] 2804         EX      DE,HL
   F292 CD 8C E6      [16] 2805         CALL    CPDEHL          ; All string arrays done?
   F295 CA E3 F2      [ 9] 2806         JP      Z,SCNEND        ; Yes - Move string if found
   F298 CD 64 F8      [16] 2807         CALL    LOADFP          ; Get array name to BCDE
   F29B 7B            [ 4] 2808         LD      A,E             ; Get type of array     
   F29C E5            [11] 2809         PUSH    HL              ; Save address of num of dim'ns
   F29D 09            [ 7] 2810         ADD     HL,BC           ; Start of next array
   F29E B7            [ 4] 2811         OR      A               ; Test type of array
   F29F F2 8C F2      [ 9] 2812         JP      P,GNXARY        ; Numeric array - Ignore it
   F2A2 22 C5 10      [16] 2813         LD      (CUROPR),HL     ; Save address of next array
   F2A5 E1            [ 9] 2814         POP     HL              ; Get address of num of dim'ns
   F2A6 4E            [ 6] 2815         LD      C,(HL)          ; BC = Number of dimensions
   F2A7 06 00         [ 6] 2816         LD      B,#0
   F2A9 09            [ 7] 2817         ADD     HL,BC           ; Two bytes per dimension size
   F2AA 09            [ 7] 2818         ADD     HL,BC
   F2AB 23            [ 4] 2819         INC     HL              ; Plus one for number of dim'ns
   F2AC EB            [ 3] 2820 GRBARY: EX      DE,HL
   F2AD 2A C5 10      [15] 2821         LD      HL,(CUROPR)     ; Get address of next array
   F2B0 EB            [ 3] 2822         EX      DE,HL
   F2B1 CD 8C E6      [16] 2823         CALL    CPDEHL          ; Is this array finished?
   F2B4 CA 8D F2      [ 9] 2824         JP      Z,ARRLP         ; Yes - Get next one
   F2B7 01 AC F2      [ 9] 2825         LD      BC,#GRBARY       ; Loop until array all done
   F2BA C5            [11] 2826 STPOOL: PUSH    BC              ; Save return address
   F2BB F6 80         [ 6] 2827         OR      #0x80             ; Flag string type
   F2BD 7E            [ 6] 2828 STRADD: LD      A,(HL)          ; Get string length
   F2BE 23            [ 4] 2829         INC     HL
   F2BF 23            [ 4] 2830         INC     HL
   F2C0 5E            [ 6] 2831         LD      E,(HL)          ; Get LSB of string address
   F2C1 23            [ 4] 2832         INC     HL
   F2C2 56            [ 6] 2833         LD      D,(HL)          ; Get MSB of string address
   F2C3 23            [ 4] 2834         INC     HL
   F2C4 F0            [10] 2835         RET     P               ; Not a string - Return
   F2C5 B7            [ 4] 2836         OR      A               ; Set flags on string length
   F2C6 C8            [10] 2837         RET     Z               ; Null string - Return
   F2C7 44            [ 4] 2838         LD      B,H             ; Save variable pointer
   F2C8 4D            [ 4] 2839         LD      C,L
   F2C9 2A C3 10      [15] 2840         LD      HL,(STRBOT)     ; Bottom of new area
   F2CC CD 8C E6      [16] 2841         CALL    CPDEHL          ; String been done?
   F2CF 60            [ 4] 2842         LD      H,B             ; Restore variable pointer
   F2D0 69            [ 4] 2843         LD      L,C
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 53.
Hexadecimal [16-Bits]



   F2D1 D8            [10] 2844         RET     C               ; String done - Ignore
   F2D2 E1            [ 9] 2845         POP     HL              ; Return address
   F2D3 E3            [16] 2846         EX      (SP),HL         ; Lowest available string area
   F2D4 CD 8C E6      [16] 2847         CALL    CPDEHL          ; String within string area?
   F2D7 E3            [16] 2848         EX      (SP),HL         ; Lowest available string area
   F2D8 E5            [11] 2849         PUSH    HL              ; Re-save return address
   F2D9 60            [ 4] 2850         LD      H,B             ; Restore variable pointer
   F2DA 69            [ 4] 2851         LD      L,C
   F2DB D0            [10] 2852         RET     NC              ; Outside string area - Ignore
   F2DC C1            [ 9] 2853         POP     BC              ; Get return , Throw 2 away
   F2DD F1            [ 9] 2854         POP     AF              ; 
   F2DE F1            [ 9] 2855         POP     AF              ; 
   F2DF E5            [11] 2856         PUSH    HL              ; Save variable pointer
   F2E0 D5            [11] 2857         PUSH    DE              ; Save address of current
   F2E1 C5            [11] 2858         PUSH    BC              ; Put back return address
   F2E2 C9            [ 9] 2859         RET                     ; Go to it
                           2860 
   F2E3 D1            [ 9] 2861 SCNEND: POP     DE              ; Addresses of strings
   F2E4 E1            [ 9] 2862         POP     HL              ; 
   F2E5 7D            [ 4] 2863         LD      A,L             ; HL = 0 if no more to do
   F2E6 B4            [ 4] 2864         OR      H
   F2E7 C8            [10] 2865         RET     Z               ; No more to do - Return
   F2E8 2B            [ 4] 2866         DEC     HL
   F2E9 46            [ 6] 2867         LD      B,(HL)          ; MSB of address of string
   F2EA 2B            [ 4] 2868         DEC     HL
   F2EB 4E            [ 6] 2869         LD      C,(HL)          ; LSB of address of string
   F2EC E5            [11] 2870         PUSH    HL              ; Save variable address
   F2ED 2B            [ 4] 2871         DEC     HL
   F2EE 2B            [ 4] 2872         DEC     HL
   F2EF 6E            [ 6] 2873         LD      L,(HL)          ; HL = Length of string
   F2F0 26 00         [ 6] 2874         LD      H,#0
   F2F2 09            [ 7] 2875         ADD     HL,BC           ; Address of end of string+1
   F2F3 50            [ 4] 2876         LD      D,B             ; String address to DE
   F2F4 59            [ 4] 2877         LD      E,C
   F2F5 2B            [ 4] 2878         DEC     HL              ; Last byte in string
   F2F6 44            [ 4] 2879         LD      B,H             ; Address to BC
   F2F7 4D            [ 4] 2880         LD      C,L
   F2F8 2A C3 10      [15] 2881         LD      HL,(STRBOT)     ; Current bottom of string area
   F2FB CD 7E E3      [16] 2882         CALL    MOVSTR          ; Move string to new address
   F2FE E1            [ 9] 2883         POP     HL              ; Restore variable address
   F2FF 71            [ 7] 2884         LD      (HL),C          ; Save new LSB of address
   F300 23            [ 4] 2885         INC     HL
   F301 70            [ 7] 2886         LD      (HL),B          ; Save new MSB of address
   F302 69            [ 4] 2887         LD      L,C             ; Next string area+1 to HL
   F303 60            [ 4] 2888         LD      H,B
   F304 2B            [ 4] 2889         DEC     HL              ; Next string area address
   F305 C3 58 F2      [ 9] 2890         JP      GARBLP          ; Look for more strings
                           2891 
   F308 C5            [11] 2892 CONCAT: PUSH    BC              ; Save prec' opr & code string
   F309 E5            [11] 2893         PUSH    HL              ; 
   F30A 2A E4 10      [15] 2894         LD      HL,(FPREG)      ; Get first string
   F30D E3            [16] 2895         EX      (SP),HL         ; Save first string
   F30E CD D3 ED      [16] 2896         CALL    OPRND           ; Get second string
   F311 E3            [16] 2897         EX      (SP),HL         ; Restore first string
   F312 CD 47 ED      [16] 2898         CALL    TSTSTR          ; Make sure it's a string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 54.
Hexadecimal [16-Bits]



   F315 7E            [ 6] 2899         LD      A,(HL)          ; Get length of second string
   F316 E5            [11] 2900         PUSH    HL              ; Save first string
   F317 2A E4 10      [15] 2901         LD      HL,(FPREG)      ; Get second string
   F31A E5            [11] 2902         PUSH    HL              ; Save second string
   F31B 86            [ 6] 2903         ADD     A,(HL)          ; Add length of second string
   F31C 1E 1C         [ 6] 2904         LD      E,#LS            ; ?LS Error
   F31E DA C3 E3      [ 9] 2905         JP      C,ERROR         ; String too long - Error
   F321 CD C1 F1      [16] 2906         CALL    MKTMST          ; Make temporary string
   F324 D1            [ 9] 2907         POP     DE              ; Get second string to DE
   F325 CD 59 F3      [16] 2908         CALL    GSTRDE          ; Move to string pool if needed
   F328 E3            [16] 2909         EX      (SP),HL         ; Get first string
   F329 CD 58 F3      [16] 2910         CALL    GSTRHL          ; Move to string pool if needed
   F32C E5            [11] 2911         PUSH    HL              ; Save first string
   F32D 2A C1 10      [15] 2912         LD      HL,(TMPSTR+2)   ; Temporary string address
   F330 EB            [ 3] 2913         EX      DE,HL           ; To DE
   F331 CD 3F F3      [16] 2914         CALL    SSTSA           ; First string to string area
   F334 CD 3F F3      [16] 2915         CALL    SSTSA           ; Second string to string area
   F337 21 68 ED      [ 9] 2916         LD      HL,#EVAL2        ; Return to evaluation loop
   F33A E3            [16] 2917         EX      (SP),HL         ; Save return,get code string
   F33B E5            [11] 2918         PUSH    HL              ; Save code string address
   F33C C3 F2 F1      [ 9] 2919         JP      TSTOPL          ; To temporary string to pool
                           2920 
   F33F E1            [ 9] 2921 SSTSA:  POP     HL              ; Return address
   F340 E3            [16] 2922         EX      (SP),HL         ; Get string block,save return
   F341 7E            [ 6] 2923         LD      A,(HL)          ; Get length of string
   F342 23            [ 4] 2924         INC     HL
   F343 23            [ 4] 2925         INC     HL
   F344 4E            [ 6] 2926         LD      C,(HL)          ; Get LSB of string address
   F345 23            [ 4] 2927         INC     HL
   F346 46            [ 6] 2928         LD      B,(HL)          ; Get MSB of string address
   F347 6F            [ 4] 2929         LD      L,A             ; Length to L
   F348 2C            [ 4] 2930 TOSTRA: INC     L               ; INC - DECed after
   F349 2D            [ 4] 2931 TSALP:  DEC     L               ; Count bytes moved
   F34A C8            [10] 2932         RET     Z               ; End of string - Return
   F34B 0A            [ 6] 2933         LD      A,(BC)          ; Get source
   F34C 12            [ 7] 2934         LD      (DE),A          ; Save destination
   F34D 03            [ 4] 2935         INC     BC              ; Next source
   F34E 13            [ 4] 2936         INC     DE              ; Next destination
   F34F C3 49 F3      [ 9] 2937         JP      TSALP           ; Loop until string moved
                           2938 
   F352 CD 47 ED      [16] 2939 GETSTR: CALL    TSTSTR          ; Make sure it's a string
   F355 2A E4 10      [15] 2940 GSTRCU: LD      HL,(FPREG)      ; Get current string
   F358 EB            [ 3] 2941 GSTRHL: EX      DE,HL           ; Save DE
   F359 CD 73 F3      [16] 2942 GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
   F35C EB            [ 3] 2943         EX      DE,HL           ; Restore DE
   F35D C0            [10] 2944         RET     NZ              ; No - Return
   F35E D5            [11] 2945         PUSH    DE              ; Save string
   F35F 50            [ 4] 2946         LD      D,B             ; String block address to DE
   F360 59            [ 4] 2947         LD      E,C
   F361 1B            [ 4] 2948         DEC     DE              ; Point to length
   F362 4E            [ 6] 2949         LD      C,(HL)          ; Get string length
   F363 2A C3 10      [15] 2950         LD      HL,(STRBOT)     ; Current bottom of string area
   F366 CD 8C E6      [16] 2951         CALL    CPDEHL          ; Last one in string area?
   F369 C2 71 F3      [ 9] 2952         JP      NZ,POPHL        ; No - Return
   F36C 47            [ 4] 2953         LD      B,A             ; Clear B (A=0)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 55.
Hexadecimal [16-Bits]



   F36D 09            [ 7] 2954         ADD     HL,BC           ; Remove string from str' area
   F36E 22 C3 10      [16] 2955         LD      (STRBOT),HL     ; Save new bottom of str' area
   F371 E1            [ 9] 2956 POPHL:  POP     HL              ; Restore string
   F372 C9            [ 9] 2957         RET
                           2958 
   F373 2A B1 10      [15] 2959 BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
   F376 2B            [ 4] 2960         DEC     HL              ; Back
   F377 46            [ 6] 2961         LD      B,(HL)          ; Get MSB of address
   F378 2B            [ 4] 2962         DEC     HL              ; Back
   F379 4E            [ 6] 2963         LD      C,(HL)          ; Get LSB of address
   F37A 2B            [ 4] 2964         DEC     HL              ; Back
   F37B 2B            [ 4] 2965         DEC     HL              ; Back
   F37C CD 8C E6      [16] 2966         CALL    CPDEHL          ; String last in string pool?
   F37F C0            [10] 2967         RET     NZ              ; Yes - Leave it
   F380 22 B1 10      [16] 2968         LD      (TMSTPT),HL     ; Save new string pool top
   F383 C9            [ 9] 2969         RET
                           2970 
   F384 01 03 F1      [ 9] 2971 LEN:    LD      BC,#PASSA        ; To return integer A
   F387 C5            [11] 2972         PUSH    BC              ; Save address
   F388 CD 52 F3      [16] 2973 GETLEN: CALL    GETSTR          ; Get string and its length
   F38B AF            [ 4] 2974         XOR     A
   F38C 57            [ 4] 2975         LD      D,A             ; Clear D
   F38D 32 AD 10      [13] 2976         LD      (TYPE),A        ; Set type to numeric
   F390 7E            [ 6] 2977         LD      A,(HL)          ; Get length of string
   F391 B7            [ 4] 2978         OR      A               ; Set status flags
   F392 C9            [ 9] 2979         RET
                           2980 
   F393 01 03 F1      [ 9] 2981 ASC:    LD      BC,#PASSA        ; To return integer A
   F396 C5            [11] 2982         PUSH    BC              ; Save address
   F397 CD 88 F3      [16] 2983 GTFLNM: CALL    GETLEN          ; Get length of string
   F39A CA A2 E9      [ 9] 2984         JP      Z,FCERR         ; Null string - Error
   F39D 23            [ 4] 2985         INC     HL
   F39E 23            [ 4] 2986         INC     HL
   F39F 5E            [ 6] 2987         LD      E,(HL)          ; Get LSB of address
   F3A0 23            [ 4] 2988         INC     HL
   F3A1 56            [ 6] 2989         LD      D,(HL)          ; Get MSB of address
   F3A2 1A            [ 6] 2990         LD      A,(DE)          ; Get first byte of string
   F3A3 C9            [ 9] 2991         RET
                           2992 
   F3A4 3E 01         [ 6] 2993 CHR:    LD      A,#1             ; One character string
   F3A6 CD C1 F1      [16] 2994         CALL    MKTMST          ; Make a temporary string
   F3A9 CD 89 F4      [16] 2995         CALL    MAKINT          ; Make it integer A
   F3AC 2A C1 10      [15] 2996         LD      HL,(TMPSTR+2)   ; Get address of string
   F3AF 73            [ 7] 2997         LD      (HL),E          ; Save character
   F3B0 C1            [ 9] 2998 TOPOOL: POP     BC              ; Clean up stack
   F3B1 C3 F2 F1      [ 9] 2999         JP      TSTOPL          ; Temporary string to pool
                           3000 
   F3B4 CD 39 F4      [16] 3001 LEFT:   CALL    LFRGNM          ; Get number and ending ")"
   F3B7 AF            [ 4] 3002         XOR     A               ; Start at first byte in string
   F3B8 E3            [16] 3003 RIGHT1: EX      (SP),HL         ; Save code string,Get string
   F3B9 4F            [ 4] 3004         LD      C,A             ; Starting position in string
   F3BA E5            [11] 3005 MID1:   PUSH    HL              ; Save string block address
   F3BB 7E            [ 6] 3006         LD      A,(HL)          ; Get length of string
   F3BC B8            [ 4] 3007         CP      B               ; Compare with number given
   F3BD DA C2 F3      [ 9] 3008         JP      C,ALLFOL        ; All following bytes required
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 56.
Hexadecimal [16-Bits]



   F3C0 78            [ 4] 3009         LD      A,B             ; Get new length
   F3C1 11                 3010         .db      0x11             ; Skip "LD C,0"
   F3C2 0E 00         [ 6] 3011 ALLFOL: LD      C,#0             ; First byte of string
   F3C4 C5            [11] 3012         PUSH    BC              ; Save position in string
   F3C5 CD 2B F2      [16] 3013         CALL    TESTR           ; See if enough string space
   F3C8 C1            [ 9] 3014         POP     BC              ; Get position in string
   F3C9 E1            [ 9] 3015         POP     HL              ; Restore string block address
   F3CA E5            [11] 3016         PUSH    HL              ; And re-save it
   F3CB 23            [ 4] 3017         INC     HL
   F3CC 23            [ 4] 3018         INC     HL
   F3CD 46            [ 6] 3019         LD      B,(HL)          ; Get LSB of address
   F3CE 23            [ 4] 3020         INC     HL
   F3CF 66            [ 6] 3021         LD      H,(HL)          ; Get MSB of address
   F3D0 68            [ 4] 3022         LD      L,B             ; HL = address of string
   F3D1 06 00         [ 6] 3023         LD      B,#0             ; BC = starting address
   F3D3 09            [ 7] 3024         ADD     HL,BC           ; Point to that byte
   F3D4 44            [ 4] 3025         LD      B,H             ; BC = source string
   F3D5 4D            [ 4] 3026         LD      C,L
   F3D6 CD C4 F1      [16] 3027         CALL    CRTMST          ; Create a string entry
   F3D9 6F            [ 4] 3028         LD      L,A             ; Length of new string
   F3DA CD 48 F3      [16] 3029         CALL    TOSTRA          ; Move string to string area
   F3DD D1            [ 9] 3030         POP     DE              ; Clear stack
   F3DE CD 59 F3      [16] 3031         CALL    GSTRDE          ; Move to string pool if needed
   F3E1 C3 F2 F1      [ 9] 3032         JP      TSTOPL          ; Temporary string to pool
                           3033 
   F3E4 CD 39 F4      [16] 3034 RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
   F3E7 D1            [ 9] 3035         POP     DE              ; Get string length
   F3E8 D5            [11] 3036         PUSH    DE              ; And re-save
   F3E9 1A            [ 6] 3037         LD      A,(DE)          ; Get length
   F3EA 90            [ 4] 3038         SUB     B               ; Move back N bytes
   F3EB C3 B8 F3      [ 9] 3039         JP      RIGHT1          ; Go and get sub-string
                           3040 
   F3EE EB            [ 3] 3041 MID:    EX      DE,HL           ; Get code string address
   F3EF 7E            [ 6] 3042         LD      A,(HL)          ; Get next byte "," or ")"
   F3F0 CD 3E F4      [16] 3043         CALL    MIDNUM          ; Get number supplied
   F3F3 04            [ 4] 3044         INC     B               ; Is it character zero?
   F3F4 05            [ 4] 3045         DEC     B
   F3F5 CA A2 E9      [ 9] 3046         JP      Z,FCERR         ; Yes - Error
   F3F8 C5            [11] 3047         PUSH    BC              ; Save starting position
   F3F9 1E FF         [ 6] 3048         LD      E,#255           ; All of string
   F3FB FE 29         [ 6] 3049         CP      #")"             ; Any length given?
   F3FD CA 07 F4      [ 9] 3050         JP      Z,#RSTSTR        ; No - Rest of string
   F400 CD 92 E6      [16] 3051         CALL    CHKSYN          ; Make sure "," follows
   F403 2C                 3052         .db     ","
   F404 CD 86 F4      [16] 3053         CALL    GETINT          ; Get integer 0-255
   F407 CD 92 E6      [16] 3054 RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
   F40A 29                 3055         .db     ")"
   F40B F1            [ 9] 3056         POP     AF              ; Restore starting position
   F40C E3            [16] 3057         EX      (SP),HL         ; Get string,8ave code string
   F40D 01 BA F3      [ 9] 3058         LD      BC,#MID1         ; Continuation of MID$ routine
   F410 C5            [11] 3059         PUSH    BC              ; Save for return
   F411 3D            [ 4] 3060         DEC     A               ; Starting position-1
   F412 BE            [ 6] 3061         CP      (HL)            ; Compare with length
   F413 06 00         [ 6] 3062         LD      B,#0             ; Zero bytes length
   F415 D0            [10] 3063         RET     NC              ; Null string if start past end
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 57.
Hexadecimal [16-Bits]



   F416 4F            [ 4] 3064         LD      C,A             ; Save starting position-1
   F417 7E            [ 6] 3065         LD      A,(HL)          ; Get length of string
   F418 91            [ 4] 3066         SUB     C               ; Subtract start
   F419 BB            [ 4] 3067         CP      E               ; Enough string for it?
   F41A 47            [ 4] 3068         LD      B,A             ; Save maximum length available
   F41B D8            [10] 3069         RET     C               ; Truncate string if needed
   F41C 43            [ 4] 3070         LD      B,E             ; Set specified length
   F41D C9            [ 9] 3071         RET                     ; Go and create string
                           3072 
   F41E CD 88 F3      [16] 3073 VAL:    CALL    GETLEN          ; Get length of string
   F421 CA 35 F6      [ 9] 3074         JP      Z,RESZER        ; Result zero
   F424 5F            [ 4] 3075         LD      E,A             ; Save length
   F425 23            [ 4] 3076         INC     HL
   F426 23            [ 4] 3077         INC     HL
   F427 7E            [ 6] 3078         LD      A,(HL)          ; Get LSB of address
   F428 23            [ 4] 3079         INC     HL
   F429 66            [ 6] 3080         LD      H,(HL)          ; Get MSB of address
   F42A 6F            [ 4] 3081         LD      L,A             ; HL = String address
   F42B E5            [11] 3082         PUSH    HL              ; Save string address
   F42C 19            [ 7] 3083         ADD     HL,DE
   F42D 46            [ 6] 3084         LD      B,(HL)          ; Get end of string+1 byte
   F42E 72            [ 7] 3085         LD      (HL),D          ; Zero it to terminate
   F42F E3            [16] 3086         EX      (SP),HL         ; Save string end,get start
   F430 C5            [11] 3087         PUSH    BC              ; Save end+1 byte
   F431 7E            [ 6] 3088         LD      A,(HL)          ; Get starting byte
   F432 CD 1C F9      [16] 3089         CALL    ASCTFP          ; Convert ASCII string to FP
   F435 C1            [ 9] 3090         POP     BC              ; Restore end+1 byte
   F436 E1            [ 9] 3091         POP     HL              ; Restore end+1 address
   F437 70            [ 7] 3092         LD      (HL),B          ; Put back original byte
   F438 C9            [ 9] 3093         RET
                           3094 
   F439 EB            [ 3] 3095 LFRGNM: EX      DE,HL           ; Code string address to HL
   F43A CD 92 E6      [16] 3096         CALL    CHKSYN          ; Make sure ")" follows
   F43D 29                 3097         .db     ")"
   F43E C1            [ 9] 3098 MIDNUM: POP     BC              ; Get return address
   F43F D1            [ 9] 3099         POP     DE              ; Get number supplied
   F440 C5            [11] 3100         PUSH    BC              ; Re-save return address
   F441 43            [ 4] 3101         LD      B,E             ; Number to B
   F442 C9            [ 9] 3102         RET
                           3103 
   F443 CD 89 F4      [16] 3104 INP:    CALL    MAKINT          ; Make it integer A
   F446 32 3F 10      [13] 3105         LD      (INPORT),A      ; Set input port
   F449 CD 3E 10      [16] 3106         CALL    INPSUB          ; Get input from port
   F44C C3 03 F1      [ 9] 3107         JP      PASSA           ; Return integer A
                           3108 
   F44F CD 73 F4      [16] 3109 POUT:   CALL    SETIO           ; Set up port number
   F452 C3 06 10      [ 9] 3110         JP      OUTSUB          ; Output data and return
                           3111 
   F455 CD 73 F4      [16] 3112 WAIT:   CALL    SETIO           ; Set up port number
   F458 F5            [11] 3113         PUSH    AF              ; Save AND mask
   F459 1E 00         [ 6] 3114         LD      E,#0             ; Assume zero if none given
   F45B 2B            [ 4] 3115         DEC     HL              ; DEC 'cos GETCHR INCs
   F45C CD 38 E8      [16] 3116         CALL    GETCHR          ; Get next character
   F45F CA 69 F4      [ 9] 3117         JP      Z,NOXOR         ; No XOR byte given
   F462 CD 92 E6      [16] 3118         CALL    CHKSYN          ; Make sure "," follows
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 58.
Hexadecimal [16-Bits]



   F465 2C                 3119         .db     ","
   F466 CD 86 F4      [16] 3120         CALL    GETINT          ; Get integer 0-255 to XOR with
   F469 C1            [ 9] 3121 NOXOR:  POP     BC              ; Restore AND mask
   F46A CD 3E 10      [16] 3122 WAITLP: CALL    INPSUB          ; Get input
   F46D AB            [ 4] 3123         XOR     E               ; Flip selected bits
   F46E A0            [ 4] 3124         AND     B               ; Result non-zero?
   F46F CA 6A F4      [ 9] 3125         JP      Z,WAITLP        ; No = keep waiting
   F472 C9            [ 9] 3126         RET
                           3127 
   F473 CD 86 F4      [16] 3128 SETIO:  CALL    GETINT          ; Get integer 0-255
   F476 32 3F 10      [13] 3129         LD      (INPORT),A      ; Set input port
   F479 32 07 10      [13] 3130         LD      (OTPORT),A      ; Set output port
   F47C CD 92 E6      [16] 3131         CALL    CHKSYN          ; Make sure "," follows
   F47F 2C                 3132         .db     ","
   F480 C3 86 F4      [ 9] 3133         JP      GETINT          ; Get integer 0-255 and return
                           3134 
   F483 CD 38 E8      [16] 3135 FNDNUM: CALL    GETCHR          ; Get next character
   F486 CD 43 ED      [16] 3136 GETINT: CALL    GETNUM          ; Get a number from 0 to 255
   F489 CD 87 E9      [16] 3137 MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
   F48C 7A            [ 4] 3138         LD      A,D             ; Get MSB of number
   F48D B7            [ 4] 3139         OR      A               ; Zero?
   F48E C2 A2 E9      [ 9] 3140         JP      NZ,FCERR        ; No - Error
   F491 2B            [ 4] 3141         DEC     HL              ; DEC 'cos GETCHR INCs
   F492 CD 38 E8      [16] 3142         CALL    GETCHR          ; Get next character
   F495 7B            [ 4] 3143         LD      A,E             ; Get number to A
   F496 C9            [ 9] 3144         RET
                           3145 
                           3146 ; << NO  REFERENCE  TO  THIS  SECTION  OF  CODE >>
                           3147 ; << Set up another program area (can be in ROM) >>
                           3148 
   F497 2A 5E 10      [15] 3149         LD      HL,(BASTXT)     ; Get start of program text
   F49A 22 D6 10      [16] 3150         LD      (PROGND),HL     ; Set more variable space
   F49D 21 00 80      [ 9] 3151         LD      HL,#0x8000        ; Address of new program
   F4A0 5E            [ 6] 3152         LD      E,(HL)          ; Get LSB of new RAM end
   F4A1 23            [ 4] 3153         INC     HL
   F4A2 56            [ 6] 3154         LD      D,(HL)          ; Get MSB of new RAM end
   F4A3 23            [ 4] 3155         INC     HL
   F4A4 23            [ 4] 3156         INC     HL              ; Null at start of program
   F4A5 22 5E 10      [16] 3157         LD      (BASTXT),HL     ; New program text area 0x8003
   F4A8 EB            [ 3] 3158         EX      DE,HL           ; New RAM end to HL
   F4A9 22 AF 10      [16] 3159         LD      (LSTRAM),HL     ; Set new RAM end
   F4AC 22 5A 10      [16] 3160         LD      (STRSPC),HL     ; Clear string space
   F4AF 01 F4 E7      [ 9] 3161         LD      BC,#RUNCNT       ; Execution driver loop
   F4B2 C5            [11] 3162         PUSH    BC              ; Save for return
   F4B3 C3 C7 E4      [ 9] 3163         JP      RUNFST          ; Clear variables and continue
                           3164 
   F4B6 C3 58 FD      [ 9] 3165 RUART:  JP      GUART           ; Get a byte from UART
                           3166 
   F4B9 CD BC F4      [16] 3167 WUART2: CALL    WUART           ; Send 2 Bytes to UART
   F4BC F5            [11] 3168 WUART:  PUSH    AF              ; Save byte
   F4BD C5            [11] 3169         PUSH    BC              ; Save BC
   F4BE 4F            [ 4] 3170         LD      C,A             ; Byte to C
   F4BF CD 6A FD      [16] 3171         CALL    SUART           ; Send byte to UART
   F4C2 C1            [ 9] 3172         POP     BC              ; Restore BC
   F4C3 F1            [ 9] 3173         POP     AF              ; Restore byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 59.
Hexadecimal [16-Bits]



   F4C4 C9            [ 9] 3174         RET
                           3175 
   F4C5 06 01         [ 6] 3176 CSAVE:  LD      B,#1             ; Flag "CSAVE"
   F4C7 FE AE         [ 6] 3177         CP      #ZTIMES          ; "*" token? ("CSAVE*")
   F4C9 CA BD E8      [ 9] 3178         JP      Z,ARRSV1        ; Yes - Array save
   F4CC CD 5C ED      [16] 3179         CALL    EVAL            ; Evaluate expression
   F4CF E5            [11] 3180         PUSH    HL              ; Save code string address
   F4D0 CD 97 F3      [16] 3181         CALL    GTFLNM          ; Get file name
   F4D3 D5            [11] 3182         PUSH    DE              ; Save file name
   F4D4 CD CA FC      [16] 3183         CALL    CASFFW          ; Turn on motor and wait
   F4D7 D1            [ 9] 3184         POP     DE              ; Restore file name
   F4D8 3E D3         [ 6] 3185         LD      A,#0b11010011     ; Header byte
   F4DA CD BC F4      [16] 3186         CALL    WUART           ; Send byte to UART
   F4DD CD B9 F4      [16] 3187         CALL    WUART2          ; Send byte twice more
   F4E0 1A            [ 6] 3188         LD      A,(DE)          ; Get file name
   F4E1 CD BC F4      [16] 3189         CALL    WUART           ; Send it to UART
   F4E4 00            [ 3] 3190         NOP
   F4E5 00            [ 3] 3191         NOP
   F4E6 00            [ 3] 3192         NOP
   F4E7 21 D6 10      [ 9] 3193         LD      HL,#PROGND       ; Start of program information
   F4EA 22 0C 0C      [16] 3194         LD      (ARG1),HL       ; Save for monitor save routine
   F4ED 2A D6 10      [15] 3195         LD      HL,(PROGND)     ; End of program information
   F4F0 22 0E 0C      [16] 3196         LD      (ARG2),HL       ; Save for monitor save routine
   F4F3 CD 75 FE      [16] 3197         CALL    SAVE            ; Save program to tape
   F4F6 CD DA FC      [16] 3198         CALL    ARET            ; Not much there!
   F4F9 E1            [ 9] 3199         POP     HL              ; Restore code string address
   F4FA C9            [ 9] 3200         RET
                           3201 
   F4FB 7E            [ 6] 3202 CLOAD:  LD      A,(HL)          ; Get byte after "CLOAD"
   F4FC FE AE         [ 6] 3203         CP      #ZTIMES          ; "*" token? ("CLOAD*")
   F4FE CA BB E8      [ 9] 3204         JP      Z,ARRLD1        ; Yes - Array load
   F501 CD D3 FF      [16] 3205         CALL    SMOTOR          ; Start motor and get "?"
   F504 D6 9E         [ 6] 3206         SUB     #ZPRINT          ; "?" ("PRINT" token) Verify?
   F506 CA 0B F5      [ 9] 3207         JP      Z,FLGVER        ; Yes - Flag "verify"
   F509 AF            [ 4] 3208         XOR     A               ; Flag "load"
   F50A 01                 3209         .db      0x01             ; Skip "CPL" and "INC HL"
   F50B 2F            [ 3] 3210 FLGVER: CPL                     ; Flag "verify"
   F50C 23            [ 4] 3211         INC     HL              ; Skip over "?"
   F50D F5            [11] 3212         PUSH    AF              ; Save verify flag
   F50E 2B            [ 4] 3213         DEC     HL              ; DEC 'cos GETCHR INCs
   F50F CD 38 E8      [16] 3214         CALL    GETCHR          ; Get next character
   F512 3E 00         [ 6] 3215         LD      A,#0             ; Any file will do
   F514 CA 1E F5      [ 9] 3216         JP      Z,ANYNAM        ; No name given - Any will do
   F517 CD 5C ED      [16] 3217         CALL    EVAL            ; Evaluate expression
   F51A CD 97 F3      [16] 3218         CALL    GTFLNM          ; Get file name
   F51D 1A            [ 6] 3219         LD      A,(DE)          ; Get first byte of name
   F51E 6F            [ 4] 3220 ANYNAM: LD      L,A             ; Save name to find
   F51F F1            [ 9] 3221         POP     AF              ; Get verify flag
   F520 F5            [11] 3222         PUSH    AF              ; And re-save
   F521 B7            [ 4] 3223         OR      A               ; Verify of load?
   F522 67            [ 4] 3224         LD      H,A
   F523 22 E4 10      [16] 3225         LD      (FPREG),HL      ; Save nam of file to find
   F526 CC BC E4      [16] 3226         CALL    Z,CLRPTR        ; Load - Clear pointers
   F529 2A E4 10      [15] 3227         LD      HL,(FPREG)      ; Get name of program to find
   F52C EB            [ 3] 3228         EX      DE,HL           ; Name to DE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 60.
Hexadecimal [16-Bits]



   F52D 06 03         [ 6] 3229 CLOAD1: LD      B,#3             ; 3 Header bytes
   F52F CD B6 F4      [16] 3230 CLOAD2: CALL    RUART           ; Get a byte from UART
   F532 D6 D3         [ 6] 3231         SUB     #0b11010011       ; Header byte?
   F534 C2 2D F5      [ 9] 3232         JP      NZ,CLOAD1       ; Look for header
   F537 05            [ 4] 3233         DEC     B               ; Count header bytes
   F538 C2 2F F5      [ 9] 3234         JP      NZ,CLOAD2       ; More to find?
   F53B CD B6 F4      [16] 3235         CALL    RUART           ; Get name of file
   F53E CD 76 F5      [16] 3236         CALL    FILFND          ; Display "file X found"
   F541 1C            [ 4] 3237         INC     E               ; Any file name given?
   F542 1D            [ 4] 3238         DEC     E
   F543 CA 4A F5      [ 9] 3239         JP      Z,THSFIL        ; No - This file will do
   F546 BB            [ 4] 3240         CP      E               ; Has file been found?
   F547 C2 2D F5      [ 9] 3241         JP      NZ,CLOAD1       ; No - Look for another
   F54A 00            [ 3] 3242 THSFIL: NOP
   F54B 00            [ 3] 3243         NOP
   F54C 00            [ 3] 3244         NOP
   F54D F1            [ 9] 3245         POP     AF              ; Get verify flag
   F54E B7            [ 4] 3246         OR      A               ; Load or verify?
   F54F C2 5E F5      [ 9] 3247         JP      NZ,CLOADV       ; Verify program
   F552 CD 8A FE      [16] 3248         CALL    MONLD           ; Use monitor to load program
   F555 2A D6 10      [15] 3249         LD      HL,(PROGND)     ; Get end of program
   F558 CD 95 E3      [16] 3250         CALL    ENFMEM          ; See if enough memory
   F55B C3 61 F5      [ 9] 3251         JP      CLOADE          ; "Ok" and set up pointers
                           3252 
   F55E CD AC FE      [16] 3253 CLOADV: CALL    MONVE           ; Use monitor to verify program
   F561 21 4D E3      [ 9] 3254 CLOADE: LD      HL,#OKMSG        ; "Ok" message
   F564 CD 12 F2      [16] 3255         CALL    PRS             ; Output string
   F567 CD DA FC      [16] 3256         CALL    ARET            ; Not a lot there!
   F56A C3 7E E4      [ 9] 3257         JP      SETPTR          ; Set up line pointers
                           3258 
   F56D 21 9F F5      [ 9] 3259 OUTBAD: LD      HL,#BAD          ; "Bad" message
   F570 CD 12 F2      [16] 3260         CALL    PRS             ; Output string
   F573 C3 E3 E3      [ 9] 3261         JP      ERRIN           ; In line message
                           3262 
   F576 C5            [11] 3263 FILFND: PUSH    BC              ; <- Save
   F577 E5            [11] 3264         PUSH    HL              ; <- all
   F578 D5            [11] 3265         PUSH    DE              ; <- the
   F579 F5            [11] 3266         PUSH    AF              ; <- registers
   F57A 21 90 F5      [ 9] 3267         LD      HL,#FILE         ; "File" message
   F57D CD 12 F2      [16] 3268         CALL    PRS             ; Output string
   F580 F1            [ 9] 3269         POP     AF              ; Get file name
   F581 F5            [11] 3270         PUSH    AF              ; And re-save
   F582 CD DB FC      [16] 3271         CALL    CONMON          ; Output file name to screen
   F585 21 96 F5      [ 9] 3272         LD      HL,#FOUND        ; "Found" message
   F588 CD 12 F2      [16] 3273         CALL    PRS             ; Output string
   F58B F1            [ 9] 3274         POP     AF              ; <- Restore
   F58C D1            [ 9] 3275         POP     DE              ; <- all
   F58D E1            [ 9] 3276         POP     HL              ; <- the
   F58E C1            [ 9] 3277         POP     BC              ; <- registers
   F58F C9            [ 9] 3278         RET
                           3279 
   F590 46 69 6C 65 20     3280 FILE:   .ascii      "File "
   F595 00                 3281         .db 0
   F596 20 46 6F 75 6E 64  3282 FOUND:  .ascii      " Found"
   F59C 0D 0A 00           3283         .db CR,LF,0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 61.
Hexadecimal [16-Bits]



   F59F 42 61 64           3284 BAD:    .ascii      "Bad"
   F5A2 00 00 00           3285         .db 0,0,0
                           3286 
   F5A5 CD 8D E9      [16] 3287 PEEK:   CALL    DEINT           ; Get memory address
   F5A8 1A            [ 6] 3288         LD      A,(DE)          ; Get byte in memory
   F5A9 C3 03 F1      [ 9] 3289         JP      PASSA           ; Return integer A
                           3290 
   F5AC CD 43 ED      [16] 3291 POKE:   CALL    GETNUM          ; Get memory address
   F5AF CD 8D E9      [16] 3292         CALL    DEINT           ; Get integer -32768 to 3276
   F5B2 D5            [11] 3293         PUSH    DE              ; Save memory address
   F5B3 CD 92 E6      [16] 3294         CALL    CHKSYN          ; Make sure "," follows
   F5B6 2C                 3295         .db      ","
   F5B7 CD 86 F4      [16] 3296         CALL    GETINT          ; Get integer 0-255
   F5BA D1            [ 9] 3297         POP     DE              ; Restore memory address
   F5BB 12            [ 7] 3298         LD      (DE),A          ; Load it into memory
   F5BC C9            [ 9] 3299         RET
                           3300 
   F5BD 21 93 FA      [ 9] 3301 ROUND:  LD      HL,#HALF         ; Add 0.5 to FPREG
   F5C0 CD 64 F8      [16] 3302 ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
   F5C3 C3 CF F5      [ 9] 3303         JP      FPADD           ; Add BCDE to FPREG
                           3304 
   F5C6 CD 64 F8      [16] 3305 SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
   F5C9 21                 3306         .db      0x21             ; Skip "POP BC" and "POP DE"
   F5CA C1            [ 9] 3307 PSUB:   POP     BC              ; Get FP number from stack
   F5CB D1            [ 9] 3308         POP     DE
   F5CC CD 3E F8      [16] 3309 SUBCDE: CALL    INVSGN          ; Negate FPREG
   F5CF 78            [ 4] 3310 FPADD:  LD      A,B             ; Get FP exponent
   F5D0 B7            [ 4] 3311         OR      A               ; Is number zero?
   F5D1 C8            [10] 3312         RET     Z               ; Yes - Nothing to add
   F5D2 3A E7 10      [12] 3313         LD      A,(FPEXP)       ; Get FPREG exponent
   F5D5 B7            [ 4] 3314         OR      A               ; Is this number zero?
   F5D6 CA 56 F8      [ 9] 3315         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
   F5D9 90            [ 4] 3316         SUB     B               ; BCDE number larger?
   F5DA D2 E9 F5      [ 9] 3317         JP      NC,NOSWAP       ; No - Don't swap them
   F5DD 2F            [ 3] 3318         CPL                     ; Two's complement
   F5DE 3C            [ 4] 3319         INC     A               ;  FP exponent
   F5DF EB            [ 3] 3320         EX      DE,HL
   F5E0 CD 46 F8      [16] 3321         CALL    STAKFP          ; Put FPREG on stack
   F5E3 EB            [ 3] 3322         EX      DE,HL
   F5E4 CD 56 F8      [16] 3323         CALL    FPBCDE          ; Move BCDE to FPREG
   F5E7 C1            [ 9] 3324         POP     BC              ; Restore number from stack
   F5E8 D1            [ 9] 3325         POP     DE
   F5E9 FE 19         [ 6] 3326 NOSWAP: CP      #24+1            ; Second number insignificant?
   F5EB D0            [10] 3327         RET     NC              ; Yes - First number is result
   F5EC F5            [11] 3328         PUSH    AF              ; Save number of bits to scale
   F5ED CD 7B F8      [16] 3329         CALL    SIGNS           ; Set MSBs & sign of result
   F5F0 67            [ 4] 3330         LD      H,A             ; Save sign of result
   F5F1 F1            [ 9] 3331         POP     AF              ; Restore scaling factor
   F5F2 CD 94 F6      [16] 3332         CALL    SCALE           ; Scale BCDE to same exponent
   F5F5 B4            [ 4] 3333         OR      H               ; Result to be positive?
   F5F6 21 E4 10      [ 9] 3334         LD      HL,#FPREG        ; Point to FPREG
   F5F9 F2 0F F6      [ 9] 3335         JP      P,MINCDE        ; No - Subtract FPREG from CDE
   F5FC CD 74 F6      [16] 3336         CALL    PLUCDE          ; Add FPREG to CDE
   F5FF D2 55 F6      [ 9] 3337         JP      NC,RONDUP       ; No overflow - Round it up
   F602 23            [ 4] 3338         INC     HL              ; Point to exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 62.
Hexadecimal [16-Bits]



   F603 34            [10] 3339         INC     (HL)            ; Increment it
   F604 CA BE E3      [ 9] 3340         JP      Z,OVERR         ; Number overflowed - Error
   F607 2E 01         [ 6] 3341         LD      L,#1             ; 1 bit to shift right
   F609 CD AA F6      [16] 3342         CALL    SHRT1           ; Shift result right
   F60C C3 55 F6      [ 9] 3343         JP      RONDUP          ; Round it up
                           3344 
   F60F AF            [ 4] 3345 MINCDE: XOR     A               ; Clear A and carry
   F610 90            [ 4] 3346         SUB     B               ; Negate exponent
   F611 47            [ 4] 3347         LD      B,A             ; Re-save exponent
   F612 7E            [ 6] 3348         LD      A,(HL)          ; Get LSB of FPREG
   F613 9B            [ 4] 3349         SBC     A, E            ; Subtract LSB of BCDE
   F614 5F            [ 4] 3350         LD      E,A             ; Save LSB of BCDE
   F615 23            [ 4] 3351         INC     HL
   F616 7E            [ 6] 3352         LD      A,(HL)          ; Get NMSB of FPREG
   F617 9A            [ 4] 3353         SBC     A,D             ; Subtract NMSB of BCDE
   F618 57            [ 4] 3354         LD      D,A             ; Save NMSB of BCDE
   F619 23            [ 4] 3355         INC     HL
   F61A 7E            [ 6] 3356         LD      A,(HL)          ; Get MSB of FPREG
   F61B 99            [ 4] 3357         SBC     A,C             ; Subtract MSB of BCDE
   F61C 4F            [ 4] 3358         LD      C,A             ; Save MSB of BCDE
   F61D DC 80 F6      [16] 3359 CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                           3360 
   F620 68            [ 4] 3361 BNORM:  LD      L,B             ; L = Exponent
   F621 63            [ 4] 3362         LD      H,E             ; H = LSB
   F622 AF            [ 4] 3363         XOR     A
   F623 47            [ 4] 3364 BNRMLP: LD      B,A             ; Save bit count
   F624 79            [ 4] 3365         LD      A,C             ; Get MSB
   F625 B7            [ 4] 3366         OR      A               ; Is it zero?
   F626 C2 42 F6      [ 9] 3367         JP      NZ,PNORM        ; No - Do it bit at a time
   F629 4A            [ 4] 3368         LD      C,D             ; MSB = NMSB
   F62A 54            [ 4] 3369         LD      D,H             ; NMSB= LSB
   F62B 65            [ 4] 3370         LD      H,L             ; LSB = VLSB
   F62C 6F            [ 4] 3371         LD      L,A             ; VLSB= 0
   F62D 78            [ 4] 3372         LD      A,B             ; Get exponent
   F62E D6 08         [ 6] 3373         SUB     #8               ; Count 8 bits
   F630 FE E0         [ 6] 3374         CP      #-24-8           ; Was number zero?
   F632 C2 23 F6      [ 9] 3375         JP      NZ,BNRMLP       ; No - Keep normalising
   F635 AF            [ 4] 3376 RESZER: XOR     A               ; Result is zero
   F636 32 E7 10      [13] 3377 SAVEXP: LD      (FPEXP),A       ; Save result as zero
   F639 C9            [ 9] 3378         RET
                           3379 
   F63A 05            [ 4] 3380 NORMAL: DEC     B               ; Count bits
   F63B 29            [ 7] 3381         ADD     HL,HL           ; Shift HL left
   F63C 7A            [ 4] 3382         LD      A,D             ; Get NMSB
   F63D 17            [ 3] 3383         RLA                     ; Shift left with last bit
   F63E 57            [ 4] 3384         LD      D,A             ; Save NMSB
   F63F 79            [ 4] 3385         LD      A,C             ; Get MSB
   F640 8F            [ 4] 3386         ADC     A,A             ; Shift left with last bit
   F641 4F            [ 4] 3387         LD      C,A             ; Save MSB
   F642 F2 3A F6      [ 9] 3388 PNORM:  JP      P,NORMAL        ; Not done - Keep going
   F645 78            [ 4] 3389         LD      A,B             ; Number of bits shifted
   F646 5C            [ 4] 3390         LD      E,H             ; Save HL in EB
   F647 45            [ 4] 3391         LD      B,L
   F648 B7            [ 4] 3392         OR      A               ; Any shifting done?
   F649 CA 55 F6      [ 9] 3393         JP      Z,RONDUP        ; No - Round it up
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 63.
Hexadecimal [16-Bits]



   F64C 21 E7 10      [ 9] 3394         LD      HL,#FPEXP        ; Point to exponent
   F64F 86            [ 6] 3395         ADD     A,(HL)          ; Add shifted bits
   F650 77            [ 7] 3396         LD      (HL),A          ; Re-save exponent
   F651 D2 35 F6      [ 9] 3397         JP      NC,RESZER       ; Underflow - Result is zero
   F654 C8            [10] 3398         RET     Z               ; Result is zero
   F655 78            [ 4] 3399 RONDUP: LD      A,B             ; Get VLSB of number
   F656 21 E7 10      [ 9] 3400 RONDB:  LD      HL,#FPEXP        ; Point to exponent
   F659 B7            [ 4] 3401         OR      A               ; Any rounding?
   F65A FC 67 F6      [16] 3402         CALL    M,FPROND        ; Yes - Round number up
   F65D 46            [ 6] 3403         LD      B,(HL)          ; B = Exponent
   F65E 23            [ 4] 3404         INC     HL
   F65F 7E            [ 6] 3405         LD      A,(HL)          ; Get sign of result
   F660 E6 80         [ 6] 3406         AND     #0b10000000       ; Only bit 7 needed
   F662 A9            [ 4] 3407         XOR     C               ; Set correct sign
   F663 4F            [ 4] 3408         LD      C,A             ; Save correct sign in number
   F664 C3 56 F8      [ 9] 3409         JP      FPBCDE          ; Move BCDE to FPREG
                           3410 
   F667 1C            [ 4] 3411 FPROND: INC     E               ; Round LSB
   F668 C0            [10] 3412         RET     NZ              ; Return if ok
   F669 14            [ 4] 3413         INC     D               ; Round NMSB
   F66A C0            [10] 3414         RET     NZ              ; Return if ok
   F66B 0C            [ 4] 3415         INC     C               ; Round MSB
   F66C C0            [10] 3416         RET     NZ              ; Return if ok
   F66D 0E 80         [ 6] 3417         LD      C,#0x80           ; Set normal value
   F66F 34            [10] 3418         INC     (HL)            ; Increment exponent
   F670 C0            [10] 3419         RET     NZ              ; Return if ok
   F671 C3 BE E3      [ 9] 3420         JP      OVERR           ; Overflow error
                           3421 
   F674 7E            [ 6] 3422 PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
   F675 83            [ 4] 3423         ADD     A,E             ; Add LSB of BCDE
   F676 5F            [ 4] 3424         LD      E,A             ; Save LSB of BCDE
   F677 23            [ 4] 3425         INC     HL
   F678 7E            [ 6] 3426         LD      A,(HL)          ; Get NMSB of FPREG
   F679 8A            [ 4] 3427         ADC     A,D             ; Add NMSB of BCDE
   F67A 57            [ 4] 3428         LD      D,A             ; Save NMSB of BCDE
   F67B 23            [ 4] 3429         INC     HL
   F67C 7E            [ 6] 3430         LD      A,(HL)          ; Get MSB of FPREG
   F67D 89            [ 4] 3431         ADC     A,C             ; Add MSB of BCDE
   F67E 4F            [ 4] 3432         LD      C,A             ; Save MSB of BCDE
   F67F C9            [ 9] 3433         RET
                           3434 
   F680 21 E8 10      [ 9] 3435 COMPL:  LD      HL,#SGNRES       ; Sign of result
   F683 7E            [ 6] 3436         LD      A,(HL)          ; Get sign of result
   F684 2F            [ 3] 3437         CPL                     ; Negate it
   F685 77            [ 7] 3438         LD      (HL),A          ; Put it back
   F686 AF            [ 4] 3439         XOR     A
   F687 6F            [ 4] 3440         LD      L,A             ; Set L to zero
   F688 90            [ 4] 3441         SUB     B               ; Negate exponent,set carry
   F689 47            [ 4] 3442         LD      B,A             ; Re-save exponent
   F68A 7D            [ 4] 3443         LD      A,L             ; Load zero
   F68B 9B            [ 4] 3444         SBC     A,E             ; Negate LSB
   F68C 5F            [ 4] 3445         LD      E,A             ; Re-save LSB
   F68D 7D            [ 4] 3446         LD      A,L             ; Load zero
   F68E 9A            [ 4] 3447         SBC     A,D             ; Negate NMSB
   F68F 57            [ 4] 3448         LD      D,A             ; Re-save NMSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 64.
Hexadecimal [16-Bits]



   F690 7D            [ 4] 3449         LD      A,L             ; Load zero
   F691 99            [ 4] 3450         SBC     A,C             ; Negate MSB
   F692 4F            [ 4] 3451         LD      C,A             ; Re-save MSB
   F693 C9            [ 9] 3452         RET
                           3453 
   F694 06 00         [ 6] 3454 SCALE:  LD      B,#0             ; Clear underflow
   F696 D6 08         [ 6] 3455 SCALLP: SUB     #8               ; 8 bits (a whole byte)?
   F698 DA A3 F6      [ 9] 3456         JP      C,SHRITE        ; No - Shift right A bits
   F69B 43            [ 4] 3457         LD      B,E             ; <- Shift
   F69C 5A            [ 4] 3458         LD      E,D             ; <- right
   F69D 51            [ 4] 3459         LD      D,C             ; <- eight
   F69E 0E 00         [ 6] 3460         LD      C,#0             ; <- bits
   F6A0 C3 96 F6      [ 9] 3461         JP      SCALLP          ; More bits to shift
                           3462 
   F6A3 C6 09         [ 6] 3463 SHRITE: ADD     A,#8+1           ; Adjust count
   F6A5 6F            [ 4] 3464         LD      L,A             ; Save bits to shift
   F6A6 AF            [ 4] 3465 SHRLP:  XOR     A               ; Flag for all done
   F6A7 2D            [ 4] 3466         DEC     L               ; All shifting done?
   F6A8 C8            [10] 3467         RET     Z               ; Yes - Return
   F6A9 79            [ 4] 3468         LD      A,C             ; Get MSB
   F6AA 1F            [ 3] 3469 SHRT1:  RRA                     ; Shift it right
   F6AB 4F            [ 4] 3470         LD      C,A             ; Re-save
   F6AC 7A            [ 4] 3471         LD      A,D             ; Get NMSB
   F6AD 1F            [ 3] 3472         RRA                     ; Shift right with last bit
   F6AE 57            [ 4] 3473         LD      D,A             ; Re-save it
   F6AF 7B            [ 4] 3474         LD      A,E             ; Get LSB
   F6B0 1F            [ 3] 3475         RRA                     ; Shift right with last bit
   F6B1 5F            [ 4] 3476         LD      E,A             ; Re-save it
   F6B2 78            [ 4] 3477         LD      A,B             ; Get underflow
   F6B3 1F            [ 3] 3478         RRA                     ; Shift right with last bit
   F6B4 47            [ 4] 3479         LD      B,A             ; Re-save underflow
   F6B5 C3 A6 F6      [ 9] 3480         JP      SHRLP           ; More bits to do
                           3481 
   F6B8 00 00 00 81        3482 UNITY:  .db       0x00,0x00,0x00,0x81    ; 1.00000
                           3483 
   F6BC 03                 3484 LOGTAB: .db      3                       ; Table used by LOG
   F6BD AA 56 19 80        3485         .db      0xAA,0x56,0x19,0x80     ; 0.59898
   F6C1 F1 22 76 80        3486         .db      0xF1,0x22,0x76,0x80     ; 0.96147
   F6C5 45 AA 38 82        3487         .db      0x45,0xAA,0x38,0x82     ; 2.88539
                           3488 
   F6C9 CD 15 F8      [16] 3489 LOG:    CALL    TSTSGN          ; Test sign of value
   F6CC B7            [ 4] 3490         OR      A
   F6CD EA A2 E9      [ 9] 3491         JP      PE,FCERR        ; ?FC Error if <= zero
   F6D0 21 E7 10      [ 9] 3492         LD      HL,#FPEXP        ; Point to exponent
   F6D3 7E            [ 6] 3493         LD      A,(HL)          ; Get exponent
   F6D4 01 35 80      [ 9] 3494         LD      BC,#0x8035        ; BCDE = SQR(1/2)
   F6D7 11 F3 04      [ 9] 3495         LD      DE,#0x04F3
   F6DA 90            [ 4] 3496         SUB     B               ; Scale value to be < 1
   F6DB F5            [11] 3497         PUSH    AF              ; Save scale factor
   F6DC 70            [ 7] 3498         LD      (HL),B          ; Save new exponent
   F6DD D5            [11] 3499         PUSH    DE              ; Save SQR(1/2)
   F6DE C5            [11] 3500         PUSH    BC
   F6DF CD CF F5      [16] 3501         CALL    FPADD           ; Add SQR(1/2) to value
   F6E2 C1            [ 9] 3502         POP     BC              ; Restore SQR(1/2)
   F6E3 D1            [ 9] 3503         POP     DE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 65.
Hexadecimal [16-Bits]



   F6E4 04            [ 4] 3504         INC     B               ; Make it SQR(2)
   F6E5 CD 6B F7      [16] 3505         CALL    DVBCDE          ; Divide by SQR(2)
   F6E8 21 B8 F6      [ 9] 3506         LD      HL,#UNITY        ; Point to 1.
   F6EB CD C6 F5      [16] 3507         CALL    SUBPHL          ; Subtract FPREG from 1
   F6EE 21 BC F6      [ 9] 3508         LD      HL,#LOGTAB       ; Coefficient table
   F6F1 CD 5D FB      [16] 3509         CALL    SUMSER          ; Evaluate sum of series
   F6F4 01 80 80      [ 9] 3510         LD      BC,#0x8080        ; BCDE = -0.5
   F6F7 11 00 00      [ 9] 3511         LD      DE,#0x0000
   F6FA CD CF F5      [16] 3512         CALL    FPADD           ; Subtract 0.5 from FPREG
   F6FD F1            [ 9] 3513         POP     AF              ; Restore scale factor
   F6FE CD 90 F9      [16] 3514         CALL    RSCALE          ; Re-scale number
   F701 01 31 80      [ 9] 3515 MULLN2: LD      BC,#0x8031        ; BCDE = Ln(2)
   F704 11 18 72      [ 9] 3516         LD      DE,#0x7218
   F707 21                 3517         .db      0x21             ; Skip "POP BC" and "POP DE"
                           3518 
   F708 C1            [ 9] 3519 MULT:   POP     BC              ; Get number from stack
   F709 D1            [ 9] 3520         POP     DE
   F70A CD 15 F8      [16] 3521 FPMULT: CALL    TSTSGN          ; Test sign of FPREG
   F70D C8            [10] 3522         RET     Z               ; Return zero if zero
   F70E 2E 00         [ 6] 3523         LD      L,#0             ; Flag add exponents
   F710 CD D3 F7      [16] 3524         CALL    ADDEXP          ; Add exponents
   F713 79            [ 4] 3525         LD      A,C             ; Get MSB of multiplier
   F714 32 F6 10      [13] 3526         LD      (MULVAL),A      ; Save MSB of multiplier
   F717 EB            [ 3] 3527         EX      DE,HL
   F718 22 F7 10      [16] 3528         LD      (MULVAL+1),HL   ; Save rest of multiplier
   F71B 01 00 00      [ 9] 3529         LD      BC,#0            ; Partial product (BCDE) = zero
   F71E 50            [ 4] 3530         LD      D,B
   F71F 58            [ 4] 3531         LD      E,B
   F720 21 20 F6      [ 9] 3532         LD      HL,#BNORM        ; Address of normalise
   F723 E5            [11] 3533         PUSH    HL              ; Save for return
   F724 21 2C F7      [ 9] 3534         LD      HL,#MULT8        ; Address of 8 bit multiply
   F727 E5            [11] 3535         PUSH    HL              ; Save for NMSB,MSB
   F728 E5            [11] 3536         PUSH    HL              ; 
   F729 21 E4 10      [ 9] 3537         LD      HL,#FPREG        ; Point to number
   F72C 7E            [ 6] 3538 MULT8:  LD      A,(HL)          ; Get LSB of number
   F72D 23            [ 4] 3539         INC     HL              ; Point to NMSB
   F72E B7            [ 4] 3540         OR      A               ; Test LSB
   F72F CA 58 F7      [ 9] 3541         JP      Z,BYTSFT        ; Zero - shift to next byte
   F732 E5            [11] 3542         PUSH    HL              ; Save address of number
   F733 2E 08         [ 6] 3543         LD      L,#8             ; 8 bits to multiply by
   F735 1F            [ 3] 3544 MUL8LP: RRA                     ; Shift LSB right
   F736 67            [ 4] 3545         LD      H,A             ; Save LSB
   F737 79            [ 4] 3546         LD      A,C             ; Get MSB
   F738 D2 46 F7      [ 9] 3547         JP      NC,NOMADD       ; Bit was zero - Don't add
   F73B E5            [11] 3548         PUSH    HL              ; Save LSB and count
   F73C 2A F7 10      [15] 3549         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
   F73F 19            [ 7] 3550         ADD     HL,DE           ; Add NMSB and LSB
   F740 EB            [ 3] 3551         EX      DE,HL           ; Leave sum in DE
   F741 E1            [ 9] 3552         POP     HL              ; Restore MSB and count
   F742 3A F6 10      [12] 3553         LD      A,(MULVAL)      ; Get MSB of multiplier
   F745 89            [ 4] 3554         ADC     A,C             ; Add MSB
   F746 1F            [ 3] 3555 NOMADD: RRA                     ; Shift MSB right
   F747 4F            [ 4] 3556         LD      C,A             ; Re-save MSB
   F748 7A            [ 4] 3557         LD      A,D             ; Get NMSB
   F749 1F            [ 3] 3558         RRA                     ; Shift NMSB right
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 66.
Hexadecimal [16-Bits]



   F74A 57            [ 4] 3559         LD      D,A             ; Re-save NMSB
   F74B 7B            [ 4] 3560         LD      A,E             ; Get LSB
   F74C 1F            [ 3] 3561         RRA                     ; Shift LSB right
   F74D 5F            [ 4] 3562         LD      E,A             ; Re-save LSB
   F74E 78            [ 4] 3563         LD      A,B             ; Get VLSB
   F74F 1F            [ 3] 3564         RRA                     ; Shift VLSB right
   F750 47            [ 4] 3565         LD      B,A             ; Re-save VLSB
   F751 2D            [ 4] 3566         DEC     L               ; Count bits multiplied
   F752 7C            [ 4] 3567         LD      A,H             ; Get LSB of multiplier
   F753 C2 35 F7      [ 9] 3568         JP      NZ,MUL8LP       ; More - Do it
   F756 E1            [ 9] 3569 POPHRT: POP     HL              ; Restore address of number
   F757 C9            [ 9] 3570         RET
                           3571 
   F758 43            [ 4] 3572 BYTSFT: LD      B,E             ; Shift partial product left
   F759 5A            [ 4] 3573         LD      E,D
   F75A 51            [ 4] 3574         LD      D,C
   F75B 4F            [ 4] 3575         LD      C,A
   F75C C9            [ 9] 3576         RET
                           3577 
   F75D CD 46 F8      [16] 3578 DIV10:  CALL    STAKFP          ; Save FPREG on stack
   F760 01 20 84      [ 9] 3579         LD      BC,#0x8420        ; BCDE = 10.
   F763 11 00 00      [ 9] 3580         LD      DE,#0x0000
   F766 CD 56 F8      [16] 3581         CALL    FPBCDE          ; Move 10 to FPREG
                           3582 
   F769 C1            [ 9] 3583 DIV:    POP     BC              ; Get number from stack
   F76A D1            [ 9] 3584         POP     DE
   F76B CD 15 F8      [16] 3585 DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
   F76E CA B2 E3      [ 9] 3586         JP      Z,DZERR         ; Error if division by zero
   F771 2E FF         [ 6] 3587         LD      L,#-1            ; Flag subtract exponents
   F773 CD D3 F7      [16] 3588         CALL    ADDEXP          ; Subtract exponents
   F776 34            [10] 3589         INC     (HL)            ; Add 2 to exponent to adjust
   F777 34            [10] 3590         INC     (HL)
   F778 2B            [ 4] 3591         DEC     HL              ; Point to MSB
   F779 7E            [ 6] 3592         LD      A,(HL)          ; Get MSB of dividend
   F77A 32 12 10      [13] 3593         LD      (DIV3),A        ; Save for subtraction
   F77D 2B            [ 4] 3594         DEC     HL
   F77E 7E            [ 6] 3595         LD      A,(HL)          ; Get NMSB of dividend
   F77F 32 0E 10      [13] 3596         LD      (DIV2),A        ; Save for subtraction
   F782 2B            [ 4] 3597         DEC     HL
   F783 7E            [ 6] 3598         LD      A,(HL)          ; Get MSB of dividend
   F784 32 0A 10      [13] 3599         LD      (DIV1),A        ; Save for subtraction
   F787 41            [ 4] 3600         LD      B,C             ; Get MSB
   F788 EB            [ 3] 3601         EX      DE,HL           ; NMSB,LSB to HL
   F789 AF            [ 4] 3602         XOR     A
   F78A 4F            [ 4] 3603         LD      C,A             ; Clear MSB of quotient
   F78B 57            [ 4] 3604         LD      D,A             ; Clear NMSB of quotient
   F78C 5F            [ 4] 3605         LD      E,A             ; Clear LSB of quotient
   F78D 32 15 10      [13] 3606         LD      (DIV4),A        ; Clear overflow count
   F790 E5            [11] 3607 DIVLP:  PUSH    HL              ; Save divisor
   F791 C5            [11] 3608         PUSH    BC
   F792 7D            [ 4] 3609         LD      A,L             ; Get LSB of number
   F793 CD 09 10      [16] 3610         CALL    DIVSUP          ; Subt' divisor from dividend
   F796 DE 00         [ 6] 3611         SBC     A,#0             ; Count for overflows
   F798 3F            [ 3] 3612         CCF
   F799 D2 A3 F7      [ 9] 3613         JP      NC,RESDIV       ; Restore divisor if borrow
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 67.
Hexadecimal [16-Bits]



   F79C 32 15 10      [13] 3614         LD      (DIV4),A        ; Re-save overflow count
   F79F F1            [ 9] 3615         POP     AF              ; Scrap divisor
   F7A0 F1            [ 9] 3616         POP     AF
   F7A1 37            [ 3] 3617         SCF                     ; Set carry to
   F7A2 D2                 3618         .db      0x0D2            ; Skip "POP BC" and "POP HL"
                           3619 
   F7A3 C1            [ 9] 3620 RESDIV: POP     BC              ; Restore divisor
   F7A4 E1            [ 9] 3621         POP     HL
   F7A5 79            [ 4] 3622         LD      A,C             ; Get MSB of quotient
   F7A6 3C            [ 4] 3623         INC     A
   F7A7 3D            [ 4] 3624         DEC     A
   F7A8 1F            [ 3] 3625         RRA                     ; Bit 0 to bit 7
   F7A9 FA 56 F6      [ 9] 3626         JP      M,RONDB         ; Done - Normalise result
   F7AC 17            [ 3] 3627         RLA                     ; Restore carry
   F7AD 7B            [ 4] 3628         LD      A,E             ; Get LSB of quotient
   F7AE 17            [ 3] 3629         RLA                     ; Double it
   F7AF 5F            [ 4] 3630         LD      E,A             ; Put it back
   F7B0 7A            [ 4] 3631         LD      A,D             ; Get NMSB of quotient
   F7B1 17            [ 3] 3632         RLA                     ; Double it
   F7B2 57            [ 4] 3633         LD      D,A             ; Put it back
   F7B3 79            [ 4] 3634         LD      A,C             ; Get MSB of quotient
   F7B4 17            [ 3] 3635         RLA                     ; Double it
   F7B5 4F            [ 4] 3636         LD      C,A             ; Put it back
   F7B6 29            [ 7] 3637         ADD     HL,HL           ; Double NMSB,LSB of divisor
   F7B7 78            [ 4] 3638         LD      A,B             ; Get MSB of divisor
   F7B8 17            [ 3] 3639         RLA                     ; Double it
   F7B9 47            [ 4] 3640         LD      B,A             ; Put it back
   F7BA 3A 15 10      [12] 3641         LD      A,(DIV4)        ; Get VLSB of quotient
   F7BD 17            [ 3] 3642         RLA                     ; Double it
   F7BE 32 15 10      [13] 3643         LD      (DIV4),A        ; Put it back
   F7C1 79            [ 4] 3644         LD      A,C             ; Get MSB of quotient
   F7C2 B2            [ 4] 3645         OR      D               ; Merge NMSB
   F7C3 B3            [ 4] 3646         OR      E               ; Merge LSB
   F7C4 C2 90 F7      [ 9] 3647         JP      NZ,DIVLP        ; Not done - Keep dividing
   F7C7 E5            [11] 3648         PUSH    HL              ; Save divisor
   F7C8 21 E7 10      [ 9] 3649         LD      HL,#FPEXP        ; Point to exponent
   F7CB 35            [10] 3650         DEC     (HL)            ; Divide by 2
   F7CC E1            [ 9] 3651         POP     HL              ; Restore divisor
   F7CD C2 90 F7      [ 9] 3652         JP      NZ,DIVLP        ; Ok - Keep going
   F7D0 C3 BE E3      [ 9] 3653         JP      OVERR           ; Overflow error
                           3654 
   F7D3 78            [ 4] 3655 ADDEXP: LD      A,B             ; Get exponent of dividend
   F7D4 B7            [ 4] 3656         OR      A               ; Test it
   F7D5 CA F7 F7      [ 9] 3657         JP      Z,OVTST3        ; Zero - Result zero
   F7D8 7D            [ 4] 3658         LD      A,L             ; Get add/subtract flag
   F7D9 21 E7 10      [ 9] 3659         LD      HL,#FPEXP        ; Point to exponent
   F7DC AE            [ 6] 3660         XOR     (HL)            ; Add or subtract it
   F7DD 80            [ 4] 3661         ADD     A,B             ; Add the other exponent
   F7DE 47            [ 4] 3662         LD      B,A             ; Save new exponent
   F7DF 1F            [ 3] 3663         RRA                     ; Test exponent for overflow
   F7E0 A8            [ 4] 3664         XOR     B
   F7E1 78            [ 4] 3665         LD      A,B             ; Get exponent
   F7E2 F2 F6 F7      [ 9] 3666         JP      P,OVTST2        ; Positive - Test for overflow
   F7E5 C6 80         [ 6] 3667         ADD     A,#0x80           ; Add excess 128
   F7E7 77            [ 7] 3668         LD      (HL),A          ; Save new exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 68.
Hexadecimal [16-Bits]



   F7E8 CA 56 F7      [ 9] 3669         JP      Z,POPHRT        ; Zero - Result zero
   F7EB CD 7B F8      [16] 3670         CALL    SIGNS           ; Set MSBs and sign of result
   F7EE 77            [ 7] 3671         LD      (HL),A          ; Save new exponent
   F7EF 2B            [ 4] 3672         DEC     HL              ; Point to MSB
   F7F0 C9            [ 9] 3673         RET
                           3674 
   F7F1 CD 15 F8      [16] 3675 OVTST1: CALL    TSTSGN          ; Test sign of FPREG
   F7F4 2F            [ 3] 3676         CPL                     ; Invert sign
   F7F5 E1            [ 9] 3677         POP     HL              ; Clean up stack
   F7F6 B7            [ 4] 3678 OVTST2: OR      A               ; Test if new exponent zero
   F7F7 E1            [ 9] 3679 OVTST3: POP     HL              ; Clear off return address
   F7F8 F2 35 F6      [ 9] 3680         JP      P,RESZER        ; Result zero
   F7FB C3 BE E3      [ 9] 3681         JP      OVERR           ; Overflow error
                           3682 
   F7FE CD 61 F8      [16] 3683 MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
   F801 78            [ 4] 3684         LD      A,B             ; Get exponent
   F802 B7            [ 4] 3685         OR      A               ; Is it zero?
   F803 C8            [10] 3686         RET     Z               ; Yes - Result is zero
   F804 C6 02         [ 6] 3687         ADD     A,#2             ; Multiply by 4
   F806 DA BE E3      [ 9] 3688         JP      C,OVERR         ; Overflow - ?OV Error
   F809 47            [ 4] 3689         LD      B,A             ; Re-save exponent
   F80A CD CF F5      [16] 3690         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
   F80D 21 E7 10      [ 9] 3691         LD      HL,#FPEXP        ; Point to exponent
   F810 34            [10] 3692         INC     (HL)            ; Double number (Times 10)
   F811 C0            [10] 3693         RET     NZ              ; Ok - Return
   F812 C3 BE E3      [ 9] 3694         JP      OVERR           ; Overflow error
                           3695 
   F815 3A E7 10      [12] 3696 TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
   F818 B7            [ 4] 3697         OR      A
   F819 C8            [10] 3698         RET     Z               ; RETurn if number is zero
   F81A 3A E6 10      [12] 3699         LD      A,(FPREG+2)     ; Get MSB of FPREG
   F81D FE                 3700         .db      0x0FE            ; Test sign
   F81E 2F            [ 3] 3701 RETREL: CPL                     ; Invert sign
   F81F 17            [ 3] 3702         RLA                     ; Sign bit to carry
   F820 9F            [ 4] 3703 FLGDIF: SBC     A,A             ; Carry to all bits of A
   F821 C0            [10] 3704         RET     NZ              ; Return -1 if negative
   F822 3C            [ 4] 3705         INC     A               ; Bump to +1
   F823 C9            [ 9] 3706         RET                     ; Positive - Return +1
                           3707 
   F824 CD 15 F8      [16] 3708 SGN:    CALL    TSTSGN          ; Test sign of FPREG
   F827 06 88         [ 6] 3709 FLGREL: LD      B,#0x80+8         ; 8 bit integer in exponent
   F829 11 00 00      [ 9] 3710         LD      DE,#0            ; Zero NMSB and LSB
   F82C 21 E7 10      [ 9] 3711 RETINT: LD      HL,#FPEXP        ; Point to exponent
   F82F 4F            [ 4] 3712         LD      C,A             ; CDE = MSB,NMSB and LSB
   F830 70            [ 7] 3713         LD      (HL),B          ; Save exponent
   F831 06 00         [ 6] 3714         LD      B,#0             ; CDE = integer to normalise
   F833 23            [ 4] 3715         INC     HL              ; Point to sign of result
   F834 36 80         [ 9] 3716         LD      (HL),#0x80        ; Set sign of result
   F836 17            [ 3] 3717         RLA                     ; Carry = sign of integer
   F837 C3 1D F6      [ 9] 3718         JP      CONPOS          ; Set sign of result
                           3719 
   F83A CD 15 F8      [16] 3720 ABS:    CALL    TSTSGN          ; Test sign of FPREG
   F83D F0            [10] 3721         RET     P               ; Return if positive
   F83E 21 E6 10      [ 9] 3722 INVSGN: LD      HL,#FPREG+2      ; Point to MSB
   F841 7E            [ 6] 3723         LD      A,(HL)          ; Get sign of mantissa
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 69.
Hexadecimal [16-Bits]



   F842 EE 80         [ 6] 3724         XOR     #0x80             ; Invert sign of mantissa
   F844 77            [ 7] 3725         LD      (HL),A          ; Re-save sign of mantissa
   F845 C9            [ 9] 3726         RET
                           3727 
   F846 EB            [ 3] 3728 STAKFP: EX      DE,HL           ; Save code string address
   F847 2A E4 10      [15] 3729         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
   F84A E3            [16] 3730         EX      (SP),HL         ; Stack them,get return
   F84B E5            [11] 3731         PUSH    HL              ; Re-save return
   F84C 2A E6 10      [15] 3732         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
   F84F E3            [16] 3733         EX      (SP),HL         ; Stack them,get return
   F850 E5            [11] 3734         PUSH    HL              ; Re-save return
   F851 EB            [ 3] 3735         EX      DE,HL           ; Restore code string address
   F852 C9            [ 9] 3736         RET
                           3737 
   F853 CD 64 F8      [16] 3738 PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
   F856 EB            [ 3] 3739 FPBCDE: EX      DE,HL           ; Save code string address
   F857 22 E4 10      [16] 3740         LD      (FPREG),HL      ; Save LSB,NLSB of number
   F85A 60            [ 4] 3741         LD      H,B             ; Exponent of number
   F85B 69            [ 4] 3742         LD      L,C             ; MSB of number
   F85C 22 E6 10      [16] 3743         LD      (FPREG+2),HL    ; Save MSB and exponent
   F85F EB            [ 3] 3744         EX      DE,HL           ; Restore code string address
   F860 C9            [ 9] 3745         RET
                           3746 
   F861 21 E4 10      [ 9] 3747 BCDEFP: LD      HL,#FPREG        ; Point to FPREG
   F864 5E            [ 6] 3748 LOADFP: LD      E,(HL)          ; Get LSB of number
   F865 23            [ 4] 3749         INC     HL
   F866 56            [ 6] 3750         LD      D,(HL)          ; Get NMSB of number
   F867 23            [ 4] 3751         INC     HL
   F868 4E            [ 6] 3752         LD      C,(HL)          ; Get MSB of number
   F869 23            [ 4] 3753         INC     HL
   F86A 46            [ 6] 3754         LD      B,(HL)          ; Get exponent of number
   F86B 23            [ 4] 3755 INCHL:  INC     HL              ; Used for conditional "INC HL"
   F86C C9            [ 9] 3756         RET
                           3757 
   F86D 11 E4 10      [ 9] 3758 FPTHL:  LD      DE,#FPREG        ; Point to FPREG
   F870 06 04         [ 6] 3759 DETHL4: LD      B,#4             ; 4 bytes to move
   F872 1A            [ 6] 3760 DETHLB: LD      A,(DE)          ; Get source
   F873 77            [ 7] 3761         LD      (HL),A          ; Save destination
   F874 13            [ 4] 3762         INC     DE              ; Next source
   F875 23            [ 4] 3763         INC     HL              ; Next destination
   F876 05            [ 4] 3764         DEC     B               ; Count bytes
   F877 C2 72 F8      [ 9] 3765         JP      NZ,DETHLB       ; Loop if more
   F87A C9            [ 9] 3766         RET
                           3767 
   F87B 21 E6 10      [ 9] 3768 SIGNS:  LD      HL,#FPREG+2      ; Point to MSB of FPREG
   F87E 7E            [ 6] 3769         LD      A,(HL)          ; Get MSB
   F87F 07            [ 3] 3770         RLCA                    ; Old sign to carry
   F880 37            [ 3] 3771         SCF                     ; Set MSBit
   F881 1F            [ 3] 3772         RRA                     ; Set MSBit of MSB
   F882 77            [ 7] 3773         LD      (HL),A          ; Save new MSB
   F883 3F            [ 3] 3774         CCF                     ; Complement sign
   F884 1F            [ 3] 3775         RRA                     ; Old sign to carry
   F885 23            [ 4] 3776         INC     HL
   F886 23            [ 4] 3777         INC     HL
   F887 77            [ 7] 3778         LD      (HL),A          ; Set sign of result
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 70.
Hexadecimal [16-Bits]



   F888 79            [ 4] 3779         LD      A,C             ; Get MSB
   F889 07            [ 3] 3780         RLCA                    ; Old sign to carry
   F88A 37            [ 3] 3781         SCF                     ; Set MSBit
   F88B 1F            [ 3] 3782         RRA                     ; Set MSBit of MSB
   F88C 4F            [ 4] 3783         LD      C,A             ; Save MSB
   F88D 1F            [ 3] 3784         RRA
   F88E AE            [ 6] 3785         XOR     (HL)            ; New sign of result
   F88F C9            [ 9] 3786         RET
                           3787 
   F890 78            [ 4] 3788 CMPNUM: LD      A,B             ; Get exponent of number
   F891 B7            [ 4] 3789         OR      A
   F892 CA 15 F8      [ 9] 3790         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
   F895 21 1E F8      [ 9] 3791         LD      HL,#RETREL       ; Return relation routine
   F898 E5            [11] 3792         PUSH    HL              ; Save for return
   F899 CD 15 F8      [16] 3793         CALL    TSTSGN          ; Test sign of FPREG
   F89C 79            [ 4] 3794         LD      A,C             ; Get MSB of number
   F89D C8            [10] 3795         RET     Z               ; FPREG zero - Number's MSB
   F89E 21 E6 10      [ 9] 3796         LD      HL,#FPREG+2      ; MSB of FPREG
   F8A1 AE            [ 6] 3797         XOR     (HL)            ; Combine signs
   F8A2 79            [ 4] 3798         LD      A,C             ; Get MSB of number
   F8A3 F8            [10] 3799         RET     M               ; Exit if signs different
   F8A4 CD AA F8      [16] 3800         CALL    CMPFP           ; Compare FP numbers
   F8A7 1F            [ 3] 3801         RRA                     ; Get carry to sign
   F8A8 A9            [ 4] 3802         XOR     C               ; Combine with MSB of number
   F8A9 C9            [ 9] 3803         RET
                           3804 
   F8AA 23            [ 4] 3805 CMPFP:  INC     HL              ; Point to exponent
   F8AB 78            [ 4] 3806         LD      A,B             ; Get exponent
   F8AC BE            [ 6] 3807         CP      (HL)            ; Compare exponents
   F8AD C0            [10] 3808         RET     NZ              ; Different
   F8AE 2B            [ 4] 3809         DEC     HL              ; Point to MBS
   F8AF 79            [ 4] 3810         LD      A,C             ; Get MSB
   F8B0 BE            [ 6] 3811         CP      (HL)            ; Compare MSBs
   F8B1 C0            [10] 3812         RET     NZ              ; Different
   F8B2 2B            [ 4] 3813         DEC     HL              ; Point to NMSB
   F8B3 7A            [ 4] 3814         LD      A,D             ; Get NMSB
   F8B4 BE            [ 6] 3815         CP      (HL)            ; Compare NMSBs
   F8B5 C0            [10] 3816         RET     NZ              ; Different
   F8B6 2B            [ 4] 3817         DEC     HL              ; Point to LSB
   F8B7 7B            [ 4] 3818         LD      A,E             ; Get LSB
   F8B8 96            [ 6] 3819         SUB     (HL)            ; Compare LSBs
   F8B9 C0            [10] 3820         RET     NZ              ; Different
   F8BA E1            [ 9] 3821         POP     HL              ; Drop RETurn
   F8BB E1            [ 9] 3822         POP     HL              ; Drop another RETurn
   F8BC C9            [ 9] 3823         RET
                           3824 
   F8BD 47            [ 4] 3825 FPINT:  LD      B,A             ; <- Move
   F8BE 4F            [ 4] 3826         LD      C,A             ; <- exponent
   F8BF 57            [ 4] 3827         LD      D,A             ; <- to all
   F8C0 5F            [ 4] 3828         LD      E,A             ; <- bits
   F8C1 B7            [ 4] 3829         OR      A               ; Test exponent
   F8C2 C8            [10] 3830         RET     Z               ; Zero - Return zero
   F8C3 E5            [11] 3831         PUSH    HL              ; Save pointer to number
   F8C4 CD 61 F8      [16] 3832         CALL    BCDEFP          ; Move FPREG to BCDE
   F8C7 CD 7B F8      [16] 3833         CALL    SIGNS           ; Set MSBs & sign of result
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 71.
Hexadecimal [16-Bits]



   F8CA AE            [ 6] 3834         XOR     (HL)            ; Combine with sign of FPREG
   F8CB 67            [ 4] 3835         LD      H,A             ; Save combined signs
   F8CC FC E1 F8      [16] 3836         CALL    M,DCBCDE        ; Negative - Decrement BCDE
   F8CF 3E 98         [ 6] 3837         LD      A,#0x80+24        ; 24 bits
   F8D1 90            [ 4] 3838         SUB     B               ; Bits to shift
   F8D2 CD 94 F6      [16] 3839         CALL    SCALE           ; Shift BCDE
   F8D5 7C            [ 4] 3840         LD      A,H             ; Get combined sign
   F8D6 17            [ 3] 3841         RLA                     ; Sign to carry
   F8D7 DC 67 F6      [16] 3842         CALL    C,FPROND        ; Negative - Round number up
   F8DA 06 00         [ 6] 3843         LD      B,#0             ; Zero exponent
   F8DC DC 80 F6      [16] 3844         CALL    C,COMPL         ; If negative make positive
   F8DF E1            [ 9] 3845         POP     HL              ; Restore pointer to number
   F8E0 C9            [ 9] 3846         RET
                           3847 
   F8E1 1B            [ 4] 3848 DCBCDE: DEC     DE              ; Decrement BCDE
   F8E2 7A            [ 4] 3849         LD      A,D             ; Test LSBs
   F8E3 A3            [ 4] 3850         AND     E
   F8E4 3C            [ 4] 3851         INC     A
   F8E5 C0            [10] 3852         RET     NZ              ; Exit if LSBs not FFFF
   F8E6 0B            [ 4] 3853         DEC     BC              ; Decrement MSBs
   F8E7 C9            [ 9] 3854         RET
                           3855 
   F8E8 21 E7 10      [ 9] 3856 INT:    LD      HL,#FPEXP        ; Point to exponent
   F8EB 7E            [ 6] 3857         LD      A,(HL)          ; Get exponent
   F8EC FE 98         [ 6] 3858         CP      #0x80+24          ; Integer accuracy only?
   F8EE 3A E4 10      [12] 3859         LD      A,(FPREG)       ; Get LSB
   F8F1 D0            [10] 3860         RET     NC              ; Yes - Already integer
   F8F2 7E            [ 6] 3861         LD      A,(HL)          ; Get exponent
   F8F3 CD BD F8      [16] 3862         CALL    FPINT           ; F.P to integer
   F8F6 36 98         [ 9] 3863         LD      (HL),#0x80+24     ; Save 24 bit integer
   F8F8 7B            [ 4] 3864         LD      A,E             ; Get LSB of number
   F8F9 F5            [11] 3865         PUSH    AF              ; Save LSB
   F8FA 79            [ 4] 3866         LD      A,C             ; Get MSB of number
   F8FB 17            [ 3] 3867         RLA                     ; Sign to carry
   F8FC CD 1D F6      [16] 3868         CALL    CONPOS          ; Set sign of result
   F8FF F1            [ 9] 3869         POP     AF              ; Restore LSB of number
   F900 C9            [ 9] 3870         RET
                           3871 
   F901 21 00 00      [ 9] 3872 MLDEBC: LD      HL,#0            ; Clear partial product
   F904 78            [ 4] 3873         LD      A,B             ; Test multiplier
   F905 B1            [ 4] 3874         OR      C
   F906 C8            [10] 3875         RET     Z               ; Return zero if zero
   F907 3E 10         [ 6] 3876         LD      A,#16            ; 16 bits
   F909 29            [ 7] 3877 MLDBLP: ADD     HL,HL           ; Shift P.P left
   F90A DA 47 F0      [ 9] 3878         JP      C,BSERR         ; ?BS Error if overflow
   F90D EB            [ 3] 3879         EX      DE,HL
   F90E 29            [ 7] 3880         ADD     HL,HL           ; Shift multiplier left
   F90F EB            [ 3] 3881         EX      DE,HL
   F910 D2 17 F9      [ 9] 3882         JP      NC,NOMLAD       ; Bit was zero - No add
   F913 09            [ 7] 3883         ADD     HL,BC           ; Add multiplicand
   F914 DA 47 F0      [ 9] 3884         JP      C,BSERR         ; ?BS Error if overflow
   F917 3D            [ 4] 3885 NOMLAD: DEC     A               ; Count bits
   F918 C2 09 F9      [ 9] 3886         JP      NZ,MLDBLP       ; More
   F91B C9            [ 9] 3887         RET
                           3888 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 72.
Hexadecimal [16-Bits]



   F91C FE 2D         [ 6] 3889 ASCTFP: CP      #"-"             ; Negative?
   F91E F5            [11] 3890         PUSH    AF              ; Save it and flags
   F91F CA 28 F9      [ 9] 3891         JP      Z,CNVNUM        ; Yes - Convert number
   F922 FE 2B         [ 6] 3892         CP      #"+"             ; Positive?
   F924 CA 28 F9      [ 9] 3893         JP      Z,CNVNUM        ; Yes - Convert number
   F927 2B            [ 4] 3894         DEC     HL              ; DEC 'cos GETCHR INCs
   F928 CD 35 F6      [16] 3895 CNVNUM: CALL    RESZER          ; Set result to zero
   F92B 47            [ 4] 3896         LD      B,A             ; Digits after point counter
   F92C 57            [ 4] 3897         LD      D,A             ; Sign of exponent
   F92D 5F            [ 4] 3898         LD      E,A             ; Exponent of ten
   F92E 2F            [ 3] 3899         CPL
   F92F 4F            [ 4] 3900         LD      C,A             ; Before or after point flag
   F930 CD 38 E8      [16] 3901 MANLP:  CALL    GETCHR          ; Get next character
   F933 DA 79 F9      [ 9] 3902         JP      C,ADDIG         ; Digit - Add to number
   F936 FE 2E         [ 6] 3903         CP      #"."
   F938 CA 54 F9      [ 9] 3904         JP      Z,DPOINT        ; "." - Flag point
   F93B FE 45         [ 6] 3905         CP      #"E"
   F93D C2 58 F9      [ 9] 3906         JP      NZ,CONEXP       ; Not "E" - Scale number
   F940 CD 38 E8      [16] 3907         CALL    GETCHR          ; Get next character
   F943 CD 72 EE      [16] 3908         CALL    SGNEXP          ; Get sign of exponent
   F946 CD 38 E8      [16] 3909 EXPLP:  CALL    GETCHR          ; Get next character
   F949 DA 9B F9      [ 9] 3910         JP      C,EDIGIT        ; Digit - Add to exponent
   F94C 14            [ 4] 3911         INC     D               ; Is sign negative?
   F94D C2 58 F9      [ 9] 3912         JP      NZ,CONEXP       ; No - Scale number
   F950 AF            [ 4] 3913         XOR     A
   F951 93            [ 4] 3914         SUB     E               ; Negate exponent
   F952 5F            [ 4] 3915         LD      E,A             ; And re-save it
   F953 0C            [ 4] 3916         INC     C               ; Flag end of number
   F954 0C            [ 4] 3917 DPOINT: INC     C               ; Flag point passed
   F955 CA 30 F9      [ 9] 3918         JP      Z,MANLP         ; Zero - Get another digit
   F958 E5            [11] 3919 CONEXP: PUSH    HL              ; Save code string address
   F959 7B            [ 4] 3920         LD      A,E             ; Get exponent
   F95A 90            [ 4] 3921         SUB     B               ; Subtract digits after point
   F95B F4 71 F9      [16] 3922 SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
   F95E F2 67 F9      [ 9] 3923         JP      P,ENDCON        ; Positive - All done
   F961 F5            [11] 3924         PUSH    AF              ; Save number of times to /10
   F962 CD 5D F7      [16] 3925         CALL    DIV10           ; Divide by 10
   F965 F1            [ 9] 3926         POP     AF              ; Restore count
   F966 3C            [ 4] 3927         INC     A               ; Count divides
                           3928 
   F967 C2 5B F9      [ 9] 3929 ENDCON: JP      NZ,SCALMI       ; More to do
   F96A D1            [ 9] 3930         POP     DE              ; Restore code string address
   F96B F1            [ 9] 3931         POP     AF              ; Restore sign of number
   F96C CC 3E F8      [16] 3932         CALL    Z,INVSGN        ; Negative - Negate number
   F96F EB            [ 3] 3933         EX      DE,HL           ; Code string address to HL
   F970 C9            [ 9] 3934         RET
                           3935 
   F971 C8            [10] 3936 SCALPL: RET     Z               ; Exit if no scaling needed
   F972 F5            [11] 3937 MULTEN: PUSH    AF              ; Save count
   F973 CD FE F7      [16] 3938         CALL    MLSP10          ; Multiply number by 10
   F976 F1            [ 9] 3939         POP     AF              ; Restore count
   F977 3D            [ 4] 3940         DEC     A               ; Count multiplies
   F978 C9            [ 9] 3941         RET
                           3942 
   F979 D5            [11] 3943 ADDIG:  PUSH    DE              ; Save sign of exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 73.
Hexadecimal [16-Bits]



   F97A 57            [ 4] 3944         LD      D,A             ; Save digit
   F97B 78            [ 4] 3945         LD      A,B             ; Get digits after point
   F97C 89            [ 4] 3946         ADC     A,C             ; Add one if after point
   F97D 47            [ 4] 3947         LD      B,A             ; Re-save counter
   F97E C5            [11] 3948         PUSH    BC              ; Save point flags
   F97F E5            [11] 3949         PUSH    HL              ; Save code string address
   F980 D5            [11] 3950         PUSH    DE              ; Save digit
   F981 CD FE F7      [16] 3951         CALL    MLSP10          ; Multiply number by 10
   F984 F1            [ 9] 3952         POP     AF              ; Restore digit
   F985 D6 30         [ 6] 3953         SUB     #"0"             ; Make it absolute
   F987 CD 90 F9      [16] 3954         CALL    RSCALE          ; Re-scale number
   F98A E1            [ 9] 3955         POP     HL              ; Restore code string address
   F98B C1            [ 9] 3956         POP     BC              ; Restore point flags
   F98C D1            [ 9] 3957         POP     DE              ; Restore sign of exponent
   F98D C3 30 F9      [ 9] 3958         JP      MANLP           ; Get another digit
                           3959 
   F990 CD 46 F8      [16] 3960 RSCALE: CALL    STAKFP          ; Put number on stack
   F993 CD 27 F8      [16] 3961         CALL    FLGREL          ; Digit to add to FPREG
   F996 C1            [ 9] 3962 PADD:   POP     BC              ; Restore number
   F997 D1            [ 9] 3963         POP     DE
   F998 C3 CF F5      [ 9] 3964         JP      FPADD           ; Add BCDE to FPREG and return
                           3965 
   F99B 7B            [ 4] 3966 EDIGIT: LD      A,E             ; Get digit
   F99C 07            [ 3] 3967         RLCA                    ; Times 2
   F99D 07            [ 3] 3968         RLCA                    ; Times 4
   F99E 83            [ 4] 3969         ADD     A,E             ; Times 5
   F99F 07            [ 3] 3970         RLCA                    ; Times 10
   F9A0 86            [ 6] 3971         ADD     A,(HL)          ; Add next digit
   F9A1 D6 30         [ 6] 3972         SUB     #"0"             ; Make it absolute
   F9A3 5F            [ 4] 3973         LD      E,A             ; Save new digit
   F9A4 C3 46 F9      [ 9] 3974         JP      EXPLP           ; Look for another digit
                           3975 
   F9A7 E5            [11] 3976 LINEIN: PUSH    HL              ; Save code string address
   F9A8 21 46 E3      [ 9] 3977         LD      HL,#INMSG        ; Output " in "
   F9AB CD 12 F2      [16] 3978         CALL    PRS             ; Output string at HL
   F9AE E1            [ 9] 3979         POP     HL              ; Restore code string address
   F9AF EB            [ 3] 3980 PRNTHL: EX      DE,HL           ; Code string address to DE
   F9B0 AF            [ 4] 3981         XOR     A
   F9B1 06 98         [ 6] 3982         LD      B,#0x80+24        ; 24 bits
   F9B3 CD 2C F8      [16] 3983         CALL    RETINT          ; Return the integer
   F9B6 21 11 F2      [ 9] 3984         LD      HL,#PRNUMS       ; Print number string
   F9B9 E5            [11] 3985         PUSH    HL              ; Save for return
   F9BA 21 E9 10      [ 9] 3986 NUMASC: LD      HL,#PBUFF        ; Convert number to ASCII
   F9BD E5            [11] 3987         PUSH    HL              ; Save for return
   F9BE CD 15 F8      [16] 3988         CALL    TSTSGN          ; Test sign of FPREG
   F9C1 36 20         [ 9] 3989         LD      (HL),#" "        ; Space at start
   F9C3 F2 C8 F9      [ 9] 3990         JP      P,SPCFST        ; Positive - Space to start
   F9C6 36 2D         [ 9] 3991         LD      (HL),#"-"        ; "-" sign at start
   F9C8 23            [ 4] 3992 SPCFST: INC     HL              ; First byte of number
   F9C9 36 30         [ 9] 3993         LD      (HL),#"0"        ; "0" if zero
   F9CB CA 7E FA      [ 9] 3994         JP      Z,JSTZER        ; Return "0" if zero
   F9CE E5            [11] 3995         PUSH    HL              ; Save buffer address
   F9CF FC 3E F8      [16] 3996         CALL    M,INVSGN        ; Negate FPREG if negative
   F9D2 AF            [ 4] 3997         XOR     A               ; Zero A
   F9D3 F5            [11] 3998         PUSH    AF              ; Save it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 74.
Hexadecimal [16-Bits]



   F9D4 CD 84 FA      [16] 3999         CALL    RNGTST          ; Test number is in range
   F9D7 01 43 91      [ 9] 4000 SIXDIG: LD      BC,#0x9143        ; BCDE - 99999.9
   F9DA 11 F8 4F      [ 9] 4001         LD      DE,#0x4FF8
   F9DD CD 90 F8      [16] 4002         CALL    CMPNUM          ; Compare numbers
   F9E0 B7            [ 4] 4003         OR      A
   F9E1 E2 F5 F9      [ 9] 4004         JP      PO,INRNG        ; > 99999.9 - Sort it out
   F9E4 F1            [ 9] 4005         POP     AF              ; Restore count
   F9E5 CD 72 F9      [16] 4006         CALL    MULTEN          ; Multiply by ten
   F9E8 F5            [11] 4007         PUSH    AF              ; Re-save count
   F9E9 C3 D7 F9      [ 9] 4008         JP      SIXDIG          ; Test it again
                           4009 
   F9EC CD 5D F7      [16] 4010 GTSIXD: CALL    DIV10           ; Divide by 10
   F9EF F1            [ 9] 4011         POP     AF              ; Get count
   F9F0 3C            [ 4] 4012         INC     A               ; Count divides
   F9F1 F5            [11] 4013         PUSH    AF              ; Re-save count
   F9F2 CD 84 FA      [16] 4014         CALL    RNGTST          ; Test number is in range
   F9F5 CD BD F5      [16] 4015 INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
   F9F8 3C            [ 4] 4016         INC     A
   F9F9 CD BD F8      [16] 4017         CALL    FPINT           ; F.P to integer
   F9FC CD 56 F8      [16] 4018         CALL    FPBCDE          ; Move BCDE to FPREG
   F9FF 01 06 03      [ 9] 4019         LD      BC,#0x0306        ; 1E+06 to 1E-03 range
   FA02 F1            [ 9] 4020         POP     AF              ; Restore count
   FA03 81            [ 4] 4021         ADD     A,C             ; 6 digits before point
   FA04 3C            [ 4] 4022         INC     A               ; Add one
   FA05 FA 11 FA      [ 9] 4023         JP      M,MAKNUM        ; Do it in "E" form if < 1E-02
   FA08 FE 08         [ 6] 4024         CP      #6+1+1           ; More than 999999 ?
   FA0A D2 11 FA      [ 9] 4025         JP      NC,MAKNUM       ; Yes - Do it in "E" form
   FA0D 3C            [ 4] 4026         INC     A               ; Adjust for exponent
   FA0E 47            [ 4] 4027         LD      B,A             ; Exponent of number
   FA0F 3E 02         [ 6] 4028         LD      A,#2             ; Make it zero after
                           4029 
   FA11 3D            [ 4] 4030 MAKNUM: DEC     A               ; Adjust for digits to do
   FA12 3D            [ 4] 4031         DEC     A
   FA13 E1            [ 9] 4032         POP     HL              ; Restore buffer address
   FA14 F5            [11] 4033         PUSH    AF              ; Save count
   FA15 11 97 FA      [ 9] 4034         LD      DE,#POWERS       ; Powers of ten
   FA18 05            [ 4] 4035         DEC     B               ; Count digits before point
   FA19 C2 22 FA      [ 9] 4036         JP      NZ,DIGTXT       ; Not zero - Do number
   FA1C 36 2E         [ 9] 4037         LD      (HL),#"."        ; Save point
   FA1E 23            [ 4] 4038         INC     HL              ; Move on
   FA1F 36 30         [ 9] 4039         LD      (HL),#"0"        ; Save zero
   FA21 23            [ 4] 4040         INC     HL              ; Move on
   FA22 05            [ 4] 4041 DIGTXT: DEC     B               ; Count digits before point
   FA23 36 2E         [ 9] 4042         LD      (HL),#"."        ; Save point in case
   FA25 CC 6B F8      [16] 4043         CALL    Z,INCHL         ; Last digit - move on
   FA28 C5            [11] 4044         PUSH    BC              ; Save digits before point
   FA29 E5            [11] 4045         PUSH    HL              ; Save buffer address
   FA2A D5            [11] 4046         PUSH    DE              ; Save powers of ten
   FA2B CD 61 F8      [16] 4047         CALL    BCDEFP          ; Move FPREG to BCDE
   FA2E E1            [ 9] 4048         POP     HL              ; Powers of ten table
   FA2F 06 2F         [ 6] 4049         LD      B, #"0"-1        ; ASCII "0" - 1
   FA31 04            [ 4] 4050 TRYAGN: INC     B               ; Count subtractions
   FA32 7B            [ 4] 4051         LD      A,E             ; Get LSB
   FA33 96            [ 6] 4052         SUB     (HL)            ; Subtract LSB
   FA34 5F            [ 4] 4053         LD      E,A             ; Save LSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 75.
Hexadecimal [16-Bits]



   FA35 23            [ 4] 4054         INC     HL
   FA36 7A            [ 4] 4055         LD      A,D             ; Get NMSB
   FA37 9E            [ 6] 4056         SBC     A,(HL)          ; Subtract NMSB
   FA38 57            [ 4] 4057         LD      D,A             ; Save NMSB
   FA39 23            [ 4] 4058         INC     HL
   FA3A 79            [ 4] 4059         LD      A,C             ; Get MSB
   FA3B 9E            [ 6] 4060         SBC     A,(HL)          ; Subtract MSB
   FA3C 4F            [ 4] 4061         LD      C,A             ; Save MSB
   FA3D 2B            [ 4] 4062         DEC     HL              ; Point back to start
   FA3E 2B            [ 4] 4063         DEC     HL
   FA3F D2 31 FA      [ 9] 4064         JP      NC,TRYAGN       ; No overflow - Try again
   FA42 CD 74 F6      [16] 4065         CALL    PLUCDE          ; Restore number
   FA45 23            [ 4] 4066         INC     HL              ; Start of next number
   FA46 CD 56 F8      [16] 4067         CALL    FPBCDE          ; Move BCDE to FPREG
   FA49 EB            [ 3] 4068         EX      DE,HL           ; Save point in table
   FA4A E1            [ 9] 4069         POP     HL              ; Restore buffer address
   FA4B 70            [ 7] 4070         LD      (HL),B          ; Save digit in buffer
   FA4C 23            [ 4] 4071         INC     HL              ; And move on
   FA4D C1            [ 9] 4072         POP     BC              ; Restore digit count
   FA4E 0D            [ 4] 4073         DEC     C               ; Count digits
   FA4F C2 22 FA      [ 9] 4074         JP      NZ,DIGTXT       ; More - Do them
   FA52 05            [ 4] 4075         DEC     B               ; Any decimal part?
   FA53 CA 62 FA      [ 9] 4076         JP      Z,DOEBIT        ; No - Do "E" bit
   FA56 2B            [ 4] 4077 SUPTLZ: DEC     HL              ; Move back through buffer
   FA57 7E            [ 6] 4078         LD      A,(HL)          ; Get character
   FA58 FE 30         [ 6] 4079         CP      #"0"             ; "0" character?
   FA5A CA 56 FA      [ 9] 4080         JP      Z,SUPTLZ        ; Yes - Look back for more
   FA5D FE 2E         [ 6] 4081         CP      #"."             ; A decimal point?
   FA5F C4 6B F8      [16] 4082         CALL    NZ,INCHL        ; Move back over digit
                           4083 
   FA62 F1            [ 9] 4084 DOEBIT: POP     AF              ; Get "E" flag
   FA63 CA 81 FA      [ 9] 4085         JP      Z,NOENED        ; No "E" needed - End buffer
   FA66 36 45         [ 9] 4086         LD      (HL),#"E"        ; Put "E" in buffer
   FA68 23            [ 4] 4087         INC     HL              ; And move on
   FA69 36 2B         [ 9] 4088         LD      (HL),#"+"        ; Put '+' in buffer
   FA6B F2 72 FA      [ 9] 4089         JP      P,OUTEXP        ; Positive - Output exponent
   FA6E 36 2D         [ 9] 4090         LD      (HL),#"-"        ; Put "-" in buffer
   FA70 2F            [ 3] 4091         CPL                     ; Negate exponent
   FA71 3C            [ 4] 4092         INC     A
   FA72 06 2F         [ 6] 4093 OUTEXP: LD      B,#"0"-1         ; ASCII "0" - 1
   FA74 04            [ 4] 4094 EXPTEN: INC     B               ; Count subtractions
   FA75 D6 0A         [ 6] 4095         SUB     #10              ; Tens digit
   FA77 D2 74 FA      [ 9] 4096         JP      NC,EXPTEN       ; More to do
   FA7A C6 3A         [ 6] 4097         ADD     A,#"0"+10        ; Restore and make ASCII
   FA7C 23            [ 4] 4098         INC     HL              ; Move on
   FA7D 70            [ 7] 4099         LD      (HL),B          ; Save MSB of exponent
   FA7E 23            [ 4] 4100 JSTZER: INC     HL              ;
   FA7F 77            [ 7] 4101         LD      (HL),A          ; Save LSB of exponent
   FA80 23            [ 4] 4102         INC     HL
   FA81 71            [ 7] 4103 NOENED: LD      (HL),C          ; Mark end of buffer
   FA82 E1            [ 9] 4104         POP     HL              ; Restore code string address
   FA83 C9            [ 9] 4105         RET
                           4106 
   FA84 01 74 94      [ 9] 4107 RNGTST: LD      BC,#0x9474        ; BCDE = 999999.
   FA87 11 F7 23      [ 9] 4108         LD      DE,#0x23F7
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 76.
Hexadecimal [16-Bits]



   FA8A CD 90 F8      [16] 4109         CALL    CMPNUM          ; Compare numbers
   FA8D B7            [ 4] 4110         OR      A
   FA8E E1            [ 9] 4111         POP     HL              ; Return address to HL
   FA8F E2 EC F9      [ 9] 4112         JP      PO,GTSIXD       ; Too big - Divide by ten
   FA92 E9            [ 3] 4113         JP      (HL)            ; Otherwise return to caller
                           4114 
   FA93 00 00 00 80        4115 HALF:   .db      0x00,0x00,0x00,0x80 ; 0.5
                           4116 
   FA97 A0 86 01           4117 POWERS: .db      0xA0,0x86,0x01  ; 100000
   FA9A 10 27 00           4118         .db      0x10,0x27,0x00  ;  10000
   FA9D E8 03 00           4119         .db      0xE8,0x03,0x00  ;   1000
   FAA0 64 00 00           4120         .db      0x64,0x00,0x00  ;    100
   FAA3 0A 00 00           4121         .db      0x0A,0x00,0x00  ;     10
   FAA6 01 00 00           4122         .db      0x01,0x00,0x00  ;      1
                           4123 
   FAA9 21 3E F8      [ 9] 4124 NEGAFT: LD  HL,#INVSGN           ; Negate result
   FAAC E3            [16] 4125         EX      (SP),HL         ; To be done after caller
   FAAD E9            [ 3] 4126         JP      (HL)            ; Return to caller
                           4127 
   FAAE CD 46 F8      [16] 4128 SQR:    CALL    STAKFP          ; Put value on stack
   FAB1 21 93 FA      [ 9] 4129         LD      HL,#HALF         ; Set power to 1/2
   FAB4 CD 53 F8      [16] 4130         CALL    PHLTFP          ; Move 1/2 to FPREG
                           4131 
   FAB7 C1            [ 9] 4132 POWER:  POP     BC              ; Get base
   FAB8 D1            [ 9] 4133         POP     DE
   FAB9 CD 15 F8      [16] 4134         CALL    TSTSGN          ; Test sign of power
   FABC 78            [ 4] 4135         LD      A,B             ; Get exponent of base
   FABD CA FC FA      [ 9] 4136         JP      Z,EXP           ; Make result 1 if zero
   FAC0 F2 C7 FA      [ 9] 4137         JP      P,POWER1        ; Positive base - Ok
   FAC3 B7            [ 4] 4138         OR      A               ; Zero to negative power?
   FAC4 CA B2 E3      [ 9] 4139         JP      Z,DZERR         ; Yes - ?/0 Error
   FAC7 B7            [ 4] 4140 POWER1: OR      A               ; Base zero?
   FAC8 CA 36 F6      [ 9] 4141         JP      Z,SAVEXP        ; Yes - Return zero
   FACB D5            [11] 4142         PUSH    DE              ; Save base
   FACC C5            [11] 4143         PUSH    BC
   FACD 79            [ 4] 4144         LD      A,C             ; Get MSB of base
   FACE F6 7F         [ 6] 4145         OR      #0b01111111       ; Get sign status
   FAD0 CD 61 F8      [16] 4146         CALL    BCDEFP          ; Move power to BCDE
   FAD3 F2 E4 FA      [ 9] 4147         JP      P,POWER2        ; Positive base - Ok
   FAD6 D5            [11] 4148         PUSH    DE              ; Save power
   FAD7 C5            [11] 4149         PUSH    BC
   FAD8 CD E8 F8      [16] 4150         CALL    INT             ; Get integer of power
   FADB C1            [ 9] 4151         POP     BC              ; Restore power
   FADC D1            [ 9] 4152         POP     DE
   FADD F5            [11] 4153         PUSH    AF              ; MSB of base
   FADE CD 90 F8      [16] 4154         CALL    CMPNUM          ; Power an integer?
   FAE1 E1            [ 9] 4155         POP     HL              ; Restore MSB of base
   FAE2 7C            [ 4] 4156         LD      A,H             ; but don't affect flags
   FAE3 1F            [ 3] 4157         RRA                     ; Exponent odd or even?
   FAE4 E1            [ 9] 4158 POWER2: POP     HL              ; Restore MSB and exponent
   FAE5 22 E6 10      [16] 4159         LD      (FPREG+2),HL    ; Save base in FPREG
   FAE8 E1            [ 9] 4160         POP     HL              ; LSBs of base
   FAE9 22 E4 10      [16] 4161         LD      (FPREG),HL      ; Save in FPREG
   FAEC DC A9 FA      [16] 4162         CALL    C,NEGAFT        ; Odd power - Negate result
   FAEF CC 3E F8      [16] 4163         CALL    Z,INVSGN        ; Negative base - Negate it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 77.
Hexadecimal [16-Bits]



   FAF2 D5            [11] 4164         PUSH    DE              ; Save power
   FAF3 C5            [11] 4165         PUSH    BC
   FAF4 CD C9 F6      [16] 4166         CALL    LOG             ; Get LOG of base
   FAF7 C1            [ 9] 4167         POP     BC              ; Restore power
   FAF8 D1            [ 9] 4168         POP     DE
   FAF9 CD 0A F7      [16] 4169         CALL    FPMULT          ; Multiply LOG by power
                           4170 
   FAFC CD 46 F8      [16] 4171 EXP:    CALL    STAKFP          ; Put value on stack
   FAFF 01 38 81      [ 9] 4172         LD      BC,#0x08138       ; BCDE = 1/Ln(2)
   FB02 11 3B AA      [ 9] 4173         LD      DE,#0x0AA3B
   FB05 CD 0A F7      [16] 4174         CALL    FPMULT          ; Multiply value by 1/LN(2)
   FB08 3A E7 10      [12] 4175         LD      A,(FPEXP)       ; Get exponent
   FB0B FE 88         [ 6] 4176         CP      #0x80+8           ; Is it in range?
   FB0D D2 F1 F7      [ 9] 4177         JP      NC,OVTST1       ; No - Test for overflow
   FB10 CD E8 F8      [16] 4178         CALL    INT             ; Get INT of FPREG
   FB13 C6 80         [ 6] 4179         ADD     A,#0x80           ; For excess 128
   FB15 C6 02         [ 6] 4180         ADD     A,#2             ; Exponent > 126?
   FB17 DA F1 F7      [ 9] 4181         JP      C,OVTST1        ; Yes - Test for overflow
   FB1A F5            [11] 4182         PUSH    AF              ; Save scaling factor
   FB1B 21 B8 F6      [ 9] 4183         LD      HL,#UNITY        ; Point to 1.
   FB1E CD C0 F5      [16] 4184         CALL    ADDPHL          ; Add 1 to FPREG
   FB21 CD 01 F7      [16] 4185         CALL    MULLN2          ; Multiply by LN(2)
   FB24 F1            [ 9] 4186         POP     AF              ; Restore scaling factor
   FB25 C1            [ 9] 4187         POP     BC              ; Restore exponent
   FB26 D1            [ 9] 4188         POP     DE
   FB27 F5            [11] 4189         PUSH    AF              ; Save scaling factor
   FB28 CD CC F5      [16] 4190         CALL    SUBCDE          ; Subtract exponent from FPREG
   FB2B CD 3E F8      [16] 4191         CALL    INVSGN          ; Negate result
   FB2E 21 3C FB      [ 9] 4192         LD      HL,#EXPTAB       ; Coefficient table
   FB31 CD 6C FB      [16] 4193         CALL    SMSER1          ; Sum the series
   FB34 11 00 00      [ 9] 4194         LD      DE,#0            ; Zero LSBs
   FB37 C1            [ 9] 4195         POP     BC              ; Scaling factor
   FB38 4A            [ 4] 4196         LD      C,D             ; Zero MSB
   FB39 C3 0A F7      [ 9] 4197         JP      FPMULT          ; Scale result to correct value
                           4198 
   FB3C 08                 4199 EXPTAB: .db      8                       ; Table used by EXP
   FB3D 40 2E 94 74        4200         .db      0x40,0x2E,0x94,0x74     ; -1/7! (-1/5040)
   FB41 70 4F 2E 77        4201         .db      0x70,0x4F,0x2E,0x77     ;  1/6! ( 1/720)
   FB45 6E 02 88 7A        4202         .db      0x6E,0x02,0x88,0x7A     ; -1/5! (-1/120)
   FB49 E6 A0 2A 7C        4203         .db      0xE6,0xA0,0x2A,0x7C     ;  1/4! ( 1/24)
   FB4D 50 AA AA 7E        4204         .db      0x50,0xAA,0xAA,0x7E     ; -1/3! (-1/6)
   FB51 FF FF 7F 7F        4205         .db      0xFF,0xFF,0x7F,0x7F     ;  1/2! ( 1/2)
   FB55 00 00 80 81        4206         .db      0x00,0x00,0x80,0x81     ; -1/1! (-1/1)
   FB59 00 00 00 81        4207         .db      0x00,0x00,0x00,0x81     ;  1/0! ( 1/1)
                           4208 
   FB5D CD 46 F8      [16] 4209 SUMSER: CALL    STAKFP          ; Put FPREG on stack
   FB60 11 08 F7      [ 9] 4210         LD      DE,#MULT         ; Multiply by "X"
   FB63 D5            [11] 4211         PUSH    DE              ; To be done after
   FB64 E5            [11] 4212         PUSH    HL              ; Save address of table
   FB65 CD 61 F8      [16] 4213         CALL    BCDEFP          ; Move FPREG to BCDE
   FB68 CD 0A F7      [16] 4214         CALL    FPMULT          ; Square the value
   FB6B E1            [ 9] 4215         POP     HL              ; Restore address of table
   FB6C CD 46 F8      [16] 4216 SMSER1: CALL    STAKFP          ; Put value on stack
   FB6F 7E            [ 6] 4217         LD      A,(HL)          ; Get number of coefficients
   FB70 23            [ 4] 4218         INC     HL              ; Point to start of table
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 78.
Hexadecimal [16-Bits]



   FB71 CD 53 F8      [16] 4219         CALL    PHLTFP          ; Move coefficient to FPREG
   FB74 06                 4220         .db      0x06             ; Skip "POP AF"
   FB75 F1            [ 9] 4221 SUMLP:  POP     AF              ; Restore count
   FB76 C1            [ 9] 4222         POP     BC              ; Restore number
   FB77 D1            [ 9] 4223         POP     DE
   FB78 3D            [ 4] 4224         DEC     A               ; Cont coefficients
   FB79 C8            [10] 4225         RET     Z               ; All done
   FB7A D5            [11] 4226         PUSH    DE              ; Save number
   FB7B C5            [11] 4227         PUSH    BC
   FB7C F5            [11] 4228         PUSH    AF              ; Save count
   FB7D E5            [11] 4229         PUSH    HL              ; Save address in table
   FB7E CD 0A F7      [16] 4230         CALL    FPMULT          ; Multiply FPREG by BCDE
   FB81 E1            [ 9] 4231         POP     HL              ; Restore address in table
   FB82 CD 64 F8      [16] 4232         CALL    LOADFP          ; Number at HL to BCDE
   FB85 E5            [11] 4233         PUSH    HL              ; Save address in table
   FB86 CD CF F5      [16] 4234         CALL    FPADD           ; Add coefficient to FPREG
   FB89 E1            [ 9] 4235         POP     HL              ; Restore address in table
   FB8A C3 75 FB      [ 9] 4236         JP      SUMLP           ; More coefficients
                           4237 
   FB8D CD 15 F8      [16] 4238 RND:    CALL    TSTSGN          ; Test sign of FPREG
   FB90 21 19 10      [ 9] 4239         LD      HL,#SEED+2       ; Random number seed
   FB93 FA EE FB      [ 9] 4240         JP      M,RESEED        ; Negative - Re-seed
   FB96 21 3A 10      [ 9] 4241         LD      HL,#LSTRND       ; Last random number
   FB99 CD 53 F8      [16] 4242         CALL    PHLTFP          ; Move last RND to FPREG
   FB9C 21 19 10      [ 9] 4243         LD      HL,#SEED+2       ; Random number seed
   FB9F C8            [10] 4244         RET     Z               ; Return if RND(0)
   FBA0 86            [ 6] 4245         ADD     A,(HL)          ; Add (SEED)+2)
   FBA1 E6 07         [ 6] 4246         AND     #0b00000111       ; 0 to 7
   FBA3 06 00         [ 6] 4247         LD      B,#0
   FBA5 77            [ 7] 4248         LD      (HL),A          ; Re-save seed
   FBA6 23            [ 4] 4249         INC     HL              ; Move to coefficient table
   FBA7 87            [ 4] 4250         ADD     A,A             ; 4 bytes
   FBA8 87            [ 4] 4251         ADD     A,A             ; per entry
   FBA9 4F            [ 4] 4252         LD      C,A             ; BC = Offset into table
   FBAA 09            [ 7] 4253         ADD     HL,BC           ; Point to coefficient
   FBAB CD 64 F8      [16] 4254         CALL    LOADFP          ; Coefficient to BCDE
   FBAE CD 0A F7      [16] 4255         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
   FBB1 3A 18 10      [12] 4256         LD      A,(SEED+1)      ; Get (SEED+1)
   FBB4 3C            [ 4] 4257         INC     A               ; Add 1
   FBB5 E6 03         [ 6] 4258         AND     #0b00000011       ; 0 to 3
   FBB7 06 00         [ 6] 4259         LD      B,#0
   FBB9 FE 01         [ 6] 4260         CP      #1               ; Is it zero?
   FBBB 88            [ 4] 4261         ADC     A,B             ; Yes - Make it 1
   FBBC 32 18 10      [13] 4262         LD      (SEED+1),A      ; Re-save seed
   FBBF 21 F2 FB      [ 9] 4263         LD      HL,#RNDTAB-4     ; Addition table
   FBC2 87            [ 4] 4264         ADD     A,A             ; 4 bytes
   FBC3 87            [ 4] 4265         ADD     A,A             ; per entry
   FBC4 4F            [ 4] 4266         LD      C,A             ; BC = Offset into table
   FBC5 09            [ 7] 4267         ADD     HL,BC           ; Point to value
   FBC6 CD C0 F5      [16] 4268         CALL    ADDPHL          ; Add value to FPREG
   FBC9 CD 61 F8      [16] 4269 RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
   FBCC 7B            [ 4] 4270         LD      A,E             ; Get LSB
   FBCD 59            [ 4] 4271         LD      E,C             ; LSB = MSB
   FBCE EE 4F         [ 6] 4272         XOR     #0b01001111       ; Fiddle around
   FBD0 4F            [ 4] 4273         LD      C,A             ; New MSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 79.
Hexadecimal [16-Bits]



   FBD1 36 80         [ 9] 4274         LD      (HL),#0x80        ; Set exponent
   FBD3 2B            [ 4] 4275         DEC     HL              ; Point to MSB
   FBD4 46            [ 6] 4276         LD      B,(HL)          ; Get MSB
   FBD5 36 80         [ 9] 4277         LD      (HL),#0x80        ; Make value -0.5
   FBD7 21 17 10      [ 9] 4278         LD      HL,#SEED         ; Random number seed
   FBDA 34            [10] 4279         INC     (HL)            ; Count seed
   FBDB 7E            [ 6] 4280         LD      A,(HL)          ; Get seed
   FBDC D6 AB         [ 6] 4281         SUB     #171             ; Do it modulo 171
   FBDE C2 E5 FB      [ 9] 4282         JP      NZ,RND2         ; Non-zero - Ok
   FBE1 77            [ 7] 4283         LD      (HL),A          ; Zero seed
   FBE2 0C            [ 4] 4284         INC     C               ; Fillde about
   FBE3 15            [ 4] 4285         DEC     D               ; with the
   FBE4 1C            [ 4] 4286         INC     E               ; number
   FBE5 CD 20 F6      [16] 4287 RND2:   CALL    BNORM           ; Normalise number
   FBE8 21 3A 10      [ 9] 4288         LD      HL,#LSTRND       ; Save random number
   FBEB C3 6D F8      [ 9] 4289         JP      FPTHL           ; Move FPREG to last and return
                           4290 
   FBEE 77            [ 7] 4291 RESEED: LD      (HL),A          ; Re-seed random numbers
   FBEF 2B            [ 4] 4292         DEC     HL
   FBF0 77            [ 7] 4293         LD      (HL),A
   FBF1 2B            [ 4] 4294         DEC     HL
   FBF2 77            [ 7] 4295         LD      (HL),A
   FBF3 C3 C9 FB      [ 9] 4296         JP      RND1            ; Return RND seed
                           4297 
   FBF6 68 B1 46 68        4298 RNDTAB: .db      0x68,0xB1,0x46,0x68     ; Table used by RND
   FBFA 99 E9 92 69        4299         .db      0x99,0xE9,0x92,0x69
   FBFE 10 D1 75 68        4300         .db      0x10,0xD1,0x75,0x68
                           4301 
   FC02 21 4C FC      [ 9] 4302 COS:    LD      HL,#HALFPI       ; Point to PI/2
   FC05 CD C0 F5      [16] 4303         CALL    ADDPHL          ; Add it to PPREG
   FC08 CD 46 F8      [16] 4304 SIN:    CALL    STAKFP          ; Put angle on stack
   FC0B 01 49 83      [ 9] 4305         LD      BC,#0x8349        ; BCDE = 2 PI
   FC0E 11 DB 0F      [ 9] 4306         LD      DE,#0x0FDB
   FC11 CD 56 F8      [16] 4307         CALL    FPBCDE          ; Move 2 PI to FPREG
   FC14 C1            [ 9] 4308         POP     BC              ; Restore angle
   FC15 D1            [ 9] 4309         POP     DE
   FC16 CD 6B F7      [16] 4310         CALL    DVBCDE          ; Divide angle by 2 PI
   FC19 CD 46 F8      [16] 4311         CALL    STAKFP          ; Put it on stack
   FC1C CD E8 F8      [16] 4312         CALL    INT             ; Get INT of result
   FC1F C1            [ 9] 4313         POP     BC              ; Restore number
   FC20 D1            [ 9] 4314         POP     DE
   FC21 CD CC F5      [16] 4315         CALL    SUBCDE          ; Make it 0 <= value < 1
   FC24 21 50 FC      [ 9] 4316         LD      HL,#QUARTR       ; Point to 0.25
   FC27 CD C6 F5      [16] 4317         CALL    SUBPHL          ; Subtract value from 0.25
   FC2A CD 15 F8      [16] 4318         CALL    TSTSGN          ; Test sign of value
   FC2D 37            [ 3] 4319         SCF                     ; Flag positive
   FC2E F2 38 FC      [ 9] 4320         JP      P,SIN1          ; Positive - Ok
   FC31 CD BD F5      [16] 4321         CALL    ROUND           ; Add 0.5 to value
   FC34 CD 15 F8      [16] 4322         CALL    TSTSGN          ; Test sign of value
   FC37 B7            [ 4] 4323         OR      A               ; Flag negative
   FC38 F5            [11] 4324 SIN1:   PUSH    AF              ; Save sign
   FC39 F4 3E F8      [16] 4325         CALL    P,INVSGN        ; Negate value if positive
   FC3C 21 50 FC      [ 9] 4326         LD      HL,#QUARTR       ; Point to 0.25
   FC3F CD C0 F5      [16] 4327         CALL    ADDPHL          ; Add 0.25 to value
   FC42 F1            [ 9] 4328         POP     AF              ; Restore sign
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 80.
Hexadecimal [16-Bits]



   FC43 D4 3E F8      [16] 4329         CALL    NC,INVSGN       ; Negative - Make positive
   FC46 21 54 FC      [ 9] 4330         LD      HL,#SINTAB       ; Coefficient table
   FC49 C3 5D FB      [ 9] 4331         JP      SUMSER          ; Evaluate sum of series
                           4332 
   FC4C DB 0F 49 81        4333 HALFPI: .db      0xDB,0x0F,0x49,0x81     ; 1.5708 (PI/2)
                           4334 
   FC50 00 00 00 7F        4335 QUARTR: .db      0x00,0x00,0x00,0x7F     ; 0.25
                           4336 
   FC54 05                 4337 SINTAB: .db      5                       ; Table used by SIN
   FC55 BA D7 1E 86        4338         .db      0xBA,0xD7,0x1E,0x86     ; 39.711
   FC59 64 26 99 87        4339         .db      0x64,0x26,0x99,0x87     ;-76.575
   FC5D 58 34 23 87        4340         .db      0x58,0x34,0x23,0x87     ; 81.602
   FC61 E0 5D A5 86        4341         .db      0xE0,0x5D,0xA5,0x86     ;-41.342
   FC65 DA 0F 49 83        4342         .db      0xDA,0x0F,0x49,0x83     ;  6.2832
                           4343 
   FC69 CD 46 F8      [16] 4344 TAN:    CALL    STAKFP          ; Put angle on stack
   FC6C CD 08 FC      [16] 4345         CALL    SIN             ; Get SIN of angle
   FC6F C1            [ 9] 4346         POP     BC              ; Restore angle
   FC70 E1            [ 9] 4347         POP     HL
   FC71 CD 46 F8      [16] 4348         CALL    STAKFP          ; Save SIN of angle
   FC74 EB            [ 3] 4349         EX      DE,HL           ; BCDE = Angle
   FC75 CD 56 F8      [16] 4350         CALL    FPBCDE          ; Angle to FPREG
   FC78 CD 02 FC      [16] 4351         CALL    COS             ; Get COS of angle
   FC7B C3 69 F7      [ 9] 4352         JP      DIV             ; TAN = SIN / COS
                           4353 
   FC7E CD 15 F8      [16] 4354 ATN:    CALL    TSTSGN          ; Test sign of value
   FC81 FC A9 FA      [16] 4355         CALL    M,NEGAFT        ; Negate result after if -ve
   FC84 FC 3E F8      [16] 4356         CALL    M,INVSGN        ; Negate value if -ve
   FC87 3A E7 10      [12] 4357         LD      A,(FPEXP)       ; Get exponent
   FC8A FE 81         [ 6] 4358         CP      #0x81             ; Number less than 1?
   FC8C DA 9B FC      [ 9] 4359         JP      C,ATN1          ; Yes - Get arc tangnt
   FC8F 01 00 81      [ 9] 4360         LD      BC,#0x8100        ; BCDE = 1
   FC92 51            [ 4] 4361         LD      D,C
   FC93 59            [ 4] 4362         LD      E,C
   FC94 CD 6B F7      [16] 4363         CALL    DVBCDE          ; Get reciprocal of number
   FC97 21 C6 F5      [ 9] 4364         LD      HL,#SUBPHL       ; Sub angle from PI/2
   FC9A E5            [11] 4365         PUSH    HL              ; Save for angle > 1
   FC9B 21 A5 FC      [ 9] 4366 ATN1:   LD      HL,#ATNTAB       ; Coefficient table
   FC9E CD 5D FB      [16] 4367         CALL    SUMSER          ; Evaluate sum of series
   FCA1 21 4C FC      [ 9] 4368         LD      HL,#HALFPI       ; PI/2 - angle in case > 1
   FCA4 C9            [ 9] 4369         RET                     ; Number > 1 - Sub from PI/2
                           4370 
   FCA5 09                 4371 ATNTAB: .db      9                       ; Table used by ATN
   FCA6 4A D7 3B 78        4372         .db      0x4A,0xD7,0x3B,0x78     ; 1/17
   FCAA 02 6E 84 7B        4373         .db      0x02,0x6E,0x84,0x7B     ;-1/15
   FCAE FE C1 2F 7C        4374         .db      0xFE,0xC1,0x2F,0x7C     ; 1/13
   FCB2 74 31 9A 7D        4375         .db      0x74,0x31,0x9A,0x7D     ;-1/11
   FCB6 84 3D 5A 7D        4376         .db      0x84,0x3D,0x5A,0x7D     ; 1/9
   FCBA C8 7F 91 7E        4377         .db      0xC8,0x7F,0x91,0x7E     ;-1/7
   FCBE E4 BB 4C 7E        4378         .db      0xE4,0xBB,0x4C,0x7E     ; 1/5
   FCC2 6C AA AA 7F        4379         .db      0x6C,0xAA,0xAA,0x7F     ;-1/3
   FCC6 00 00 00 81        4380         .db      0x00,0x00,0x00,0x81     ; 1/1
                           4381 
   FCCA CD 3B FE      [16] 4382 CASFFW: CALL    FLPLED          ; Turn on cassette
   FCCD 06 00         [ 6] 4383         LD      B,#0             ; Set 1 second delay
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 81.
Hexadecimal [16-Bits]



   FCCF CD 9D FD      [16] 4384 DELAYB: CALL    DELAY           ; Wait a bit
   FCD2 05            [ 4] 4385         DEC     B               ; Count
   FCD3 C2 CF FC      [ 9] 4386         JP      NZ,DELAYB       ; More delay needed
   FCD6 C9            [ 9] 4387         RET
                           4388 
   FCD7 C3 3B FE      [ 9] 4389 CASFF:  JP      FLPLED          ; Flip tape LED
                           4390 
   FCDA C9            [ 9] 4391 ARET:   RET                     ; A RETurn instruction
                           4392 
   FCDB E5            [11] 4393 CONMON: PUSH    HL              ; Output character to screen
   FCDC C5            [11] 4394         PUSH    BC              ; 
   FCDD D5            [11] 4395         PUSH    DE              ; 
   FCDE F5            [11] 4396         PUSH    AF              ; 
   FCDF CD 6F FE      [16] 4397         CALL    MONTST          ; See if NAS-SYS
   FCE2 C2 FD FC      [ 9] 4398         JP      NZ,NASOUT       ; NAS-SYS - Output ASCII
   FCE5 F1            [ 9] 4399         POP     AF              ; Get character
   FCE6 F5            [11] 4400         PUSH    AF              ; And re-save
   FCE7 FE 0A         [ 6] 4401         CP      #LF              ; ASCII Line feed?
   FCE9 CA 02 FD      [ 9] 4402         JP      Z,IGCHR         ; Yes - Ignore it
   FCEC FE 08         [ 6] 4403         CP      #BKSP            ; ASCII back space?
   FCEE C2 F3 FC      [ 9] 4404         JP      NZ,CONOT1       ; No - Test for CR
   FCF1 3E 1D         [ 6] 4405         LD      A,#TBS           ; NASBUG back space
   FCF3 FE 0D         [ 6] 4406 CONOT1: CP      #CR              ; ASCII CR?
   FCF5 C2 FF FC      [ 9] 4407         JP      NZ,OUTCHR       ; No - Output character
   FCF8 3E 1F         [ 6] 4408         LD      A,#TCR           ; NASBUG CR
   FCFA C3 FF FC      [ 9] 4409         JP      OUTCHR          ; Output it
                           4410 
   FCFD F1            [ 9] 4411 NASOUT: POP     AF              ; Get character
   FCFE F5            [11] 4412         PUSH    AF              ; And re-save
   FCFF CD 47 FE      [16] 4413 OUTCHR: CALL    MONOUT          ; Output it
   FD02 F1            [ 9] 4414 IGCHR:  POP     AF              ; Restore character
   FD03 D1            [ 9] 4415         POP     DE              ;
   FD04 C1            [ 9] 4416         POP     BC              ;
   FD05 E1            [ 9] 4417         POP     HL              ;
   FD06 C9            [ 9] 4418         RET
                           4419 
   FD07 E5            [11] 4420 GETINP: PUSH    HL              ; Get an input character
   FD08 C5            [11] 4421         PUSH    BC              ;
   FD09 D5            [11] 4422         PUSH    DE              ;
   FD0A CD 6F FE      [16] 4423         CALL    MONTST          ; See if NAS-SYS
   FD0D CA 15 FD      [ 9] 4424         JP      Z,GETTIN        ; "T" monitor - Get input
   FD10 DF 7B              4425         .dw      _BLNK
   FD12 C3 1B FD      [ 9] 4426         JP      CONVIN          ; Convert to ASCII
                           4427 
   FD15 CD 4D 0C      [16] 4428 GETTIN: CALL    TIN             ; "T" input a character
   FD18 D2 15 FD      [ 9] 4429         JP      NC,GETTIN       ; No input - wait
   FD1B FE 1D         [ 6] 4430 CONVIN: CP      #TBS             ; NASBUG back space?
   FD1D C2 22 FD      [ 9] 4431         JP      NZ,CNVIN1       ; No - Test for break
   FD20 3E 08         [ 6] 4432         LD      A,#BKSP          ; ASCII back space
   FD22 FE 1C         [ 6] 4433 CNVIN1: CP      #TBRK            ; NASBUG break?
   FD24 C2 29 FD      [ 9] 4434         JP      NZ,CNVIN2       ; No - Test for control Z
   FD27 3E 03         [ 6] 4435         LD      A,#CTRLC         ; Control C
   FD29 FE 1A         [ 6] 4436 CNVIN2: CP      #CTRLZ           ; ^Z?
   FD2B C2 30 FD      [ 9] 4437         JP      NZ,CNVIN3       ; No - Test for escape
   FD2E 3E 7F         [ 6] 4438         LD      A,#DEL           ; Delete
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 82.
Hexadecimal [16-Bits]



   FD30 FE 1B         [ 6] 4439 CNVIN3: CP      #ESC             ; "ESC" ?
   FD32 C2 37 FD      [ 9] 4440         JP      NZ,CNVIN4       ; No - Test for CR
   FD35 3E 03         [ 6] 4441         LD      A,#CTRLC         ; Control C
   FD37 FE 1F         [ 6] 4442 CNVIN4: CP      #TCR             ; NASBUG CR?
   FD39 C2 3E FD      [ 9] 4443         JP      NZ,CNVIN5       ; No - Return character
   FD3C 3E 0D         [ 6] 4444         LD      A,#CR            ; ASCII CR
   FD3E D1            [ 9] 4445 CNVIN5: POP     DE
   FD3F C1            [ 9] 4446         POP     BC
   FD40 E1            [ 9] 4447         POP     HL
   FD41 C9            [ 9] 4448         RET
                           4449 
   FD42 AF            [ 4] 4450 CHKBRK: XOR     A               ; Check for break
   FD43 CD 72 FD      [16] 4451         CALL    SFTENT          ; Test for shift/enter
   FD46 CA 52 FD      [ 9] 4452         JP      Z,TBRK2         ; Yes - Test for second break
   FD49 3A 4D 10      [12] 4453         LD      A,(BRKFLG)      ; Get break flag
   FD4C B7            [ 4] 4454         OR      A               ; Break flag set?
   FD4D C2 52 FD      [ 9] 4455         JP      NZ,TBRK2        ; Yes - Test for second break
   FD50 AF            [ 4] 4456         XOR     A               ; Flag no break
   FD51 C9            [ 9] 4457         RET
                           4458 
   FD52 CD 55 FE      [16] 4459 TBRK2:  CALL    BREAK2          ; Second break?
   FD55 3E FF         [ 6] 4460         LD      A,#-1            ; Flag break
   FD57 C9            [ 9] 4461         RET
                           4462 
   FD58 DB 02         [ 9] 4463 GUART:  IN      A,(UARTS)       ; Get UART status
   FD5A 17            [ 3] 4464         RLA                     ; Any data ready?
   FD5B D2 58 FD      [ 9] 4465         JP      NC,GUART        ; No - wait until there is
   FD5E DB 01         [ 9] 4466         IN      A,(UARTD)       ; Get data from UART
   FD60 C9            [ 9] 4467         RET
                           4468 
   FD61 D3 01         [10] 4469 UARTOT: OUT     (UARTD),A       ; Send data to UART
   FD63 DB 02         [ 9] 4470 URTOLP: IN      A,(UARTS)       ; Get status
   FD65 87            [ 4] 4471         ADD     A,A             ; Byte sent?
   FD66 F8            [10] 4472         RET     M               ; Yes - Return
   FD67 C3 63 FD      [ 9] 4473         JP      URTOLP          ; Keep waiting
                           4474 
   FD6A F5            [11] 4475 SUART:  PUSH    AF              ; Save A
   FD6B CD 61 FD      [16] 4476         CALL    UARTOT          ; Send it to UART
   FD6E F1            [ 9] 4477         POP     AF              ; Restore A
   FD6F C9            [ 9] 4478         RET
                           4479 
   FD70 00            [ 3] 4480         NOP
   FD71 00            [ 3] 4481         NOP
                           4482 
   FD72 E5            [11] 4483 SFTENT: PUSH    HL              ; Test for Shift Enter from KBD
   FD73 3E 02         [ 6] 4484         LD      A,#0b00000010   ; Reset KBD counter mask
   FD75 21 00 0C      [ 9] 4485         LD      HL,#PORT0        ; Get old contents
   FD78 AE            [ 6] 4486         XOR     (HL)            ; Toggle bit
   FD79 D3 00         [10] 4487         OUT     (0),A           ; Reset KBD counter
   FD7B EE 01         [ 6] 4488         XOR     #0b00000001       ; Toggle bit
   FD7D D3 00         [10] 4489         OUT     (0),A           ; Next row
   FD7F EE 02         [ 6] 4490         XOR     #0b00000010
   FD81 D3 00         [10] 4491         OUT     (0),A           ; Clear "clear" strobe
   FD83 7E            [ 6] 4492         LD      A,(HL)          ; Get old value
   FD84 D3 00         [10] 4493         OUT     (0),A           ; Original contents
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 83.
Hexadecimal [16-Bits]



   FD86 19            [ 7] 4494         ADD     HL,DE           ; ?? WHAT ??
   FD87 E1            [ 9] 4495         POP     HL              ; Restore HL
   FD88 DB 00         [ 9] 4496         IN      A,(0)           ; Read in row
   FD8A E6 12         [ 6] 4497         AND     #0b00010010       ; Mask SHIFT and ENTER
   FD8C C9            [ 9] 4498         RET
                           4499 
   FD8D CD 6F FE      [16] 4500 CLS:    CALL    MONTST          ; See if NAS-SYS
   FD90 CA 98 FD      [ 9] 4501         JP      Z,TCLS          ; "T" CLS
   FD93 3E 0C         [ 6] 4502         LD      A,#CS            ; ASCII Clear screen
   FD95 C3 DB FC      [ 9] 4503         JP      CONMON          ; Output character
                           4504 
   FD98 3E 1E         [ 6] 4505 TCLS:   LD      A,#TCS           ; NASBUG Clear screen
   FD9A C3 DB FC      [ 9] 4506         JP      CONMON          ; Output character
                           4507 
   FD9D AF            [ 4] 4508 DELAY:  XOR     A               ; Delay routine
   FD9E F5            [11] 4509 DELAY1: PUSH    AF              ; PUSHes and POPs delay
   FD9F F1            [ 9] 4510         POP     AF
   FDA0 F5            [11] 4511         PUSH    AF
   FDA1 F1            [ 9] 4512         POP     AF
   FDA2 3D            [ 4] 4513         DEC     A               ; Count delays
   FDA3 C2 9E FD      [ 9] 4514         JP      NZ,DELAY1       ; More delay
   FDA6 C9            [ 9] 4515         RET
                           4516 
   FDA7 CD 86 F4      [16] 4517 WIDTH:  CALL    GETINT          ; Get integer 0-255
   FDAA 7B            [ 4] 4518         LD      A,E             ; Width to A
   FDAB 32 42 10      [13] 4519         LD      (LWIDTH),A      ; Set width
   FDAE C9            [ 9] 4520         RET
                           4521 
   FDAF CD 43 ED      [16] 4522 LINES:  CALL    GETNUM          ; Get a number
   FDB2 CD 8D E9      [16] 4523         CALL    DEINT           ; Get integer -32768 to 32767
   FDB5 ED 53 46 10   [19] 4524         LD      (LINESC),DE     ; Set lines counter
   FDB9 ED 53 48 10   [19] 4525         LD      (LINESN),DE     ; Set lines number
   FDBD C9            [ 9] 4526         RET
                           4527 
   FDBE CD 8D E9      [16] 4528 DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
   FDC1 D5            [11] 4529         PUSH    DE              ; Save number
   FDC2 E1            [ 9] 4530         POP     HL              ; Number to HL
   FDC3 46            [ 6] 4531         LD      B,(HL)          ; Get LSB of contents
   FDC4 23            [ 4] 4532         INC     HL
   FDC5 7E            [ 6] 4533         LD      A,(HL)          ; Get MSB of contents
   FDC6 C3 F4 F0      [ 9] 4534         JP      ABPASS          ; Return integer AB
                           4535 
   FDC9 CD 43 ED      [16] 4536 DOKE:   CALL    GETNUM          ; Get a number
   FDCC CD 8D E9      [16] 4537         CALL    DEINT           ; Get integer -32768 to 32767
   FDCF D5            [11] 4538         PUSH    DE              ; Save address
   FDD0 CD 92 E6      [16] 4539         CALL    CHKSYN          ; Make sure "," follows
   FDD3 2C                 4540         .db      ","
   FDD4 CD 43 ED      [16] 4541         CALL    GETNUM          ; Get a number
   FDD7 CD 8D E9      [16] 4542         CALL    DEINT           ; Get integer -32768 to 32767
   FDDA E3            [16] 4543         EX      (SP),HL         ; Save value,get address
   FDDB 73            [ 7] 4544         LD      (HL),E          ; Save LSB of value
   FDDC 23            [ 4] 4545         INC     HL
   FDDD 72            [ 7] 4546         LD      (HL),D          ; Save MSB of value
   FDDE E1            [ 9] 4547         POP     HL              ; Restore code string address
   FDDF C9            [ 9] 4548         RET
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 84.
Hexadecimal [16-Bits]



                           4549 
   FDE0 F3            [ 3] 4550 JJUMP1: DI                      ; Disable interrupts
   FDE1 DD 21 FF FF   [12] 4551         LD      IX,#-1           ; Flag cold start
   FDE5 C3 12 E0      [ 9] 4552         JP      CSTART          ; Go and initialise
                           4553 
   FDE8 CD 86 F4      [16] 4554 SCREEN: CALL    GETINT          ; Get integer 0 to 255
   FDEB F5            [11] 4555         PUSH    AF              ; Save column
   FDEC CD 92 E6      [16] 4556         CALL    CHKSYN          ; Make sure "," follows
   FDEF 2C                 4557         .db      ","
   FDF0 CD 86 F4      [16] 4558         CALL    GETINT          ; Get integer 0 to 255
   FDF3 C1            [ 9] 4559         POP     BC              ; Column to B
   FDF4 E5            [11] 4560         PUSH    HL              ; Save code string address
   FDF5 C5            [11] 4561         PUSH    BC              ; Save column
   FDF6 CD 13 FE      [16] 4562         CALL    SCRADR          ; Calculate screen address
   FDF9 E5            [11] 4563         PUSH    HL              ; Save screen address
   FDFA CD 6F FE      [16] 4564         CALL    MONTST          ; See if NAS-SYS
   FDFD CA 06 FE      [ 9] 4565         JP      Z,TMNCUR        ; "T" monitor - "T" cursor
   FE00 E1            [ 9] 4566         POP     HL              ; Restore screen address
   FE01 22 29 0C      [16] 4567         LD      (CURSOR),HL     ; Set new cursor position
   FE04 E1            [ 9] 4568         POP     HL              ; Rstore code string address
   FE05 C9            [ 9] 4569         RET
                           4570 
   FE06 2A 18 0C      [15] 4571 TMNCUR: LD      HL,(TCUR)       ; Get address or cursor
   FE09 36 20         [ 9] 4572         LD      (HL),#" "        ; Remove cursor
   FE0B E1            [ 9] 4573         POP     HL              ; Get new cursor address
   FE0C 22 18 0C      [16] 4574         LD      (TCUR),HL       ; Set new cursor
   FE0F 36 5F         [ 9] 4575         LD      (HL),#"_"        ; Put it on screen
   FE11 E1            [ 9] 4576         POP     HL              ; Restore code string address
   FE12 C9            [ 9] 4577         RET
                           4578 
   FE13 21 C9 07      [ 9] 4579 SCRADR: LD      HL,#VDU+10-65    ; SCREEN VDU address (0,0)
   FE16 06 00         [ 6] 4580         LD      B,#0
   FE18 4F            [ 4] 4581         LD      C,A             ; Line to BC
   FE19 B7            [ 4] 4582         OR      A               ; Test it
   FE1A CA A2 E9      [ 9] 4583         JP      Z,FCERR         ; Zero - ?FC Error
   FE1D FE 11         [ 6] 4584         CP      #16+1            ; 16 lines
   FE1F F2 A2 E9      [ 9] 4585         JP      P,FCERR         ; > 16 - ?FC Error
   FE22 D1            [ 9] 4586         POP     DE              ; RETurn address
   FE23 F1            [ 9] 4587         POP     AF              ; Get column
   FE24 D5            [11] 4588         PUSH    DE              ; Re-save RETurn
   FE25 16 00         [ 6] 4589         LD      D,#0
   FE27 5F            [ 4] 4590         LD      E,A             ; Column to DE
   FE28 B7            [ 4] 4591         OR      A               ; Test it
   FE29 CA A2 E9      [ 9] 4592         JP      Z,FCERR         ; Zero - ?FC Error
   FE2C FE 31         [ 6] 4593         CP      #48+1            ; 48 characters per line
   FE2E F2 A2 E9      [ 9] 4594         JP      P,FCERR         ; > 48 - ?FC Error
   FE31 19            [ 7] 4595         ADD     HL,DE           ; Add column to address
   FE32 16 00         [ 6] 4596         LD      D,#0
   FE34 59            [ 4] 4597         LD      E,C             ; Line to DE
   FE35 06 40         [ 6] 4598         LD      B,#64            ; 64 Bytes per line
   FE37 19            [ 7] 4599 ADD64X: ADD     HL,DE           ; Add line
   FE38 10 FD         [ 9] 4600         DJNZ    ADD64X          ; SIXTY FOUR TIMES!!!
   FE3A C9            [ 9] 4601         RET
                           4602 
   FE3B CD 6F FE      [16] 4603 FLPLED: CALL    MONTST          ; See if NAS-SYS
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 85.
Hexadecimal [16-Bits]



   FE3E CA 44 FE      [ 9] 4604         JP      Z,TMFLP         ; "T" MFLP
   FE41 DF 5F              4605         .dw      _MFLP
   FE43 C9            [ 9] 4606         RET
                           4607 
   FE44 C3 51 00      [ 9] 4608 TMFLP:  JP      MFLP            ; Flip drive LED
                           4609 
   FE47 F5            [11] 4610 MONOUT: PUSH    AF              ; Save character
   FE48 CD 6F FE      [16] 4611         CALL    MONTST          ; See if NAS-SYS
   FE4B CA 51 FE      [ 9] 4612         JP      Z,TMNOUT        ; "T" output
   FE4E F1            [ 9] 4613         POP     AF              ; Restore character
   FE4F F7                 4614         .db      _ROUT           ; Output it
   FE50 C9            [ 9] 4615         RET
                           4616 
   FE51 F1            [ 9] 4617 TMNOUT: POP     AF              ; Restore character
   FE52 C3 4A 0C      [ 9] 4618         JP      TOUT            ; "T" output
                           4619 
   FE55 3A 4D 10      [12] 4620 BREAK2: LD      A,(BRKFLG)      ; Break flag set?
   FE58 C2 67 FE      [ 9] 4621         JP      NZ,RETCTC       ; Yes - Return ^C
   FE5B CD 6F FE      [16] 4622         CALL    MONTST          ; See if NAS-SYS
   FE5E CA 64 FE      [ 9] 4623         JP      Z,T0xCINP        ; Get "T" character input
   FE61 DF 62              4624         .dw      _RIN            ; Scan for a character
   FE63 C9            [ 9] 4625         RET
                           4626 
   FE64 C3 4D 0C      [ 9] 4627 T0xCINP: JP      TIN             ; "T" input a character
                           4628 
   FE67 3E 00         [ 6] 4629 RETCTC: LD      A,#0             ; Clear Break flag
   FE69 32 4D 10      [13] 4630         LD      (BRKFLG),A
   FE6C 3E 03         [ 6] 4631         LD      A,#CTRLC         ; Return ^C
   FE6E C9            [ 9] 4632         RET
                           4633 
   FE6F 3A 01 00      [12] 4634 MONTST: LD      A,(MONSTT+1)    ; "T" monitor or NAS-SYS?
   FE72 FE 33         [ 6] 4635         CP      #0x33             ; 31 00 10 / 31 33 0C
   FE74 C9            [ 9] 4636         RET
                           4637 
   FE75 CD 3B FE      [16] 4638 SAVE:   CALL    FLPLED          ; Flip tape LED
   FE78 CD 6F FE      [16] 4639         CALL    MONTST          ; See if NAS-SYS
   FE7B CA 81 FE      [ 9] 4640         JP      Z,TSAVE         ; "T" save
   FE7E DF 57              4641         .dw      _WRIT           ; Save program
   FE80 C9            [ 9] 4642         RET
                           4643 
   FE81 3A 8D 00      [12] 4644 TSAVE:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
   FE84 CA 00 04      [ 9] 4645         JP      Z,T4WR          ; T4 Write
   FE87 C3 D1 03      [ 9] 4646         JP      T2DUMP          ; T2 Dump
                           4647 
   FE8A CD 3B FE      [16] 4648 MONLD:  CALL    FLPLED          ; Flip tape LED
   FE8D CD 6F FE      [16] 4649         CALL    MONTST          ; See if NAS-SYS
   FE90 CA 9B FE      [ 9] 4650         JP      Z,TLOAD         ; "T" load
   FE93 3E 52         [ 6] 4651         LD      A,#"R"           ; Set READ
   FE95 32 2B 0C      [13] 4652         LD      (ARGN),A
   FE98 DF 52              4653         .dw      _READ           ; Load program
   FE9A C9            [ 9] 4654         RET
                           4655 
   FE9B 3A 8D 00      [12] 4656 TLOAD:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
   FE9E CA 0C 07      [ 9] 4657         JP      Z,T4READ        ; T4 Read
   FEA1 C3 D1 03      [ 9] 4658         JP      T2DUMP          ; T2 Dump ??????????
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 86.
Hexadecimal [16-Bits]



                           4659 
   FEA4 CD 6F FE      [16] 4660 MONITR: CALL    MONTST          ; See if NAS-SYS
   FEA7 CA 00 00      [ 9] 4661         JP      Z,MONSTT        ; Jump to zero if "T"
   FEAA DF 5B              4662         .dw      _MRET           ; Return to NAS-SYS
                           4663 
   FEAC CD 3B FE      [16] 4664 MONVE:  CALL    FLPLED          ; Flip tape LED
   FEAF CD 6F FE      [16] 4665         CALL    MONTST          ; See if NAS-SYS
   FEB2 CA A2 E9      [ 9] 4666         JP      Z,FCERR         ; Verify not available on "T"
   FEB5 3E 56         [ 6] 4667         LD      A,#"V"           ; Set VERIFY
   FEB7 32 2B 0C      [13] 4668         LD      (ARGN),A
   FEBA DF 56              4669         .dw      _VRFY           ; Verify tape
   FEBC C9            [ 9] 4670         RET
                           4671 
   FEBD 3E 00         [ 6] 4672 INITST: LD      A,#0             ; Clear break flag
   FEBF 32 4D 10      [13] 4673         LD      (BRKFLG),A
   FEC2 CD 6F FE      [16] 4674         CALL    MONTST          ; See if NAS-SYS
   FEC5 CA 19 E0      [ 9] 4675         JP      Z,INIT          ; "T" - No NMI vector
   FEC8 21 E0 FE      [ 9] 4676         LD      HL,#BREAK        ; Set NMI gives break
   FECB 22 7E 0C      [16] 4677         LD      (NMI),HL
   FECE DD E5         [14] 4678         PUSH    IX              ; Get start up condition
   FED0 F1            [ 9] 4679         POP     AF              ; "Z" set if cold , Else clear
   FED1 B7            [ 4] 4680         OR      A               ; "Cold" or "Cool" start?
   FED2 C2 19 E0      [ 9] 4681         JP      NZ,INIT         ; "Cool" don't init NAS-SYS
   FED5 06 0F         [ 6] 4682         LD      B,#15            ; Delay for keyboard clear
   FED7 CD CF FC      [16] 4683         CALL    DELAYB          ; Allow time for key release
   FEDA CD 0D 00      [16] 4684         CALL    STMON           ; Initialise NAS-SYS
   FEDD C3 19 E0      [ 9] 4685         JP      INIT            ; Initialise BASIC
                           4686 
   FEE0 F5            [11] 4687 BREAK:  PUSH    AF              ; Save character
   FEE1 3E FF         [ 6] 4688         LD      A,#-1
   FEE3 32 4D 10      [13] 4689         LD      (BRKFLG),A      ; Flag break
   FEE6 F1            [ 9] 4690         POP     AF              ; Restore character
   FEE7 ED 45         [12] 4691 ARETN:  RETN                    ; Return from NMI
                           4692 
   FEE9 00            [ 3] 4693         NOP
                           4694 
   FEEA DF 63              4695 INLINE: .dw      _INLN           ; Get an input line
   FEEC D5            [11] 4696         PUSH    DE              ; Save cursor address
   FEED D5            [11] 4697         PUSH    DE              ; Cursor address to HL
   FEEE E1            [ 9] 4698         POP     HL
   FEEF 11 2F 00      [ 9] 4699         LD      DE,#48-1         ; Length of line-1
   FEF2 19            [ 7] 4700         ADD     HL,DE           ; Point to end of line
   FEF3 7E            [ 6] 4701 ENDLIN: LD      A,(HL)          ; Get end of line
   FEF4 FE 20         [ 6] 4702         CP      #" "             ; Space?
   FEF6 C2 04 FF      [ 9] 4703         JP      NZ,LINTBF       ; No - Copy to buffer
   FEF9 1D            [ 4] 4704         DEC     E               ; Back 1 character
   FEFA 3E 00         [ 6] 4705         LD      A,#0             ; Wasteful test on E
   FEFC B3            [ 4] 4706         OR      E
   FEFD CA 04 FF      [ 9] 4707         JP      Z,LINTBF        ; Start of line - Copy it
   FF00 2B            [ 4] 4708         DEC     HL              ; Back 1 character
   FF01 C3 F3 FE      [ 9] 4709         JP      ENDLIN          ; Keep looking for end
                           4710 
   FF04 D5            [11] 4711 LINTBF: PUSH    DE              ; Line length to BC
   FF05 C1            [ 9] 4712         POP     BC
   FF06 03            [ 4] 4713         INC     BC              ; Length +1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 87.
Hexadecimal [16-Bits]



   FF07 11 61 10      [ 9] 4714         LD      DE,#BUFFER       ; Input buffer
   FF0A E1            [ 9] 4715         POP     HL              ; Line start
   FF0B C5            [11] 4716         PUSH    BC              ; Save length
   FF0C ED B0         [14] 4717         LDIR                    ; Move line to buffer
   FF0E 3E 00         [ 6] 4718         LD      A,#0
   FF10 12            [ 7] 4719         LD      (DE),A          ; Mark end of buffer with 00
   FF11 C1            [ 9] 4720         POP     BC              ; Restore buffer length
   FF12 41            [ 4] 4721         LD      B,C             ; Length returned in B
   FF13 21 60 10      [ 9] 4722         LD      HL,#BUFFER-1     ; Point to start of buffer-1
   FF16 C9            [ 9] 4723         RET
                           4724 
   FF17 CD 92 E6      [16] 4725 GETXYA: CALL    CHKSYN          ; Make sure "(" follows
   FF1A 28                 4726         .db      "("
   FF1B CD 43 ED      [16] 4727         CALL    GETNUM          ; Get a number
   FF1E CD 8D E9      [16] 4728         CALL    DEINT           ; Get integer -32768 to 32767
   FF21 D5            [11] 4729         PUSH    DE              ; Save "X"
   FF22 CD 92 E6      [16] 4730         CALL    CHKSYN          ; Make sure "," follows
   FF25 2C                 4731         .db      ","
   FF26 CD 43 ED      [16] 4732         CALL    GETNUM          ; Get a number
   FF29 CD 92 E6      [16] 4733         CALL    CHKSYN          ; Make sure ")" follows
   FF2C 29                 4734         .db      ")"
   FF2D CD 8D E9      [16] 4735         CALL    DEINT           ; Get integer -32768 to 32767
   FF30 E5            [11] 4736         PUSH    HL              ; Save code string address
   FF31 FD E1         [12] 4737         POP     IY              ; In IY
   FF33 CD 98 FF      [16] 4738         CALL    XYPOS           ; Address and bit mask
   FF36 F5            [11] 4739         PUSH    AF              ; Save mask
   FF37 CD C4 FF      [16] 4740         CALL    ADJCOL          ; Adjust column
   FF3A CD 13 FE      [16] 4741         CALL    SCRADR          ; Get VDU address
   FF3D F1            [ 9] 4742         POP     AF              ; Restore bit mask
   FF3E 06 C0         [ 6] 4743         LD      B,#0b11000000     ; Block graphics base
   FF40 B0            [ 4] 4744         OR      B               ; Set bits 7 & 6
   FF41 C9            [ 9] 4745         RET
                           4746 
   FF42 CD 17 FF      [16] 4747 SETB:   CALL    GETXYA          ; Get co-ords and VDU address
   FF45 F5            [11] 4748         PUSH    AF              ; Save bit mask
   FF46 7E            [ 6] 4749         LD      A,(HL)          ; Get character from screen
   FF47 FE C0         [ 6] 4750         CP      #0b11000000       ; Is it a block graphic?
   FF49 D2 52 FF      [ 9] 4751         JP      NC,#SETOR        ; Yes - OR new bit
   FF4C F1            [ 9] 4752         POP     AF              ; Restore bit mask
   FF4D 77            [ 7] 4753 PUTBIT: LD      (HL),A          ; Put character on screen
   FF4E FD E5         [14] 4754 RESCSA: PUSH    IY              ; Restore code string address
   FF50 E1            [ 9] 4755         POP     HL              ; From IY
   FF51 C9            [ 9] 4756         RET
                           4757 
   FF52 C1            [ 9] 4758 SETOR:  POP     BC              ; Restore bit mask
   FF53 B0            [ 4] 4759         OR      B               ; Merge the bits
   FF54 C3 4D FF      [ 9] 4760         JP      PUTBIT          ; Save on screen
                           4761 
   FF57 CD 17 FF      [16] 4762 RESETB: CALL    GETXYA          ; Get co-ords and VDU address
   FF5A F5            [11] 4763         PUSH    AF              ; Save bit mask
   FF5B 7E            [ 6] 4764         LD      A,(HL)          ; Get byte from screen
   FF5C FE C0         [ 6] 4765         CP      #0b11000000       ; Is it a block graphic?
   FF5E DA 77 FF      [ 9] 4766         JP      C,NORES         ; No - Leave it
   FF61 06 3F         [ 6] 4767         LD      B,#0b00111111     ; Six bits per block
   FF63 A0            [ 4] 4768         AND     B               ; Clear bits 7 & 6
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 88.
Hexadecimal [16-Bits]



   FF64 C1            [ 9] 4769         POP     BC              ; Get bit mask
   FF65 A0            [ 4] 4770         AND     B               ; Test for common bit
   FF66 CA 4E FF      [ 9] 4771         JP      Z,RESCSA        ; None - Leave it
   FF69 7E            [ 6] 4772         LD      A,(HL)          ; Get byte from screen
   FF6A E6 3F         [ 6] 4773         AND     #0b00111111       ; Isolate bit
   FF6C A8            [ 4] 4774         XOR     B               ; Clear that bit
   FF6D FE C0         [ 6] 4775         CP      #0b11000000       ; Is it a graphic blank?
   FF6F C2 4D FF      [ 9] 4776         JP      NZ,PUTBIT       ; No - Save character
   FF72 3E 20         [ 6] 4777         LD      A,#" "           ; Put a space there
   FF74 C3 4D FF      [ 9] 4778         JP      PUTBIT          ; Save the space
                           4779 
   FF77 C1            [ 9] 4780 NORES:  POP     BC              ; Drop bit mask
   FF78 C3 4E FF      [ 9] 4781         JP      RESCSA          ; Restore code string address
                           4782 
   FF7B CD 17 FF      [16] 4783 POINTB: CALL    GETXYA          ; Get co-ords and VDU address
   FF7E 46            [ 6] 4784         LD      B,(HL)          ; Get character from screen
   FF7F CD EF FF      [16] 4785         CALL    TSTBIT          ; Test if bit is set
   FF82 C2 93 FF      [ 9] 4786         JP      NZ,POINT0       ; Different - Return zero
   FF85 3E 00         [ 6] 4787         LD      A,#0
   FF87 06 01         [ 6] 4788         LD      B,#1             ; Integer AB = 1
   FF89 E1            [ 9] 4789 POINTX: POP     HL              ; Drop return
   FF8A FD E5         [14] 4790         PUSH    IY              ; PUSH code string address
   FF8C 11 1F EE      [ 9] 4791         LD      DE,#RETNUM       ; To return a number
   FF8F D5            [11] 4792         PUSH    DE              ; Save for return
   FF90 C3 F4 F0      [ 9] 4793         JP      ABPASS          ; Return integer AB
                           4794 
   FF93 06 00         [ 6] 4795 POINT0: LD      B,#0             ; Set zero
   FF95 C3 89 FF      [ 9] 4796         JP      POINTX          ; Return value
                           4797 
   FF98 C1            [ 9] 4798 XYPOS:  POP     BC              ; Get return address
   FF99 E1            [ 9] 4799         POP     HL              ; Get column
   FF9A E5            [11] 4800         PUSH    HL              ; And re-save
   FF9B C5            [11] 4801         PUSH    BC              ; Put back return address
   FF9C 7D            [ 4] 4802         LD      A,L             ; Get column
   FF9D 06 01         [ 6] 4803         LD      B,#0b00000001     ; 2 bits per character
   FF9F A0            [ 4] 4804         AND     B               ; Odd or even bit
   FFA0 F5            [11] 4805         PUSH    AF              ; Save it
   FFA1 D5            [11] 4806         PUSH    DE              ; Get row
   FFA2 E1            [ 9] 4807         POP     HL              ; to HL
   FFA3 11 00 00      [ 9] 4808         LD      DE,#0            ; Zero line count
   FFA6 01 03 00      [ 9] 4809         LD      BC,#3            ; 3 blocks per line
   FFA9 23            [ 4] 4810         INC     HL
   FFAA ED 42         [10] 4811 DIV3LP: SBC     HL,BC           ; Subtract 3
   FFAC 13            [ 4] 4812         INC     DE              ; Count the subtractions
   FFAD CA B3 FF      [ 9] 4813         JP      Z,DIV3EX        ; Exactly - Exit
   FFB0 F2 AA FF      [ 9] 4814         JP      P,DIV3LP        ; More to do
                           4815 
   FFB3 09            [ 7] 4816 DIV3EX: ADD     HL,BC           ; Restore number
   FFB4 F1            [ 9] 4817         POP     AF              ; Restore column and odd/even
   FFB5 B7            [ 4] 4818         OR      A               ; Set flags (NZ or Z)
   FFB6 7D            [ 4] 4819         LD      A,L             ; Get remainder from /3
   FFB7 CA BC FF      [ 9] 4820         JP      Z,NOREMD        ; No remainder
   FFBA C6 03         [ 6] 4821         ADD     A,#3             ; Adjust remainder
   FFBC 47            [ 4] 4822 NOREMD: LD      B,A             ; Bit number+1 to B
   FFBD 3E 01         [ 6] 4823         LD      A,#0b00000001     ; Bit to rotate
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 89.
Hexadecimal [16-Bits]



   FFBF 07            [ 3] 4824 SHFTBT: RLCA                    ; Shift bit left
   FFC0 10 FD         [ 9] 4825         DJNZ    SHFTBT          ; Count shifts
   FFC2 1F            [ 3] 4826         RRA                     ; Restore correct place
   FFC3 C9            [ 9] 4827         RET
                           4828 
   FFC4 C1            [ 9] 4829 ADJCOL: POP     BC              ; Restore return address
   FFC5 F1            [ 9] 4830         POP     AF              ; Get bit mask
   FFC6 E1            [ 9] 4831         POP     HL              ; Get column
   FFC7 F5            [11] 4832         PUSH    AF              ; Re-save but mask
   FFC8 7D            [ 4] 4833         LD      A,L             ; Get column
   FFC9 1F            [ 3] 4834         RRA                     ; Divide by 2
   FFCA C6 01         [ 6] 4835         ADD     A,#1             ; Start at column 1
   FFCC E6 3F         [ 6] 4836         AND     #0b00111111       ; 0 to 63
   FFCE 67            [ 4] 4837         LD      H,A             ; Save column in H
   FFCF E5            [11] 4838         PUSH    HL              ; Re-save column
   FFD0 C5            [11] 4839         PUSH    BC              ; Put back return
   FFD1 7B            [ 4] 4840         LD      A,E             ; Get row
   FFD2 C9            [ 9] 4841         RET
                           4842 
   FFD3 CD D7 FC      [16] 4843 SMOTOR: CALL    CASFF           ; Flip tape drive
   FFD6 7E            [ 6] 4844         LD      A,(HL)          ; Get byte
   FFD7 C9            [ 9] 4845         RET
                           4846 
   FFD8 3A CE 10      [12] 4847 JPLDSV: LD      A,(BRKLIN)      ; CLOAD or CSAVE?
   FFDB FE FF         [ 6] 4848         CP      #-1
   FFDD C2 08 E9      [ 9] 4849         JP      NZ,SNDHDR       ; CSAVE - Send header
   FFE0 C3 12 E9      [ 9] 4850         JP      GETHDR          ; CLOAD - Get header
                           4851 
   FFE3 CD 83 EB      [16] 4852 CRLIN1: CALL    PRNTCR          ; Output CRLF
   FFE6 C3 F4 E5      [ 9] 4853         JP      GETLIN          ; Get an input line
                           4854 
   FFE9 CD 83 EB      [16] 4855 CRLIN:  CALL    PRNTCR          ; Output CRLF
   FFEC C3 F4 E5      [ 9] 4856         JP      GETLIN          ; Get an input line
                           4857 
   FFEF F5            [11] 4858 TSTBIT: PUSH    AF              ; Save bit mask
   FFF0 A0            [ 4] 4859         AND     B               ; Get common bits
   FFF1 C1            [ 9] 4860         POP     BC              ; Restore bit mask
   FFF2 B8            [ 4] 4861         CP      B               ; Same bit set?
   FFF3 3E 00         [ 6] 4862         LD      A,#0             ; Return 0 in A
   FFF5 C9            [ 9] 4863         RET
                           4864 
   FFF6 CD 9D E6      [16] 4865 OUTNCR: CALL    OUTC            ; Output character in A
   FFF9 C3 83 EB      [ 9] 4866         JP      PRNTCR          ; Output CRLF
                           4867 
   FFFC C3 E0 FD      [ 9] 4868 JJUMP:  JP      JJUMP1          ; "Cool" start
                           4869 
   FFFF C3 B1 E0      [ 9] 4870 ZJUMP:  JP      BRKRET          ; Warm start
                           4871         
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 90.
Hexadecimal [16-Bits]

Symbol Table

    .__.$$$.=  2710 L   |     .__.ABS.=  0000 G   |     .__.CPU.=  0001 L
    .__.H$L.=  0000 L   |   2 ABPASS     F0F4 R   |   2 ABS        F83A R
  2 ACCSUM     E942 R   |   2 ACPASS     F0F3 R   |   2 ADD64X     FE37 R
  2 ADDEXP     F7D3 R   |   2 ADDIG      F979 R   |   2 ADDPHL     F5C0 R
  2 ADJCOL     FFC4 R   |   2 ALLFOL     F3C2 R   |   2 ANTVLU     EC67 R
  2 ANYNAM     F51E R   |   2 ARET       FCDA R   |   2 ARETN      FEE7 R
    ARG1    =  0C0C     |     ARG2    =  0C0E     |     ARGN    =  0C2B 
  2 ARLDSV     F014 R   |     ARREND  =  10DA     |   2 ARRLD1     E8BB R
  2 ARRLP      F28D R   |   2 ARRSV1     E8BD R   |   2 ARYLP      E922 R
  2 ASC        F393 R   |   2 ASCTFP     F91C R   |   2 ASPCS      EBC9 R
  2 ATN        FC7E R   |   2 ATN1       FC9B R   |   2 ATNTAB     FCA5 R
  2 ATOH       E9A7 R   |   2 BAD        F59F R   |   2 BADINP     EBEE R
  2 BAKSTK     E358 R   |   2 BAKTMP     F373 R   |     BASTXT  =  105E 
  2 BCDEFP     F861 R   |   2 BFREE      E0B7 R   |     BKSP    =  0008 
  2 BNORM      F620 R   |   2 BNRMLP     F623 R   |   2 BREAK      FEE0 R
  2 BREAK2     FE55 R   |     BRKFLG  =  104D     |     BRKLIN  =  10CE 
  2 BRKMSG     E352 R   |   2 BRKRET     E0B1 R   |     BS      =  0010 
  2 BSERR      F047 R   |     BUFFER  =  1061     |   2 BYTSFT     F758 R
  2 CASFF      FCD7 R   |   2 CASFFW     FCCA R   |   2 CFEVAL     EFAA R
  2 CHARTY     EF58 R   |   2 CHEKFN     F18B R   |   2 CHKBRK     FD42 R
  2 CHKLTR     E979 R   |   2 CHKSTK     E38C R   |     CHKSUM  =  104A 
  2 CHKSYN     E692 R   |   2 CHKTYP     ED48 R   |   2 CHR        F3A4 R
  2 CHSUMS     E962 R   |     CIN     =  0C75     |   2 CLEAR      E9CC R
  2 CLOAD      F4FB R   |   2 CLOAD1     F52D R   |   2 CLOAD2     F52F R
  2 CLOADE     F561 R   |   2 CLOADV     F55E R   |   2 CLOTST     E6CE R
  2 CLREG      E4E1 R   |   2 CLRPTR     E4BC R   |   2 CLS        FD8D R
  2 CMPFP      F8AA R   |   2 CMPLG1     EEBE R   |   2 CMPLOG     EEBC R
  2 CMPNUM     F890 R   |   2 CMPRES     EF00 R   |   2 CMPSTR     EEE8 R
    CN      =  0020     |   2 CNVIN1     FD22 R   |   2 CNVIN2     FD29 R
  2 CNVIN3     FD30 R   |   2 CNVIN4     FD37 R   |   2 CNVIN5     FD3E R
  2 CNVNUM     F928 R   |     COMMAN  =  1043     |   2 COMPL      F680 R
  2 CONCAT     F308 R   |   2 CONEXP     F958 R   |   2 CONMON     FCDB R
  2 CONOT1     FCF3 R   |   2 CONPOS     F61D R   |   2 CONT       E8A0 R
    CONTAD  =  10D4     |   2 CONVAR     EE24 R   |   2 CONVIN     FD1B R
  2 COPY       E021 R   |   2 COS        FC02 R   |   2 COUNT      E748 R
  2 CPDEHL     E68C R   |   2 CPYLIT     E5B3 R   |     CR      =  000D 
  2 CRARLP     F067 R   |   2 CREARY     F04C R   |   2 CRESTR     EACB R
  2 CRLIN      FFE9 R   |   2 CRLIN1     FFE3 R   |   2 CRNCLP     E514 R
  2 CRTMST     F1C4 R   |   2 CRTST      F1D0 R   |   2 CRTSTE     F1E6 R
  2 CRUN0xC    E50B R   |     CS      =  000C     |   2 CSAVE      F4C5 R
  2 CSTART     E012 R   |     CTLOFG  =  1045     |     CTRLC   =  0003 
    CTRLG   =  0007     |     CTRLO   =  000F     |     CTRLR   =  0012 
    CTRLS   =  0013     |     CTRLU   =  0015     |     CTRLZ   =  001A 
    CUROPR  =  10C5     |     CURPOS  =  10AB     |     CURSOR  =  0C29 
  2 DATA       EA72 R   |     DATFLG  =  10AE     |     DATLIN  =  10C9 
  2 DATSNR     E3A9 R   |   2 DCBCDE     F8E1 R   |     DD      =  0012 
  2 DDERR      E3B8 R   |   2 DEEK       FDBE R   |   2 DEF        F108 R
  2 DEFSIZ     F06F R   |   2 DEINT      E98D R   |     DEL     =  007F 
  2 DELAY      FD9D R   |   2 DELAY1     FD9E R   |   2 DELAYB     FCCF R
  2 DELCHR     E5E3 R   |   2 DEPINT     E987 R   |   2 DETHL4     F870 R
  2 DETHLB     F872 R   |   2 DIGTXT     FA22 R   |   2 DIM        EF2A R
  2 DIMRET     EF21 R   |   2 DINPOS     E6C1 R   |   2 DIV        F769 R
    DIV1    =  100A     |   2 DIV10      F75D R   |     DIV2    =  100E 
    DIV3    =  1012     |   2 DIV3EX     FFB3 R   |   2 DIV3LP     FFAA R
    DIV4    =  1015     |   2 DIVLP      F790 R   |     DIVSUP  =  1009 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 91.
Hexadecimal [16-Bits]

Symbol Table

  2 DOAGN      E4FA R   |   2 DOCOM      EB9A R   |   2 DODEL      E5C3 R
  2 DOEBIT     FA62 R   |   2 DOFN       F135 R   |   2 DOKE       FDC9 R
  2 DONULL     EB88 R   |   2 DOSPC      EBC4 R   |   2 DOSUM      E94F R
  2 DOTAB      EBB1 R   |   2 DPOINT     F954 R   |   2 DTSTR      F1D4 R
  2 DVBCDE     F76B R   |     DZ      =  0014     |   2 DZERR      E3B2 R
  2 ECHDEL     E5D7 R   |   2 EDIGIT     F99B R   |   2 ENDBUF     E5BA R
  2 ENDCON     F967 R   |   2 ENDDIM     F0CE R   |   2 ENDINP     EB7E R
  2 ENDLIN     FEF3 R   |   2 ENDNAM     EF4C R   |   2 ENDPRG     E87C R
  2 ENFMEM     E395 R   |   2 ERRIN      E3E3 R   |     ERRLIN  =  10D2 
  2 ERRMSG     E33F R   |   2 ERROR      E3C3 R   |   2 ERRORS     E2B9 R
    ESC     =  001B     |   2 EVAL       ED5C R   |   2 EVAL1      ED5F R
  2 EVAL2      ED68 R   |   2 EVAL3      ED6B R   |   2 EVLPAR     EE0B R
  2 EVNOT      EF0A R   |   2 EXCUTE     E818 R   |   2 EXP        FAFC R
  2 EXPLP      F946 R   |   2 EXPTAB     FB3C R   |   2 EXPTEN     FA74 R
  2 EXTIG      ECC3 R   |   2 FANDT      ECED R   |     FC      =  0008 
  2 FCERR      E9A2 R   |   2 FDTLP      ECD4 R   |   2 FILE       F590 R
  2 FILFND     F576 R   |   2 FINDEL     F0AA R   |   2 FLGDIF     F820 R
  2 FLGREL     F827 R   |   2 FLGVER     F50B R   |   2 FLPLED     FE3B R
    FNARG   =  10E0     |   2 FNCTAB     E10F R   |   2 FNDARY     F01A R
  2 FNDELP     F0AF R   |   2 FNDEND     E48F R   |   2 FNDNUM     F483 R
  2 FNDTOK     E71D R   |   2 FNDVAR     EF91 R   |   2 FNDWRD     E53E R
  2 FNOFST     EE35 R   |     FNRGNM  =  10DE     |   2 FNTHR      EF9F R
  2 FNVAL      EE61 R   |   2 FOPRND     ED94 R   |   2 FOR        E77B R
    FORFLG  =  10CB     |   2 FORFND     E7AB R   |   2 FORSLP     E78F R
  2 FOUND      F596 R   |   2 FPADD      F5CF R   |   2 FPBCDE     F856 R
    FPEXP   =  10E7     |   2 FPINT      F8BD R   |   2 FPMULT     F70A R
    FPREG   =  10E4     |   2 FPROND     F667 R   |   2 FPSINT     E981 R
  2 FPTHL      F86D R   |   2 FRE        F0D2 R   |   2 FRENUM     F0EE R
  2 FRMEVL     EE27 R   |   2 GARBGE     F255 R   |   2 GARBLP     F258 R
  2 GETCHR     E838 R   |   2 GETCMD     E407 R   |   2 GETHDR     E912 R
  2 GETINP     FD07 R   |   2 GETINT     F486 R   |   2 GETLEN     F388 R
  2 GETLIN     E5F4 R   |   2 GETLN      E9A8 R   |   2 GETNUM     ED43 R
  2 GETNXT     E559 R   |   2 GETSTR     F352 R   |   2 GETTIN     FD15 R
  2 GETVAR     EF2F R   |   2 GETXYA     FF17 R   |   2 GNXARY     F28C R
  2 GOFUNC     EE69 R   |   2 GOSUB      EA1E R   |   2 GOTO       EA2F R
  2 GRBARY     F2AC R   |   2 GRBDON     F22D R   |   2 GRBLP      F266 R
  2 GSTRCU     F355 R   |   2 GSTRDE     F359 R   |   2 GSTRHL     F358 R
  2 GTFLNM     F397 R   |   2 GTFNAM     EF34 R   |   2 GTLNLP     E9AB R
  2 GTSIXD     F9EC R   |   2 GTVLUS     EC3F R   |   2 GUART      FD58 R
  2 HALF       FA93 R   |   2 HALFPI     FC4C R   |   2 HDRLP      E914 R
    ID      =  0016     |   2 IDTEST     F17D R   |   2 IF         EB01 R
  2 IFGO       EB0F R   |   2 IFJMP      E81F R   |   2 IGCHR      FD02 R
  2 INCHL      F86B R   |   2 INCLEN     E6BD R   |   2 INDFND     E372 R
  2 INEWLN     E457 R   |   2 INIT       E019 R   |   2 INITAB     E2DF R
  2 INITBE     E33F R   |   2 INITST     FEBD R   |   2 INLINE     FEEA R
  2 INMSG      E346 R   |   2 INP        F443 R   |   2 INPBIN     EC91 R
  2 INPBRK     E879 R   |     INPORT  =  103F     |     INPSUB  =  103E 
  2 INPUT      EBFF R   |   2 INRNG      F9F5 R   |   2 INT        F8E8 R
  2 INTVAR     E4CB R   |   2 INVSGN     F83E R   |   2 ITMSEP     EC82 R
  2 JJUMP      FFFC R   |   2 JJUMP1     FDE0 R   |   2 JPLDSV     FFD8 R
  2 JSTZER     FA7E R   |   2 KILFOR     ED33 R   |   2 KILIN      E5EE R
    LCRFLG  =  10AC     |   2 LDNMI1     E73E R   |   2 LEFT       F3B4 R
  2 LEN        F384 R   |   2 LET        EA89 R   |   2 LETNUM     EADC R
  2 LETSTR     EAA4 R   |     LF      =  000A     |   2 LFRGNM     F439 R
    LINEAT  =  105C     |   2 LINEIN     F9A7 R   |   2 LINES      FDAF R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 92.
Hexadecimal [16-Bits]

Symbol Table

    LINESC  =  1046     |     LINESN  =  1048     |   2 LINFND     E440 R
  2 LINTBF     FF04 R   |   2 LIST       E6DF R   |   2 LISTLP     E6EB R
  2 LOADFP     F864 R   |   2 LOG        F6C9 R   |   2 LOGTAB     F6BC R
  2 LOKFOR     E35C R   |     LOOPST  =  10C7     |     LS      =  001C 
    LSTBIN  =  10CC     |   2 LSTLP2     E70B R   |   2 LSTLP3     E70E R
    LSTRAM  =  10AF     |     LSTRND  =  103A     |   2 LTSTND     EC9C R
    LWIDTH  =  1042     |   2 MAKINT     F489 R   |   2 MAKNUM     FA11 R
  2 MANLP      F930 R   |   2 MATCH      E58B R   |   2 MEMMSG     E103 R
    MFLP    =  0051     |   2 MID        F3EE R   |   2 MID1       F3BA R
  2 MIDNUM     F43E R   |   2 MINCDE     F60F R   |   2 MINUS      EE13 R
  2 MKTMST     F1C1 R   |   2 MLDBLP     F909 R   |   2 MLDEBC     F901 R
  2 MLOOP      E049 R   |   2 MLSP10     F7FE R   |     MO      =  0024 
  2 MONITR     FEA4 R   |   2 MONLD      FE8A R   |   2 MONOUT     FE47 R
    MONSTT  =  0000     |   2 MONTST     FE6F R   |     MONTYP  =  008D 
  2 MONVE      FEAC R   |   2 MORDT      ECA8 R   |   2 MORINP     E612 R
  2 MOVBUF     E476 R   |   2 MOVDIR     E593 R   |   2 MOVLP      E381 R
  2 MOVSTR     E37E R   |   2 MOVUP      E37B R   |   2 MRPRNT     EB21 R
  2 MSIZE      E036 R   |   2 MUL8LP     F735 R   |   2 MULLN2     F701 R
  2 MULT       F708 R   |   2 MULT8      F72C R   |   2 MULTEN     F972 R
    MULVAL  =  10F6     |   2 MVSTPT     EAD3 R   |   2 NASOUT     FCFD R
  2 NEDMOR     EC3B R   |   2 NEGAFT     FAA9 R   |   2 NEW        E4BB R
  2 NEXITM     EBD4 R   |   2 NEXT       ECF8 R   |   2 NEXT1      ECFB R
    NF      =  0000     |   2 NFERR      E3B5 R   |     NMI     =  0C7E 
    NMIFLG  =  104C     |   2 NOCHNG     E583 R   |   2 NOENED     FA81 R
  2 NOLIN      E88F R   |   2 NOMADD     F746 R   |   2 NOMLAD     F917 R
  2 NOPMPT     EC19 R   |   2 NOREMD     FFBC R   |   2 NORES      FF77 R
  2 NORMAL     F63A R   |   2 NOSPC      E57A R   |   2 NOSWAP     F5E9 R
  2 NOTSTR     EF67 R   |   2 NOXOR      F469 R   |   2 NSCFOR     EF77 R
    NULFLG  =  1044     |   2 NULL       E8B3 R   |   2 NULLP      EB8F R
    NULLS   =  1041     |   2 NUMASC     F9BA R   |   2 NXTARY     F02E R
  2 NXTBYT     E569 R   |   2 NXTCHR     E5AA R   |     NXTDAT  =  10DC 
  2 NXTDTA     EA71 R   |   2 NXTITM     EC33 R   |     NXTOPR  =  10D0 
  2 NXTSTL     EA78 R   |   2 NXTSTT     EA7B R   |     OD      =  0006 
  2 OKMSG      E34D R   |     OM      =  000C     |   2 OMERR      E3A4 R
  2 ON         EAE3 R   |   2 ONGO       EAF2 R   |   2 ONGOLP     EAF3 R
  2 ONJMP      E820 R   |   2 OPNPAR     ED58 R   |   2 OPRND      EDD3 R
    OS      =  001A     |   2 OTKLN      E5EB R   |     OTPORT  =  1007 
  2 OUTBAD     F56D R   |   2 OUTC       E69D R   |   2 OUTCHR     FCFF R
  2 OUTEXP     FA72 R   |   2 OUTIT      E67E R   |   2 OUTNBS     E684 R
  2 OUTNCR     FFF6 R   |     OUTSUB  =  1006     |   2 OUTWRD     E727 R
    OV      =  000A     |   2 OVERR      E3BE R   |   2 OVTST1     F7F1 R
  2 OVTST2     F7F6 R   |   2 OVTST3     F7F7 R   |   2 PADD       F996 R
  2 PAND       EE83 R   |   2 PASSA      F103 R   |     PBUFF   =  10E9 
  2 PEEK       F5A5 R   |   2 PEND       E874 R   |   2 PHLTFP     F853 R
  2 PLUCDE     F674 R   |   2 PNORM      F642 R   |     POINT   =  1051 
  2 POINT0     FF93 R   |   2 POINTB     FF7B R   |   2 POINTX     FF89 R
  2 POKE       F5AC R   |   2 POPAF      F247 R   |   2 POPHL      F371 R
  2 POPHRT     F756 R   |   2 POPNOK     E3F9 R   |   2 POR        EE82 R
  2 POR1       EEA5 R   |     PORT0   =  0C00     |   2 POS        F100 R
  2 POSINT     E984 R   |   2 POUT       F44F R   |   2 POWER      FAB7 R
  2 POWER1     FAC7 R   |   2 POWER2     FAE4 R   |   2 POWERS     FA97 R
  2 PRINT      EB25 R   |   2 PRITAB     E2A4 R   |   2 PRNTCR     EB83 R
  2 PRNTHL     F9AF R   |   2 PRNTLP     EB28 R   |   2 PRNTNB     EB6B R
  2 PRNTOK     E3FA R   |   2 PRNTST     EB6F R   |   2 PRNUMS     F211 R
  2 PROCES     E62B R   |     PROGND  =  10D6     |     PROGST  =  10F9 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 93.
Hexadecimal [16-Bits]

Symbol Table

  2 PROMPT     E4FE R   |   2 PRS        F212 R   |   2 PRS1       F215 R
  2 PRSLP      F21C R   |     PSET    =  1054     |   2 PSUB       F5CA R
  2 PTRLP      E483 R   |   2 PUTBIT     FF4D R   |   2 PUTBUF     E66A R
  2 PUTCTL     E66F R   |   2 PUTFID     E7F0 R   |   2 QTSTLP     F1D7 R
  2 QTSTR      F1D1 R   |   2 QUARTR     FC50 R   |   2 READ       EC2E R
    READFG  =  10CD     |   2 REDO       EBDB R   |   2 REM        EA74 R
  2 RESCSA     FF4E R   |   2 RESDIV     F7A3 R   |   2 RESEED     FBEE R
    RESET   =  1057     |   2 RESETB     FF57 R   |   2 RESTNL     E85D R
  2 RESTOR     E848 R   |   2 RESZER     F635 R   |   2 RETADR     EFDE R
  2 RETCTC     FE67 R   |   2 RETINT     F82C R   |   2 RETLIN     EA6C R
  2 RETNAD     E58F R   |   2 RETNUL     EFE1 R   |   2 RETNUM     EE1F R
  2 RETREL     F81E R   |   2 RETURN     EA4D R   |     RG      =  0004 
  2 RIGHT      F3E4 R   |   2 RIGHT1     F3B8 R   |     RINPUT  =  104E 
  2 RLTLP      ED78 R   |   2 RND        FB8D R   |   2 RND1       FBC9 R
  2 RND2       FBE5 R   |   2 RNDTAB     FBF6 R   |   2 RNGTST     FA84 R
  2 RONDB      F656 R   |   2 RONDUP     F655 R   |   2 ROUND      F5BD R
  2 RSCALE     F990 R   |   2 RSLNBK     E772 R   |   2 RSTSTR     F407 R
  2 RUART      F4B6 R   |   2 RUN        EA12 R   |   2 RUNCNT     E7F4 R
  2 RUNFST     E4C7 R   |   2 RUNLIN     EA2E R   |   2 SAVE       FE75 R
  2 SAVEXP     F636 R   |   2 SAVSTP     E7E7 R   |   2 SAVSTR     F1AC R
  2 SBSCPT     EFEC R   |   2 SCALE      F694 R   |   2 SCALLP     F696 R
  2 SCALMI     F95B R   |   2 SCALPL     F971 R   |   2 SCNEND     F2E3 R
  2 SCPTLP     EFF2 R   |   2 SCRADR     FE13 R   |   2 SCREEN     FDE8 R
  2 SEARCH     E557 R   |     SEED    =  1017     |   2 SETB       FF42 R
  2 SETIO      F473 R   |   2 SETLIN     E735 R   |   2 SETLIT     E5A1 R
  2 SETOR      FF52 R   |   2 SETPTR     E47E R   |   2 SETTOP     E06D R
  2 SFTENT     FD72 R   |   2 SFTPRG     E448 R   |   2 SGN        F824 R
  2 SGNEXP     EE72 R   |     SGNRES  =  10E8     |   2 SHFTBT     FFBF R
  2 SHRITE     F6A3 R   |   2 SHRLP      F6A6 R   |   2 SHRT1      F6AA R
  2 SIGNON     E0C5 R   |   2 SIGNS      F87B R   |   2 SIN        FC08 R
  2 SIN1       FC38 R   |   2 SINTAB     FC54 R   |   2 SIXDIG     F9D7 R
  2 SMOTOR     FFD3 R   |   2 SMPVAR     F277 R   |   2 SMSER1     FB6C R
    SN      =  0002     |   2 SNDARY     E91F R   |   2 SNDHDR     E908 R
  2 SNERR      E3AF R   |   2 SPCFST     F9C8 R   |   2 SPCLP      EBCD R
  2 SQR        FAAE R   |   2 SRCHLN     E49B R   |   2 SRCHLP     E49E R
  2 SSTSA      F33F R   |     ST      =  001E     |     STACK   =  1066 
  2 STAKFP     F846 R   |   2 STALL      E868 R   |   2 START      E000 R
  2 STARTB     E003 R   |   2 STKTHS     EDBC R   |     STLOOK  =  115D 
    STMON   =  000D     |   2 STOP       E872 R   |   2 STORED     E9EF R
  2 STPOOL     F2BA R   |   2 STR        F19C R   |   2 STRADD     F2BD R
    STRBOT  =  10C3     |   2 STRENT     EC85 R   |     STRSPC  =  105A 
  2 STTLIN     EB76 R   |   2 SUART      FD6A R   |   2 SUBCDE     F5CC R
  2 SUBPHL     F5C6 R   |   2 SUMLP      FB75 R   |   2 SUMOFF     E939 R
  2 SUMSER     FB5D R   |   2 SUPTLZ     FA56 R   |   2 SVNAM2     EF4B R
  2 SVSTAD     F1CA R   |   2 T0xCINP    FE64 R   |     T2DUMP  =  03D1 
    T4READ  =  070C     |     T4WR    =  0400     |   2 TAN        FC69 R
    TBRK    =  001C     |   2 TBRK2      FD52 R   |     TBS     =  001D 
  2 TCLS       FD98 R   |     TCR     =  001F     |     TCS     =  001E 
    TCUR    =  0C18     |   2 TESTOS     F249 R   |   2 TESTR      F22B R
  2 THSFIL     F54A R   |     TIN     =  0C4D     |   2 TLOAD      FE9B R
    TM      =  0018     |   2 TMERR      E3C1 R   |   2 TMFLP      FE44 R
  2 TMNCUR     FE06 R   |   2 TMNOUT     FE51 R   |     TMPSTR  =  10BF 
    TMSTPL  =  10B3     |     TMSTPT  =  10B1     |   2 TOPOOL     F3B0 R
  2 TOSTRA     F348 R   |     TOUT    =  0C4A     |   2 TRYAGN     FA31 R
  2 TSALP      F349 R   |   2 TSAVE      FE81 R   |   2 TSTBIT     FFEF R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 94.
Hexadecimal [16-Bits]

Symbol Table

  2 TSTBRK     E863 R   |   2 TSTMEM     E05B R   |   2 TSTNUM     ED46 R
  2 TSTOPL     F1F2 R   |   2 TSTRED     EEAA R   |   2 TSTREM     E5A4 R
  2 TSTSGN     F815 R   |   2 TSTSTR     ED47 R   |   2 TTYLIN     E609 R
    TYPE    =  10AD     |     UARTD   =  0001     |   2 UARTOT     FD61 R
    UARTS   =  0002     |     UF      =  0022     |   2 UFERR      E3BB R
    UL      =  000E     |   2 ULERR      EA48 R   |   2 UNITY      F6B8 R
  2 UPDATA     E85E R   |   2 URTOLP     FD63 R   |     USR     =  1003 
  2 VAL        F41E R   |     VAREND  =  10D8     |     VDU     =  0800 
  2 WAIT       F455 R   |   2 WAITLP     F46A R   |   2 WARMST     E0AE R
  2 WIDTH      FDA7 R   |   2 WORDS      E143 R   |   2 WORDTB     E25A R
    WRKSPC  =  1000     |   2 WUART      F4BC R   |   2 WUART2     F4B9 R
  2 XYPOS      FF98 R   |     ZDATA   =  0083     |     ZDIV    =  00AF 
    ZEND    =  0080     |     ZEQUAL  =  00B4     |   2 ZERARY     F08D R
  2 ZERBYT     E34B R   |   2 ZEROLP     EFD0 R   |     ZFN     =  00A7 
    ZFOR    =  0081     |     ZGOSUB  =  008C     |     ZGOTO   =  0088 
    ZGTR    =  00B3     |   2 ZJUMP      FFFF R   |     ZLEFT   =  00CD 
    ZLTH    =  00B5     |     ZMINUS  =  00AD     |     ZNEW    =  00A4 
    ZNOT    =  00AA     |   2 ZONELP     EBA8 R   |     ZOR     =  00B2 
    ZPLUS   =  00AC     |     ZPOINT  =  00C7     |     ZPRINT  =  009E 
    ZREM    =  008E     |     ZSGN    =  00B6     |     ZSPC    =  00A8 
    ZSTEP   =  00AB     |     ZTAB    =  00A5     |     ZTHEN   =  00A9 
    ZTIMES  =  00AE     |     ZTO     =  00A6     |     _BLNK   =  7BDF 
    _INLN   =  63DF     |     _MFLP   =  5FDF     |     _MRET   =  5BDF 
    _READ   =  52DF     |     _RIN    =  62DF     |     _ROUT   =  00F7 
    _VRFY   =  56DF     |     _WRIT   =  57DF 

ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 95.
Hexadecimal [16-Bits]

Area Table

   0 _CODE      size    0   flags    0
   1 CODE       size    0   flags    8
   2 CODE0      size 2002   flags    8

