0000-                  6
0000-                  7           .include ../../include/z180_defs.asm
0000-            I     1       ; ------------------------------------
0000-            I     2       ; Z180 constants
0000-            I     3       ; ------------------------------------
0000-            I     4
0000-            I     5       ; ASCI
0000-            I     6       ; ----------
0000-            I     7
0000-            I     8       ; ASCI Control Register A 0 (CNTLA0: 00H)
0000-            I     9       CNTLA0         .equ $00
0000-            I    10
0080-            I    11       CNTLA0_MPE     .equ $80
0040-            I    12       CNTLA0_RE      .equ $40
0020-            I    13       CNTLA0_TE      .equ $20
0010-            I    14       CNTLA0_RTS0    .equ $10
0008-            I    15       CNTLA0_EFR     .equ $08
0004-            I    16       CNTLA0_MOD2    .equ $04
0002-            I    17       CNTLA0_MOD1    .equ $02
0001-            I    18       CNTLA0_MOD0    .equ $01
0000-            I    19
0000-            I    20       ; ASCI Control Register A 1 (CNTLA1: 01H)
0001-            I    21       CNTLA1         .equ $01
0000-            I    22
0080-            I    23       CNTLA1_MPE     .equ $80
0040-            I    24       CNTLA1_RE      .equ $40
0020-            I    25       CNTLA1_TE      .equ $20
0010-            I    26       CNTLA1_CKA1D   .equ $10
0008-            I    27       CNTLA1_EFR     .equ $08
0004-            I    28       CNTLA1_MOD2    .equ $04
0002-            I    29       CNTLA1_MOD1    .equ $02
0001-            I    30       CNTLA1_MOD0    .equ $01
0000-            I    31
0000-            I    32       ; ASCI Control Register B 0 (CNTLB0: 02H)
0002-            I    33       CNTLB0         .equ $02
0000-            I    34
0080-            I    35       CNTLB0_MPBT    .equ $80
0040-            I    36       CNTLB0_MP      .equ $40
0020-            I    37       CNTLB0_CTS     .equ $20
0010-            I    38       CNTLB0_PEO     .equ $10
0008-            I    39       CNTLB0_DR      .equ $08
0004-            I    40       CNTLB0_SS2     .equ $04
0002-            I    41       CNTLB0_SS1     .equ $02
0001-            I    42       CNTLB0_SS0     .equ $01
0000-            I    43
0000-            I    44       ; ASCI Control Register B 1 (CNTLB1: 03H)
0003-            I    45       CNTLB1         .equ $03
0000-            I    46
0080-            I    47       CNTLB1_MPBT    .equ $80
0040-            I    48       CNTLB1_MP      .equ $40
0020-            I    49       CNTLB1_CTS     .equ $20
0010-            I    50       CNTLB1_PEO     .equ $10
0008-            I    51       CNTLB1_DR      .equ $08
0004-            I    52       CNTLB1_SS2     .equ $04
0002-            I    53       CNTLB1_SS1     .equ $02
0001-            I    54       CNTLB1_SS0     .equ $01
0000-            I    55
0000-            I    56       ; ASCI Status Register 0 (STAT0: 04H)
0004-            I    57       STAT0          .equ $04
0000-            I    58
0080-            I    59       STAT0_RDRF     .equ $80
0040-            I    60       STAT0_OVRN     .equ $40
0020-            I    61       STAT0_PE       .equ $20
0010-            I    62       STAT0_FE       .equ $10
0008-            I    63       STAT0_RIE      .equ $08
0004-            I    64       STAT0_DCD0     .equ $04
0002-            I    65       STAT0_TDRE     .equ $02
0001-            I    66       STAT0_TIE      .equ $01
0000-            I    67
0000-            I    68       ; ASCI Status Register 1 (STAT1: 05H)
0005-            I    69       STAT1          .equ $05
0000-            I    70
0080-            I    71       STAT1_RDRF     .equ $80
0040-            I    72       STAT1_OVRN     .equ $40
0020-            I    73       STAT1_PE       .equ $20
0010-            I    74       STAT1_FE       .equ $10
0008-            I    75       STAT1_RIE      .equ $08
0004-            I    76       STAT1_CTS1E    .equ $04
0002-            I    77       STAT1_TDRE     .equ $02
0001-            I    78       STAT1_TIE      .equ $01
0000-            I    79
0000-            I    80       ; ASCI Transmit Data Register Ch. 0 (TDR0: 06H)
0006-            I    81       TDR0           .equ $06
0000-            I    82
0000-            I    83       ; ASCI Transmit Data Register Ch. 1 (TDR1: 07H)
0007-            I    84       TDR1           .equ $07
0000-            I    85
0000-            I    86       ; ASCI Receive Data Register Ch. 0 (RDR0: 08H)
0008-            I    87       RDR0           .equ $08
0000-            I    88
0000-            I    89       ; ASCI Receive Data Register Ch. 1 (RDR1: 09H)
0009-            I    90       RDR1           .equ $09
0000-            I    91
0000-            I    92       ; ASCI0 Extension Control Register 0 (ASEXT0: 12H)
0012-            I    93       ASEXT0         .equ $12
0000-            I    94
0080-            I    95       ASEXT0_RDRFI   .equ $80
0040-            I    96       ASEXT0_DCD0D   .equ $40
0020-            I    97       ASEXT0_CTS0D   .equ $20
0010-            I    98       ASEXT0_X1      .equ $10
0008-            I    99       ASEXT0_BRG0    .equ $08
0004-            I   100       ASEXT0_BRKE    .equ $04
0002-            I   101       ASEXT0_BRK     .equ $02
0001-            I   102       ASEXT0_SBRK    .equ $01
0000-            I   103
0000-            I   104       ; ASCI1 Extension Control Register 1 (ASEXT1: 13H)
0013-            I   105       ASEXT1         .equ $13
0000-            I   106
0080-            I   107       ASEXT1_RDRFI   .equ $80
0010-            I   108       ASEXT1_X1      .equ $10
0008-            I   109       ASEXT1_BRG1    .equ $08
0004-            I   110       ASEXT1_BRKE    .equ $04
0002-            I   111       ASEXT1_BRK     .equ $02
0001-            I   112       ASEXT1_SBRK    .equ $01
0000-            I   113
0000-            I   114       ; ASCI0 Time Constant Low Register (ASTC0L : 1AH)
001A-            I   115       ASTC0L         .equ $1A
0000-            I   116       ; ASCI0 Time Constant High Register (ASTC0H: 1BH)
001B-            I   117       ASTC0H         .equ $1B
0000-            I   118       ; ASCI1 Time Constant Low Register (ASTC1L : 1AH)
001C-            I   119       ASTC1L         .equ $1C
0000-            I   120       ; ASCI1 Time Constant High Register (ASTC1H: 1BH)
001D-            I   121       ASTC1H         .equ $1D
0000-            I   122
0000-            I   123       ; CSI/0
0000-            I   124       ; ------------------------------------
0000-            I   125
0000-            I   126       ; CSI/O Control Register (CNTR: 0AH)
000A-            I   127       CNTR           .equ $0A
0000-            I   128
0080-            I   129       CNTR_EF        .equ $80
0040-            I   130       CNTR_EIE       .equ $40
0020-            I   131       CNTR_RE        .equ $20
0010-            I   132       CNTR_TE        .equ $10
0004-            I   133       CNTR_SS2       .equ $04
0002-            I   134       CNTR_SS1       .equ $02
0001-            I   135       CNTR_SS0       .equ $01
0000-            I   136
0000-            I   137       ; CSI/O Transmit/Receive Data Register (TRD: 0BH)
000B-            I   138       TRDR           .equ $0B
0000-            I   139
0000-            I   140       ; Timer
0000-            I   141       ; ------------------------------------
0000-            I   142
0000-            I   143       ; Data Register Ch 0 L (TMDR0L: 0CH)
000C-            I   144       TMDR0L         .equ $0C
0000-            I   145       ; Data Register Ch 0 H (TMDR0H: 0DH)
000D-            I   146       TMDR0H         .equ $0D
0000-            I   147       ; Reload Register Ch 0 L (RLDR0L: OEH)
000E-            I   148       RLDR0L         .equ $0E
0000-            I   149       ; Reload Register Ch 0 H (RLDR0H: 0FH)
000F-            I   150       RLDR0H         .equ $0F
0000-            I   151
0000-            I   152       ; Timer Control Register (TCR: 10H)
0010-            I   153       TCR            .equ $10
0000-            I   154
0080-            I   155       TCR_TF1        .equ $80
0040-            I   156       TCR_TF0        .equ $40
0020-            I   157       TCR_TE1        .equ $20
0010-            I   158       TCR_TE0        .equ $10
0008-            I   159       TCR_TOC1       .equ $08
0004-            I   160       TCR_TOC0       .equ $04
0002-            I   161       TCR_TDE1       .equ $02
0001-            I   162       TCR_TDE0       .equ $01
0000-            I   163
0000-            I   164       ; Data Register Ch 1 L (TMDR1L: 14h)
0014-            I   165       TMDR1L         .equ $14
0000-            I   166       ; Data Register Ch 1 H (TMDR1H: 15H)
0015-            I   167       TMDR1H         .equ $15
0000-            I   168       ; Reload Register Ch 1 L (RLDR1L: 16H)
0016-            I   169       RLDR1L         .equ $16
0000-            I   170       ; Reload Register Ch 1 H (RLDR1H: 17H)
0017-            I   171       RLDR1H         .equ $17
0000-            I   172
0000-            I   173       ; Others
0000-            I   174       ; ------------------------------------
0000-            I   175
0000-            I   176       ; Clock Multiplier Register (CMR: 1EH)
001E-            I   177       CMR            .equ $1E
0000-            I   178
0080-            I   179       CMR_X2         .equ $80
0000-            I   180
0000-            I   181       ; Free Running Counter (FRC: 18H)
0018-            I   182       FRC            .equ $18
0000-            I   183
0000-            I   184       ; CPU Control Register (CCR: 1FH)
001F-            I   185       CCR            .equ $1F
0080-            I   186       CCR_CD         .equ $80
0040-            I   187       CCR_SB1        .equ $40
0020-            I   188       CCR_BREXT      .equ $20
0010-            I   189       CCR_LNPHI      .equ $10
0008-            I   190       CCR_SB2        .equ $08
0004-            I   191       CCR_LNIO       .equ $04
0002-            I   192       CCR_LNCPU      .equ $02
0001-            I   193       CCR_LNAD       .equ $01
0000-            I   194
0000-            I   195       ; DMA
0000-            I   196       ; ---------------------------------------------------------------------------
0000-            I   197
0000-            I   198
0000-            I   199       ; DMA/WAIT Control Register (DCNTL: 32H)
0000-            I   200
0000-            I   201       ; INT
0000-            I   202       ; ---------------------------------------------------------------------------
0000-            I   203
0000-            I   204       ; Interrupt Vector Low Register (IL: 33H)
0033-            I   205       IL              .equ $33
0000-            I   206
0000-            I   207       ; INT/TRAP Control Register (ITC: 34H)
0034-            I   208       ITC             .equ $34
0000-            I   209
0080-            I   210       ITC_TRAP        .equ $80
0040-            I   211       ITC_UFO         .equ $40
0004-            I   212       ITC_ITE2        .equ $04
0002-            I   213       ITC_ITE1        .equ $02
0001-            I   214       ITC_ITE0        .equ $01
0000-            I   215
0000-            I   216
0000-            I   217       ; Refresh
0000-            I   218       ; ---------------------------------------------------------------------------
0000-            I   219
0000-            I   220       ; Refresh Control Register (RCR: 36H)
0036-            I   221       RCR            .equ $36
0080-            I   222       RCR_REFE       .equ $80
0040-            I   223       RCR_REFW       .equ $40
0002-            I   224       RCR_CYC1       .equ $02
0001-            I   225       RCR_CYC0       .equ $01
0000-            I   226
0000-            I   227       ; MMU
0000-            I   228       ; ---------------------------------------------------------------------------
0000-            I   229
0000-            I   230       ; MMU Common Base Register (CBR: 38H)
0038-            I   231       CBR            .equ $38
0000-            I   232       ; MMU Bank Base Register (BBR: 39H)
0039-            I   233       BBR            .equ $39
0000-            I   234       ; MMU Common/Bank Register (CBAR: 3AH)
003A-            I   235       CBAR           .equ $3A
0000-            I   236       ; I/O
0000-            I   237       ; ---------------------------------------------------------------------------
0000-            I   238
0000-            I   239       ; Operation Mode Control Register (OMCR: 3EH)
003E-            I   240       OMCR           .equ $3E
0000-            I   241
0080-            I   242       OMCR_M1E       .equ $80
0040-            I   243       OMCR_M1TE      .equ $40
0000-            I   244       ;OMCR_M1E       .equ $20
0000-            I   245
0000-            I   246       ; I/O Control Register (ICR: 3FH)
003F-            I   247       ICR            .equ $3F
0000-            I   248
0080-            I   249       ICR_IOA7       .equ $80
0040-            I   250       ICR_IOA6       .equ $40
0020-            I   251       ICR_IOSTP      .equ $20
0000-                  8
0000-                  9       ; bios entries
E01F-                 10       asci1_putc  .equ $E01F
E019-                 11       asci1_getc  .equ $E019
E01C-                 12       asci1_rx_empty .equ $E01C
E000-                 13       int_noop .equ $E000
E004-                 14       int_asci0 .equ $E004
E016-                 15       int_asci1 .equ $E016
E001-                 16       asci0_init .equ $E001
E013-                 17       asci1_init .equ $E013
0000-                 18
0000-                 19           .org $0000
0000-C3 00 01         20 (  9)     jp  mreset
0003-                 21
0003-                 22       rst08:
0008-                 23           .org $0008
0008-C3 1F E0         24 (  9)     jp asci1_putc
000B-                 25
000B-                 26       rst10:
0010-                 27           .org $0010
0010-C3 19 E0         28 (  9)     jp asci1_getc
0013-                 29
0013-                 30       rst18:
0018-                 31           .org $0018
0018-C3 1C E0         32 (  9)     jp asci1_rx_empty
001B-                 33
0038-                 34           .org $0038
0038-C3 00 E0         35 (  9)     jp int_noop    ; INT0
003B-                 36
0066-                 37           .org $0066
0066-C3 00 E0         38 (  9)     jp int_noop    ; NMI
0069-                 39
0069-                 40       ; interrupt vector table
0080-                 41           .org $0080
0080-00 E0            42           .dw int_noop    ; INT1
0082-00 E0            43           .dw int_noop    ; INT2
0084-00 E0            44           .dw int_noop    ; PRT0
0086-00 E0            45           .dw int_noop    ; PRT1
0088-00 E0            46           .dw int_noop    ; DMA0
008A-00 E0            47           .dw int_noop    ; DMA1
008C-00 E0            48           .dw int_noop    ; CSIO
008E-04 E0            49           .dw int_asci0   ; ASCI0
0090-16 E0            50           .dw int_asci1    ; ASCI1
0092-                 51
0100-                 52           .org $0100
0100-                 53       mreset:
0100-                 54
0100-F3               55 (  3)     di ; disable interrupts
0101-                 56
0101-                 57           ; CMR_X2 : clock * 2 => xtal 16Mhz ---> 32Mhz, phi 8Mhz --> 16Mhz
0101-                 58           ; ld a,CMR_X2
0101-                 59           ; out0 (CMR),a
0101-                 60
0101-                 61           ; CCR_CD : phi = XTAL/1 => phi 16Mhz ---> 32Mhz !!!
0101-                 62           ; ld a,CCR_CD
0101-                 63           ; out0 (CCR),a
0101-                 64
0101-3E 00            65 (  6)     ld  a,0
0103-ED 39 36         66 ( 13)     out0 (RCR),a    ; Refresh disable
0106-                 67
0106-                 68           ; Temporary stack pointer = $DFFF
0106-31 FF DF         69 (  9)     ld sp,$DFFF
0109-                 70
0109-CD 01 E0         71 ( 16)     call asci0_init
010C-CD 13 E0         72 ( 16)     call asci1_init
010F-                 73
010F-                 74           ; setup interupts
010F-ED 56            75 (  6)     im 1    ; interrupt mode 1
0111-3E 00            76 (  6)     ld a,0  ; interrupts high order byte : 00H
0113-ED 47            77 (  6)     ld i,a
0115-3E 80            78 (  6)     ld a,0b10000000 ; interrupts low order byte : 80H
0117-ED 39 33         79 ( 13)     out0 (IL),a
011A-                 80
011A-FB               81 (  3)     ei      ; enable interrupts
011B-                 82
011B-C3 50 01         83 (  9)     jp COLD
011E-                 84
011E-                 85           .include basic.asm
011E-            I     1       ;==================================================================================
011E-            I     2       ; The updates to the original BASIC within this file are copyright Grant Searle
011E-            I     3       ;
011E-            I     4       ; You have permission to use this for NON COMMERCIAL USE ONLY
011E-            I     5       ; If you wish to use it elsewhere, please include an acknowledgement to myself.
011E-            I     6       ;
011E-            I     7       ; http://searle.hostei.com/grant/index.html
011E-            I     8       ;
011E-            I     9       ; eMail: home.micros01@btinternet.com
011E-            I    10       ;
011E-            I    11       ; If the above don't work, please perform an Internet search to see if I have
011E-            I    12       ; updated the web page hosting service.
011E-            I    13       ;
011E-            I    14       ;==================================================================================
011E-            I    15        ;       .CR z180
011E-            I    16        ;       .TF basic.hex,INT,24
011E-            I    17        ;       .LF basic.lst
011E-            I    18       ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
011E-            I    19       ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
011E-            I    20       ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
011E-            I    21       ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
011E-            I    22       ; the original ROM code (checksum A934H). PA
011E-            I    23
011E-            I    24       ; GENERAL EQUATES
011E-            I    25
0003-            I    26       CTRLC   .EQU    03H             ; Control "C"
0007-            I    27       CTRLG   .EQU    07H             ; Control "G"
0008-            I    28       BKSP    .EQU    08H             ; Back space
000A-            I    29       LF      .EQU    0AH             ; Line feed
000C-            I    30       CS      .EQU    0CH             ; Clear screen
000D-            I    31       CR      .EQU    0DH             ; Carriage return
000F-            I    32       CTRLO   .EQU    0FH             ; Control "O"
0011-            I    33       CTRLQ   .EQU    11H                     ; Control "Q"
0012-            I    34       CTRLR   .EQU    12H             ; Control "R"
0013-            I    35       CTRLS   .EQU    13H             ; Control "S"
0015-            I    36       CTRLU   .EQU    15H             ; Control "U"
001B-            I    37       ESC     .EQU    1BH             ; Escape
007F-            I    38       DEL     .EQU    7FH             ; Delete
011E-            I    39
011E-            I    40       ; BASIC WORK SPACE LOCATIONS
011E-            I    41
2245-            I    42       WRKSPC  .EQU    2245H             ; BASIC Work space
2248-            I    43       USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
224B-            I    44       OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
224C-            I    45       OTPORT  .EQU    WRKSPC+7H           ; Port (p)
224E-            I    46       DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
224F-            I    47       DIV1    .EQU    WRKSPC+0AH           ; <- Values
2253-            I    48       DIV2    .EQU    WRKSPC+0EH           ; <-   to
2257-            I    49       DIV3    .EQU    WRKSPC+12H           ; <-   be
225A-            I    50       DIV4    .EQU    WRKSPC+15H           ; <-inserted
225C-            I    51       SEED    .EQU    WRKSPC+17H           ; Random number seed
227F-            I    52       LSTRND  .EQU    WRKSPC+3AH           ; Last random number
2283-            I    53       INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
2284-            I    54       INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
2286-            I    55       NULLS   .EQU    WRKSPC+41H           ; Number of nulls
2287-            I    56       LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
2288-            I    57       COMMAN  .EQU    WRKSPC+43H           ; Width for commas
2289-            I    58       NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
228A-            I    59       CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
228B-            I    60       LINESC  .EQU    WRKSPC+46H           ; Lines counter
228D-            I    61       LINESN  .EQU    WRKSPC+48H           ; Lines number
228F-            I    62       CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
2291-            I    63       NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
2292-            I    64       BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
2293-            I    65       RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
2296-            I    66       POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
2299-            I    67       PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
229C-            I    68       RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
229F-            I    69       STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
22A1-            I    70       LINEAT  .EQU    WRKSPC+5CH           ; Current line number
22A3-            I    71       BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
22A6-            I    72       BUFFER  .EQU    WRKSPC+61H           ; Input buffer
22AB-            I    73       STACK   .EQU    WRKSPC+66H           ; Initial stack
22F0-            I    74       CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
22F1-            I    75       LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
22F2-            I    76       TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
22F3-            I    77       DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
22F4-            I    78       LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
22F6-            I    79       TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
22F8-            I    80       TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
2304-            I    81       TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
2308-            I    82       STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
230A-            I    83       CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
230C-            I    84       LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
230E-            I    85       DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
2310-            I    86       FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
2311-            I    87       LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
2312-            I    88       READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
2313-            I    89       BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
2315-            I    90       NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
2317-            I    91       ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
2319-            I    92       CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
231B-            I    93       PROGND  .EQU    WRKSPC+0D6H          ; End of program
231D-            I    94       VAREND  .EQU    WRKSPC+0D8H          ; End of variables
231F-            I    95       ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
2321-            I    96       NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
2323-            I    97       FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
2325-            I    98       FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
2329-            I    99       FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
232C-            I   100       FPEXP   .EQU    FPREG+3         ; Floating point exponent
232D-            I   101       SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
232E-            I   102       PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
233B-            I   103       MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
233E-            I   104       PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
23A2-            I   105       STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
011E-            I   106
011E-            I   107       ; BASIC ERROR CODE VALUES
011E-            I   108
0000-            I   109       NF      .EQU    00H             ; NEXT without FOR
0002-            I   110       SN      .EQU    02H             ; Syntax error
0004-            I   111       RG      .EQU    04H             ; RETURN without GOSUB
0006-            I   112       OD      .EQU    06H             ; Out of DATA
0008-            I   113       FC      .EQU    08H             ; Function call error
000A-            I   114       OV      .EQU    0AH             ; Overflow
000C-            I   115       OM      .EQU    0CH             ; Out of memory
000E-            I   116       UL      .EQU    0EH             ; Undefined line number
0010-            I   117       BS      .EQU    10H             ; Bad subscript
0012-            I   118       DD      .EQU    12H             ; Re-DIMensioned array
0014-            I   119       DZ      .EQU    14H             ; Division by zero (/0)
0016-            I   120       ID      .EQU    16H             ; Illegal direct
0018-            I   121       TM      .EQU    18H             ; Type miss-match
001A-            I   122       OS      .EQU    1AH             ; Out of string space
001C-            I   123       LS      .EQU    1CH             ; String too long
001E-            I   124       ST      .EQU    1EH             ; String formula too complex
0020-            I   125       CN      .EQU    20H             ; Can't CONTinue
0022-            I   126       UF      .EQU    22H             ; UnDEFined FN function
0024-            I   127       MO      .EQU    24H             ; Missing operand
0026-            I   128       HX      .EQU    26H             ; HEX error
0028-            I   129       BN      .EQU    28H             ; BIN error
011E-            I   130
0150-            I   131               .ORG    00150H
0150-            I   132
0150-C3 56 01    I   133 (  9) COLD:   JP      STARTB          ; Jump for cold start
0153-C3 F4 01    I   134 (  9) WARM:   JP      WARMST          ; Jump for warm start
0156-            I   135       STARTB:
0156-DD 21 00 00 I   136 ( 12)         LD      IX,0            ; Flag cold start
015A-C3 61 01    I   137 (  9)         JP      CSTART          ; Jump to initialise
015D-            I   138
015D-07 0A       I   139               .DW   DEINT           ; Get integer -32768 to 32767
015F-7D 11       I   140               .DW   ABPASS          ; Return integer in AB
0161-            I   141
0161-            I   142
0161-21 45 22    I   143 (  9) CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0164-F9          I   144 (  4)         LD      SP,HL           ; Set up a temporary stack
0165-C3 9C 1D    I   145 (  9)         JP      INITST          ; Go to initialise
0168-            I   146
0168-11 2E 04    I   147 (  9) INIT:   LD      DE,INITAB       ; Initialise workspace
016B-06 63       I   148 (  6)         LD      B,INITBE-INITAB+3 ; Bytes to copy
016D-21 45 22    I   149 (  9)         LD      HL,WRKSPC       ; Into workspace RAM
0170-1A          I   150 (  6) COPY:   LD      A,(DE)          ; Get source
0171-77          I   151 (  7)         LD      (HL),A          ; To destination
0172-23          I   152 (  4)         INC     HL              ; Next destination
0173-13          I   153 (  4)         INC     DE              ; Next source
0174-05          I   154 (  4)         DEC     B               ; Count bytes
0175-C2 70 01    I   155 ( 6+)         JP      NZ,COPY         ; More to move
0178-F9          I   156 (  4)         LD      SP,HL           ; Temporary stack
0179-CD 2F 06    I   157 ( 16)         CALL    CLREG           ; Clear registers and stack
017C-CD FD 0B    I   158 ( 16)         CALL    PRNTCRLF        ; Output CRLF
017F-32 EF 22    I   159 ( 13)         LD      (BUFFER+72+1),A ; Mark end of buffer
0182-32 3E 23    I   160 ( 13)         LD      (PROGST),A      ; Initialise program area
0185-21 43 02    I   161 (  9) MSIZE:  LD      HL,MEMMSG       ; Point to message
0188-CD 9B 12    I   162 ( 16)         CALL    PRS             ; Output "Memory size"
018B-CD 4C 06    I   163 ( 16)         CALL    PROMPT          ; Get input with '?'
018E-CD 55 09    I   164 ( 16)         CALL    GETCHR          ; Get next character
0191-B7          I   165 (  4)         OR      A               ; Set flags
0192-C2 AA 01    I   166 ( 6+)         JP      NZ,TSTMEM       ; If number - Test if RAM there
0195-21 A2 23    I   167 (  9)         LD      HL,STLOOK       ; Point to start of RAM
0198-23          I   168 (  4) MLOOP:  INC     HL              ; Next byte
0199-7C          I   169 (  4)         LD      A,H             ; Above address FFFF ?
019A-B5          I   170 (  4)         OR      L
019B-CA BC 01    I   171 ( 6+)         JP      Z,SETTOP        ; Yes - 64K RAM
019E-7E          I   172 (  6)         LD      A,(HL)          ; Get contents
019F-47          I   173 (  4)         LD      B,A             ; Save it
01A0-2F          I   174 (  3)         CPL                     ; Flip all bits
01A1-77          I   175 (  7)         LD      (HL),A          ; Put it back
01A2-BE          I   176 (  6)         CP      (HL)            ; RAM there if same
01A3-70          I   177 (  7)         LD      (HL),B          ; Restore old contents
01A4-CA 98 01    I   178 ( 6+)         JP      Z,MLOOP         ; If RAM - test next byte
01A7-C3 BC 01    I   179 (  9)         JP      SETTOP          ; Top of RAM found
01AA-            I   180
01AA-CD 21 0A    I   181 ( 16) TSTMEM: CALL    ATOH            ; Get high memory into DE
01AD-B7          I   182 (  4)         OR      A               ; Set flags on last byte
01AE-C2 FD 04    I   183 ( 6+)         JP      NZ,SNERR        ; ?SN Error if bad character
01B1-EB          I   184 (  3)         EX      DE,HL           ; Address into HL
01B2-2B          I   185 (  4)         DEC     HL              ; Back one byte
01B3-3E D9       I   186 (  6)         LD      A,11011001B     ; Test byte
01B5-46          I   187 (  6)         LD      B,(HL)          ; Get old contents
01B6-77          I   188 (  7)         LD      (HL),A          ; Load test byte
01B7-BE          I   189 (  6)         CP      (HL)            ; RAM there if same
01B8-70          I   190 (  7)         LD      (HL),B          ; Restore old contents
01B9-C2 85 01    I   191 ( 6+)         JP      NZ,MSIZE        ; Ask again if no RAM
01BC-            I   192
01BC-2B          I   193 (  4) SETTOP: DEC     HL              ; Back one byte
01BD-11 A1 23    I   194 (  9)         LD      DE,STLOOK-1     ; See if enough RAM
01C0-CD C5 07    I   195 ( 16)         CALL    CPDEHL          ; Compare DE with HL
01C3-DA 85 01    I   196 ( 6+)         JP      C,MSIZE         ; Ask again if not enough RAM
01C6-11 CE FF    I   197 (  9)         LD      DE,0-50         ; 50 Bytes string space
01C9-22 F4 22    I   198 ( 20)         LD      (LSTRAM),HL     ; Save last available RAM
01CC-19          I   199 (  7)         ADD     HL,DE           ; Allocate string space
01CD-22 9F 22    I   200 ( 20)         LD      (STRSPC),HL     ; Save string space
01D0-CD 0A 06    I   201 ( 16)         CALL    CLRPTR          ; Clear program area
01D3-2A 9F 22    I   202 ( 15)         LD      HL,(STRSPC)     ; Get end of memory
01D6-11 EF FF    I   203 (  9)         LD      DE,0-17         ; Offset for free bytes
01D9-19          I   204 (  7)         ADD     HL,DE           ; Adjust HL
01DA-11 3E 23    I   205 (  9)         LD      DE,PROGST       ; Start of program text
01DD-7D          I   206 (  4)         LD      A,L             ; Get LSB
01DE-93          I   207 (  4)         SUB     E               ; Adjust it
01DF-6F          I   208 (  4)         LD      L,A             ; Re-save
01E0-7C          I   209 (  4)         LD      A,H             ; Get MSB
01E1-9A          I   210 (  4)         SBC     A,D             ; Adjust it
01E2-67          I   211 (  4)         LD      H,A             ; Re-save
01E3-E5          I   212 ( 11)         PUSH    HL              ; Save bytes free
01E4-21 0C 02    I   213 (  9)         LD      HL,SIGNON       ; Sign-on message
01E7-CD 9B 12    I   214 ( 16)         CALL    PRS             ; Output string
01EA-E1          I   215 (  9)         POP     HL              ; Get bytes free back
01EB-CD 3E 19    I   216 ( 16)         CALL    PRNTHL          ; Output amount of free memory
01EE-21 FD 01    I   217 (  9)         LD      HL,BFREE        ; " Bytes free" message
01F1-CD 9B 12    I   218 ( 16)         CALL    PRS             ; Output string
01F4-            I   219
01F4-31 AB 22    I   220 (  9) WARMST: LD      SP,STACK        ; Temporary stack
01F7-CD 2F 06    I   221 ( 16) BRKRET: CALL    CLREG           ; Clear registers and stack
01FA-C3 48 05    I   222 (  9)         JP      PRNTOK          ; Go to get command line
01FD-            I   223
01FD-20 42 79 74 
     65 73 20 66 
     72 65 65 0D 
     0A 00 00    I   224       BFREE:  .DB   " Bytes free",CR,LF,0,0
020C-            I   225
020C-5A 38 30 20 
     42 41 53 49 
     43 20 56 65 
     72 20 34 2E 
     37 62 0D 0A I   226       SIGNON: .DB   "Z80 BASIC Ver 4.7b",CR,LF
0220-43 6F 70 79 
     72 69 67 68 
     74 20 28 43 
     29          I   227               .DB   "Copyright ",40,"C",41
022D-20 31 39 37 
     38 20 62 79 
     20 4D 69 63 
     72 6F 73 6F 
     66 74 0D 0A 
     00 00       I   228               .DB   " 1978 by Microsoft",CR,LF,0,0
0243-            I   229
0243-4D 65 6D 6F 
     72 79 20 74 
     6F 70 00    I   230       MEMMSG: .DB   "Memory top",0
024E-            I   231
024E-            I   232       ; FUNCTION ADDRESS TABLE
024E-            I   233
024E-B3 17       I   234       FNCTAB: .DW   SGN
0250-77 18       I   235               .DW   INT
0252-C9 17       I   236               .DW   ABS
0254-48 22       I   237               .DW   USR
0256-5B 11       I   238               .DW   FRE
0258-E0 14       I   239               .DW   INP
025A-89 11       I   240               .DW   POS
025C-3D 1A       I   241               .DW   SQR
025E-1C 1B       I   242               .DW   RND
0260-58 16       I   243               .DW   LOG
0262-8B 1A       I   244               .DW   EXP
0264-91 1B       I   245               .DW   COS
0266-97 1B       I   246               .DW   SIN
0268-F8 1B       I   247               .DW   TAN
026A-0D 1C       I   248               .DW   ATN
026C-34 15       I   249               .DW   PEEK
026E-78 1C       I   250               .DW   DEEK
0270-96 22       I   251               .DW   POINT
0272-0D 14       I   252               .DW   LEN
0274-25 12       I   253               .DW   STR
0276-A7 14       I   254               .DW   VAL
0278-1C 14       I   255               .DW   ASC
027A-2D 14       I   256               .DW   CHR
027C-9A 1C       I   257               .DW   HEX
027E-2D 1D       I   258               .DW   BIN
0280-3D 14       I   259               .DW   LEFT
0282-6D 14       I   260               .DW   RIGHT
0284-77 14       I   261               .DW   MID
0286-            I   262
0286-            I   263       ; RESERVED WORD LIST
0286-            I   264
0286-C5          I   265       WORDS:  .AT   'E'
0287-4E 44       I   266               .DB "ND"
0289-C6          I   267               .AT   'F'
028A-4F 52       I   268               .DB "OR"
028C-CE          I   269               .AT   'N'
028D-45 58 54    I   270               .DB "EXT"
0290-C4          I   271               .AT   'D'
0291-41 54 41    I   272               .DB "ATA"
0294-C9          I   273               .AT   'I'
0295-4E 50 55 54 I   274               .DB "NPUT"
0299-C4          I   275               .AT   'D'
029A-49 4D       I   276               .DB "IM"
029C-D2          I   277               .AT   'R'
029D-45 41 44    I   278               .DB "EAD"
02A0-CC          I   279               .AT   'L'
02A1-45 54       I   280               .DB "ET"
02A3-C7          I   281               .AT   'G'
02A4-4F 54 4F    I   282               .DB "OTO"
02A7-D2          I   283               .AT   'R'
02A8-55 4E       I   284               .DB "UN"
02AA-C9          I   285               .AT   'I'
02AB-46          I   286               .DB "F"
02AC-D2          I   287               .AT   'R'
02AD-45 53 54 4F 
     52 45       I   288               .DB "ESTORE"
02B3-C7          I   289               .AT   'G'
02B4-4F 53 55 42 I   290               .DB "OSUB"
02B8-D2          I   291               .AT   'R'
02B9-45 54 55 52 
     4E          I   292               .DB "ETURN"
02BE-D2          I   293               .AT   'R'
02BF-45 4D       I   294               .DB "EM"
02C1-D3          I   295               .AT   'S'
02C2-54 4F 50    I   296               .DB "TOP"
02C5-CF          I   297               .AT   'O'
02C6-55 54       I   298               .DB "UT"
02C8-CF          I   299               .AT   'O'
02C9-4E          I   300               .DB "N"
02CA-CE          I   301               .AT   'N'
02CB-55 4C 4C    I   302               .DB "ULL"
02CE-D7          I   303               .AT   'W'
02CF-41 49 54    I   304               .DB "AIT"
02D2-C4          I   305               .AT   'D'
02D3-45 46       I   306               .DB "EF"
02D5-D0          I   307               .AT   'P'
02D6-4F 4B 45    I   308               .DB "OKE"
02D9-C4          I   309               .AT   'D'
02DA-4F 4B 45    I   310               .DB "OKE"
02DD-D3          I   311               .AT   'S'
02DE-43 52 45 45 
     4E          I   312               .DB "CREEN"
02E3-CC          I   313               .AT   'L'
02E4-49 4E 45 53 I   314               .DB "INES"
02E8-C3          I   315               .AT   'C'
02E9-4C 53       I   316               .DB "LS"
02EB-D7          I   317               .AT   'W'
02EC-49 44 54 48 I   318               .DB "IDTH"
02F0-CD          I   319               .AT   'M'
02F1-4F 4E 49 54 
     4F 52       I   320               .DB "ONITOR"
02F7-D3          I   321               .AT   'S'
02F8-45 54       I   322               .DB "ET"
02FA-D2          I   323               .AT   'R'
02FB-45 53 45 54 I   324               .DB "ESET"
02FF-D0          I   325               .AT   'P'
0300-52 49 4E 54 I   326               .DB "RINT"
0304-C3          I   327               .AT   'C'
0305-4F 4E 54    I   328               .DB "ONT"
0308-CC          I   329               .AT   'L'
0309-49 53 54    I   330               .DB "IST"
030C-C3          I   331               .AT   'C'
030D-4C 45 41 52 I   332               .DB "LEAR"
0311-C3          I   333               .AT   'C'
0312-4C 4F 41 44 I   334               .DB "LOAD"
0316-C3          I   335               .AT   'C'
0317-53 41 56 45 I   336               .DB "SAVE"
031B-CE          I   337               .AT   'N'
031C-45 57       I   338               .DB "EW"
031E-            I   339
031E-D4          I   340               .AT   'T'
031F-41 42 28    I   341               .DB "AB("
0322-D4          I   342               .AT   'T'
0323-4F          I   343               .DB "O"
0324-C6          I   344               .AT   'F'
0325-4E          I   345               .DB "N"
0326-D3          I   346               .AT   'S'
0327-50 43 28    I   347               .DB "PC("
032A-D4          I   348               .AT   'T'
032B-48 45 4E    I   349               .DB "HEN"
032E-CE          I   350               .AT   'N'
032F-4F 54       I   351               .DB "OT"
0331-D3          I   352               .AT   'S'
0332-54 45 50    I   353               .DB "TEP"
0335-            I   354
0335-AB          I   355               .AT   '+'
0336-AD          I   356               .AT   '-'
0337-AA          I   357               .AT   '*'
0338-AF          I   358               .AT   '/'
0339-DE          I   359               .AT   '^'
033A-C1          I   360               .AT   'A'
033B-4E 44       I   361               .DB "ND"
033D-CF          I   362               .AT   'O'
033E-52          I   363               .DB "R"
033F-BE          I   364               .AT   '>'
0340-BD          I   365               .AT   '='
0341-BC          I   366               .AT   '<'
0342-            I   367
0342-D3          I   368               .AT   'S'
0343-47 4E       I   369               .DB "GN"
0345-C9          I   370               .AT   'I'
0346-4E 54       I   371               .DB "NT"
0348-C1          I   372               .AT   'A'
0349-42 53       I   373               .DB "BS"
034B-D5          I   374               .AT   'U'
034C-53 52       I   375               .DB "SR"
034E-C6          I   376               .AT   'F'
034F-52 45       I   377               .DB "RE"
0351-C9          I   378               .AT   'I'
0352-4E 50       I   379               .DB "NP"
0354-D0          I   380               .AT   'P'
0355-4F 53       I   381               .DB "OS"
0357-D3          I   382               .AT   'S'
0358-51 52       I   383               .DB "QR"
035A-D2          I   384               .AT   'R'
035B-4E 44       I   385               .DB "ND"
035D-CC          I   386               .AT   'L'
035E-4F 47       I   387               .DB "OG"
0360-C5          I   388               .AT   'E'
0361-58 50       I   389               .DB "XP"
0363-C3          I   390               .AT   'C'
0364-4F 53       I   391               .DB "OS"
0366-D3          I   392               .AT   'S'
0367-49 4E       I   393               .DB "IN"
0369-D4          I   394               .AT   'T'
036A-41 4E       I   395               .DB "AN"
036C-C1          I   396               .AT   'A'
036D-54 4E       I   397               .DB "TN"
036F-D0          I   398               .AT   'P'
0370-45 45 4B    I   399               .DB "EEK"
0373-C4          I   400               .AT   'D'
0374-45 45 4B    I   401               .DB "EEK"
0377-D0          I   402               .AT   'P'
0378-4F 49 4E 54 I   403               .DB "OINT"
037C-CC          I   404               .AT   'L'
037D-45 4E       I   405               .DB "EN"
037F-D3          I   406               .AT   'S'
0380-54 52 24    I   407               .DB "TR$"
0383-D6          I   408               .AT   'V'
0384-41 4C       I   409               .DB "AL"
0386-C1          I   410               .AT   'A'
0387-53 43       I   411               .DB "SC"
0389-C3          I   412               .AT   'C'
038A-48 52 24    I   413               .DB "HR$"
038D-C8          I   414               .AT   'H'
038E-45 58 24    I   415               .DB "EX$"
0391-C2          I   416               .AT   'B'
0392-49 4E 24    I   417               .DB "IN$"
0395-CC          I   418               .AT   'L'
0396-45 46 54 24 I   419               .DB "EFT$"
039A-D2          I   420               .AT   'R'
039B-49 47 48 54 
     24          I   421               .DB "IGHT$"
03A0-CD          I   422               .AT   'M'
03A1-49 44 24    I   423               .DB "ID$"
03A4-80          I   424               .DB   80H             ; End of list marker
03A5-            I   425
03A5-            I   426       ; KEYWORD ADDRESS TABLE
03A5-            I   427
03A5-9F 09       I   428       WORDTB: .DW   PEND
03A7-9C 08       I   429               .DW   FOR
03A9-77 0D       I   430               .DW   NEXT
03AB-EC 0A       I   431               .DW   DATA
03AD-7E 0C       I   432               .DW   INPUT
03AF-B3 0F       I   433               .DW   DIM
03B1-AD 0C       I   434               .DW   READ
03B3-03 0B       I   435               .DW   LET
03B5-A9 0A       I   436               .DW   GOTO
03B7-8C 0A       I   437               .DW   RUN
03B9-7B 0B       I   438               .DW   IF
03BB-65 09       I   439               .DW   RESTOR
03BD-98 0A       I   440               .DW   GOSUB
03BF-C7 0A       I   441               .DW   RETURN
03C1-EE 0A       I   442               .DW   REM
03C3-9D 09       I   443               .DW   STOP
03C5-EC 14       I   444               .DW   POUT
03C7-5D 0B       I   445               .DW   ON
03C9-DE 09       I   446               .DW   NULL
03CB-F2 14       I   447               .DW   WAIT
03CD-91 11       I   448               .DW   DEF
03CF-3B 15       I   449               .DW   POKE
03D1-83 1C       I   450               .DW   DOKE
03D3-EE 0A       I   451               .DW   REM
03D5-69 1C       I   452               .DW   LINES
03D7-5C 1C       I   453               .DW   CLS
03D9-61 1C       I   454               .DW   WIDTH
03DB-99 1D       I   455               .DW   MONITR
03DD-99 22       I   456               .DW   PSET
03DF-9C 22       I   457               .DW   RESET
03E1-9F 0B       I   458               .DW   PRINT
03E3-CB 09       I   459               .DW   CONT
03E5-11 08       I   460               .DW   LIST
03E7-46 0A       I   461               .DW   CLEAR
03E9-EE 0A       I   462               .DW   REM
03EB-EE 0A       I   463               .DW   REM
03ED-09 06       I   464               .DW   NEW
03EF-            I   465
03EF-            I   466       ; RESERVED WORD TOKEN VALUES
03EF-            I   467
0080-            I   468       ZEND    .EQU    080H            ; END
0081-            I   469       ZFOR    .EQU    081H            ; FOR
0083-            I   470       ZDATA   .EQU    083H            ; DATA
0088-            I   471       ZGOTO   .EQU    088H            ; GOTO
008C-            I   472       ZGOSUB  .EQU    08CH            ; GOSUB
008E-            I   473       ZREM    .EQU    08EH            ; REM
009E-            I   474       ZPRINT  .EQU    09EH            ; PRINT
00A4-            I   475       ZNEW    .EQU    0A4H            ; NEW
03EF-            I   476
00A5-            I   477       ZTAB    .EQU    0A5H            ; TAB
00A6-            I   478       ZTO     .EQU    0A6H            ; TO
00A7-            I   479       ZFN     .EQU    0A7H            ; FN
00A8-            I   480       ZSPC    .EQU    0A8H            ; SPC
00A9-            I   481       ZTHEN   .EQU    0A9H            ; THEN
00AA-            I   482       ZNOT    .EQU    0AAH            ; NOT
00AB-            I   483       ZSTEP   .EQU    0ABH            ; STEP
03EF-            I   484
00AC-            I   485       ZPLUS   .EQU    0ACH            ; +
00AD-            I   486       ZMINUS  .EQU    0ADH            ; -
00AE-            I   487       ZTIMES  .EQU    0AEH            ; *
00AF-            I   488       ZDIV    .EQU    0AFH            ; /
00B2-            I   489       ZOR     .EQU    0B2H            ; OR
00B3-            I   490       ZGTR    .EQU    0B3H            ; >
00B4-            I   491       ZEQUAL  .EQU    0B4H            ; M
00B5-            I   492       ZLTH    .EQU    0B5H            ; <
00B6-            I   493       ZSGN    .EQU    0B6H            ; SGN
00C7-            I   494       ZPOINT  .EQU    0C7H            ; POINT
00CD-            I   495       ZLEFT   .EQU    0CDH +2         ; LEFT$
03EF-            I   496
03EF-            I   497       ; ARITHMETIC PRECEDENCE TABLE
03EF-            I   498
03EF-79          I   499       PRITAB: .DB   79H             ; Precedence value
03F0-25 19       I   500               .DW   PADD            ; FPREG = <last> + FPREG
03F2-            I   501
03F2-79          I   502               .DB   79H             ; Precedence value
03F3-59 15       I   503               .DW   PSUB            ; FPREG = <last> - FPREG
03F5-            I   504
03F5-7C          I   505               .DB   7CH             ; Precedence value
03F6-97 16       I   506               .DW   MULT            ; PPREG = <last> * FPREG
03F8-            I   507
03F8-7C          I   508               .DB   7CH             ; Precedence value
03F9-F8 16       I   509               .DW   DIV             ; FPREG = <last> / FPREG
03FB-            I   510
03FB-7F          I   511               .DB   7FH             ; Precedence value
03FC-46 1A       I   512               .DW   POWER           ; FPREG = <last> ^ FPREG
03FE-            I   513
03FE-50          I   514               .DB   50H             ; Precedence value
03FF-0C 0F       I   515               .DW   PAND            ; FPREG = <last> AND FPREG
0401-            I   516
0401-46          I   517               .DB   46H             ; Precedence value
0402-0B 0F       I   518               .DW   POR             ; FPREG = <last> OR FPREG
0404-            I   519
0404-            I   520       ; BASIC ERROR CODE LIST
0404-            I   521
0404-4E 46       I   522       ERRORS: .DB   "NF"            ; NEXT without FOR
0406-53 4E       I   523               .DB   "SN"            ; Syntax error
0408-52 47       I   524               .DB   "RG"            ; RETURN without GOSUB
040A-4F 44       I   525               .DB   "OD"            ; Out of DATA
040C-46 43       I   526               .DB   "FC"            ; Illegal function call
040E-4F 56       I   527               .DB   "OV"            ; Overflow error
0410-4F 4D       I   528               .DB   "OM"            ; Out of memory
0412-55 4C       I   529               .DB   "UL"            ; Undefined line
0414-42 53       I   530               .DB   "BS"            ; Bad subscript
0416-44 44       I   531               .DB   "DD"            ; Re-DIMensioned array
0418-2F 30       I   532               .DB   "/0"            ; Division by zero
041A-49 44       I   533               .DB   "ID"            ; Illegal direct
041C-54 4D       I   534               .DB   "TM"            ; Type mis-match
041E-4F 53       I   535               .DB   "OS"            ; Out of string space
0420-4C 53       I   536               .DB   "LS"            ; String too long
0422-53 54       I   537               .DB   "ST"            ; String formula too complex
0424-43 4E       I   538               .DB   "CN"            ; Can't CONTinue
0426-55 46       I   539               .DB   "UF"            ; Undefined FN function
0428-4D 4F       I   540               .DB   "MO"            ; Missing operand
042A-48 58       I   541               .DB   "HX"            ; HEX error
042C-42 4E       I   542               .DB   "BN"            ; BIN error
042E-            I   543
042E-            I   544       ; INITIALISATION TABLE -------------------------------------------------------
042E-            I   545
042E-C3 F4 01    I   546 (  9) INITAB: JP      WARMST          ; Warm start jump
0431-C3 1C 0A    I   547 (  9)         JP      FCERR           ; "USR (X)" jump (Set to Error)
0434-D3 00       I   548 ( 10)         OUT     (0),A           ; "OUT p,n" skeleton
0436-C9          I   549 (  9)         RET
0437-D6 00       I   550 (  6)         SUB     0               ; Division support routine
0439-6F          I   551 (  4)         LD      L,A
043A-7C          I   552 (  4)         LD      A,H
043B-DE 00       I   553 (  6)         SBC     A,0
043D-67          I   554 (  4)         LD      H,A
043E-78          I   555 (  4)         LD      A,B
043F-DE 00       I   556 (  6)         SBC     A,0
0441-47          I   557 (  4)         LD      B,A
0442-3E 00       I   558 (  6)         LD      A,0
0444-C9          I   559 (  9)         RET
0445-00 00 00    I   560               .DB   0,0,0                   ; Random number seed table used by RND
0448-35 4A CA 99 I   561               .DB   035H,04AH,0CAH,099H     ;-2.65145E+07
044C-39 1C 76 98 I   562               .DB   039H,01CH,076H,098H     ; 1.61291E+07
0450-22 95 B3 98 I   563               .DB   022H,095H,0B3H,098H     ;-1.17691E+07
0454-0A DD 47 98 I   564               .DB   00AH,0DDH,047H,098H     ; 1.30983E+07
0458-53 D1 99 99 I   565               .DB   053H,0D1H,099H,099H     ;-2-01612E+07
045C-0A 1A 9F 98 I   566               .DB   00AH,01AH,09FH,098H     ;-1.04269E+07
0460-65 BC CD 98 I   567               .DB   065H,0BCH,0CDH,098H     ;-1.34831E+07
0464-D6 77 3E 98 I   568               .DB   0D6H,077H,03EH,098H     ; 1.24825E+07
0468-52 C7 4F 80 I   569               .DB   052H,0C7H,04FH,080H     ; Last random number
046C-DB 00       I   570 (  9)         IN      A,(0)           ; INP (x) skeleton
046E-C9          I   571 (  9)         RET
046F-01          I   572               .DB   1               ; POS (x) number (1)
0470-FF          I   573               .DB   255             ; Terminal width (255 = no auto CRLF)
0471-1C          I   574               .DB   28              ; Width for commas (3 columns)
0472-00          I   575               .DB   0               ; No nulls after input bytes
0473-00          I   576               .DB   0               ; Output enabled (^O off)
0474-14 00       I   577               .DW   20              ; Initial lines counter
0476-14 00       I   578               .DW   20              ; Initial lines number
0478-00 00       I   579               .DW   0               ; Array load/save check sum
047A-00          I   580               .DB   0               ; Break not by NMI
047B-00          I   581               .DB   0               ; Break flag
047C-C3 42 07    I   582 (  9)         JP      TTYLIN          ; Input reflection (set to TTY)
047F-C3 00 00    I   583 (  9)         JP      $0000           ; POINT reflection unused
0482-C3 00 00    I   584 (  9)         JP      $0000           ; SET reflection
0485-C3 00 00    I   585 (  9)         JP      $0000           ; RESET reflection
0488-A2 23       I   586               .DW   STLOOK          ; Temp string space
048A-FE FF       I   587               .DW   -2              ; Current line number (cold)
048C-3F 23       I   588               .DW   PROGST+1        ; Start of program text
048E-            I   589       INITBE:
048E-            I   590
048E-            I   591       ; END OF INITIALISATION TABLE ---------------------------------------------------
048E-            I   592
048E-20 45 72 72 
     6F 72 00    I   593       ERRMSG: .DB   " Error",0
0495-20 69 6E 20 
     00          I   594       INMSG:  .DB   " in ",0
0499-            I   595       ZERBYT  .EQU    $-1             ; A zero byte
049A-4F 6B 0D 0A 
     00 00       I   596       OKMSG:  .DB   "Ok",CR,LF,0,0
04A0-42 72 65 61 
     6B 00       I   597       BRKMSG: .DB   "Break",0
04A6-            I   598
04A6-21 04 00    I   599 (  9) BAKSTK: LD      HL,4            ; Look for "FOR" block with
04A9-39          I   600 (  7)         ADD     HL,SP           ; same index as specified
04AA-7E          I   601 (  6) LOKFOR: LD      A,(HL)          ; Get block ID
04AB-23          I   602 (  4)         INC     HL              ; Point to index address
04AC-FE 81       I   603 (  6)         CP      ZFOR            ; Is it a "FOR" token
04AE-C0          I   604 ( 5+)         RET     NZ              ; No - exit
04AF-4E          I   605 (  6)         LD      C,(HL)          ; BC = Address of "FOR" index
04B0-23          I   606 (  4)         INC     HL
04B1-46          I   607 (  6)         LD      B,(HL)
04B2-23          I   608 (  4)         INC     HL              ; Point to sign of STEP
04B3-E5          I   609 ( 11)         PUSH    HL              ; Save pointer to sign
04B4-69          I   610 (  4)         LD      L,C             ; HL = address of "FOR" index
04B5-60          I   611 (  4)         LD      H,B
04B6-7A          I   612 (  4)         LD      A,D             ; See if an index was specified
04B7-B3          I   613 (  4)         OR      E               ; DE = 0 if no index specified
04B8-EB          I   614 (  3)         EX      DE,HL           ; Specified index into HL
04B9-CA C0 04    I   615 ( 6+)         JP      Z,INDFND        ; Skip if no index given
04BC-EB          I   616 (  3)         EX      DE,HL           ; Index back into DE
04BD-CD C5 07    I   617 ( 16)         CALL    CPDEHL          ; Compare index with one given
04C0-01 0D 00    I   618 (  9) INDFND: LD      BC,16-3         ; Offset to next block
04C3-E1          I   619 (  9)         POP     HL              ; Restore pointer to sign
04C4-C8          I   620 ( 5+)         RET     Z               ; Return if block found
04C5-09          I   621 (  7)         ADD     HL,BC           ; Point to next block
04C6-C3 AA 04    I   622 (  9)         JP      LOKFOR          ; Keep on looking
04C9-            I   623
04C9-CD E3 04    I   624 ( 16) MOVUP:  CALL    ENFMEM          ; See if enough memory
04CC-C5          I   625 ( 11) MOVSTR: PUSH    BC              ; Save end of source
04CD-E3          I   626 ( 16)         EX      (SP),HL         ; Swap source and dest" end
04CE-C1          I   627 (  9)         POP     BC              ; Get end of destination
04CF-CD C5 07    I   628 ( 16) MOVLP:  CALL    CPDEHL          ; See if list moved
04D2-7E          I   629 (  6)         LD      A,(HL)          ; Get byte
04D3-02          I   630 (  7)         LD      (BC),A          ; Move it
04D4-C8          I   631 ( 5+)         RET     Z               ; Exit if all done
04D5-0B          I   632 (  4)         DEC     BC              ; Next byte to move to
04D6-2B          I   633 (  4)         DEC     HL              ; Next byte to move
04D7-C3 CF 04    I   634 (  9)         JP      MOVLP           ; Loop until all bytes moved
04DA-            I   635
04DA-E5          I   636 ( 11) CHKSTK: PUSH    HL              ; Save code string address
04DB-2A 1F 23    I   637 ( 15)         LD      HL,(ARREND)     ; Lowest free memory
04DE-06 00       I   638 (  6)         LD      B,0             ; BC = Number of levels to test
04E0-09          I   639 (  7)         ADD     HL,BC           ; 2 Bytes for each level
04E1-09          I   640 (  7)         ADD     HL,BC
04E2-3E          I   641               .DB   3EH             ; Skip "PUSH HL"
04E3-E5          I   642 ( 11) ENFMEM: PUSH    HL              ; Save code string address
04E4-3E D0       I   643 (  6)         LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
04E6-95          I   644 (  4)         SUB     L
04E7-6F          I   645 (  4)         LD      L,A
04E8-3E FF       I   646 (  6)         LD      A,0FFH ;HIGH (-48) ; 48 Bytes minimum RAM
04EA-9C          I   647 (  4)         SBC     A,H
04EB-DA F2 04    I   648 ( 6+)         JP      C,OMERR         ; Not enough - ?OM Error
04EE-67          I   649 (  4)         LD      H,A
04EF-39          I   650 (  7)         ADD     HL,SP           ; Test if stack is overflowed
04F0-E1          I   651 (  9)         POP     HL              ; Restore code string address
04F1-D8          I   652 ( 5+)         RET     C               ; Return if enough mmory
04F2-1E 0C       I   653 (  6) OMERR:  LD      E,OM            ; ?OM Error
04F4-C3 11 05    I   654 (  9)         JP      ERROR
04F7-            I   655
04F7-2A 0E 23    I   656 ( 15) DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
04FA-22 A1 22    I   657 ( 20)         LD      (LINEAT),HL     ; Save as current line
04FD-1E 02       I   658 (  6) SNERR:  LD      E,SN            ; ?SN Error
04FF-01          I   659               .DB   01H             ; Skip "LD E,DZ"
0500-1E 14       I   660 (  6) DZERR:  LD      E,DZ            ; ?/0 Error
0502-01          I   661               .DB   01H             ; Skip "LD E,NF"
0503-1E 00       I   662 (  6) NFERR:  LD      E,NF            ; ?NF Error
0505-01          I   663               .DB   01H             ; Skip "LD E,DD"
0506-1E 12       I   664 (  6) DDERR:  LD      E,DD            ; ?DD Error
0508-01          I   665               .DB   01H             ; Skip "LD E,UF"
0509-1E 22       I   666 (  6) UFERR:  LD      E,UF            ; ?UF Error
050B-01          I   667               .DB   01H             ; Skip "LD E,OV
050C-1E 0A       I   668 (  6) OVERR:  LD      E,OV            ; ?OV Error
050E-01          I   669               .DB   01H             ; Skip "LD E,TM"
050F-1E 18       I   670 (  6) TMERR:  LD      E,TM            ; ?TM Error
0511-            I   671
0511-CD 2F 06    I   672 ( 16) ERROR:  CALL    CLREG           ; Clear registers and stack
0514-32 8A 22    I   673 ( 13)         LD      (CTLOFG),A      ; Enable output (A is 0)
0517-CD F0 0B    I   674 ( 16)         CALL    STTLIN          ; Start new line
051A-21 04 04    I   675 (  9)         LD      HL,ERRORS       ; Point to error codes
051D-57          I   676 (  4)         LD      D,A             ; D = 0 (A is 0)
051E-3E 3F       I   677 (  6)         LD      A,'?'
0520-CD D6 07    I   678 ( 16)         CALL    OUTC            ; Output '?'
0523-19          I   679 (  7)         ADD     HL,DE           ; Offset to correct error code
0524-7E          I   680 (  6)         LD      A,(HL)          ; First character
0525-CD D6 07    I   681 ( 16)         CALL    OUTC            ; Output it
0528-CD 55 09    I   682 ( 16)         CALL    GETCHR          ; Get next character
052B-CD D6 07    I   683 ( 16)         CALL    OUTC            ; Output it
052E-21 8E 04    I   684 (  9)         LD      HL,ERRMSG       ; "Error" message
0531-CD 9B 12    I   685 ( 16) ERRIN:  CALL    PRS             ; Output message
0534-2A A1 22    I   686 ( 15)         LD      HL,(LINEAT)     ; Get line of error
0537-11 FE FF    I   687 (  9)         LD      DE,-2           ; Cold start error if -2
053A-CD C5 07    I   688 ( 16)         CALL    CPDEHL          ; See if cold start error
053D-CA 61 01    I   689 ( 6+)         JP      Z,CSTART        ; Cold start error - Restart
0540-7C          I   690 (  4)         LD      A,H             ; Was it a direct error?
0541-A5          I   691 (  4)         AND     L               ; Line = -1 if direct error
0542-3C          I   692 (  4)         INC     A
0543-C4 36 19    I   693 ( 6+)         CALL    NZ,LINEIN       ; No - output line of error
0546-3E          I   694               .DB   3EH             ; Skip "POP BC"
0547-C1          I   695 (  9) POPNOK: POP     BC              ; Drop address in input buffer
0548-            I   696
0548-AF          I   697 (  4) PRNTOK: XOR     A               ; Output "Ok" and get command
0549-32 8A 22    I   698 ( 13)         LD      (CTLOFG),A      ; Enable output
054C-CD F0 0B    I   699 ( 16)         CALL    STTLIN          ; Start new line
054F-21 9A 04    I   700 (  9)         LD      HL,OKMSG        ; "Ok" message
0552-CD 9B 12    I   701 ( 16)         CALL    PRS             ; Output "Ok"
0555-21 FF FF    I   702 (  9) GETCMD: LD      HL,-1           ; Flag direct mode
0558-22 A1 22    I   703 ( 20)         LD      (LINEAT),HL     ; Save as current line
055B-CD 42 07    I   704 ( 16)         CALL    GETLIN          ; Get an input line
055E-DA 55 05    I   705 ( 6+)         JP      C,GETCMD        ; Get line again if break
0561-CD 55 09    I   706 ( 16)         CALL    GETCHR          ; Get first character
0564-3C          I   707 (  4)         INC     A               ; Test if end of line
0565-3D          I   708 (  4)         DEC     A               ; Without affecting Carry
0566-CA 55 05    I   709 ( 6+)         JP      Z,GETCMD        ; Nothing entered - Get another
0569-F5          I   710 ( 11)         PUSH    AF              ; Save Carry status
056A-CD 21 0A    I   711 ( 16)         CALL    ATOH            ; Get line number into DE
056D-D5          I   712 ( 11)         PUSH    DE              ; Save line number
056E-CD 59 06    I   713 ( 16)         CALL    CRUNCH          ; Tokenise rest of line
0571-47          I   714 (  4)         LD      B,A             ; Length of tokenised line
0572-D1          I   715 (  9)         POP     DE              ; Restore line number
0573-F1          I   716 (  9)         POP     AF              ; Restore Carry
0574-D2 35 09    I   717 ( 6+)         JP      NC,EXCUTE       ; No line number - Direct mode
0577-D5          I   718 ( 11)         PUSH    DE              ; Save line number
0578-C5          I   719 ( 11)         PUSH    BC              ; Save length of tokenised line
0579-AF          I   720 (  4)         XOR     A
057A-32 11 23    I   721 ( 13)         LD      (LSTBIN),A      ; Clear last byte input
057D-CD 55 09    I   722 ( 16)         CALL    GETCHR          ; Get next character
0580-B7          I   723 (  4)         OR      A               ; Set flags
0581-F5          I   724 ( 11)         PUSH    AF              ; And save them
0582-CD E9 05    I   725 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0585-DA 8E 05    I   726 ( 6+)         JP      C,LINFND        ; Jump if line found
0588-F1          I   727 (  9)         POP     AF              ; Get status
0589-F5          I   728 ( 11)         PUSH    AF              ; And re-save
058A-CA C2 0A    I   729 ( 6+)         JP      Z,ULERR         ; Nothing after number - Error
058D-B7          I   730 (  4)         OR      A               ; Clear Carry
058E-C5          I   731 ( 11) LINFND: PUSH    BC              ; Save address of line in prog
058F-D2 A5 05    I   732 ( 6+)         JP      NC,INEWLN       ; Line not found - Insert new
0592-EB          I   733 (  3)         EX      DE,HL           ; Next line address in DE
0593-2A 1B 23    I   734 ( 15)         LD      HL,(PROGND)     ; End of program
0596-1A          I   735 (  6) SFTPRG: LD      A,(DE)          ; Shift rest of program down
0597-02          I   736 (  7)         LD      (BC),A
0598-03          I   737 (  4)         INC     BC              ; Next destination
0599-13          I   738 (  4)         INC     DE              ; Next source
059A-CD C5 07    I   739 ( 16)         CALL    CPDEHL          ; All done?
059D-C2 96 05    I   740 ( 6+)         JP      NZ,SFTPRG       ; More to do
05A0-60          I   741 (  4)         LD      H,B             ; HL - New end of program
05A1-69          I   742 (  4)         LD      L,C
05A2-22 1B 23    I   743 ( 20)         LD      (PROGND),HL     ; Update end of program
05A5-            I   744
05A5-D1          I   745 (  9) INEWLN: POP     DE              ; Get address of line,
05A6-F1          I   746 (  9)         POP     AF              ; Get status
05A7-CA CC 05    I   747 ( 6+)         JP      Z,SETPTR        ; No text - Set up pointers
05AA-2A 1B 23    I   748 ( 15)         LD      HL,(PROGND)     ; Get end of program
05AD-E3          I   749 ( 16)         EX      (SP),HL         ; Get length of input line
05AE-C1          I   750 (  9)         POP     BC              ; End of program to BC
05AF-09          I   751 (  7)         ADD     HL,BC           ; Find new end
05B0-E5          I   752 ( 11)         PUSH    HL              ; Save new end
05B1-CD C9 04    I   753 ( 16)         CALL    MOVUP           ; Make space for line
05B4-E1          I   754 (  9)         POP     HL              ; Restore new end
05B5-22 1B 23    I   755 ( 20)         LD      (PROGND),HL     ; Update end of program pointer
05B8-EB          I   756 (  3)         EX      DE,HL           ; Get line to move up in HL
05B9-74          I   757 (  7)         LD      (HL),H          ; Save MSB
05BA-D1          I   758 (  9)         POP     DE              ; Get new line number
05BB-23          I   759 (  4)         INC     HL              ; Skip pointer
05BC-23          I   760 (  4)         INC     HL
05BD-73          I   761 (  7)         LD      (HL),E          ; Save LSB of line number
05BE-23          I   762 (  4)         INC     HL
05BF-72          I   763 (  7)         LD      (HL),D          ; Save MSB of line number
05C0-23          I   764 (  4)         INC     HL              ; To first byte in line
05C1-11 A6 22    I   765 (  9)         LD      DE,BUFFER       ; Copy buffer to program
05C4-1A          I   766 (  6) MOVBUF: LD      A,(DE)          ; Get source
05C5-77          I   767 (  7)         LD      (HL),A          ; Save destinations
05C6-23          I   768 (  4)         INC     HL              ; Next source
05C7-13          I   769 (  4)         INC     DE              ; Next destination
05C8-B7          I   770 (  4)         OR      A               ; Done?
05C9-C2 C4 05    I   771 ( 6+)         JP      NZ,MOVBUF       ; No - Repeat
05CC-CD 15 06    I   772 ( 16) SETPTR: CALL    RUNFST          ; Set line pointers
05CF-23          I   773 (  4)         INC     HL              ; To LSB of pointer
05D0-EB          I   774 (  3)         EX      DE,HL           ; Address to DE
05D1-62          I   775 (  4) PTRLP:  LD      H,D             ; Address to HL
05D2-6B          I   776 (  4)         LD      L,E
05D3-7E          I   777 (  6)         LD      A,(HL)          ; Get LSB of pointer
05D4-23          I   778 (  4)         INC     HL              ; To MSB of pointer
05D5-B6          I   779 (  6)         OR      (HL)            ; Compare with MSB pointer
05D6-CA 55 05    I   780 ( 6+)         JP      Z,GETCMD        ; Get command line if end
05D9-23          I   781 (  4)         INC     HL              ; To LSB of line number
05DA-23          I   782 (  4)         INC     HL              ; Skip line number
05DB-23          I   783 (  4)         INC     HL              ; Point to first byte in line
05DC-AF          I   784 (  4)         XOR     A               ; Looking for 00 byte
05DD-BE          I   785 (  6) FNDEND: CP      (HL)            ; Found end of line?
05DE-23          I   786 (  4)         INC     HL              ; Move to next byte
05DF-C2 DD 05    I   787 ( 6+)         JP      NZ,FNDEND       ; No - Keep looking
05E2-EB          I   788 (  3)         EX      DE,HL           ; Next line address to HL
05E3-73          I   789 (  7)         LD      (HL),E          ; Save LSB of pointer
05E4-23          I   790 (  4)         INC     HL
05E5-72          I   791 (  7)         LD      (HL),D          ; Save MSB of pointer
05E6-C3 D1 05    I   792 (  9)         JP      PTRLP           ; Do next line
05E9-            I   793
05E9-2A A3 22    I   794 ( 15) SRCHLN: LD      HL,(BASTXT)     ; Start of program text
05EC-44          I   795 (  4) SRCHLP: LD      B,H             ; BC = Address to look at
05ED-4D          I   796 (  4)         LD      C,L
05EE-7E          I   797 (  6)         LD      A,(HL)          ; Get address of next line
05EF-23          I   798 (  4)         INC     HL
05F0-B6          I   799 (  6)         OR      (HL)            ; End of program found?
05F1-2B          I   800 (  4)         DEC     HL
05F2-C8          I   801 ( 5+)         RET     Z               ; Yes - Line not found
05F3-23          I   802 (  4)         INC     HL
05F4-23          I   803 (  4)         INC     HL
05F5-7E          I   804 (  6)         LD      A,(HL)          ; Get LSB of line number
05F6-23          I   805 (  4)         INC     HL
05F7-66          I   806 (  6)         LD      H,(HL)          ; Get MSB of line number
05F8-6F          I   807 (  4)         LD      L,A
05F9-CD C5 07    I   808 ( 16)         CALL    CPDEHL          ; Compare with line in DE
05FC-60          I   809 (  4)         LD      H,B             ; HL = Start of this line
05FD-69          I   810 (  4)         LD      L,C
05FE-7E          I   811 (  6)         LD      A,(HL)          ; Get LSB of next line address
05FF-23          I   812 (  4)         INC     HL
0600-66          I   813 (  6)         LD      H,(HL)          ; Get MSB of next line address
0601-6F          I   814 (  4)         LD      L,A             ; Next line to HL
0602-3F          I   815 (  3)         CCF
0603-C8          I   816 ( 5+)         RET     Z               ; Lines found - Exit
0604-3F          I   817 (  3)         CCF
0605-D0          I   818 ( 5+)         RET     NC              ; Line not found,at line after
0606-C3 EC 05    I   819 (  9)         JP      SRCHLP          ; Keep looking
0609-            I   820
0609-C0          I   821 ( 5+) NEW:    RET     NZ              ; Return if any more on line
060A-2A A3 22    I   822 ( 15) CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
060D-AF          I   823 (  4)         XOR     A               ; Set program area to empty
060E-77          I   824 (  7)         LD      (HL),A          ; Save LSB = 00
060F-23          I   825 (  4)         INC     HL
0610-77          I   826 (  7)         LD      (HL),A          ; Save MSB = 00
0611-23          I   827 (  4)         INC     HL
0612-22 1B 23    I   828 ( 20)         LD      (PROGND),HL     ; Set program end
0615-            I   829
0615-2A A3 22    I   830 ( 15) RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0618-2B          I   831 (  4)         DEC     HL
0619-            I   832
0619-22 13 23    I   833 ( 20) INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
061C-2A F4 22    I   834 ( 15)         LD      HL,(LSTRAM)     ; Get end of RAM
061F-22 08 23    I   835 ( 20)         LD      (STRBOT),HL     ; Clear string space
0622-AF          I   836 (  4)         XOR     A
0623-CD 65 09    I   837 ( 16)         CALL    RESTOR          ; Reset DATA pointers
0626-2A 1B 23    I   838 ( 15)         LD      HL,(PROGND)     ; Get end of program
0629-22 1D 23    I   839 ( 20)         LD      (VAREND),HL     ; Clear variables
062C-22 1F 23    I   840 ( 20)         LD      (ARREND),HL     ; Clear arrays
062F-            I   841
062F-C1          I   842 (  9) CLREG:  POP     BC              ; Save return address
0630-2A 9F 22    I   843 ( 15)         LD      HL,(STRSPC)     ; Get end of working RAN
0633-F9          I   844 (  4)         LD      SP,HL           ; Set stack
0634-21 F8 22    I   845 (  9)         LD      HL,TMSTPL       ; Temporary string pool
0637-22 F6 22    I   846 ( 20)         LD      (TMSTPT),HL     ; Reset temporary string ptr
063A-AF          I   847 (  4)         XOR     A               ; A = 00
063B-6F          I   848 (  4)         LD      L,A             ; HL = 0000
063C-67          I   849 (  4)         LD      H,A
063D-22 19 23    I   850 ( 20)         LD      (CONTAD),HL     ; No CONTinue
0640-32 10 23    I   851 ( 13)         LD      (FORFLG),A      ; Clear FOR flag
0643-22 23 23    I   852 ( 20)         LD      (FNRGNM),HL     ; Clear FN argument
0646-E5          I   853 ( 11)         PUSH    HL              ; HL = 0000
0647-C5          I   854 ( 11)         PUSH    BC              ; Put back return
0648-2A 13 23    I   855 ( 15) DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
064B-C9          I   856 (  9)         RET                     ; Return to execution driver
064C-            I   857
064C-3E 3F       I   858 (  6) PROMPT: LD      A,'?'           ; '?'
064E-CD D6 07    I   859 ( 16)         CALL    OUTC            ; Output character
0651-3E 20       I   860 (  6)         LD      A,' '           ; Space
0653-CD D6 07    I   861 ( 16)         CALL    OUTC            ; Output character
0656-C3 93 22    I   862 (  9)         JP      RINPUT          ; Get input line
0659-            I   863
0659-AF          I   864 (  4) CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
065A-32 F3 22    I   865 ( 13)         LD      (DATFLG),A      ; Reset literal flag
065D-0E 05       I   866 (  6)         LD      C,2+3           ; 2 byte number and 3 nulls
065F-11 A6 22    I   867 (  9)         LD      DE,BUFFER       ; Start of input buffer
0662-7E          I   868 (  6) CRNCLP: LD      A,(HL)          ; Get byte
0663-FE 20       I   869 (  6)         CP      ' '             ; Is it a space?
0665-CA E1 06    I   870 ( 6+)         JP      Z,MOVDIR        ; Yes - Copy direct
0668-47          I   871 (  4)         LD      B,A             ; Save character
0669-FE 22       I   872 (  6)         CP      '"'             ; Is it a quote?
066B-CA 01 07    I   873 ( 6+)         JP      Z,CPYLIT        ; Yes - Copy literal string
066E-B7          I   874 (  4)         OR      A               ; Is it end of buffer?
066F-CA 08 07    I   875 ( 6+)         JP      Z,ENDBUF        ; Yes - End buffer
0672-3A F3 22    I   876 ( 12)         LD      A,(DATFLG)      ; Get data type
0675-B7          I   877 (  4)         OR      A               ; Literal?
0676-7E          I   878 (  6)         LD      A,(HL)          ; Get byte to copy
0677-C2 E1 06    I   879 ( 6+)         JP      NZ,MOVDIR       ; Literal - Copy direct
067A-FE 3F       I   880 (  6)         CP      '?'             ; Is it '?' short for PRINT
067C-3E 9E       I   881 (  6)         LD      A,ZPRINT        ; "PRINT" token
067E-CA E1 06    I   882 ( 6+)         JP      Z,MOVDIR        ; Yes - replace it
0681-7E          I   883 (  6)         LD      A,(HL)          ; Get byte again
0682-FE 30       I   884 (  6)         CP      '0'             ; Is it less than '0'
0684-DA 8C 06    I   885 ( 6+)         JP      C,FNDWRD        ; Yes - Look for reserved words
0687-FE 3C       I   886 (  6)         CP      60 ; ";"+1           ; Is it "0123456789:;" ?
0689-DA E1 06    I   887 ( 6+)         JP      C,MOVDIR        ; Yes - copy it direct
068C-D5          I   888 ( 11) FNDWRD: PUSH    DE              ; Look for reserved words
068D-11 85 02    I   889 (  9)         LD      DE,WORDS-1      ; Point to table
0690-C5          I   890 ( 11)         PUSH    BC              ; Save count
0691-01 DD 06    I   891 (  9)         LD      BC,RETNAD       ; Where to return to
0694-C5          I   892 ( 11)         PUSH    BC              ; Save return address
0695-06 7F       I   893 (  6)         LD      B,ZEND-1        ; First token value -1
0697-7E          I   894 (  6)         LD      A,(HL)          ; Get byte
0698-FE 61       I   895 (  6)         CP      'a'             ; Less than 'a' ?
069A-DA A5 06    I   896 ( 6+)         JP      C,SEARCH        ; Yes - search for words
069D-FE 7B       I   897 (  6)         CP      'z'+1           ; Greater than 'z' ?
069F-D2 A5 06    I   898 ( 6+)         JP      NC,SEARCH       ; Yes - search for words
06A2-E6 5F       I   899 (  6)         AND     01011111B       ; Force upper case
06A4-77          I   900 (  7)         LD      (HL),A          ; Replace byte
06A5-4E          I   901 (  6) SEARCH: LD      C,(HL)          ; Search for a word
06A6-EB          I   902 (  3)         EX      DE,HL
06A7-23          I   903 (  4) GETNXT: INC     HL              ; Get next reserved word
06A8-B6          I   904 (  6)         OR      (HL)            ; Start of word?
06A9-F2 A7 06    I   905 ( 6+)         JP      P,GETNXT        ; No - move on
06AC-04          I   906 (  4)         INC     B               ; Increment token value
06AD-7E          I   907 (  6)         LD      A, (HL)         ; Get byte from table
06AE-E6 7F       I   908 (  6)         AND     01111111B       ; Strip bit 7
06B0-C8          I   909 ( 5+)         RET     Z               ; Return if end of list
06B1-B9          I   910 (  4)         CP      C               ; Same character as in buffer?
06B2-C2 A7 06    I   911 ( 6+)         JP      NZ,GETNXT       ; No - get next word
06B5-EB          I   912 (  3)         EX      DE,HL
06B6-E5          I   913 ( 11)         PUSH    HL              ; Save start of word
06B7-            I   914
06B7-13          I   915 (  4) NXTBYT: INC     DE              ; Look through rest of word
06B8-1A          I   916 (  6)         LD      A,(DE)          ; Get byte from table
06B9-B7          I   917 (  4)         OR      A               ; End of word ?
06BA-FA D9 06    I   918 ( 6+)         JP      M,MATCH         ; Yes - Match found
06BD-4F          I   919 (  4)         LD      C,A             ; Save it
06BE-78          I   920 (  4)         LD      A,B             ; Get token value
06BF-FE 88       I   921 (  6)         CP      ZGOTO           ; Is it "GOTO" token ?
06C1-C2 C8 06    I   922 ( 6+)         JP      NZ,NOSPC        ; No - Don't allow spaces
06C4-CD 55 09    I   923 ( 16)         CALL    GETCHR          ; Get next character
06C7-2B          I   924 (  4)         DEC     HL              ; Cancel increment from GETCHR
06C8-23          I   925 (  4) NOSPC:  INC     HL              ; Next byte
06C9-7E          I   926 (  6)         LD      A,(HL)          ; Get byte
06CA-FE 61       I   927 (  6)         CP      'a'             ; Less than 'a' ?
06CC-DA D1 06    I   928 ( 6+)         JP      C,NOCHNG        ; Yes - don't change
06CF-E6 5F       I   929 (  6)         AND     01011111B       ; Make upper case
06D1-B9          I   930 (  4) NOCHNG: CP      C               ; Same as in buffer ?
06D2-CA B7 06    I   931 ( 6+)         JP      Z,NXTBYT        ; Yes - keep testing
06D5-E1          I   932 (  9)         POP     HL              ; Get back start of word
06D6-C3 A5 06    I   933 (  9)         JP      SEARCH          ; Look at next word
06D9-            I   934
06D9-48          I   935 (  4) MATCH:  LD      C,B             ; Word found - Save token value
06DA-F1          I   936 (  9)         POP     AF              ; Throw away return
06DB-EB          I   937 (  3)         EX      DE,HL
06DC-C9          I   938 (  9)         RET                     ; Return to "RETNAD"
06DD-EB          I   939 (  3) RETNAD: EX      DE,HL           ; Get address in string
06DE-79          I   940 (  4)         LD      A,C             ; Get token value
06DF-C1          I   941 (  9)         POP     BC              ; Restore buffer length
06E0-D1          I   942 (  9)         POP     DE              ; Get destination address
06E1-23          I   943 (  4) MOVDIR: INC     HL              ; Next source in buffer
06E2-12          I   944 (  7)         LD      (DE),A          ; Put byte in buffer
06E3-13          I   945 (  4)         INC     DE              ; Move up buffer
06E4-0C          I   946 (  4)         INC     C               ; Increment length of buffer
06E5-D6 3A       I   947 (  6)         SUB     ':'             ; End of statement?
06E7-CA EF 06    I   948 ( 6+)         JP      Z,SETLIT        ; Jump if multi-statement line
06EA-FE 49       I   949 (  6)         CP      ZDATA-3AH       ; Is it DATA statement ?
06EC-C2 F2 06    I   950 ( 6+)         JP      NZ,TSTREM       ; No - see if REM
06EF-32 F3 22    I   951 ( 13) SETLIT: LD      (DATFLG),A      ; Set literal flag
06F2-D6 54       I   952 (  6) TSTREM: SUB     ZREM-3AH        ; Is it REM?
06F4-C2 62 06    I   953 ( 6+)         JP      NZ,CRNCLP       ; No - Leave flag
06F7-47          I   954 (  4)         LD      B,A             ; Copy rest of buffer
06F8-7E          I   955 (  6) NXTCHR: LD      A,(HL)          ; Get byte
06F9-B7          I   956 (  4)         OR      A               ; End of line ?
06FA-CA 08 07    I   957 ( 6+)         JP      Z,ENDBUF        ; Yes - Terminate buffer
06FD-B8          I   958 (  4)         CP      B               ; End of statement ?
06FE-CA E1 06    I   959 ( 6+)         JP      Z,MOVDIR        ; Yes - Get next one
0701-23          I   960 (  4) CPYLIT: INC     HL              ; Move up source string
0702-12          I   961 (  7)         LD      (DE),A          ; Save in destination
0703-0C          I   962 (  4)         INC     C               ; Increment length
0704-13          I   963 (  4)         INC     DE              ; Move up destination
0705-C3 F8 06    I   964 (  9)         JP      NXTCHR          ; Repeat
0708-            I   965
0708-21 A5 22    I   966 (  9) ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
070B-12          I   967 (  7)         LD      (DE),A          ; Mark end of buffer (A = 00)
070C-13          I   968 (  4)         INC     DE
070D-12          I   969 (  7)         LD      (DE),A          ; A = 00
070E-13          I   970 (  4)         INC     DE
070F-12          I   971 (  7)         LD      (DE),A          ; A = 00
0710-C9          I   972 (  9)         RET
0711-            I   973
0711-3A 89 22    I   974 ( 12) DODEL:  LD      A,(NULFLG)      ; Get null flag status
0714-B7          I   975 (  4)         OR      A               ; Is it zero?
0715-3E 00       I   976 (  6)         LD      A,0             ; Zero A - Leave flags
0717-32 89 22    I   977 ( 13)         LD      (NULFLG),A      ; Zero null flag
071A-C2 25 07    I   978 ( 6+)         JP      NZ,ECHDEL       ; Set - Echo it
071D-05          I   979 (  4)         DEC     B               ; Decrement length
071E-CA 42 07    I   980 ( 6+)         JP      Z,GETLIN        ; Get line again if empty
0721-CD D6 07    I   981 ( 16)         CALL    OUTC            ; Output null character
0724-3E          I   982               .DB   3EH             ; Skip "DEC B"
0725-05          I   983 (  4) ECHDEL: DEC     B               ; Count bytes in buffer
0726-2B          I   984 (  4)         DEC     HL              ; Back space buffer
0727-CA 39 07    I   985 ( 6+)         JP      Z,OTKLN         ; No buffer - Try again
072A-7E          I   986 (  6)         LD      A,(HL)          ; Get deleted byte
072B-CD D6 07    I   987 ( 16)         CALL    OUTC            ; Echo it
072E-C3 4B 07    I   988 (  9)         JP      MORINP          ; Get more input
0731-            I   989
0731-05          I   990 (  4) DELCHR: DEC     B               ; Count bytes in buffer
0732-2B          I   991 (  4)         DEC     HL              ; Back space buffer
0733-CD D6 07    I   992 ( 16)         CALL    OUTC            ; Output character in A
0736-C2 4B 07    I   993 ( 6+)         JP      NZ,MORINP       ; Not end - Get more
0739-CD D6 07    I   994 ( 16) OTKLN:  CALL    OUTC            ; Output character in A
073C-CD FD 0B    I   995 ( 16) KILIN:  CALL    PRNTCRLF        ; Output CRLF
073F-C3 42 07    I   996 (  9)         JP      TTYLIN          ; Get line again
0742-            I   997
0742-            I   998       GETLIN:
0742-21 A6 22    I   999 (  9) TTYLIN: LD      HL,BUFFER       ; Get a line by character
0745-06 01       I  1000 (  6)         LD      B,1             ; Set buffer as empty
0747-AF          I  1001 (  4)         XOR     A
0748-32 89 22    I  1002 ( 13)         LD      (NULFLG),A      ; Clear null flag
074B-CD 00 08    I  1003 ( 16) MORINP: CALL    CLOTST          ; Get character and test ^O
074E-4F          I  1004 (  4)         LD      C,A             ; Save character in C
074F-FE 7F       I  1005 (  6)         CP      DEL             ; Delete character?
0751-CA 11 07    I  1006 ( 6+)         JP      Z,DODEL         ; Yes - Process it
0754-3A 89 22    I  1007 ( 12)         LD      A,(NULFLG)      ; Get null flag
0757-B7          I  1008 (  4)         OR      A               ; Test null flag status
0758-CA 64 07    I  1009 ( 6+)         JP      Z,PROCES        ; Reset - Process character
075B-3E 00       I  1010 (  6)         LD      A,0             ; Set a null
075D-CD D6 07    I  1011 ( 16)         CALL    OUTC            ; Output null
0760-AF          I  1012 (  4)         XOR     A               ; Clear A
0761-32 89 22    I  1013 ( 13)         LD      (NULFLG),A      ; Reset null flag
0764-79          I  1014 (  4) PROCES: LD      A,C             ; Get character
0765-FE 07       I  1015 (  6)         CP      CTRLG           ; Bell?
0767-CA A8 07    I  1016 ( 6+)         JP      Z,PUTCTL        ; Yes - Save it
076A-FE 03       I  1017 (  6)         CP      CTRLC           ; Is it control "C"?
076C-CC FD 0B    I  1018 ( 6+)         CALL    Z,PRNTCRLF      ; Yes - Output CRLF
076F-37          I  1019 (  3)         SCF                     ; Flag break
0770-C8          I  1020 ( 5+)         RET     Z               ; Return if control "C"
0771-FE 0D       I  1021 (  6)         CP      CR              ; Is it enter?
0773-CA F8 0B    I  1022 ( 6+)         JP      Z,ENDINP        ; Yes - Terminate input
0776-FE 15       I  1023 (  6)         CP      CTRLU           ; Is it control "U"?
0778-CA 3C 07    I  1024 ( 6+)         JP      Z,KILIN         ; Yes - Get another line
077B-FE 40       I  1025 (  6)         CP      '@'             ; Is it "kill line"?
077D-CA 39 07    I  1026 ( 6+)         JP      Z,OTKLN         ; Yes - Kill line
0780-FE 5F       I  1027 (  6)         CP      '_'             ; Is it delete?
0782-CA 31 07    I  1028 ( 6+)         JP      Z,DELCHR        ; Yes - Delete character
0785-FE 08       I  1029 (  6)         CP      BKSP            ; Is it backspace?
0787-CA 31 07    I  1030 ( 6+)         JP      Z,DELCHR        ; Yes - Delete character
078A-FE 12       I  1031 (  6)         CP      CTRLR           ; Is it control "R"?
078C-C2 A3 07    I  1032 ( 6+)         JP      NZ,PUTBUF       ; No - Put in buffer
078F-C5          I  1033 ( 11)         PUSH    BC              ; Save buffer length
0790-D5          I  1034 ( 11)         PUSH    DE              ; Save DE
0791-E5          I  1035 ( 11)         PUSH    HL              ; Save buffer address
0792-36 00       I  1036 (  9)         LD      (HL),0          ; Mark end of buffer
0794-CD AD 1D    I  1037 ( 16)         CALL    OUTNCR          ; Output and do CRLF
0797-21 A6 22    I  1038 (  9)         LD      HL,BUFFER       ; Point to buffer start
079A-CD 9B 12    I  1039 ( 16)         CALL    PRS             ; Output buffer
079D-E1          I  1040 (  9)         POP     HL              ; Restore buffer address
079E-D1          I  1041 (  9)         POP     DE              ; Restore DE
079F-C1          I  1042 (  9)         POP     BC              ; Restore buffer length
07A0-C3 4B 07    I  1043 (  9)         JP      MORINP          ; Get another character
07A3-            I  1044
07A3-FE 20       I  1045 (  6) PUTBUF: CP      ' '             ; Is it a control code?
07A5-DA 4B 07    I  1046 ( 6+)         JP      C,MORINP        ; Yes - Ignore
07A8-78          I  1047 (  4) PUTCTL: LD      A,B             ; Get number of bytes in buffer
07A9-FE 49       I  1048 (  6)         CP      72+1            ; Test for line overflow
07AB-3E 07       I  1049 (  6)         LD      A,CTRLG         ; Set a bell
07AD-D2 BD 07    I  1050 ( 6+)         JP      NC,OUTNBS       ; Ring bell if buffer full
07B0-79          I  1051 (  4)         LD      A,C             ; Get character
07B1-71          I  1052 (  7)         LD      (HL),C          ; Save in buffer
07B2-32 11 23    I  1053 ( 13)         LD      (LSTBIN),A      ; Save last input byte
07B5-23          I  1054 (  4)         INC     HL              ; Move up buffer
07B6-04          I  1055 (  4)         INC     B               ; Increment length
07B7-CD D6 07    I  1056 ( 16) OUTIT:  CALL    OUTC            ; Output the character entered
07BA-C3 4B 07    I  1057 (  9)         JP      MORINP          ; Get another character
07BD-            I  1058
07BD-CD D6 07    I  1059 ( 16) OUTNBS: CALL    OUTC            ; Output bell and back over it
07C0-3E 08       I  1060 (  6)         LD      A,BKSP          ; Set back space
07C2-C3 B7 07    I  1061 (  9)         JP      OUTIT           ; Output it and get more
07C5-            I  1062
07C5-7C          I  1063 (  4) CPDEHL: LD      A,H             ; Get H
07C6-92          I  1064 (  4)         SUB     D               ; Compare with D
07C7-C0          I  1065 ( 5+)         RET     NZ              ; Different - Exit
07C8-7D          I  1066 (  4)         LD      A,L             ; Get L
07C9-93          I  1067 (  4)         SUB     E               ; Compare with E
07CA-C9          I  1068 (  9)         RET                     ; Return status
07CB-            I  1069
07CB-7E          I  1070 (  6) CHKSYN: LD      A,(HL)          ; Check syntax of character
07CC-E3          I  1071 ( 16)         EX      (SP),HL         ; Address of test byte
07CD-BE          I  1072 (  6)         CP      (HL)            ; Same as in code string?
07CE-23          I  1073 (  4)         INC     HL              ; Return address
07CF-E3          I  1074 ( 16)         EX      (SP),HL         ; Put it back
07D0-CA 55 09    I  1075 ( 6+)         JP      Z,GETCHR        ; Yes - Get next character
07D3-C3 FD 04    I  1076 (  9)         JP      SNERR           ; Different - ?SN Error
07D6-            I  1077
07D6-F5          I  1078 ( 11) OUTC:   PUSH    AF              ; Save character
07D7-3A 8A 22    I  1079 ( 12)         LD      A,(CTLOFG)      ; Get control "O" flag
07DA-B7          I  1080 (  4)         OR      A               ; Is it set?
07DB-C2 D0 12    I  1081 ( 6+)         JP      NZ,POPAF        ; Yes - don't output
07DE-F1          I  1082 (  9)         POP     AF              ; Restore character
07DF-C5          I  1083 ( 11)         PUSH    BC              ; Save buffer length
07E0-F5          I  1084 ( 11)         PUSH    AF              ; Save character
07E1-FE 20       I  1085 (  6)         CP      ' '             ; Is it a control code?
07E3-DA FA 07    I  1086 ( 6+)         JP      C,DINPOS        ; Yes - Don't INC POS(X)
07E6-3A 87 22    I  1087 ( 12)         LD      A,(LWIDTH)      ; Get line width
07E9-47          I  1088 (  4)         LD      B,A             ; To B
07EA-3A F0 22    I  1089 ( 12)         LD      A,(CURPOS)      ; Get cursor position
07ED-04          I  1090 (  4)         INC     B               ; Width 255?
07EE-CA F6 07    I  1091 ( 6+)         JP      Z,INCLEN        ; Yes - No width limit
07F1-05          I  1092 (  4)         DEC     B               ; Restore width
07F2-B8          I  1093 (  4)         CP      B               ; At end of line?
07F3-CC FD 0B    I  1094 ( 6+)         CALL    Z,PRNTCRLF      ; Yes - output CRLF
07F6-3C          I  1095 (  4) INCLEN: INC     A               ; Move on one character
07F7-32 F0 22    I  1096 ( 13)         LD      (CURPOS),A      ; Save new position
07FA-F1          I  1097 (  9) DINPOS: POP     AF              ; Restore character
07FB-C1          I  1098 (  9)         POP     BC              ; Restore buffer length
07FC-CD 96 1D    I  1099 ( 16)         CALL    MONOUT          ; Send it
07FF-C9          I  1100 (  9)         RET
0800-            I  1101
0800-CD 5A 1C    I  1102 ( 16) CLOTST: CALL    GETINP          ; Get input character
0803-E6 7F       I  1103 (  6)         AND     01111111B       ; Strip bit 7
0805-FE 0F       I  1104 (  6)         CP      CTRLO           ; Is it control "O"?
0807-C0          I  1105 ( 5+)         RET     NZ              ; No don't flip flag
0808-3A 8A 22    I  1106 ( 12)         LD      A,(CTLOFG)      ; Get flag
080B-2F          I  1107 (  3)         CPL                     ; Flip it
080C-32 8A 22    I  1108 ( 13)         LD      (CTLOFG),A      ; Put it back
080F-AF          I  1109 (  4)         XOR     A               ; Null character
0810-C9          I  1110 (  9)         RET
0811-            I  1111
0811-CD 21 0A    I  1112 ( 16) LIST:   CALL    ATOH            ; ASCII number to DE
0814-C0          I  1113 ( 5+)         RET     NZ              ; Return if anything extra
0815-C1          I  1114 (  9)         POP     BC              ; Rubbish - Not needed
0816-CD E9 05    I  1115 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0819-C5          I  1116 ( 11)         PUSH    BC              ; Save address of line
081A-CD 67 08    I  1117 ( 16)         CALL    SETLIN          ; Set up lines counter
081D-E1          I  1118 (  9) LISTLP: POP     HL              ; Restore address of line
081E-4E          I  1119 (  6)         LD      C,(HL)          ; Get LSB of next line
081F-23          I  1120 (  4)         INC     HL
0820-46          I  1121 (  6)         LD      B,(HL)          ; Get MSB of next line
0821-23          I  1122 (  4)         INC     HL
0822-78          I  1123 (  4)         LD      A,B             ; BC = 0 (End of program)?
0823-B1          I  1124 (  4)         OR      C
0824-CA 48 05    I  1125 ( 6+)         JP      Z,PRNTOK        ; Yes - Go to command mode
0827-CD 70 08    I  1126 ( 16)         CALL    COUNT           ; Count lines
082A-CD 80 09    I  1127 ( 16)         CALL    TSTBRK          ; Test for break key
082D-C5          I  1128 ( 11)         PUSH    BC              ; Save address of next line
082E-CD FD 0B    I  1129 ( 16)         CALL    PRNTCRLF        ; Output CRLF
0831-5E          I  1130 (  6)         LD      E,(HL)          ; Get LSB of line number
0832-23          I  1131 (  4)         INC     HL
0833-56          I  1132 (  6)         LD      D,(HL)          ; Get MSB of line number
0834-23          I  1133 (  4)         INC     HL
0835-E5          I  1134 ( 11)         PUSH    HL              ; Save address of line start
0836-EB          I  1135 (  3)         EX      DE,HL           ; Line number to HL
0837-CD 3E 19    I  1136 ( 16)         CALL    PRNTHL          ; Output line number in decimal
083A-3E 20       I  1137 (  6)         LD      A,' '           ; Space after line number
083C-E1          I  1138 (  9)         POP     HL              ; Restore start of line address
083D-CD D6 07    I  1139 ( 16) LSTLP2: CALL    OUTC            ; Output character in A
0840-7E          I  1140 (  6) LSTLP3: LD      A,(HL)          ; Get next byte in line
0841-B7          I  1141 (  4)         OR      A               ; End of line?
0842-23          I  1142 (  4)         INC     HL              ; To next byte in line
0843-CA 1D 08    I  1143 ( 6+)         JP      Z,LISTLP        ; Yes - get next line
0846-F2 3D 08    I  1144 ( 6+)         JP      P,LSTLP2        ; No token - output it
0849-D6 7F       I  1145 (  6)         SUB     ZEND-1          ; Find and output word
084B-4F          I  1146 (  4)         LD      C,A             ; Token offset+1 to C
084C-11 86 02    I  1147 (  9)         LD      DE,WORDS        ; Reserved word list
084F-1A          I  1148 (  6) FNDTOK: LD      A,(DE)          ; Get character in list
0850-13          I  1149 (  4)         INC     DE              ; Move on to next
0851-B7          I  1150 (  4)         OR      A               ; Is it start of word?
0852-F2 4F 08    I  1151 ( 6+)         JP      P,FNDTOK        ; No - Keep looking for word
0855-0D          I  1152 (  4)         DEC     C               ; Count words
0856-C2 4F 08    I  1153 ( 6+)         JP      NZ,FNDTOK       ; Not there - keep looking
0859-E6 7F       I  1154 (  6) OUTWRD: AND     01111111B       ; Strip bit 7
085B-CD D6 07    I  1155 ( 16)         CALL    OUTC            ; Output first character
085E-1A          I  1156 (  6)         LD      A,(DE)          ; Get next character
085F-13          I  1157 (  4)         INC     DE              ; Move on to next
0860-B7          I  1158 (  4)         OR      A               ; Is it end of word?
0861-F2 59 08    I  1159 ( 6+)         JP      P,OUTWRD        ; No - output the rest
0864-C3 40 08    I  1160 (  9)         JP      LSTLP3          ; Next byte in line
0867-            I  1161
0867-E5          I  1162 ( 11) SETLIN: PUSH    HL              ; Set up LINES counter
0868-2A 8D 22    I  1163 ( 15)         LD      HL,(LINESN)     ; Get LINES number
086B-22 8B 22    I  1164 ( 20)         LD      (LINESC),HL     ; Save in LINES counter
086E-E1          I  1165 (  9)         POP     HL
086F-C9          I  1166 (  9)         RET
0870-            I  1167
0870-E5          I  1168 ( 11) COUNT:  PUSH    HL              ; Save code string address
0871-D5          I  1169 ( 11)         PUSH    DE
0872-2A 8B 22    I  1170 ( 15)         LD      HL,(LINESC)     ; Get LINES counter
0875-11 FF FF    I  1171 (  9)         LD      DE,-1
0878-ED 5A       I  1172 ( 10)         ADC     HL,DE           ; Decrement
087A-22 8B 22    I  1173 ( 20)         LD      (LINESC),HL     ; Put it back
087D-D1          I  1174 (  9)         POP     DE
087E-E1          I  1175 (  9)         POP     HL              ; Restore code string address
087F-F0          I  1176 ( 5+)         RET     P               ; Return if more lines to go
0880-E5          I  1177 ( 11)         PUSH    HL              ; Save code string address
0881-2A 8D 22    I  1178 ( 15)         LD      HL,(LINESN)     ; Get LINES number
0884-22 8B 22    I  1179 ( 20)         LD      (LINESC),HL     ; Reset LINES counter
0887-CD 5A 1C    I  1180 ( 16)         CALL    GETINP          ; Get input character
088A-FE 03       I  1181 (  6)         CP      CTRLC           ; Is it control "C"?
088C-CA 93 08    I  1182 ( 6+)         JP      Z,RSLNBK        ; Yes - Reset LINES and break
088F-E1          I  1183 (  9)         POP     HL              ; Restore code string address
0890-C3 70 08    I  1184 (  9)         JP      COUNT           ; Keep on counting
0893-            I  1185
0893-2A 8D 22    I  1186 ( 15) RSLNBK: LD      HL,(LINESN)     ; Get LINES number
0896-22 8B 22    I  1187 ( 20)         LD      (LINESC),HL     ; Reset LINES counter
0899-C3 F7 01    I  1188 (  9)         JP      BRKRET          ; Go and output "Break"
089C-            I  1189
089C-3E 64       I  1190 (  6) FOR:    LD      A,64H           ; Flag "FOR" assignment
089E-32 10 23    I  1191 ( 13)         LD      (FORFLG),A      ; Save "FOR" flag
08A1-CD 03 0B    I  1192 ( 16)         CALL    LET             ; Set up initial index
08A4-C1          I  1193 (  9)         POP     BC              ; Drop RETurn address
08A5-E5          I  1194 ( 11)         PUSH    HL              ; Save code string address
08A6-CD EC 0A    I  1195 ( 16)         CALL    DATA            ; Get next statement address
08A9-22 0C 23    I  1196 ( 20)         LD      (LOOPST),HL     ; Save it for start of loop
08AC-21 02 00    I  1197 (  9)         LD      HL,2            ; Offset for "FOR" block
08AF-39          I  1198 (  7)         ADD     HL,SP           ; Point to it
08B0-CD AA 04    I  1199 ( 16) FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
08B3-D1          I  1200 (  9)         POP     DE              ; Get code string address
08B4-C2 CC 08    I  1201 ( 6+)         JP      NZ,FORFND       ; No nesting found
08B7-09          I  1202 (  7)         ADD     HL,BC           ; Move into "FOR" block
08B8-D5          I  1203 ( 11)         PUSH    DE              ; Save code string address
08B9-2B          I  1204 (  4)         DEC     HL
08BA-56          I  1205 (  6)         LD      D,(HL)          ; Get MSB of loop statement
08BB-2B          I  1206 (  4)         DEC     HL
08BC-5E          I  1207 (  6)         LD      E,(HL)          ; Get LSB of loop statement
08BD-23          I  1208 (  4)         INC     HL
08BE-23          I  1209 (  4)         INC     HL
08BF-E5          I  1210 ( 11)         PUSH    HL              ; Save block address
08C0-2A 0C 23    I  1211 ( 15)         LD      HL,(LOOPST)     ; Get address of loop statement
08C3-CD C5 07    I  1212 ( 16)         CALL    CPDEHL          ; Compare the FOR loops
08C6-E1          I  1213 (  9)         POP     HL              ; Restore block address
08C7-C2 B0 08    I  1214 ( 6+)         JP      NZ,FORSLP       ; Different FORs - Find another
08CA-D1          I  1215 (  9)         POP     DE              ; Restore code string address
08CB-F9          I  1216 (  4)         LD      SP,HL           ; Remove all nested loops
08CC-            I  1217
08CC-EB          I  1218 (  3) FORFND: EX      DE,HL           ; Code string address to HL
08CD-0E 08       I  1219 (  6)         LD      C,8
08CF-CD DA 04    I  1220 ( 16)         CALL    CHKSTK          ; Check for 8 levels of stack
08D2-E5          I  1221 ( 11)         PUSH    HL              ; Save code string address
08D3-2A 0C 23    I  1222 ( 15)         LD      HL,(LOOPST)     ; Get first statement of loop
08D6-E3          I  1223 ( 16)         EX      (SP),HL         ; Save and restore code string
08D7-E5          I  1224 ( 11)         PUSH    HL              ; Re-save code string address
08D8-2A A1 22    I  1225 ( 15)         LD      HL,(LINEAT)     ; Get current line number
08DB-E3          I  1226 ( 16)         EX      (SP),HL         ; Save and restore code string
08DC-CD C5 0D    I  1227 ( 16)         CALL    TSTNUM          ; Make sure it's a number
08DF-CD CB 07    I  1228 ( 16)         CALL    CHKSYN          ; Make sure "TO" is next
08E2-A6          I  1229               .DB   ZTO          ; "TO" token
08E3-CD C2 0D    I  1230 ( 16)         CALL    GETNUM          ; Get "TO" expression value
08E6-E5          I  1231 ( 11)         PUSH    HL              ; Save code string address
08E7-CD F0 17    I  1232 ( 16)         CALL    BCDEFP          ; Move "TO" value to BCDE
08EA-E1          I  1233 (  9)         POP     HL              ; Restore code string address
08EB-C5          I  1234 ( 11)         PUSH    BC              ; Save "TO" value in block
08EC-D5          I  1235 ( 11)         PUSH    DE
08ED-01 00 81    I  1236 (  9)         LD      BC,8100H        ; BCDE - 1 (default STEP)
08F0-51          I  1237 (  4)         LD      D,C             ; C=0
08F1-5A          I  1238 (  4)         LD      E,D             ; D=0
08F2-7E          I  1239 (  6)         LD      A,(HL)          ; Get next byte in code string
08F3-FE AB       I  1240 (  6)         CP      ZSTEP           ; See if "STEP" is stated
08F5-3E 01       I  1241 (  6)         LD      A,1             ; Sign of step = 1
08F7-C2 08 09    I  1242 ( 6+)         JP      NZ,SAVSTP       ; No STEP given - Default to 1
08FA-CD 55 09    I  1243 ( 16)         CALL    GETCHR          ; Jump over "STEP" token
08FD-CD C2 0D    I  1244 ( 16)         CALL    GETNUM          ; Get step value
0900-E5          I  1245 ( 11)         PUSH    HL              ; Save code string address
0901-CD F0 17    I  1246 ( 16)         CALL    BCDEFP          ; Move STEP to BCDE
0904-CD A4 17    I  1247 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
0907-E1          I  1248 (  9)         POP     HL              ; Restore code string address
0908-C5          I  1249 ( 11) SAVSTP: PUSH    BC              ; Save the STEP value in block
0909-D5          I  1250 ( 11)         PUSH    DE
090A-F5          I  1251 ( 11)         PUSH    AF              ; Save sign of STEP
090B-33          I  1252 (  4)         INC     SP              ; Don't save flags
090C-E5          I  1253 ( 11)         PUSH    HL              ; Save code string address
090D-2A 13 23    I  1254 ( 15)         LD      HL,(BRKLIN)     ; Get address of index variable
0910-E3          I  1255 ( 16)         EX      (SP),HL         ; Save and restore code string
0911-06 81       I  1256 (  6) PUTFID: LD      B,ZFOR          ; "FOR" block marker
0913-C5          I  1257 ( 11)         PUSH    BC              ; Save it
0914-33          I  1258 (  4)         INC     SP              ; Don't save C
0915-            I  1259
0915-CD 80 09    I  1260 ( 16) RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
0918-22 13 23    I  1261 ( 20)         LD      (BRKLIN),HL     ; Save code address for break
091B-7E          I  1262 (  6)         LD      A,(HL)          ; Get next byte in code string
091C-FE 3A       I  1263 (  6)         CP      ':'             ; Multi statement line?
091E-CA 35 09    I  1264 ( 6+)         JP      Z,EXCUTE        ; Yes - Execute it
0921-B7          I  1265 (  4)         OR      A               ; End of line?
0922-C2 FD 04    I  1266 ( 6+)         JP      NZ,SNERR        ; No - Syntax error
0925-23          I  1267 (  4)         INC     HL              ; Point to address of next line
0926-7E          I  1268 (  6)         LD      A,(HL)          ; Get LSB of line pointer
0927-23          I  1269 (  4)         INC     HL
0928-B6          I  1270 (  6)         OR      (HL)            ; Is it zero (End of prog)?
0929-CA A7 09    I  1271 ( 6+)         JP      Z,ENDPRG        ; Yes - Terminate execution
092C-23          I  1272 (  4)         INC     HL              ; Point to line number
092D-5E          I  1273 (  6)         LD      E,(HL)          ; Get LSB of line number
092E-23          I  1274 (  4)         INC     HL
092F-56          I  1275 (  6)         LD      D,(HL)          ; Get MSB of line number
0930-EB          I  1276 (  3)         EX      DE,HL           ; Line number to HL
0931-22 A1 22    I  1277 ( 20)         LD      (LINEAT),HL     ; Save as current line number
0934-EB          I  1278 (  3)         EX      DE,HL           ; Line number back to DE
0935-CD 55 09    I  1279 ( 16) EXCUTE: CALL    GETCHR          ; Get key word
0938-11 15 09    I  1280 (  9)         LD      DE,RUNCNT       ; Where to RETurn to
093B-D5          I  1281 ( 11)         PUSH    DE              ; Save for RETurn
093C-C8          I  1282 ( 5+) IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
093D-D6 80       I  1283 (  6) ONJMP:  SUB     ZEND            ; Is it a token?
093F-DA 03 0B    I  1284 ( 6+)         JP      C,LET           ; No - try to assign it
0942-FE 25       I  1285 (  6)         CP      ZNEW+1-ZEND     ; END to NEW ?
0944-D2 FD 04    I  1286 ( 6+)         JP      NC,SNERR        ; Not a key word - ?SN Error
0947-07          I  1287 (  3)         RLCA                    ; Double it
0948-4F          I  1288 (  4)         LD      C,A             ; BC = Offset into table
0949-06 00       I  1289 (  6)         LD      B,0
094B-EB          I  1290 (  3)         EX      DE,HL           ; Save code string address
094C-21 A5 03    I  1291 (  9)         LD      HL,WORDTB       ; Keyword address table
094F-09          I  1292 (  7)         ADD     HL,BC           ; Point to routine address
0950-4E          I  1293 (  6)         LD      C,(HL)          ; Get LSB of routine address
0951-23          I  1294 (  4)         INC     HL
0952-46          I  1295 (  6)         LD      B,(HL)          ; Get MSB of routine address
0953-C5          I  1296 ( 11)         PUSH    BC              ; Save routine address
0954-EB          I  1297 (  3)         EX      DE,HL           ; Restore code string address
0955-            I  1298
0955-23          I  1299 (  4) GETCHR: INC     HL              ; Point to next character
0956-7E          I  1300 (  6)         LD      A,(HL)          ; Get next code string byte
0957-FE 3A       I  1301 (  6)         CP      ':'             ; Z if ':'
0959-D0          I  1302 ( 5+)         RET     NC              ; NC if > "9"
095A-FE 20       I  1303 (  6)         CP      ' '
095C-CA 55 09    I  1304 ( 6+)         JP      Z,GETCHR        ; Skip over spaces
095F-FE 30       I  1305 (  6)         CP      '0'
0961-3F          I  1306 (  3)         CCF                     ; NC if < '0'
0962-3C          I  1307 (  4)         INC     A               ; Test for zero - Leave carry
0963-3D          I  1308 (  4)         DEC     A               ; Z if Null
0964-C9          I  1309 (  9)         RET
0965-            I  1310
0965-EB          I  1311 (  3) RESTOR: EX      DE,HL           ; Save code string address
0966-2A A3 22    I  1312 ( 15)         LD      HL,(BASTXT)     ; Point to start of program
0969-CA 7A 09    I  1313 ( 6+)         JP      Z,RESTNL        ; Just RESTORE - reset pointer
096C-EB          I  1314 (  3)         EX      DE,HL           ; Restore code string address
096D-CD 21 0A    I  1315 ( 16)         CALL    ATOH            ; Get line number to DE
0970-E5          I  1316 ( 11)         PUSH    HL              ; Save code string address
0971-CD E9 05    I  1317 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0974-60          I  1318 (  4)         LD      H,B             ; HL = Address of line
0975-69          I  1319 (  4)         LD      L,C
0976-D1          I  1320 (  9)         POP     DE              ; Restore code string address
0977-D2 C2 0A    I  1321 ( 6+)         JP      NC,ULERR        ; ?UL Error if not found
097A-2B          I  1322 (  4) RESTNL: DEC     HL              ; Byte before DATA statement
097B-22 21 23    I  1323 ( 20) UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
097E-EB          I  1324 (  3)         EX      DE,HL           ; Restore code string address
097F-C9          I  1325 (  9)         RET
0980-            I  1326
0980-            I  1327
0980-DF          I  1328 ( 11) TSTBRK: RST     18H             ; Check input status
0981-C8          I  1329 ( 5+)         RET     Z               ; No key, go back
0982-D7          I  1330 ( 11)         RST     10H             ; Get the key into A
0983-FE 1B       I  1331 (  6)         CP      ESC             ; Escape key?
0985-28 11       I  1332 ( 6+)         JR      Z,BRK           ; Yes, break
0987-FE 03       I  1333 (  6)         CP      CTRLC           ; <Ctrl-C>
0989-28 0D       I  1334 ( 6+)         JR      Z,BRK           ; Yes, break
098B-FE 13       I  1335 (  6)         CP      CTRLS           ; Stop scrolling?
098D-C0          I  1336 ( 5+)         RET     NZ              ; Other key, ignore
098E-            I  1337
098E-            I  1338
098E-D7          I  1339 ( 11) STALL:  RST     10H             ; Wait for key
098F-FE 11       I  1340 (  6)         CP      CTRLQ           ; Resume scrolling?
0991-C8          I  1341 ( 5+)         RET      Z              ; Release the chokehold
0992-FE 03       I  1342 (  6)         CP      CTRLC           ; Second break?
0994-28 07       I  1343 ( 6+)         JR      Z,STOP          ; Break during hold exits prog
0996-18 F6       I  1344 (  8)         JR      STALL           ; Loop until <Ctrl-Q> or <brk>
0998-            I  1345
0998-3E FF       I  1346 (  6) BRK     LD      A,$FF           ; Set BRKFLG
099A-32 92 22    I  1347 ( 13)         LD      (BRKFLG),A      ; Store it
099D-            I  1348
099D-            I  1349
099D-C0          I  1350 ( 5+) STOP:   RET     NZ              ; Exit if anything else
099E-F6          I  1351               .DB   0F6H            ; Flag "STOP"
099F-C0          I  1352 ( 5+) PEND:   RET     NZ              ; Exit if anything else
09A0-22 13 23    I  1353 ( 20)         LD      (BRKLIN),HL     ; Save point of break
09A3-21          I  1354               .DB   21H             ; Skip "OR 11111111B"
09A4-F6 FF       I  1355 (  6) INPBRK: OR      11111111B       ; Flag "Break" wanted
09A6-C1          I  1356 (  9)         POP     BC              ; Return not needed and more
09A7-2A A1 22    I  1357 ( 15) ENDPRG: LD      HL,(LINEAT)     ; Get current line number
09AA-F5          I  1358 ( 11)         PUSH    AF              ; Save STOP / END status
09AB-7D          I  1359 (  4)         LD      A,L             ; Is it direct break?
09AC-A4          I  1360 (  4)         AND     H
09AD-3C          I  1361 (  4)         INC     A               ; Line is -1 if direct break
09AE-CA BA 09    I  1362 ( 6+)         JP      Z,NOLIN         ; Yes - No line number
09B1-22 17 23    I  1363 ( 20)         LD      (ERRLIN),HL     ; Save line of break
09B4-2A 13 23    I  1364 ( 15)         LD      HL,(BRKLIN)     ; Get point of break
09B7-22 19 23    I  1365 ( 20)         LD      (CONTAD),HL     ; Save point to CONTinue
09BA-AF          I  1366 (  4) NOLIN:  XOR     A
09BB-32 8A 22    I  1367 ( 13)         LD      (CTLOFG),A      ; Enable output
09BE-CD F0 0B    I  1368 ( 16)         CALL    STTLIN          ; Start a new line
09C1-F1          I  1369 (  9)         POP     AF              ; Restore STOP / END status
09C2-21 A0 04    I  1370 (  9)         LD      HL,BRKMSG       ; "Break" message
09C5-C2 31 05    I  1371 ( 6+)         JP      NZ,ERRIN        ; "in line" wanted?
09C8-C3 48 05    I  1372 (  9)         JP      PRNTOK          ; Go to command mode
09CB-            I  1373
09CB-2A 19 23    I  1374 ( 15) CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
09CE-7C          I  1375 (  4)         LD      A,H             ; Is it zero?
09CF-B5          I  1376 (  4)         OR      L
09D0-1E 20       I  1377 (  6)         LD      E,CN            ; ?CN Error
09D2-CA 11 05    I  1378 ( 6+)         JP      Z,ERROR         ; Yes - output "?CN Error"
09D5-EB          I  1379 (  3)         EX      DE,HL           ; Save code string address
09D6-2A 17 23    I  1380 ( 15)         LD      HL,(ERRLIN)     ; Get line of last break
09D9-22 A1 22    I  1381 ( 20)         LD      (LINEAT),HL     ; Set up current line number
09DC-EB          I  1382 (  3)         EX      DE,HL           ; Restore code string address
09DD-C9          I  1383 (  9)         RET                     ; CONTinue where left off
09DE-            I  1384
09DE-CD 23 15    I  1385 ( 16) NULL:   CALL    GETINT          ; Get integer 0-255
09E1-C0          I  1386 ( 5+)         RET     NZ              ; Return if bad value
09E2-32 86 22    I  1387 ( 13)         LD      (NULLS),A       ; Set nulls number
09E5-C9          I  1388 (  9)         RET
09E6-            I  1389
09E6-            I  1390
09E6-E5          I  1391 ( 11) ACCSUM: PUSH    HL              ; Save address in array
09E7-2A 8F 22    I  1392 ( 15)         LD      HL,(CHKSUM)     ; Get check sum
09EA-06 00       I  1393 (  6)         LD      B,0             ; BC - Value of byte
09EC-4F          I  1394 (  4)         LD      C,A
09ED-09          I  1395 (  7)         ADD     HL,BC           ; Add byte to check sum
09EE-22 8F 22    I  1396 ( 20)         LD      (CHKSUM),HL     ; Re-save check sum
09F1-E1          I  1397 (  9)         POP     HL              ; Restore address in array
09F2-C9          I  1398 (  9)         RET
09F3-            I  1399
09F3-7E          I  1400 (  6) CHKLTR: LD      A,(HL)          ; Get byte
09F4-FE 41       I  1401 (  6)         CP      'A'             ; < 'a' ?
09F6-D8          I  1402 ( 5+)         RET     C               ; Carry set if not letter
09F7-FE 5B       I  1403 (  6)         CP      'Z'+1           ; > 'z' ?
09F9-3F          I  1404 (  3)         CCF
09FA-C9          I  1405 (  9)         RET                     ; Carry set if not letter
09FB-            I  1406
09FB-CD 55 09    I  1407 ( 16) FPSINT: CALL    GETCHR          ; Get next character
09FE-CD C2 0D    I  1408 ( 16) POSINT: CALL    GETNUM          ; Get integer 0 to 32767
0A01-CD A4 17    I  1409 ( 16) DEPINT: CALL    TSTSGN          ; Test sign of FPREG
0A04-FA 1C 0A    I  1410 ( 6+)         JP      M,FCERR         ; Negative - ?FC Error
0A07-3A 2C 23    I  1411 ( 12) DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
0A0A-FE 90       I  1412 (  6)         CP      80H+16          ; Exponent in range (16 bits)?
0A0C-DA 4C 18    I  1413 ( 6+)         JP      C,FPINT         ; Yes - convert it
0A0F-01 80 90    I  1414 (  9)         LD      BC,9080H        ; BCDE = -32768
0A12-11 00 00    I  1415 (  9)         LD      DE,0000
0A15-E5          I  1416 ( 11)         PUSH    HL              ; Save code string address
0A16-CD 1F 18    I  1417 ( 16)         CALL    CMPNUM          ; Compare FPREG with BCDE
0A19-E1          I  1418 (  9)         POP     HL              ; Restore code string address
0A1A-51          I  1419 (  4)         LD      D,C             ; MSB to D
0A1B-C8          I  1420 ( 5+)         RET     Z               ; Return if in range
0A1C-1E 08       I  1421 (  6) FCERR:  LD      E,FC            ; ?FC Error
0A1E-C3 11 05    I  1422 (  9)         JP      ERROR           ; Output error-
0A21-            I  1423
0A21-2B          I  1424 (  4) ATOH:   DEC     HL              ; ASCII number to DE binary
0A22-11 00 00    I  1425 (  9) GETLN:  LD      DE,0            ; Get number to DE
0A25-CD 55 09    I  1426 ( 16) GTLNLP: CALL    GETCHR          ; Get next character
0A28-D0          I  1427 ( 5+)         RET     NC              ; Exit if not a digit
0A29-E5          I  1428 ( 11)         PUSH    HL              ; Save code string address
0A2A-F5          I  1429 ( 11)         PUSH    AF              ; Save digit
0A2B-21 98 19    I  1430 (  9)         LD      HL,65529/10     ; Largest number 65529
0A2E-CD C5 07    I  1431 ( 16)         CALL    CPDEHL          ; Number in range?
0A31-DA FD 04    I  1432 ( 6+)         JP      C,SNERR         ; No - ?SN Error
0A34-62          I  1433 (  4)         LD      H,D             ; HL = Number
0A35-6B          I  1434 (  4)         LD      L,E
0A36-19          I  1435 (  7)         ADD     HL,DE           ; Times 2
0A37-29          I  1436 (  7)         ADD     HL,HL           ; Times 4
0A38-19          I  1437 (  7)         ADD     HL,DE           ; Times 5
0A39-29          I  1438 (  7)         ADD     HL,HL           ; Times 10
0A3A-F1          I  1439 (  9)         POP     AF              ; Restore digit
0A3B-D6 30       I  1440 (  6)         SUB     '0'             ; Make it 0 to 9
0A3D-5F          I  1441 (  4)         LD      E,A             ; DE = Value of digit
0A3E-16 00       I  1442 (  6)         LD      D,0
0A40-19          I  1443 (  7)         ADD     HL,DE           ; Add to number
0A41-EB          I  1444 (  3)         EX      DE,HL           ; Number to DE
0A42-E1          I  1445 (  9)         POP     HL              ; Restore code string address
0A43-C3 25 0A    I  1446 (  9)         JP      GTLNLP          ; Go to next character
0A46-            I  1447
0A46-CA 19 06    I  1448 ( 6+) CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
0A49-CD FE 09    I  1449 ( 16)         CALL    POSINT          ; Get integer 0 to 32767 to DE
0A4C-2B          I  1450 (  4)         DEC     HL              ; Cancel increment
0A4D-CD 55 09    I  1451 ( 16)         CALL    GETCHR          ; Get next character
0A50-E5          I  1452 ( 11)         PUSH    HL              ; Save code string address
0A51-2A F4 22    I  1453 ( 15)         LD      HL,(LSTRAM)     ; Get end of RAM
0A54-CA 69 0A    I  1454 ( 6+)         JP      Z,STORED        ; No value given - Use stored
0A57-E1          I  1455 (  9)         POP     HL              ; Restore code string address
0A58-CD CB 07    I  1456 ( 16)         CALL    CHKSYN          ; Check for comma
0A5B-2C          I  1457               .DB      ','
0A5C-D5          I  1458 ( 11)         PUSH    DE              ; Save number
0A5D-CD FE 09    I  1459 ( 16)         CALL    POSINT          ; Get integer 0 to 32767
0A60-2B          I  1460 (  4)         DEC     HL              ; Cancel increment
0A61-CD 55 09    I  1461 ( 16)         CALL    GETCHR          ; Get next character
0A64-C2 FD 04    I  1462 ( 6+)         JP      NZ,SNERR        ; ?SN Error if more on line
0A67-E3          I  1463 ( 16)         EX      (SP),HL         ; Save code string address
0A68-EB          I  1464 (  3)         EX      DE,HL           ; Number to DE
0A69-7D          I  1465 (  4) STORED: LD      A,L             ; Get LSB of new RAM top
0A6A-93          I  1466 (  4)         SUB     E               ; Subtract LSB of string space
0A6B-5F          I  1467 (  4)         LD      E,A             ; Save LSB
0A6C-7C          I  1468 (  4)         LD      A,H             ; Get MSB of new RAM top
0A6D-9A          I  1469 (  4)         SBC     A,D             ; Subtract MSB of string space
0A6E-57          I  1470 (  4)         LD      D,A             ; Save MSB
0A6F-DA F2 04    I  1471 ( 6+)         JP      C,OMERR         ; ?OM Error if not enough mem
0A72-E5          I  1472 ( 11)         PUSH    HL              ; Save RAM top
0A73-2A 1B 23    I  1473 ( 15)         LD      HL,(PROGND)     ; Get program end
0A76-01 28 00    I  1474 (  9)         LD      BC,40           ; 40 Bytes minimum working RAM
0A79-09          I  1475 (  7)         ADD     HL,BC           ; Get lowest address
0A7A-CD C5 07    I  1476 ( 16)         CALL    CPDEHL          ; Enough memory?
0A7D-D2 F2 04    I  1477 ( 6+)         JP      NC,OMERR        ; No - ?OM Error
0A80-EB          I  1478 (  3)         EX      DE,HL           ; RAM top to HL
0A81-22 9F 22    I  1479 ( 20)         LD      (STRSPC),HL     ; Set new string space
0A84-E1          I  1480 (  9)         POP     HL              ; End of memory to use
0A85-22 F4 22    I  1481 ( 20)         LD      (LSTRAM),HL     ; Set new top of RAM
0A88-E1          I  1482 (  9)         POP     HL              ; Restore code string address
0A89-C3 19 06    I  1483 (  9)         JP      INTVAR          ; Initialise variables
0A8C-            I  1484
0A8C-CA 15 06    I  1485 ( 6+) RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
0A8F-CD 19 06    I  1486 ( 16)         CALL    INTVAR          ; Initialise variables
0A92-01 15 09    I  1487 (  9)         LD      BC,RUNCNT       ; Execution driver loop
0A95-C3 A8 0A    I  1488 (  9)         JP      RUNLIN          ; RUN from line number
0A98-            I  1489
0A98-0E 03       I  1490 (  6) GOSUB:  LD      C,3             ; 3 Levels of stack needed
0A9A-CD DA 04    I  1491 ( 16)         CALL    CHKSTK          ; Check for 3 levels of stack
0A9D-C1          I  1492 (  9)         POP     BC              ; Get return address
0A9E-E5          I  1493 ( 11)         PUSH    HL              ; Save code string for RETURN
0A9F-E5          I  1494 ( 11)         PUSH    HL              ; And for GOSUB routine
0AA0-2A A1 22    I  1495 ( 15)         LD      HL,(LINEAT)     ; Get current line
0AA3-E3          I  1496 ( 16)         EX      (SP),HL         ; Into stack - Code string out
0AA4-3E 8C       I  1497 (  6)         LD      A,ZGOSUB        ; "GOSUB" token
0AA6-F5          I  1498 ( 11)         PUSH    AF              ; Save token
0AA7-33          I  1499 (  4)         INC     SP              ; Don't save flags
0AA8-            I  1500
0AA8-C5          I  1501 ( 11) RUNLIN: PUSH    BC              ; Save return address
0AA9-CD 21 0A    I  1502 ( 16) GOTO:   CALL    ATOH            ; ASCII number to DE binary
0AAC-CD EE 0A    I  1503 ( 16)         CALL    REM             ; Get end of line
0AAF-E5          I  1504 ( 11)         PUSH    HL              ; Save end of line
0AB0-2A A1 22    I  1505 ( 15)         LD      HL,(LINEAT)     ; Get current line
0AB3-CD C5 07    I  1506 ( 16)         CALL    CPDEHL          ; Line after current?
0AB6-E1          I  1507 (  9)         POP     HL              ; Restore end of line
0AB7-23          I  1508 (  4)         INC     HL              ; Start of next line
0AB8-DC EC 05    I  1509 ( 6+)         CALL    C,SRCHLP        ; Line is after current line
0ABB-D4 E9 05    I  1510 ( 6+)         CALL    NC,SRCHLN       ; Line is before current line
0ABE-60          I  1511 (  4)         LD      H,B             ; Set up code string address
0ABF-69          I  1512 (  4)         LD      L,C
0AC0-2B          I  1513 (  4)         DEC     HL              ; Incremented after
0AC1-D8          I  1514 ( 5+)         RET     C               ; Line found
0AC2-1E 0E       I  1515 (  6) ULERR:  LD      E,UL            ; ?UL Error
0AC4-C3 11 05    I  1516 (  9)         JP      ERROR           ; Output error message
0AC7-            I  1517
0AC7-C0          I  1518 ( 5+) RETURN: RET     NZ              ; Return if not just RETURN
0AC8-16 FF       I  1519 (  6)         LD      D,-1            ; Flag "GOSUB" search
0ACA-CD A6 04    I  1520 ( 16)         CALL    BAKSTK          ; Look "GOSUB" block
0ACD-F9          I  1521 (  4)         LD      SP,HL           ; Kill all FORs in subroutine
0ACE-FE 8C       I  1522 (  6)         CP      ZGOSUB          ; Test for "GOSUB" token
0AD0-1E 04       I  1523 (  6)         LD      E,RG            ; ?RG Error
0AD2-C2 11 05    I  1524 ( 6+)         JP      NZ,ERROR        ; Error if no "GOSUB" found
0AD5-E1          I  1525 (  9)         POP     HL              ; Get RETURN line number
0AD6-22 A1 22    I  1526 ( 20)         LD      (LINEAT),HL     ; Save as current
0AD9-23          I  1527 (  4)         INC     HL              ; Was it from direct statement?
0ADA-7C          I  1528 (  4)         LD      A,H
0ADB-B5          I  1529 (  4)         OR      L               ; Return to line
0ADC-C2 E6 0A    I  1530 ( 6+)         JP      NZ,RETLIN       ; No - Return to line
0ADF-3A 11 23    I  1531 ( 12)         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
0AE2-B7          I  1532 (  4)         OR      A               ; If so buffer is corrupted
0AE3-C2 47 05    I  1533 ( 6+)         JP      NZ,POPNOK       ; Yes - Go to command mode
0AE6-21 15 09    I  1534 (  9) RETLIN: LD      HL,RUNCNT       ; Execution driver loop
0AE9-E3          I  1535 ( 16)         EX      (SP),HL         ; Into stack - Code string out
0AEA-3E          I  1536               .DB      3EH             ; Skip "POP HL"
0AEB-E1          I  1537 (  9) NXTDTA: POP     HL              ; Restore code string address
0AEC-            I  1538
0AEC-01 3A       I  1539       DATA:   .DB      01H,3AH         ; ':' End of statement
0AEE-0E 00       I  1540 (  6) REM:    LD      C,0             ; 00  End of statement
0AF0-06 00       I  1541 (  6)         LD      B,0
0AF2-79          I  1542 (  4) NXTSTL: LD      A,C             ; Statement and byte
0AF3-48          I  1543 (  4)         LD      C,B
0AF4-47          I  1544 (  4)         LD      B,A             ; Statement end byte
0AF5-7E          I  1545 (  6) NXTSTT: LD      A,(HL)          ; Get byte
0AF6-B7          I  1546 (  4)         OR      A               ; End of line?
0AF7-C8          I  1547 ( 5+)         RET     Z               ; Yes - Exit
0AF8-B8          I  1548 (  4)         CP      B               ; End of statement?
0AF9-C8          I  1549 ( 5+)         RET     Z               ; Yes - Exit
0AFA-23          I  1550 (  4)         INC     HL              ; Next byte
0AFB-FE 22       I  1551 (  6)         CP      '"'             ; Literal string?
0AFD-CA F2 0A    I  1552 ( 6+)         JP      Z,NXTSTL        ; Yes - Look for another '"'
0B00-C3 F5 0A    I  1553 (  9)         JP      NXTSTT          ; Keep looking
0B03-            I  1554
0B03-CD B8 0F    I  1555 ( 16) LET:    CALL    GETVAR          ; Get variable name
0B06-CD CB 07    I  1556 ( 16)         CALL    CHKSYN          ; Make sure "=" follows
0B09-B4          I  1557               .DB      ZEQUAL          ; "=" token
0B0A-D5          I  1558 ( 11)         PUSH    DE              ; Save address of variable
0B0B-3A F2 22    I  1559 ( 12)         LD      A,(TYPE)        ; Get data type
0B0E-F5          I  1560 ( 11)         PUSH    AF              ; Save type
0B0F-CD D4 0D    I  1561 ( 16)         CALL    EVAL            ; Evaluate expression
0B12-F1          I  1562 (  9)         POP     AF              ; Restore type
0B13-E3          I  1563 ( 16)         EX      (SP),HL         ; Save code - Get var addr
0B14-22 13 23    I  1564 ( 20)         LD      (BRKLIN),HL     ; Save address of variable
0B17-1F          I  1565 (  3)         RRA                     ; Adjust type
0B18-CD C7 0D    I  1566 ( 16)         CALL    CHKTYP          ; Check types are the same
0B1B-CA 56 0B    I  1567 ( 6+)         JP      Z,LETNUM        ; Numeric - Move value
0B1E-E5          I  1568 ( 11) LETSTR: PUSH    HL              ; Save address of string var
0B1F-2A 29 23    I  1569 ( 15)         LD      HL,(FPREG)      ; Pointer to string entry
0B22-E5          I  1570 ( 11)         PUSH    HL              ; Save it on stack
0B23-23          I  1571 (  4)         INC     HL              ; Skip over length
0B24-23          I  1572 (  4)         INC     HL
0B25-5E          I  1573 (  6)         LD      E,(HL)          ; LSB of string address
0B26-23          I  1574 (  4)         INC     HL
0B27-56          I  1575 (  6)         LD      D,(HL)          ; MSB of string address
0B28-2A A3 22    I  1576 ( 15)         LD      HL,(BASTXT)     ; Point to start of program
0B2B-CD C5 07    I  1577 ( 16)         CALL    CPDEHL          ; Is string before program?
0B2E-D2 45 0B    I  1578 ( 6+)         JP      NC,CRESTR       ; Yes - Create string entry
0B31-2A 9F 22    I  1579 ( 15)         LD      HL,(STRSPC)     ; Point to string space
0B34-CD C5 07    I  1580 ( 16)         CALL    CPDEHL          ; Is string literal in program?
0B37-D1          I  1581 (  9)         POP     DE              ; Restore address of string
0B38-D2 4D 0B    I  1582 ( 6+)         JP      NC,MVSTPT       ; Yes - Set up pointer
0B3B-21 04 23    I  1583 (  9)         LD      HL,TMPSTR       ; Temporary string pool
0B3E-CD C5 07    I  1584 ( 16)         CALL    CPDEHL          ; Is string in temporary pool?
0B41-D2 4D 0B    I  1585 ( 6+)         JP      NC,MVSTPT       ; No - Set up pointer
0B44-3E          I  1586               .DB   3EH             ; Skip "POP DE"
0B45-D1          I  1587 (  9) CRESTR: POP     DE              ; Restore address of string
0B46-CD FC 13    I  1588 ( 16)         CALL    BAKTMP          ; Back to last tmp-str entry
0B49-EB          I  1589 (  3)         EX      DE,HL           ; Address of string entry
0B4A-CD 35 12    I  1590 ( 16)         CALL    SAVSTR          ; Save string in string area
0B4D-CD FC 13    I  1591 ( 16) MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
0B50-E1          I  1592 (  9)         POP     HL              ; Get string pointer
0B51-CD FF 17    I  1593 ( 16)         CALL    DETHL4          ; Move string pointer to var
0B54-E1          I  1594 (  9)         POP     HL              ; Restore code string address
0B55-C9          I  1595 (  9)         RET
0B56-            I  1596
0B56-E5          I  1597 ( 11) LETNUM: PUSH    HL              ; Save address of variable
0B57-CD FC 17    I  1598 ( 16)         CALL    FPTHL           ; Move value to variable
0B5A-D1          I  1599 (  9)         POP     DE              ; Restore address of variable
0B5B-E1          I  1600 (  9)         POP     HL              ; Restore code string address
0B5C-C9          I  1601 (  9)         RET
0B5D-            I  1602
0B5D-CD 23 15    I  1603 ( 16) ON:     CALL    GETINT          ; Get integer 0-255
0B60-7E          I  1604 (  6)         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
0B61-47          I  1605 (  4)         LD      B,A             ; Save in B
0B62-FE 8C       I  1606 (  6)         CP      ZGOSUB          ; "GOSUB" token?
0B64-CA 6C 0B    I  1607 ( 6+)         JP      Z,ONGO          ; Yes - Find line number
0B67-CD CB 07    I  1608 ( 16)         CALL    CHKSYN          ; Make sure it's "GOTO"
0B6A-88          I  1609               .DB   ZGOTO           ; "GOTO" token
0B6B-2B          I  1610 (  4)         DEC     HL              ; Cancel increment
0B6C-4B          I  1611 (  4) ONGO:   LD      C,E             ; Integer of branch value
0B6D-0D          I  1612 (  4) ONGOLP: DEC     C               ; Count branches
0B6E-78          I  1613 (  4)         LD      A,B             ; Get "GOTO" or "GOSUB" token
0B6F-CA 3D 09    I  1614 ( 6+)         JP      Z,ONJMP         ; Go to that line if right one
0B72-CD 22 0A    I  1615 ( 16)         CALL    GETLN           ; Get line number to DE
0B75-FE 2C       I  1616 (  6)         CP      ','             ; Another line number?
0B77-C0          I  1617 ( 5+)         RET     NZ              ; No - Drop through
0B78-C3 6D 0B    I  1618 (  9)         JP      ONGOLP          ; Yes - loop
0B7B-            I  1619
0B7B-CD D4 0D    I  1620 ( 16) IF:     CALL    EVAL            ; Evaluate expression
0B7E-7E          I  1621 (  6)         LD      A,(HL)          ; Get token
0B7F-FE 88       I  1622 (  6)         CP      ZGOTO           ; "GOTO" token?
0B81-CA 89 0B    I  1623 ( 6+)         JP      Z,IFGO          ; Yes - Get line
0B84-CD CB 07    I  1624 ( 16)         CALL    CHKSYN          ; Make sure it's "THEN"
0B87-A9          I  1625               .DB      ZTHEN           ; "THEN" token
0B88-2B          I  1626 (  4)         DEC     HL              ; Cancel increment
0B89-CD C5 0D    I  1627 ( 16) IFGO:   CALL    TSTNUM          ; Make sure it's numeric
0B8C-CD A4 17    I  1628 ( 16)         CALL    TSTSGN          ; Test state of expression
0B8F-CA EE 0A    I  1629 ( 6+)         JP      Z,REM           ; False - Drop through
0B92-CD 55 09    I  1630 ( 16)         CALL    GETCHR          ; Get next character
0B95-DA A9 0A    I  1631 ( 6+)         JP      C,GOTO          ; Number - GOTO that line
0B98-C3 3C 09    I  1632 (  9)         JP      IFJMP           ; Otherwise do statement
0B9B-            I  1633
0B9B-2B          I  1634 (  4) MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
0B9C-CD 55 09    I  1635 ( 16)         CALL    GETCHR          ; Get next character
0B9F-CA FD 0B    I  1636 ( 6+) PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
0BA2-C8          I  1637 ( 5+) PRNTLP: RET     Z               ; End of list - Exit
0BA3-FE A5       I  1638 (  6)         CP      ZTAB            ; "TAB(" token?
0BA5-CA 30 0C    I  1639 ( 6+)         JP      Z,DOTAB         ; Yes - Do TAB routine
0BA8-FE A8       I  1640 (  6)         CP      ZSPC            ; "SPC(" token?
0BAA-CA 30 0C    I  1641 ( 6+)         JP      Z,DOTAB         ; Yes - Do SPC routine
0BAD-E5          I  1642 ( 11)         PUSH    HL              ; Save code string address
0BAE-FE 2C       I  1643 (  6)         CP      ','             ; Comma?
0BB0-CA 19 0C    I  1644 ( 6+)         JP      Z,DOCOM         ; Yes - Move to next zone
0BB3-FE 3B       I  1645 (  6)         CP      59 ;";"         ; Semi-colon?
0BB5-CA 53 0C    I  1646 ( 6+)         JP      Z,NEXITM        ; Do semi-colon routine
0BB8-C1          I  1647 (  9)         POP     BC              ; Code string address to BC
0BB9-CD D4 0D    I  1648 ( 16)         CALL    EVAL            ; Evaluate expression
0BBC-E5          I  1649 ( 11)         PUSH    HL              ; Save code string address
0BBD-3A F2 22    I  1650 ( 12)         LD      A,(TYPE)        ; Get variable type
0BC0-B7          I  1651 (  4)         OR      A               ; Is it a string variable?
0BC1-C2 E9 0B    I  1652 ( 6+)         JP      NZ,PRNTST       ; Yes - Output string contents
0BC4-CD 49 19    I  1653 ( 16)         CALL    NUMASC          ; Convert number to text
0BC7-CD 59 12    I  1654 ( 16)         CALL    CRTST           ; Create temporary string
0BCA-36 20       I  1655 (  9)         LD      (HL),' '        ; Followed by a space
0BCC-2A 29 23    I  1656 ( 15)         LD      HL,(FPREG)      ; Get length of output
0BCF-34          I  1657 ( 10)         INC     (HL)            ; Plus 1 for the space
0BD0-2A 29 23    I  1658 ( 15)         LD      HL,(FPREG)      ; < Not needed >
0BD3-3A 87 22    I  1659 ( 12)         LD      A,(LWIDTH)      ; Get width of line
0BD6-47          I  1660 (  4)         LD      B,A             ; To B
0BD7-04          I  1661 (  4)         INC     B               ; Width 255 (No limit)?
0BD8-CA E5 0B    I  1662 ( 6+)         JP      Z,PRNTNB        ; Yes - Output number string
0BDB-04          I  1663 (  4)         INC     B               ; Adjust it
0BDC-3A F0 22    I  1664 ( 12)         LD      A,(CURPOS)      ; Get cursor position
0BDF-86          I  1665 (  6)         ADD     A,(HL)          ; Add length of string
0BE0-3D          I  1666 (  4)         DEC     A               ; Adjust it
0BE1-B8          I  1667 (  4)         CP      B               ; Will output fit on this line?
0BE2-D4 FD 0B    I  1668 ( 6+)         CALL    NC,PRNTCRLF     ; No - CRLF first
0BE5-CD 9E 12    I  1669 ( 16) PRNTNB: CALL    PRS1            ; Output string at (HL)
0BE8-AF          I  1670 (  4)         XOR     A               ; Skip CALL by setting 'z' flag
0BE9-C4 9E 12    I  1671 ( 6+) PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
0BEC-E1          I  1672 (  9)         POP     HL              ; Restore code string address
0BED-C3 9B 0B    I  1673 (  9)         JP      MRPRNT          ; See if more to PRINT
0BF0-            I  1674
0BF0-3A F0 22    I  1675 ( 12) STTLIN: LD      A,(CURPOS)      ; Make sure on new line
0BF3-B7          I  1676 (  4)         OR      A               ; Already at start?
0BF4-C8          I  1677 ( 5+)         RET     Z               ; Yes - Do nothing
0BF5-C3 FD 0B    I  1678 (  9)         JP      PRNTCRLF        ; Start a new line
0BF8-            I  1679
0BF8-36 00       I  1680 (  9) ENDINP: LD      (HL),0          ; Mark end of buffer
0BFA-21 A5 22    I  1681 (  9)         LD      HL,BUFFER-1     ; Point to buffer
0BFD-3E 0D       I  1682 (  6) PRNTCRLF: LD    A,CR            ; Load a CR
0BFF-CD D6 07    I  1683 ( 16)         CALL    OUTC            ; Output character
0C02-3E 0A       I  1684 (  6)         LD      A,LF            ; Load a LF
0C04-CD D6 07    I  1685 ( 16)         CALL    OUTC            ; Output character
0C07-AF          I  1686 (  4) DONULL: XOR     A               ; Set to position 0
0C08-32 F0 22    I  1687 ( 13)         LD      (CURPOS),A      ; Store it
0C0B-3A 86 22    I  1688 ( 12)         LD      A,(NULLS)       ; Get number of nulls
0C0E-3D          I  1689 (  4) NULLP:  DEC     A               ; Count them
0C0F-C8          I  1690 ( 5+)         RET     Z               ; Return if done
0C10-F5          I  1691 ( 11)         PUSH    AF              ; Save count
0C11-AF          I  1692 (  4)         XOR     A               ; Load a null
0C12-CD D6 07    I  1693 ( 16)         CALL    OUTC            ; Output it
0C15-F1          I  1694 (  9)         POP     AF              ; Restore count
0C16-C3 0E 0C    I  1695 (  9)         JP      NULLP           ; Keep counting
0C19-            I  1696
0C19-3A 88 22    I  1697 ( 12) DOCOM:  LD      A,(COMMAN)      ; Get comma width
0C1C-47          I  1698 (  4)         LD      B,A             ; Save in B
0C1D-3A F0 22    I  1699 ( 12)         LD      A,(CURPOS)      ; Get current position
0C20-B8          I  1700 (  4)         CP      B               ; Within the limit?
0C21-D4 FD 0B    I  1701 ( 6+)         CALL    NC,PRNTCRLF     ; No - output CRLF
0C24-D2 53 0C    I  1702 ( 6+)         JP      NC,NEXITM       ; Get next item
0C27-D6 0E       I  1703 (  6) ZONELP: SUB     14              ; Next zone of 14 characters
0C29-D2 27 0C    I  1704 ( 6+)         JP      NC,ZONELP       ; Repeat if more zones
0C2C-2F          I  1705 (  3)         CPL                     ; Number of spaces to output
0C2D-C3 48 0C    I  1706 (  9)         JP      ASPCS           ; Output them
0C30-            I  1707
0C30-F5          I  1708 ( 11) DOTAB:  PUSH    AF              ; Save token
0C31-CD 20 15    I  1709 ( 16)         CALL    FNDNUM          ; Evaluate expression
0C34-CD CB 07    I  1710 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
0C37-29          I  1711               .DB   ")"
0C38-2B          I  1712 (  4)         DEC     HL              ; Back space on to ")"
0C39-F1          I  1713 (  9)         POP     AF              ; Restore token
0C3A-D6 A8       I  1714 (  6)         SUB     ZSPC            ; Was it "SPC(" ?
0C3C-E5          I  1715 ( 11)         PUSH    HL              ; Save code string address
0C3D-CA 43 0C    I  1716 ( 6+)         JP      Z,DOSPC         ; Yes - Do 'E' spaces
0C40-3A F0 22    I  1717 ( 12)         LD      A,(CURPOS)      ; Get current position
0C43-2F          I  1718 (  3) DOSPC:  CPL                     ; Number of spaces to print to
0C44-83          I  1719 (  4)         ADD     A,E             ; Total number to print
0C45-D2 53 0C    I  1720 ( 6+)         JP      NC,NEXITM       ; TAB < Current POS(X)
0C48-3C          I  1721 (  4) ASPCS:  INC     A               ; Output A spaces
0C49-47          I  1722 (  4)         LD      B,A             ; Save number to print
0C4A-3E 20       I  1723 (  6)         LD      A,' '           ; Space
0C4C-CD D6 07    I  1724 ( 16) SPCLP:  CALL    OUTC            ; Output character in A
0C4F-05          I  1725 (  4)         DEC     B               ; Count them
0C50-C2 4C 0C    I  1726 ( 6+)         JP      NZ,SPCLP        ; Repeat if more
0C53-E1          I  1727 (  9) NEXITM: POP     HL              ; Restore code string address
0C54-CD 55 09    I  1728 ( 16)         CALL    GETCHR          ; Get next character
0C57-C3 A2 0B    I  1729 (  9)         JP      PRNTLP          ; More to print
0C5A-            I  1730
0C5A-3F 52 65 64 
     6F 20 66 72 
     6F 6D 20 73 
     74 61 72 74 
     0D 0A 00    I  1731       REDO:   .DB   "?Redo from start",CR,LF,0
0C6D-            I  1732
0C6D-3A 12 23    I  1733 ( 12) BADINP: LD      A,(READFG)      ; READ or INPUT?
0C70-B7          I  1734 (  4)         OR      A
0C71-C2 F7 04    I  1735 ( 6+)         JP      NZ,DATSNR       ; READ - ?SN Error
0C74-C1          I  1736 (  9)         POP     BC              ; Throw away code string addr
0C75-21 5A 0C    I  1737 (  9)         LD      HL,REDO         ; "Redo from start" message
0C78-CD 9B 12    I  1738 ( 16)         CALL    PRS             ; Output string
0C7B-C3 48 06    I  1739 (  9)         JP      DOAGN           ; Do last INPUT again
0C7E-            I  1740
0C7E-CD 06 12    I  1741 ( 16) INPUT:  CALL    IDTEST          ; Test for illegal direct
0C81-7E          I  1742 (  6)         LD      A,(HL)          ; Get character after "INPUT"
0C82-FE 22       I  1743 (  6)         CP      '"'             ; Is there a prompt string?
0C84-3E 00       I  1744 (  6)         LD      A,0             ; Clear A and leave flags
0C86-32 8A 22    I  1745 ( 13)         LD      (CTLOFG),A      ; Enable output
0C89-C2 98 0C    I  1746 ( 6+)         JP      NZ,NOPMPT       ; No prompt - get input
0C8C-CD 5A 12    I  1747 ( 16)         CALL    QTSTR           ; Get string terminated by '"'
0C8F-CD CB 07    I  1748 ( 16)         CALL    CHKSYN          ; Check for ';' after prompt
0C92-3B          I  1749               .DB   ';'
0C93-E5          I  1750 ( 11)         PUSH    HL              ; Save code string address
0C94-CD 9E 12    I  1751 ( 16)         CALL    PRS1            ; Output prompt string
0C97-3E          I  1752               .DB   3EH             ; Skip "PUSH HL"
0C98-E5          I  1753 ( 11) NOPMPT: PUSH    HL              ; Save code string address
0C99-CD 4C 06    I  1754 ( 16)         CALL    PROMPT          ; Get input with "? " prompt
0C9C-C1          I  1755 (  9)         POP     BC              ; Restore code string address
0C9D-DA A4 09    I  1756 ( 6+)         JP      C,INPBRK        ; Break pressed - Exit
0CA0-23          I  1757 (  4)         INC     HL              ; Next byte
0CA1-7E          I  1758 (  6)         LD      A,(HL)          ; Get it
0CA2-B7          I  1759 (  4)         OR      A               ; End of line?
0CA3-2B          I  1760 (  4)         DEC     HL              ; Back again
0CA4-C5          I  1761 ( 11)         PUSH    BC              ; Re-save code string address
0CA5-CA EB 0A    I  1762 ( 6+)         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
0CA8-36 2C       I  1763 (  9)         LD      (HL),','        ; Store comma as separator
0CAA-C3 B2 0C    I  1764 (  9)         JP      NXTITM          ; Get next item
0CAD-            I  1765
0CAD-E5          I  1766 ( 11) READ:   PUSH    HL              ; Save code string address
0CAE-2A 21 23    I  1767 ( 15)         LD      HL,(NXTDAT)     ; Next DATA statement
0CB1-F6          I  1768               .DB   0F6H            ; Flag "READ"
0CB2-AF          I  1769 (  4) NXTITM: XOR     A               ; Flag "INPUT"
0CB3-32 12 23    I  1770 ( 13)         LD      (READFG),A      ; Save "READ"/"INPUT" flag
0CB6-E3          I  1771 ( 16)         EX      (SP),HL         ; Get code str' , Save pointer
0CB7-C3 BE 0C    I  1772 (  9)         JP      GTVLUS          ; Get values
0CBA-            I  1773
0CBA-CD CB 07    I  1774 ( 16) NEDMOR: CALL    CHKSYN          ; Check for comma between items
0CBD-2C          I  1775               .DB      ','
0CBE-CD B8 0F    I  1776 ( 16) GTVLUS: CALL    GETVAR          ; Get variable name
0CC1-E3          I  1777 ( 16)         EX      (SP),HL         ; Save code str" , Get pointer
0CC2-D5          I  1778 ( 11)         PUSH    DE              ; Save variable address
0CC3-7E          I  1779 (  6)         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
0CC4-FE 2C       I  1780 (  6)         CP      ','             ; Comma?
0CC6-CA E6 0C    I  1781 ( 6+)         JP      Z,ANTVLU        ; Yes - Get another value
0CC9-3A 12 23    I  1782 ( 12)         LD      A,(READFG)      ; Is it READ?
0CCC-B7          I  1783 (  4)         OR      A
0CCD-C2 53 0D    I  1784 ( 6+)         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
0CD0-3E 3F       I  1785 (  6)         LD      A,'?'           ; More INPUT needed
0CD2-CD D6 07    I  1786 ( 16)         CALL    OUTC            ; Output character
0CD5-CD 4C 06    I  1787 ( 16)         CALL    PROMPT          ; Get INPUT with prompt
0CD8-D1          I  1788 (  9)         POP     DE              ; Variable address
0CD9-C1          I  1789 (  9)         POP     BC              ; Code string address
0CDA-DA A4 09    I  1790 ( 6+)         JP      C,INPBRK        ; Break pressed
0CDD-23          I  1791 (  4)         INC     HL              ; Point to next DATA byte
0CDE-7E          I  1792 (  6)         LD      A,(HL)          ; Get byte
0CDF-B7          I  1793 (  4)         OR      A               ; Is it zero (No input) ?
0CE0-2B          I  1794 (  4)         DEC     HL              ; Back space INPUT pointer
0CE1-C5          I  1795 ( 11)         PUSH    BC              ; Save code string address
0CE2-CA EB 0A    I  1796 ( 6+)         JP      Z,NXTDTA        ; Find end of buffer
0CE5-D5          I  1797 ( 11)         PUSH    DE              ; Save variable address
0CE6-3A F2 22    I  1798 ( 12) ANTVLU: LD      A,(TYPE)        ; Check data type
0CE9-B7          I  1799 (  4)         OR      A               ; Is it numeric?
0CEA-CA 10 0D    I  1800 ( 6+)         JP      Z,INPBIN        ; Yes - Convert to binary
0CED-CD 55 09    I  1801 ( 16)         CALL    GETCHR          ; Get next character
0CF0-57          I  1802 (  4)         LD      D,A             ; Save input character
0CF1-47          I  1803 (  4)         LD      B,A             ; Again
0CF2-FE 22       I  1804 (  6)         CP      '"'             ; Start of literal sting?"
0CF4-CA 04 0D    I  1805 ( 6+)         JP      Z,STRENT        ; Yes - Create string entry
0CF7-3A 12 23    I  1806 ( 12)         LD      A,(READFG)      ; "READ" or "INPUT" ?
0CFA-B7          I  1807 (  4)         OR      A
0CFB-57          I  1808 (  4)         LD      D,A             ; Save 00 if "INPUT"
0CFC-CA 01 0D    I  1809 ( 6+)         JP      Z,ITMSEP        ; "INPUT" - End with 00
0CFF-16 3A       I  1810 (  6)         LD      D,':'           ; "DATA" - End with 00 or ':'
0D01-06 2C       I  1811 (  6) ITMSEP: LD      B,','           ; Item separator
0D03-2B          I  1812 (  4)         DEC     HL              ; Back space for DTSTR
0D04-CD 5D 12    I  1813 ( 16) STRENT: CALL    DTSTR           ; Get string terminated by D
0D07-EB          I  1814 (  3)         EX      DE,HL           ; String address to DE
0D08-21 1B 0D    I  1815 (  9)         LD      HL,LTSTND       ; Where to go after LETSTR
0D0B-E3          I  1816 ( 16)         EX      (SP),HL         ; Save HL , get input pointer
0D0C-D5          I  1817 ( 11)         PUSH    DE              ; Save address of string
0D0D-C3 1E 0B    I  1818 (  9)         JP      LETSTR          ; Assign string to variable
0D10-            I  1819
0D10-CD 55 09    I  1820 ( 16) INPBIN: CALL    GETCHR          ; Get next character
0D13-CD AB 18    I  1821 ( 16)         CALL    ASCTFP          ; Convert ASCII to FP number
0D16-E3          I  1822 ( 16)         EX      (SP),HL         ; Save input ptr, Get var addr
0D17-CD FC 17    I  1823 ( 16)         CALL    FPTHL           ; Move FPREG to variable
0D1A-E1          I  1824 (  9)         POP     HL              ; Restore input pointer
0D1B-2B          I  1825 (  4) LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
0D1C-CD 55 09    I  1826 ( 16)         CALL    GETCHR          ; Get next character
0D1F-CA 27 0D    I  1827 ( 6+)         JP      Z,MORDT         ; End of line - More needed?
0D22-FE 2C       I  1828 (  6)         CP      ','             ; Another value?
0D24-C2 6D 0C    I  1829 ( 6+)         JP      NZ,BADINP       ; No - Bad input
0D27-E3          I  1830 ( 16) MORDT:  EX      (SP),HL         ; Get code string address
0D28-2B          I  1831 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
0D29-CD 55 09    I  1832 ( 16)         CALL    GETCHR          ; Get next character
0D2C-C2 BA 0C    I  1833 ( 6+)         JP      NZ,NEDMOR       ; More needed - Get it
0D2F-D1          I  1834 (  9)         POP     DE              ; Restore DATA pointer
0D30-3A 12 23    I  1835 ( 12)         LD      A,(READFG)      ; "READ" or "INPUT" ?
0D33-B7          I  1836 (  4)         OR      A
0D34-EB          I  1837 (  3)         EX      DE,HL           ; DATA pointer to HL
0D35-C2 7B 09    I  1838 ( 6+)         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
0D38-D5          I  1839 ( 11)         PUSH    DE              ; Save code string address
0D39-B6          I  1840 (  6)         OR      (HL)            ; More input given?
0D3A-21 42 0D    I  1841 (  9)         LD      HL,EXTIG        ; "?Extra ignored" message
0D3D-C4 9B 12    I  1842 ( 6+)         CALL    NZ,PRS          ; Output string if extra given
0D40-E1          I  1843 (  9)         POP     HL              ; Restore code string address
0D41-C9          I  1844 (  9)         RET
0D42-            I  1845
0D42-3F 45 78 74 
     72 61 20 69 
     67 6E 6F 72 
     65 64 0D 0A 
     00          I  1846       EXTIG:  .DB   "?Extra ignored",CR,LF,0
0D53-            I  1847
0D53-CD EC 0A    I  1848 ( 16) FDTLP:  CALL    DATA            ; Get next statement
0D56-B7          I  1849 (  4)         OR      A               ; End of line?
0D57-C2 6C 0D    I  1850 ( 6+)         JP      NZ,FANDT        ; No - See if DATA statement
0D5A-23          I  1851 (  4)         INC     HL
0D5B-7E          I  1852 (  6)         LD      A,(HL)          ; End of program?
0D5C-23          I  1853 (  4)         INC     HL
0D5D-B6          I  1854 (  6)         OR      (HL)            ; 00 00 Ends program
0D5E-1E 06       I  1855 (  6)         LD      E,OD            ; ?OD Error
0D60-CA 11 05    I  1856 ( 6+)         JP      Z,ERROR         ; Yes - Out of DATA
0D63-23          I  1857 (  4)         INC     HL
0D64-5E          I  1858 (  6)         LD      E,(HL)          ; LSB of line number
0D65-23          I  1859 (  4)         INC     HL
0D66-56          I  1860 (  6)         LD      D,(HL)          ; MSB of line number
0D67-EB          I  1861 (  3)         EX      DE,HL
0D68-22 0E 23    I  1862 ( 20)         LD      (DATLIN),HL     ; Set line of current DATA item
0D6B-EB          I  1863 (  3)         EX      DE,HL
0D6C-CD 55 09    I  1864 ( 16) FANDT:  CALL    GETCHR          ; Get next character
0D6F-FE 83       I  1865 (  6)         CP      ZDATA           ; "DATA" token
0D71-C2 53 0D    I  1866 ( 6+)         JP      NZ,FDTLP        ; No "DATA" - Keep looking
0D74-C3 E6 0C    I  1867 (  9)         JP      ANTVLU          ; Found - Convert input
0D77-            I  1868
0D77-11 00 00    I  1869 (  9) NEXT:   LD      DE,0            ; In case no index given
0D7A-C4 B8 0F    I  1870 ( 6+) NEXT1:  CALL    NZ,GETVAR       ; Get index address
0D7D-22 13 23    I  1871 ( 20)         LD      (BRKLIN),HL     ; Save code string address
0D80-CD A6 04    I  1872 ( 16)         CALL    BAKSTK          ; Look for "FOR" block
0D83-C2 03 05    I  1873 ( 6+)         JP      NZ,NFERR        ; No "FOR" - ?NF Error
0D86-F9          I  1874 (  4)         LD      SP,HL           ; Clear nested loops
0D87-D5          I  1875 ( 11)         PUSH    DE              ; Save index address
0D88-7E          I  1876 (  6)         LD      A,(HL)          ; Get sign of STEP
0D89-23          I  1877 (  4)         INC     HL
0D8A-F5          I  1878 ( 11)         PUSH    AF              ; Save sign of STEP
0D8B-D5          I  1879 ( 11)         PUSH    DE              ; Save index address
0D8C-CD E2 17    I  1880 ( 16)         CALL    PHLTFP          ; Move index value to FPREG
0D8F-E3          I  1881 ( 16)         EX      (SP),HL         ; Save address of TO value
0D90-E5          I  1882 ( 11)         PUSH    HL              ; Save address of index
0D91-CD 4F 15    I  1883 ( 16)         CALL    ADDPHL          ; Add STEP to index value
0D94-E1          I  1884 (  9)         POP     HL              ; Restore address of index
0D95-CD FC 17    I  1885 ( 16)         CALL    FPTHL           ; Move value to index variable
0D98-E1          I  1886 (  9)         POP     HL              ; Restore address of TO value
0D99-CD F3 17    I  1887 ( 16)         CALL    LOADFP          ; Move TO value to BCDE
0D9C-E5          I  1888 ( 11)         PUSH    HL              ; Save address of line of FOR
0D9D-CD 1F 18    I  1889 ( 16)         CALL    CMPNUM          ; Compare index with TO value
0DA0-E1          I  1890 (  9)         POP     HL              ; Restore address of line num
0DA1-C1          I  1891 (  9)         POP     BC              ; Address of sign of STEP
0DA2-90          I  1892 (  4)         SUB     B               ; Compare with expected sign
0DA3-CD F3 17    I  1893 ( 16)         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
0DA6-CA B2 0D    I  1894 ( 6+)         JP      Z,KILFOR        ; Loop finished - Terminate it
0DA9-EB          I  1895 (  3)         EX      DE,HL           ; Loop statement line number
0DAA-22 A1 22    I  1896 ( 20)         LD      (LINEAT),HL     ; Set loop line number
0DAD-69          I  1897 (  4)         LD      L,C             ; Set code string to loop
0DAE-60          I  1898 (  4)         LD      H,B
0DAF-C3 11 09    I  1899 (  9)         JP      PUTFID          ; Put back "FOR" and continue
0DB2-            I  1900
0DB2-F9          I  1901 (  4) KILFOR: LD      SP,HL           ; Remove "FOR" block
0DB3-2A 13 23    I  1902 ( 15)         LD      HL,(BRKLIN)     ; Code string after "NEXT"
0DB6-7E          I  1903 (  6)         LD      A,(HL)          ; Get next byte in code string
0DB7-FE 2C       I  1904 (  6)         CP      ','             ; More NEXTs ?
0DB9-C2 15 09    I  1905 ( 6+)         JP      NZ,RUNCNT       ; No - Do next statement
0DBC-CD 55 09    I  1906 ( 16)         CALL    GETCHR          ; Position to index name
0DBF-CD 7A 0D    I  1907 ( 16)         CALL    NEXT1           ; Re-enter NEXT routine
0DC2-            I  1908       ; < will not RETurn to here , Exit to RUNCNT or Loop >
0DC2-            I  1909
0DC2-CD D4 0D    I  1910 ( 16) GETNUM: CALL    EVAL            ; Get a numeric expression
0DC5-F6          I  1911       TSTNUM: .DB      0F6H            ; Clear carry (numeric)
0DC6-37          I  1912 (  3) TSTSTR: SCF                     ; Set carry (string)
0DC7-3A F2 22    I  1913 ( 12) CHKTYP: LD      A,(TYPE)        ; Check types match
0DCA-8F          I  1914 (  4)         ADC     A,A             ; Expected + actual
0DCB-B7          I  1915 (  4)         OR      A               ; Clear carry , set parity
0DCC-E8          I  1916 ( 5+)         RET     PE              ; Even parity - Types match
0DCD-C3 0F 05    I  1917 (  9)         JP      TMERR           ; Different types - Error
0DD0-            I  1918
0DD0-CD CB 07    I  1919 ( 16) OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
0DD3-28          I  1920               .DB   "("
0DD4-2B          I  1921 (  4) EVAL:   DEC     HL              ; Evaluate expression & save
0DD5-16 00       I  1922 (  6)         LD      D,0             ; Precedence value
0DD7-D5          I  1923 ( 11) EVAL1:  PUSH    DE              ; Save precedence
0DD8-0E 01       I  1924 (  6)         LD      C,1
0DDA-CD DA 04    I  1925 ( 16)         CALL    CHKSTK          ; Check for 1 level of stack
0DDD-CD 4B 0E    I  1926 ( 16)         CALL    OPRND           ; Get next expression value
0DE0-22 15 23    I  1927 ( 20) EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
0DE3-2A 15 23    I  1928 ( 15) EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
0DE6-C1          I  1929 (  9)         POP     BC              ; Precedence value and operator
0DE7-78          I  1930 (  4)         LD      A,B             ; Get precedence value
0DE8-FE 78       I  1931 (  6)         CP      78H             ; "AND" or "OR" ?
0DEA-D4 C5 0D    I  1932 ( 6+)         CALL    NC,TSTNUM       ; No - Make sure it's a number
0DED-7E          I  1933 (  6)         LD      A,(HL)          ; Get next operator / function
0DEE-16 00       I  1934 (  6)         LD      D,0             ; Clear Last relation
0DF0-D6 B3       I  1935 (  6) RLTLP:  SUB     ZGTR            ; ">" Token
0DF2-DA 0C 0E    I  1936 ( 6+)         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
0DF5-FE 03       I  1937 (  6)         CP      ZLTH+1-ZGTR     ; < = >
0DF7-D2 0C 0E    I  1938 ( 6+)         JP      NC,FOPRND       ; Function - Call it
0DFA-FE 01       I  1939 (  6)         CP      ZEQUAL-ZGTR     ; "="
0DFC-17          I  1940 (  3)         RLA                     ; <- Test for legal
0DFD-AA          I  1941 (  4)         XOR     D               ; <- combinations of < = >
0DFE-BA          I  1942 (  4)         CP      D               ; <- by combining last token
0DFF-57          I  1943 (  4)         LD      D,A             ; <- with current one
0E00-DA FD 04    I  1944 ( 6+)         JP      C,SNERR         ; Error if "<<' '==" or ">>"
0E03-22 0A 23    I  1945 ( 20)         LD      (CUROPR),HL     ; Save address of current token
0E06-CD 55 09    I  1946 ( 16)         CALL    GETCHR          ; Get next character
0E09-C3 F0 0D    I  1947 (  9)         JP      RLTLP           ; Treat the two as one
0E0C-            I  1948
0E0C-7A          I  1949 (  4) FOPRND: LD      A,D             ; < = > found ?
0E0D-B7          I  1950 (  4)         OR      A
0E0E-C2 33 0F    I  1951 ( 6+)         JP      NZ,TSTRED       ; Yes - Test for reduction
0E11-7E          I  1952 (  6)         LD      A,(HL)          ; Get operator token
0E12-22 0A 23    I  1953 ( 20)         LD      (CUROPR),HL     ; Save operator address
0E15-D6 AC       I  1954 (  6)         SUB     ZPLUS           ; Operator or function?
0E17-D8          I  1955 ( 5+)         RET     C               ; Neither - Exit
0E18-FE 07       I  1956 (  6)         CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
0E1A-D0          I  1957 ( 5+)         RET     NC              ; No - Exit
0E1B-5F          I  1958 (  4)         LD      E,A             ; Coded operator
0E1C-3A F2 22    I  1959 ( 12)         LD      A,(TYPE)        ; Get data type
0E1F-3D          I  1960 (  4)         DEC     A               ; FF = numeric , 00 = string
0E20-B3          I  1961 (  4)         OR      E               ; Combine with coded operator
0E21-7B          I  1962 (  4)         LD      A,E             ; Get coded operator
0E22-CA 91 13    I  1963 ( 6+)         JP      Z,CONCAT        ; String concatenation
0E25-07          I  1964 (  3)         RLCA                    ; Times 2
0E26-83          I  1965 (  4)         ADD     A,E             ; Times 3
0E27-5F          I  1966 (  4)         LD      E,A             ; To DE (D is 0)
0E28-21 EF 03    I  1967 (  9)         LD      HL,PRITAB       ; Precedence table
0E2B-19          I  1968 (  7)         ADD     HL,DE           ; To the operator concerned
0E2C-78          I  1969 (  4)         LD      A,B             ; Last operator precedence
0E2D-56          I  1970 (  6)         LD      D,(HL)          ; Get evaluation precedence
0E2E-BA          I  1971 (  4)         CP      D               ; Compare with eval precedence
0E2F-D0          I  1972 ( 5+)         RET     NC              ; Exit if higher precedence
0E30-23          I  1973 (  4)         INC     HL              ; Point to routine address
0E31-CD C5 0D    I  1974 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0E34-            I  1975
0E34-C5          I  1976 ( 11) STKTHS: PUSH    BC              ; Save last precedence & token
0E35-01 E3 0D    I  1977 (  9)         LD      BC,EVAL3        ; Where to go on prec' break
0E38-C5          I  1978 ( 11)         PUSH    BC              ; Save on stack for return
0E39-43          I  1979 (  4)         LD      B,E             ; Save operator
0E3A-4A          I  1980 (  4)         LD      C,D             ; Save precedence
0E3B-CD D5 17    I  1981 ( 16)         CALL    STAKFP          ; Move value to stack
0E3E-58          I  1982 (  4)         LD      E,B             ; Restore operator
0E3F-51          I  1983 (  4)         LD      D,C             ; Restore precedence
0E40-4E          I  1984 (  6)         LD      C,(HL)          ; Get LSB of routine address
0E41-23          I  1985 (  4)         INC     HL
0E42-46          I  1986 (  6)         LD      B,(HL)          ; Get MSB of routine address
0E43-23          I  1987 (  4)         INC     HL
0E44-C5          I  1988 ( 11)         PUSH    BC              ; Save routine address
0E45-2A 0A 23    I  1989 ( 15)         LD      HL,(CUROPR)     ; Address of current operator
0E48-C3 D7 0D    I  1990 (  9)         JP      EVAL1           ; Loop until prec' break
0E4B-            I  1991
0E4B-AF          I  1992 (  4) OPRND:  XOR     A               ; Get operand routine
0E4C-32 F2 22    I  1993 ( 13)         LD      (TYPE),A        ; Set numeric expected
0E4F-CD 55 09    I  1994 ( 16)         CALL    GETCHR          ; Get next character
0E52-1E 24       I  1995 (  6)         LD      E,MO            ; ?MO Error
0E54-CA 11 05    I  1996 ( 6+)         JP      Z,ERROR         ; No operand - Error
0E57-DA AB 18    I  1997 ( 6+)         JP      C,ASCTFP        ; Number - Get value
0E5A-CD F3 09    I  1998 ( 16)         CALL    CHKLTR          ; See if a letter
0E5D-D2 B2 0E    I  1999 ( 6+)         JP      NC,CONVAR       ; Letter - Find variable
0E60-FE 26       I  2000 (  6)         CP      '&'                             ; &H = HEX, &B = BINARY
0E62-20 12       I  2001 ( 6+)         JR      NZ,NOTAMP
0E64-CD 55 09    I  2002 ( 16)         CALL    GETCHR          ; Get next character
0E67-FE 48       I  2003 (  6)         CP      'H'             ; Hex number indicated? [function added]
0E69-CA EF 1C    I  2004 ( 6+)         JP      Z,HEXTFP        ; Convert Hex to FPREG
0E6C-FE 42       I  2005 (  6)         CP      'B'             ; Binary number indicated? [function added]
0E6E-CA 5F 1D    I  2006 ( 6+)         JP      Z,BINTFP        ; Convert Bin to FPREG
0E71-1E 02       I  2007 (  6)         LD      E,SN            ; If neither then a ?SN Error
0E73-CA 11 05    I  2008 ( 6+)         JP      Z,ERROR         ;
0E76-FE AC       I  2009 (  6) NOTAMP: CP      ZPLUS           ; '+' Token ?
0E78-CA 4B 0E    I  2010 ( 6+)         JP      Z,OPRND         ; Yes - Look for operand
0E7B-FE 2E       I  2011 (  6)         CP      '.'             ; '.' ?
0E7D-CA AB 18    I  2012 ( 6+)         JP      Z,ASCTFP        ; Yes - Create FP number
0E80-FE AD       I  2013 (  6)         CP      ZMINUS          ; '-' Token ?
0E82-CA A1 0E    I  2014 ( 6+)         JP      Z,MINUS         ; Yes - Do minus
0E85-FE 22       I  2015 (  6)         CP      '"'             ; Literal string ?
0E87-CA 5A 12    I  2016 ( 6+)         JP      Z,QTSTR         ; Get string terminated by '"'
0E8A-FE AA       I  2017 (  6)         CP      ZNOT            ; "NOT" Token ?
0E8C-CA 93 0F    I  2018 ( 6+)         JP      Z,EVNOT         ; Yes - Eval NOT expression
0E8F-FE A7       I  2019 (  6)         CP      ZFN             ; "FN" Token ?
0E91-CA BE 11    I  2020 ( 6+)         JP      Z,DOFN          ; Yes - Do FN routine
0E94-D6 B6       I  2021 (  6)         SUB     ZSGN            ; Is it a function?
0E96-D2 C3 0E    I  2022 ( 6+)         JP      NC,FNOFST       ; Yes - Evaluate function
0E99-CD D0 0D    I  2023 ( 16) EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
0E9C-CD CB 07    I  2024 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
0E9F-29          I  2025               .DB   ")"
0EA0-C9          I  2026 (  9)         RET
0EA1-            I  2027
0EA1-16 7D       I  2028 (  6) MINUS:  LD      D,7DH           ; '-' precedence
0EA3-CD D7 0D    I  2029 ( 16)         CALL    EVAL1           ; Evaluate until prec' break
0EA6-2A 15 23    I  2030 ( 15)         LD      HL,(NXTOPR)     ; Get next operator address
0EA9-E5          I  2031 ( 11)         PUSH    HL              ; Save next operator address
0EAA-CD CD 17    I  2032 ( 16)         CALL    INVSGN          ; Negate value
0EAD-CD C5 0D    I  2033 ( 16) RETNUM: CALL    TSTNUM          ; Make sure it's a number
0EB0-E1          I  2034 (  9)         POP     HL              ; Restore next operator address
0EB1-C9          I  2035 (  9)         RET
0EB2-            I  2036
0EB2-CD B8 0F    I  2037 ( 16) CONVAR: CALL    GETVAR          ; Get variable address to DE
0EB5-E5          I  2038 ( 11) FRMEVL: PUSH    HL              ; Save code string address
0EB6-EB          I  2039 (  3)         EX      DE,HL           ; Variable address to HL
0EB7-22 29 23    I  2040 ( 20)         LD      (FPREG),HL      ; Save address of variable
0EBA-3A F2 22    I  2041 ( 12)         LD      A,(TYPE)        ; Get type
0EBD-B7          I  2042 (  4)         OR      A               ; Numeric?
0EBE-CC E2 17    I  2043 ( 6+)         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
0EC1-E1          I  2044 (  9)         POP     HL              ; Restore code string address
0EC2-C9          I  2045 (  9)         RET
0EC3-            I  2046
0EC3-06 00       I  2047 (  6) FNOFST: LD      B,0             ; Get address of function
0EC5-07          I  2048 (  3)         RLCA                    ; Double function offset
0EC6-4F          I  2049 (  4)         LD      C,A             ; BC = Offset in function table
0EC7-C5          I  2050 ( 11)         PUSH    BC              ; Save adjusted token value
0EC8-CD 55 09    I  2051 ( 16)         CALL    GETCHR          ; Get next character
0ECB-79          I  2052 (  4)         LD      A,C             ; Get adjusted token value
0ECC-FE 31       I  2053 (  6)         CP      031H ; 2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT$ or MID$ ?
0ECE-DA EA 0E    I  2054 ( 6+)         JP      C,FNVAL         ; No - Do function
0ED1-CD D0 0D    I  2055 ( 16)         CALL    OPNPAR          ; Evaluate expression  (X,...
0ED4-CD CB 07    I  2056 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
0ED7-2C          I  2057               .DB      ','
0ED8-CD C6 0D    I  2058 ( 16)         CALL    TSTSTR          ; Make sure it's a string
0EDB-EB          I  2059 (  3)         EX      DE,HL           ; Save code string address
0EDC-2A 29 23    I  2060 ( 15)         LD      HL,(FPREG)      ; Get address of string
0EDF-E3          I  2061 ( 16)         EX      (SP),HL         ; Save address of string
0EE0-E5          I  2062 ( 11)         PUSH    HL              ; Save adjusted token value
0EE1-EB          I  2063 (  3)         EX      DE,HL           ; Restore code string address
0EE2-CD 23 15    I  2064 ( 16)         CALL    GETINT          ; Get integer 0-255
0EE5-EB          I  2065 (  3)         EX      DE,HL           ; Save code string address
0EE6-E3          I  2066 ( 16)         EX      (SP),HL         ; Save integer,HL = adj' token
0EE7-C3 F2 0E    I  2067 (  9)         JP      GOFUNC          ; Jump to string function
0EEA-            I  2068
0EEA-CD 99 0E    I  2069 ( 16) FNVAL:  CALL    EVLPAR          ; Evaluate expression
0EED-E3          I  2070 ( 16)         EX      (SP),HL         ; HL = Adjusted token value
0EEE-11 AD 0E    I  2071 (  9)         LD      DE,RETNUM       ; Return number from function
0EF1-D5          I  2072 ( 11)         PUSH    DE              ; Save on stack
0EF2-01 4E 02    I  2073 (  9) GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
0EF5-09          I  2074 (  7)         ADD     HL,BC           ; Point to right address
0EF6-4E          I  2075 (  6)         LD      C,(HL)          ; Get LSB of address
0EF7-23          I  2076 (  4)         INC     HL              ;
0EF8-66          I  2077 (  6)         LD      H,(HL)          ; Get MSB of address
0EF9-69          I  2078 (  4)         LD      L,C             ; Address to HL
0EFA-E9          I  2079 (  3)         JP      (HL)            ; Jump to function
0EFB-            I  2080
0EFB-15          I  2081 (  4) SGNEXP: DEC     D               ; Dee to flag negative exponent
0EFC-FE AD       I  2082 (  6)         CP      ZMINUS          ; '-' token ?
0EFE-C8          I  2083 ( 5+)         RET     Z               ; Yes - Return
0EFF-FE 2D       I  2084 (  6)         CP      '-'             ; '-' ASCII ?
0F01-C8          I  2085 ( 5+)         RET     Z               ; Yes - Return
0F02-14          I  2086 (  4)         INC     D               ; Inc to flag positive exponent
0F03-FE 2B       I  2087 (  6)         CP      '+'             ; '+' ASCII ?
0F05-C8          I  2088 ( 5+)         RET     Z               ; Yes - Return
0F06-FE AC       I  2089 (  6)         CP      ZPLUS           ; '+' token ?
0F08-C8          I  2090 ( 5+)         RET     Z               ; Yes - Return
0F09-2B          I  2091 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
0F0A-C9          I  2092 (  9)         RET                     ; Return "NZ"
0F0B-            I  2093
0F0B-F6          I  2094       POR:    .DB      0F6H            ; Flag "OR"
0F0C-AF          I  2095 (  4) PAND:   XOR     A               ; Flag "AND"
0F0D-F5          I  2096 ( 11)         PUSH    AF              ; Save "AND" / "OR" flag
0F0E-CD C5 0D    I  2097 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0F11-CD 07 0A    I  2098 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
0F14-F1          I  2099 (  9)         POP     AF              ; Restore "AND" / "OR" flag
0F15-EB          I  2100 (  3)         EX      DE,HL           ; <- Get last
0F16-C1          I  2101 (  9)         POP     BC              ; <-  value
0F17-E3          I  2102 ( 16)         EX      (SP),HL         ; <-  from
0F18-EB          I  2103 (  3)         EX      DE,HL           ; <-  stack
0F19-CD E5 17    I  2104 ( 16)         CALL    FPBCDE          ; Move last value to FPREG
0F1C-F5          I  2105 ( 11)         PUSH    AF              ; Save "AND" / "OR" flag
0F1D-CD 07 0A    I  2106 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
0F20-F1          I  2107 (  9)         POP     AF              ; Restore "AND" / "OR" flag
0F21-C1          I  2108 (  9)         POP     BC              ; Get value
0F22-79          I  2109 (  4)         LD      A,C             ; Get LSB
0F23-21 7C 11    I  2110 (  9)         LD      HL,ACPASS       ; Address of save AC as current
0F26-C2 2E 0F    I  2111 ( 6+)         JP      NZ,POR1         ; Jump if OR
0F29-A3          I  2112 (  4)         AND     E               ; "AND" LSBs
0F2A-4F          I  2113 (  4)         LD      C,A             ; Save LSB
0F2B-78          I  2114 (  4)         LD      A,B             ; Get MBS
0F2C-A2          I  2115 (  4)         AND     D               ; "AND" MSBs
0F2D-E9          I  2116 (  3)         JP      (HL)            ; Save AC as current (ACPASS)
0F2E-            I  2117
0F2E-B3          I  2118 (  4) POR1:   OR      E               ; "OR" LSBs
0F2F-4F          I  2119 (  4)         LD      C,A             ; Save LSB
0F30-78          I  2120 (  4)         LD      A,B             ; Get MSB
0F31-B2          I  2121 (  4)         OR      D               ; "OR" MSBs
0F32-E9          I  2122 (  3)         JP      (HL)            ; Save AC as current (ACPASS)
0F33-            I  2123
0F33-21 45 0F    I  2124 (  9) TSTRED: LD      HL,CMPLOG       ; Logical compare routine
0F36-3A F2 22    I  2125 ( 12)         LD      A,(TYPE)        ; Get data type
0F39-1F          I  2126 (  3)         RRA                     ; Carry set = string
0F3A-7A          I  2127 (  4)         LD      A,D             ; Get last precedence value
0F3B-17          I  2128 (  3)         RLA                     ; Times 2 plus carry
0F3C-5F          I  2129 (  4)         LD      E,A             ; To E
0F3D-16 64       I  2130 (  6)         LD      D,64H           ; Relational precedence
0F3F-78          I  2131 (  4)         LD      A,B             ; Get current precedence
0F40-BA          I  2132 (  4)         CP      D               ; Compare with last
0F41-D0          I  2133 ( 5+)         RET     NC              ; Eval if last was rel' or log'
0F42-C3 34 0E    I  2134 (  9)         JP      STKTHS          ; Stack this one and get next
0F45-            I  2135
0F45-47 0F       I  2136       CMPLOG: .DW   CMPLG1          ; Compare two values / strings
0F47-79          I  2137 (  4) CMPLG1: LD      A,C             ; Get data type
0F48-B7          I  2138 (  4)         OR      A
0F49-1F          I  2139 (  3)         RRA
0F4A-C1          I  2140 (  9)         POP     BC              ; Get last expression to BCDE
0F4B-D1          I  2141 (  9)         POP     DE
0F4C-F5          I  2142 ( 11)         PUSH    AF              ; Save status
0F4D-CD C7 0D    I  2143 ( 16)         CALL    CHKTYP          ; Check that types match
0F50-21 89 0F    I  2144 (  9)         LD      HL,CMPRES       ; Result to comparison
0F53-E5          I  2145 ( 11)         PUSH    HL              ; Save for RETurn
0F54-CA 1F 18    I  2146 ( 6+)         JP      Z,CMPNUM        ; Compare values if numeric
0F57-AF          I  2147 (  4)         XOR     A               ; Compare two strings
0F58-32 F2 22    I  2148 ( 13)         LD      (TYPE),A        ; Set type to numeric
0F5B-D5          I  2149 ( 11)         PUSH    DE              ; Save string name
0F5C-CD DE 13    I  2150 ( 16)         CALL    GSTRCU          ; Get current string
0F5F-7E          I  2151 (  6)         LD      A,(HL)          ; Get length of string
0F60-23          I  2152 (  4)         INC     HL
0F61-23          I  2153 (  4)         INC     HL
0F62-4E          I  2154 (  6)         LD      C,(HL)          ; Get LSB of address
0F63-23          I  2155 (  4)         INC     HL
0F64-46          I  2156 (  6)         LD      B,(HL)          ; Get MSB of address
0F65-D1          I  2157 (  9)         POP     DE              ; Restore string name
0F66-C5          I  2158 ( 11)         PUSH    BC              ; Save address of string
0F67-F5          I  2159 ( 11)         PUSH    AF              ; Save length of string
0F68-CD E2 13    I  2160 ( 16)         CALL    GSTRDE          ; Get second string
0F6B-CD F3 17    I  2161 ( 16)         CALL    LOADFP          ; Get address of second string
0F6E-F1          I  2162 (  9)         POP     AF              ; Restore length of string 1
0F6F-57          I  2163 (  4)         LD      D,A             ; Length to D
0F70-E1          I  2164 (  9)         POP     HL              ; Restore address of string 1
0F71-7B          I  2165 (  4) CMPSTR: LD      A,E             ; Bytes of string 2 to do
0F72-B2          I  2166 (  4)         OR      D               ; Bytes of string 1 to do
0F73-C8          I  2167 ( 5+)         RET     Z               ; Exit if all bytes compared
0F74-7A          I  2168 (  4)         LD      A,D             ; Get bytes of string 1 to do
0F75-D6 01       I  2169 (  6)         SUB     1
0F77-D8          I  2170 ( 5+)         RET     C               ; Exit if end of string 1
0F78-AF          I  2171 (  4)         XOR     A
0F79-BB          I  2172 (  4)         CP      E               ; Bytes of string 2 to do
0F7A-3C          I  2173 (  4)         INC     A
0F7B-D0          I  2174 ( 5+)         RET     NC              ; Exit if end of string 2
0F7C-15          I  2175 (  4)         DEC     D               ; Count bytes in string 1
0F7D-1D          I  2176 (  4)         DEC     E               ; Count bytes in string 2
0F7E-0A          I  2177 (  6)         LD      A,(BC)          ; Byte in string 2
0F7F-BE          I  2178 (  6)         CP      (HL)            ; Compare to byte in string 1
0F80-23          I  2179 (  4)         INC     HL              ; Move up string 1
0F81-03          I  2180 (  4)         INC     BC              ; Move up string 2
0F82-CA 71 0F    I  2181 ( 6+)         JP      Z,CMPSTR        ; Same - Try next bytes
0F85-3F          I  2182 (  3)         CCF                     ; Flag difference (">" or "<")
0F86-C3 AF 17    I  2183 (  9)         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
0F89-            I  2184
0F89-3C          I  2185 (  4) CMPRES: INC     A               ; Increment current value
0F8A-8F          I  2186 (  4)         ADC     A,A             ; Double plus carry
0F8B-C1          I  2187 (  9)         POP     BC              ; Get other value
0F8C-A0          I  2188 (  4)         AND     B               ; Combine them
0F8D-C6 FF       I  2189 (  6)         ADD     A,-1            ; Carry set if different
0F8F-9F          I  2190 (  4)         SBC     A,A             ; 00 - Equal , FF - Different
0F90-C3 B6 17    I  2191 (  9)         JP      FLGREL          ; Set current value & continue
0F93-            I  2192
0F93-16 5A       I  2193 (  6) EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
0F95-CD D7 0D    I  2194 ( 16)         CALL    EVAL1           ; Eval until precedence break
0F98-CD C5 0D    I  2195 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0F9B-CD 07 0A    I  2196 ( 16)         CALL    DEINT           ; Get integer -32768 - 32767
0F9E-7B          I  2197 (  4)         LD      A,E             ; Get LSB
0F9F-2F          I  2198 (  3)         CPL                     ; Invert LSB
0FA0-4F          I  2199 (  4)         LD      C,A             ; Save "NOT" of LSB
0FA1-7A          I  2200 (  4)         LD      A,D             ; Get MSB
0FA2-2F          I  2201 (  3)         CPL                     ; Invert MSB
0FA3-CD 7C 11    I  2202 ( 16)         CALL    ACPASS          ; Save AC as current
0FA6-C1          I  2203 (  9)         POP     BC              ; Clean up stack
0FA7-C3 E3 0D    I  2204 (  9)         JP      EVAL3           ; Continue evaluation
0FAA-            I  2205
0FAA-2B          I  2206 (  4) DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
0FAB-CD 55 09    I  2207 ( 16)         CALL    GETCHR          ; Get next character
0FAE-C8          I  2208 ( 5+)         RET     Z               ; End of DIM statement
0FAF-CD CB 07    I  2209 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
0FB2-2C          I  2210               .DB      ','
0FB3-01 AA 0F    I  2211 (  9) DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
0FB6-C5          I  2212 ( 11)         PUSH    BC              ; Save on stack
0FB7-F6          I  2213               .DB      0F6H            ; Flag "Create" variable
0FB8-AF          I  2214 (  4) GETVAR: XOR     A               ; Find variable address,to DE
0FB9-32 F1 22    I  2215 ( 13)         LD      (LCRFLG),A      ; Set locate / create flag
0FBC-46          I  2216 (  6)         LD      B,(HL)          ; Get First byte of name
0FBD-CD F3 09    I  2217 ( 16) GTFNAM: CALL    CHKLTR          ; See if a letter
0FC0-DA FD 04    I  2218 ( 6+)         JP      C,SNERR         ; ?SN Error if not a letter
0FC3-AF          I  2219 (  4)         XOR     A
0FC4-4F          I  2220 (  4)         LD      C,A             ; Clear second byte of name
0FC5-32 F2 22    I  2221 ( 13)         LD      (TYPE),A        ; Set type to numeric
0FC8-CD 55 09    I  2222 ( 16)         CALL    GETCHR          ; Get next character
0FCB-DA D4 0F    I  2223 ( 6+)         JP      C,SVNAM2        ; Numeric - Save in name
0FCE-CD F3 09    I  2224 ( 16)         CALL    CHKLTR          ; See if a letter
0FD1-DA E1 0F    I  2225 ( 6+)         JP      C,CHARTY        ; Not a letter - Check type
0FD4-4F          I  2226 (  4) SVNAM2: LD      C,A             ; Save second byte of name
0FD5-CD 55 09    I  2227 ( 16) ENDNAM: CALL    GETCHR          ; Get next character
0FD8-DA D5 0F    I  2228 ( 6+)         JP      C,ENDNAM        ; Numeric - Get another
0FDB-CD F3 09    I  2229 ( 16)         CALL    CHKLTR          ; See if a letter
0FDE-D2 D5 0F    I  2230 ( 6+)         JP      NC,ENDNAM       ; Letter - Get another
0FE1-D6 24       I  2231 (  6) CHARTY: SUB     '$'             ; String variable?
0FE3-C2 F0 0F    I  2232 ( 6+)         JP      NZ,NOTSTR       ; No - Numeric variable
0FE6-3C          I  2233 (  4)         INC     A               ; A = 1 (string type)
0FE7-32 F2 22    I  2234 ( 13)         LD      (TYPE),A        ; Set type to string
0FEA-0F          I  2235 (  3)         RRCA                    ; A = 80H , Flag for string
0FEB-81          I  2236 (  4)         ADD     A,C             ; 2nd byte of name has bit 7 on
0FEC-4F          I  2237 (  4)         LD      C,A             ; Resave second byte on name
0FED-CD 55 09    I  2238 ( 16)         CALL    GETCHR          ; Get next character
0FF0-3A 10 23    I  2239 ( 12) NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
0FF3-3D          I  2240 (  4)         DEC     A
0FF4-CA 9D 10    I  2241 ( 6+)         JP      Z,ARLDSV        ; Yes - Get array name
0FF7-F2 00 10    I  2242 ( 6+)         JP      P,NSCFOR        ; No array with "FOR" or "FN"
0FFA-7E          I  2243 (  6)         LD      A,(HL)          ; Get byte again
0FFB-D6 28       I  2244 (  6)         SUB     '('             ; Subscripted variable?
0FFD-CA 75 10    I  2245 ( 6+)         JP      Z,SBSCPT        ; Yes - Sort out subscript
1000-            I  2246
1000-AF          I  2247 (  4) NSCFOR: XOR     A               ; Simple variable
1001-32 10 23    I  2248 ( 13)         LD      (FORFLG),A      ; Clear "FOR" flag
1004-E5          I  2249 ( 11)         PUSH    HL              ; Save code string address
1005-50          I  2250 (  4)         LD      D,B             ; DE = Variable name to find
1006-59          I  2251 (  4)         LD      E,C
1007-2A 23 23    I  2252 ( 15)         LD      HL,(FNRGNM)     ; FN argument name
100A-CD C5 07    I  2253 ( 16)         CALL    CPDEHL          ; Is it the FN argument?
100D-11 25 23    I  2254 (  9)         LD      DE,FNARG        ; Point to argument value
1010-CA E5 16    I  2255 ( 6+)         JP      Z,POPHRT        ; Yes - Return FN argument value
1013-2A 1D 23    I  2256 ( 15)         LD      HL,(VAREND)     ; End of variables
1016-EB          I  2257 (  3)         EX      DE,HL           ; Address of end of search
1017-2A 1B 23    I  2258 ( 15)         LD      HL,(PROGND)     ; Start of variables address
101A-CD C5 07    I  2259 ( 16) FNDVAR: CALL    CPDEHL          ; End of variable list table?
101D-CA 33 10    I  2260 ( 6+)         JP      Z,CFEVAL        ; Yes - Called from EVAL?
1020-79          I  2261 (  4)         LD      A,C             ; Get second byte of name
1021-96          I  2262 (  6)         SUB     (HL)            ; Compare with name in list
1022-23          I  2263 (  4)         INC     HL              ; Move on to first byte
1023-C2 28 10    I  2264 ( 6+)         JP      NZ,FNTHR        ; Different - Find another
1026-78          I  2265 (  4)         LD      A,B             ; Get first byte of name
1027-96          I  2266 (  6)         SUB     (HL)            ; Compare with name in list
1028-23          I  2267 (  4) FNTHR:  INC     HL              ; Move on to LSB of value
1029-CA 67 10    I  2268 ( 6+)         JP      Z,RETADR        ; Found - Return address
102C-23          I  2269 (  4)         INC     HL              ; <- Skip
102D-23          I  2270 (  4)         INC     HL              ; <- over
102E-23          I  2271 (  4)         INC     HL              ; <- F.P.
102F-23          I  2272 (  4)         INC     HL              ; <- value
1030-C3 1A 10    I  2273 (  9)         JP      FNDVAR          ; Keep looking
1033-            I  2274
1033-E1          I  2275 (  9) CFEVAL: POP     HL              ; Restore code string address
1034-E3          I  2276 ( 16)         EX      (SP),HL         ; Get return address
1035-D5          I  2277 ( 11)         PUSH    DE              ; Save address of variable
1036-11 B5 0E    I  2278 (  9)         LD      DE,FRMEVL       ; Return address in EVAL
1039-CD C5 07    I  2279 ( 16)         CALL    CPDEHL          ; Called from EVAL ?
103C-D1          I  2280 (  9)         POP     DE              ; Restore address of variable
103D-CA 6A 10    I  2281 ( 6+)         JP      Z,RETNUL        ; Yes - Return null variable
1040-E3          I  2282 ( 16)         EX      (SP),HL         ; Put back return
1041-E5          I  2283 ( 11)         PUSH    HL              ; Save code string address
1042-C5          I  2284 ( 11)         PUSH    BC              ; Save variable name
1043-01 06 00    I  2285 (  9)         LD      BC,6            ; 2 byte name plus 4 byte data
1046-2A 1F 23    I  2286 ( 15)         LD      HL,(ARREND)     ; End of arrays
1049-E5          I  2287 ( 11)         PUSH    HL              ; Save end of arrays
104A-09          I  2288 (  7)         ADD     HL,BC           ; Move up 6 bytes
104B-C1          I  2289 (  9)         POP     BC              ; Source address in BC
104C-E5          I  2290 ( 11)         PUSH    HL              ; Save new end address
104D-CD C9 04    I  2291 ( 16)         CALL    MOVUP           ; Move arrays up
1050-E1          I  2292 (  9)         POP     HL              ; Restore new end address
1051-22 1F 23    I  2293 ( 20)         LD      (ARREND),HL     ; Set new end address
1054-60          I  2294 (  4)         LD      H,B             ; End of variables to HL
1055-69          I  2295 (  4)         LD      L,C
1056-22 1D 23    I  2296 ( 20)         LD      (VAREND),HL     ; Set new end address
1059-            I  2297
1059-2B          I  2298 (  4) ZEROLP: DEC     HL              ; Back through to zero variable
105A-36 00       I  2299 (  9)         LD      (HL),0          ; Zero byte in variable
105C-CD C5 07    I  2300 ( 16)         CALL    CPDEHL          ; Done them all?
105F-C2 59 10    I  2301 ( 6+)         JP      NZ,ZEROLP       ; No - Keep on going
1062-D1          I  2302 (  9)         POP     DE              ; Get variable name
1063-73          I  2303 (  7)         LD      (HL),E          ; Store second character
1064-23          I  2304 (  4)         INC     HL
1065-72          I  2305 (  7)         LD      (HL),D          ; Store first character
1066-23          I  2306 (  4)         INC     HL
1067-EB          I  2307 (  3) RETADR: EX      DE,HL           ; Address of variable in DE
1068-E1          I  2308 (  9)         POP     HL              ; Restore code string address
1069-C9          I  2309 (  9)         RET
106A-            I  2310
106A-32 2C 23    I  2311 ( 13) RETNUL: LD      (FPEXP),A       ; Set result to zero
106D-21 99 04    I  2312 (  9)         LD      HL,ZERBYT       ; Also set a null string
1070-22 29 23    I  2313 ( 20)         LD      (FPREG),HL      ; Save for EVAL
1073-E1          I  2314 (  9)         POP     HL              ; Restore code string address
1074-C9          I  2315 (  9)         RET
1075-            I  2316
1075-E5          I  2317 ( 11) SBSCPT: PUSH    HL              ; Save code string address
1076-2A F1 22    I  2318 ( 15)         LD      HL,(LCRFLG)     ; Locate/Create and Type
1079-E3          I  2319 ( 16)         EX      (SP),HL         ; Save and get code string
107A-57          I  2320 (  4)         LD      D,A             ; Zero number of dimensions
107B-D5          I  2321 ( 11) SCPTLP: PUSH    DE              ; Save number of dimensions
107C-C5          I  2322 ( 11)         PUSH    BC              ; Save array name
107D-CD FB 09    I  2323 ( 16)         CALL    FPSINT          ; Get subscript (0-32767)
1080-C1          I  2324 (  9)         POP     BC              ; Restore array name
1081-F1          I  2325 (  9)         POP     AF              ; Get number of dimensions
1082-EB          I  2326 (  3)         EX      DE,HL
1083-E3          I  2327 ( 16)         EX      (SP),HL         ; Save subscript value
1084-E5          I  2328 ( 11)         PUSH    HL              ; Save LCRFLG and TYPE
1085-EB          I  2329 (  3)         EX      DE,HL
1086-3C          I  2330 (  4)         INC     A               ; Count dimensions
1087-57          I  2331 (  4)         LD      D,A             ; Save in D
1088-7E          I  2332 (  6)         LD      A,(HL)          ; Get next byte in code string
1089-FE 2C       I  2333 (  6)         CP      ','             ; Comma (more to come)?
108B-CA 7B 10    I  2334 ( 6+)         JP      Z,SCPTLP        ; Yes - More subscripts
108E-CD CB 07    I  2335 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
1091-29          I  2336               .DB      ")"
1092-22 15 23    I  2337 ( 20)         LD      (NXTOPR),HL     ; Save code string address
1095-E1          I  2338 (  9)         POP     HL              ; Get LCRFLG and TYPE
1096-22 F1 22    I  2339 ( 20)         LD      (LCRFLG),HL     ; Restore Locate/create & type
1099-1E 00       I  2340 (  6)         LD      E,0             ; Flag not CSAVE* or CLOAD*
109B-D5          I  2341 ( 11)         PUSH    DE              ; Save number of dimensions (D)
109C-11          I  2342               .DB      11H             ; Skip "PUSH HL" and "PUSH AF'
109D-            I  2343
109D-E5          I  2344 ( 11) ARLDSV: PUSH    HL              ; Save code string address
109E-F5          I  2345 ( 11)         PUSH    AF              ; A = 00 , Flags set = Z,N
109F-2A 1D 23    I  2346 ( 15)         LD      HL,(VAREND)     ; Start of arrays
10A2-3E          I  2347               .DB      3EH             ; Skip "ADD HL,DE"
10A3-19          I  2348 (  7) FNDARY: ADD     HL,DE           ; Move to next array start
10A4-EB          I  2349 (  3)         EX      DE,HL
10A5-2A 1F 23    I  2350 ( 15)         LD      HL,(ARREND)     ; End of arrays
10A8-EB          I  2351 (  3)         EX      DE,HL           ; Current array pointer
10A9-CD C5 07    I  2352 ( 16)         CALL    CPDEHL          ; End of arrays found?
10AC-CA D5 10    I  2353 ( 6+)         JP      Z,CREARY        ; Yes - Create array
10AF-7E          I  2354 (  6)         LD      A,(HL)          ; Get second byte of name
10B0-B9          I  2355 (  4)         CP      C               ; Compare with name given
10B1-23          I  2356 (  4)         INC     HL              ; Move on
10B2-C2 B7 10    I  2357 ( 6+)         JP      NZ,NXTARY       ; Different - Find next array
10B5-7E          I  2358 (  6)         LD      A,(HL)          ; Get first byte of name
10B6-B8          I  2359 (  4)         CP      B               ; Compare with name given
10B7-23          I  2360 (  4) NXTARY: INC     HL              ; Move on
10B8-5E          I  2361 (  6)         LD      E,(HL)          ; Get LSB of next array address
10B9-23          I  2362 (  4)         INC     HL
10BA-56          I  2363 (  6)         LD      D,(HL)          ; Get MSB of next array address
10BB-23          I  2364 (  4)         INC     HL
10BC-C2 A3 10    I  2365 ( 6+)         JP      NZ,FNDARY       ; Not found - Keep looking
10BF-3A F1 22    I  2366 ( 12)         LD      A,(LCRFLG)      ; Found Locate or Create it?
10C2-B7          I  2367 (  4)         OR      A
10C3-C2 06 05    I  2368 ( 6+)         JP      NZ,DDERR        ; Create - ?DD Error
10C6-F1          I  2369 (  9)         POP     AF              ; Locate - Get number of dim'ns
10C7-44          I  2370 (  4)         LD      B,H             ; BC Points to array dim'ns
10C8-4D          I  2371 (  4)         LD      C,L
10C9-CA E5 16    I  2372 ( 6+)         JP      Z,POPHRT        ; Jump if array load/save
10CC-96          I  2373 (  6)         SUB     (HL)            ; Same number of dimensions?
10CD-CA 33 11    I  2374 ( 6+)         JP      Z,FINDEL        ; Yes - Find element
10D0-1E 10       I  2375 (  6) BSERR:  LD      E,BS            ; ?BS Error
10D2-C3 11 05    I  2376 (  9)         JP      ERROR           ; Output error
10D5-            I  2377
10D5-11 04 00    I  2378 (  9) CREARY: LD      DE,4            ; 4 Bytes per entry
10D8-F1          I  2379 (  9)         POP     AF              ; Array to save or 0 dim'ns?
10D9-CA 1C 0A    I  2380 ( 6+)         JP      Z,FCERR         ; Yes - ?FC Error
10DC-71          I  2381 (  7)         LD      (HL),C          ; Save second byte of name
10DD-23          I  2382 (  4)         INC     HL
10DE-70          I  2383 (  7)         LD      (HL),B          ; Save first byte of name
10DF-23          I  2384 (  4)         INC     HL
10E0-4F          I  2385 (  4)         LD      C,A             ; Number of dimensions to C
10E1-CD DA 04    I  2386 ( 16)         CALL    CHKSTK          ; Check if enough memory
10E4-23          I  2387 (  4)         INC     HL              ; Point to number of dimensions
10E5-23          I  2388 (  4)         INC     HL
10E6-22 0A 23    I  2389 ( 20)         LD      (CUROPR),HL     ; Save address of pointer
10E9-71          I  2390 (  7)         LD      (HL),C          ; Set number of dimensions
10EA-23          I  2391 (  4)         INC     HL
10EB-3A F1 22    I  2392 ( 12)         LD      A,(LCRFLG)      ; Locate of Create?
10EE-17          I  2393 (  3)         RLA                     ; Carry set = Create
10EF-79          I  2394 (  4)         LD      A,C             ; Get number of dimensions
10F0-01 0B 00    I  2395 (  9) CRARLP: LD      BC,10+1         ; Default dimension size 10
10F3-D2 F8 10    I  2396 ( 6+)         JP      NC,DEFSIZ       ; Locate - Set default size
10F6-C1          I  2397 (  9)         POP     BC              ; Get specified dimension size
10F7-03          I  2398 (  4)         INC     BC              ; Include zero element
10F8-71          I  2399 (  7) DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
10F9-23          I  2400 (  4)         INC     HL
10FA-70          I  2401 (  7)         LD      (HL),B          ; Save MSB of dimension size
10FB-23          I  2402 (  4)         INC     HL
10FC-F5          I  2403 ( 11)         PUSH    AF              ; Save num' of dim'ns an status
10FD-E5          I  2404 ( 11)         PUSH    HL              ; Save address of dim'n size
10FE-CD 90 18    I  2405 ( 16)         CALL    MLDEBC          ; Multiply DE by BC to find
1101-EB          I  2406 (  3)         EX      DE,HL           ; amount of mem needed (to DE)
1102-E1          I  2407 (  9)         POP     HL              ; Restore address of dimension
1103-F1          I  2408 (  9)         POP     AF              ; Restore number of dimensions
1104-3D          I  2409 (  4)         DEC     A               ; Count them
1105-C2 F0 10    I  2410 ( 6+)         JP      NZ,CRARLP       ; Do next dimension if more
1108-F5          I  2411 ( 11)         PUSH    AF              ; Save locate/create flag
1109-42          I  2412 (  4)         LD      B,D             ; MSB of memory needed
110A-4B          I  2413 (  4)         LD      C,E             ; LSB of memory needed
110B-EB          I  2414 (  3)         EX      DE,HL
110C-19          I  2415 (  7)         ADD     HL,DE           ; Add bytes to array start
110D-DA F2 04    I  2416 ( 6+)         JP      C,OMERR         ; Too big - Error
1110-CD E3 04    I  2417 ( 16)         CALL    ENFMEM          ; See if enough memory
1113-22 1F 23    I  2418 ( 20)         LD      (ARREND),HL     ; Save new end of array
1116-            I  2419
1116-2B          I  2420 (  4) ZERARY: DEC     HL              ; Back through array data
1117-36 00       I  2421 (  9)         LD      (HL),0          ; Set array element to zero
1119-CD C5 07    I  2422 ( 16)         CALL    CPDEHL          ; All elements zeroed?
111C-C2 16 11    I  2423 ( 6+)         JP      NZ,ZERARY       ; No - Keep on going
111F-03          I  2424 (  4)         INC     BC              ; Number of bytes + 1
1120-57          I  2425 (  4)         LD      D,A             ; A=0
1121-2A 0A 23    I  2426 ( 15)         LD      HL,(CUROPR)     ; Get address of array
1124-5E          I  2427 (  6)         LD      E,(HL)          ; Number of dimensions
1125-EB          I  2428 (  3)         EX      DE,HL           ; To HL
1126-29          I  2429 (  7)         ADD     HL,HL           ; Two bytes per dimension size
1127-09          I  2430 (  7)         ADD     HL,BC           ; Add number of bytes
1128-EB          I  2431 (  3)         EX      DE,HL           ; Bytes needed to DE
1129-2B          I  2432 (  4)         DEC     HL
112A-2B          I  2433 (  4)         DEC     HL
112B-73          I  2434 (  7)         LD      (HL),E          ; Save LSB of bytes needed
112C-23          I  2435 (  4)         INC     HL
112D-72          I  2436 (  7)         LD      (HL),D          ; Save MSB of bytes needed
112E-23          I  2437 (  4)         INC     HL
112F-F1          I  2438 (  9)         POP     AF              ; Locate / Create?
1130-DA 57 11    I  2439 ( 6+)         JP      C,ENDDIM        ; A is 0 , End if create
1133-47          I  2440 (  4) FINDEL: LD      B,A             ; Find array element
1134-4F          I  2441 (  4)         LD      C,A
1135-7E          I  2442 (  6)         LD      A,(HL)          ; Number of dimensions
1136-23          I  2443 (  4)         INC     HL
1137-16          I  2444               .DB      16H             ; Skip "POP HL"
1138-E1          I  2445 (  9) FNDELP: POP     HL              ; Address of next dim' size
1139-5E          I  2446 (  6)         LD      E,(HL)          ; Get LSB of dim'n size
113A-23          I  2447 (  4)         INC     HL
113B-56          I  2448 (  6)         LD      D,(HL)          ; Get MSB of dim'n size
113C-23          I  2449 (  4)         INC     HL
113D-E3          I  2450 ( 16)         EX      (SP),HL         ; Save address - Get index
113E-F5          I  2451 ( 11)         PUSH    AF              ; Save number of dim'ns
113F-CD C5 07    I  2452 ( 16)         CALL    CPDEHL          ; Dimension too large?
1142-D2 D0 10    I  2453 ( 6+)         JP      NC,BSERR        ; Yes - ?BS Error
1145-E5          I  2454 ( 11)         PUSH    HL              ; Save index
1146-CD 90 18    I  2455 ( 16)         CALL    MLDEBC          ; Multiply previous by size
1149-D1          I  2456 (  9)         POP     DE              ; Index supplied to DE
114A-19          I  2457 (  7)         ADD     HL,DE           ; Add index to pointer
114B-F1          I  2458 (  9)         POP     AF              ; Number of dimensions
114C-3D          I  2459 (  4)         DEC     A               ; Count them
114D-44          I  2460 (  4)         LD      B,H             ; MSB of pointer
114E-4D          I  2461 (  4)         LD      C,L             ; LSB of pointer
114F-C2 38 11    I  2462 ( 6+)         JP      NZ,FNDELP       ; More - Keep going
1152-29          I  2463 (  7)         ADD     HL,HL           ; 4 Bytes per element
1153-29          I  2464 (  7)         ADD     HL,HL
1154-C1          I  2465 (  9)         POP     BC              ; Start of array
1155-09          I  2466 (  7)         ADD     HL,BC           ; Point to element
1156-EB          I  2467 (  3)         EX      DE,HL           ; Address of element to DE
1157-2A 15 23    I  2468 ( 15) ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
115A-C9          I  2469 (  9)         RET
115B-            I  2470
115B-2A 1F 23    I  2471 ( 15) FRE:    LD      HL,(ARREND)     ; Start of free memory
115E-EB          I  2472 (  3)         EX      DE,HL           ; To DE
115F-21 00 00    I  2473 (  9)         LD      HL,0            ; End of free memory
1162-39          I  2474 (  7)         ADD     HL,SP           ; Current stack value
1163-3A F2 22    I  2475 ( 12)         LD      A,(TYPE)        ; Dummy argument type
1166-B7          I  2476 (  4)         OR      A
1167-CA 77 11    I  2477 ( 6+)         JP      Z,FRENUM        ; Numeric - Free variable space
116A-CD DE 13    I  2478 ( 16)         CALL    GSTRCU          ; Current string to pool
116D-CD DE 12    I  2479 ( 16)         CALL    GARBGE          ; Garbage collection
1170-2A 9F 22    I  2480 ( 15)         LD      HL,(STRSPC)     ; Bottom of string space in use
1173-EB          I  2481 (  3)         EX      DE,HL           ; To DE
1174-2A 08 23    I  2482 ( 15)         LD      HL,(STRBOT)     ; Bottom of string space
1177-7D          I  2483 (  4) FRENUM: LD      A,L             ; Get LSB of end
1178-93          I  2484 (  4)         SUB     E               ; Subtract LSB of beginning
1179-4F          I  2485 (  4)         LD      C,A             ; Save difference if C
117A-7C          I  2486 (  4)         LD      A,H             ; Get MSB of end
117B-9A          I  2487 (  4)         SBC     A,D             ; Subtract MSB of beginning
117C-41          I  2488 (  4) ACPASS: LD      B,C             ; Return integer AC
117D-50          I  2489 (  4) ABPASS: LD      D,B             ; Return integer AB
117E-1E 00       I  2490 (  6)         LD      E,0
1180-21 F2 22    I  2491 (  9)         LD      HL,TYPE         ; Point to type
1183-73          I  2492 (  7)         LD      (HL),E          ; Set type to numeric
1184-06 90       I  2493 (  6)         LD      B,80H+16        ; 16 bit integer
1186-C3 BB 17    I  2494 (  9)         JP      RETINT          ; Return the integr
1189-            I  2495
1189-3A F0 22    I  2496 ( 12) POS:    LD      A,(CURPOS)      ; Get cursor position
118C-47          I  2497 (  4) PASSA:  LD      B,A             ; Put A into AB
118D-AF          I  2498 (  4)         XOR     A               ; Zero A
118E-C3 7D 11    I  2499 (  9)         JP      ABPASS          ; Return integer AB
1191-            I  2500
1191-CD 14 12    I  2501 ( 16) DEF:    CALL    CHEKFN          ; Get "FN" and name
1194-CD 06 12    I  2502 ( 16)         CALL    IDTEST          ; Test for illegal direct
1197-01 EC 0A    I  2503 (  9)         LD      BC,DATA         ; To get next statement
119A-C5          I  2504 ( 11)         PUSH    BC              ; Save address for RETurn
119B-D5          I  2505 ( 11)         PUSH    DE              ; Save address of function ptr
119C-CD CB 07    I  2506 ( 16)         CALL    CHKSYN          ; Make sure "(" follows
119F-28          I  2507               .DB      "("
11A0-CD B8 0F    I  2508 ( 16)         CALL    GETVAR          ; Get argument variable name
11A3-E5          I  2509 ( 11)         PUSH    HL              ; Save code string address
11A4-EB          I  2510 (  3)         EX      DE,HL           ; Argument address to HL
11A5-2B          I  2511 (  4)         DEC     HL
11A6-56          I  2512 (  6)         LD      D,(HL)          ; Get first byte of arg name
11A7-2B          I  2513 (  4)         DEC     HL
11A8-5E          I  2514 (  6)         LD      E,(HL)          ; Get second byte of arg name
11A9-E1          I  2515 (  9)         POP     HL              ; Restore code string address
11AA-CD C5 0D    I  2516 ( 16)         CALL    TSTNUM          ; Make sure numeric argument
11AD-CD CB 07    I  2517 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
11B0-29          I  2518               .DB      ")"
11B1-CD CB 07    I  2519 ( 16)         CALL    CHKSYN          ; Make sure "=" follows
11B4-B4          I  2520               .DB      ZEQUAL          ; "=" token
11B5-44          I  2521 (  4)         LD      B,H             ; Code string address to BC
11B6-4D          I  2522 (  4)         LD      C,L
11B7-E3          I  2523 ( 16)         EX      (SP),HL         ; Save code str , Get FN ptr
11B8-71          I  2524 (  7)         LD      (HL),C          ; Save LSB of FN code string
11B9-23          I  2525 (  4)         INC     HL
11BA-70          I  2526 (  7)         LD      (HL),B          ; Save MSB of FN code string
11BB-C3 53 12    I  2527 (  9)         JP      SVSTAD          ; Save address and do function
11BE-            I  2528
11BE-CD 14 12    I  2529 ( 16) DOFN:   CALL    CHEKFN          ; Make sure FN follows
11C1-D5          I  2530 ( 11)         PUSH    DE              ; Save function pointer address
11C2-CD 99 0E    I  2531 ( 16)         CALL    EVLPAR          ; Evaluate expression in "()"
11C5-CD C5 0D    I  2532 ( 16)         CALL    TSTNUM          ; Make sure numeric result
11C8-E3          I  2533 ( 16)         EX      (SP),HL         ; Save code str , Get FN ptr
11C9-5E          I  2534 (  6)         LD      E,(HL)          ; Get LSB of FN code string
11CA-23          I  2535 (  4)         INC     HL
11CB-56          I  2536 (  6)         LD      D,(HL)          ; Get MSB of FN code string
11CC-23          I  2537 (  4)         INC     HL
11CD-7A          I  2538 (  4)         LD      A,D             ; And function DEFined?
11CE-B3          I  2539 (  4)         OR      E
11CF-CA 09 05    I  2540 ( 6+)         JP      Z,UFERR         ; No - ?UF Error
11D2-7E          I  2541 (  6)         LD      A,(HL)          ; Get LSB of argument address
11D3-23          I  2542 (  4)         INC     HL
11D4-66          I  2543 (  6)         LD      H,(HL)          ; Get MSB of argument address
11D5-6F          I  2544 (  4)         LD      L,A             ; HL = Arg variable address
11D6-E5          I  2545 ( 11)         PUSH    HL              ; Save it
11D7-2A 23 23    I  2546 ( 15)         LD      HL,(FNRGNM)     ; Get old argument name
11DA-E3          I  2547 ( 16)         EX      (SP),HL ;       ; Save old , Get new
11DB-22 23 23    I  2548 ( 20)         LD      (FNRGNM),HL     ; Set new argument name
11DE-2A 27 23    I  2549 ( 15)         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
11E1-E5          I  2550 ( 11)         PUSH    HL              ; Save it
11E2-2A 25 23    I  2551 ( 15)         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
11E5-E5          I  2552 ( 11)         PUSH    HL              ; Save it
11E6-21 25 23    I  2553 (  9)         LD      HL,FNARG        ; HL = Value of argument
11E9-D5          I  2554 ( 11)         PUSH    DE              ; Save FN code string address
11EA-CD FC 17    I  2555 ( 16)         CALL    FPTHL           ; Move FPREG to argument
11ED-E1          I  2556 (  9)         POP     HL              ; Get FN code string address
11EE-CD C2 0D    I  2557 ( 16)         CALL    GETNUM          ; Get value from function
11F1-2B          I  2558 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
11F2-CD 55 09    I  2559 ( 16)         CALL    GETCHR          ; Get next character
11F5-C2 FD 04    I  2560 ( 6+)         JP      NZ,SNERR        ; Bad character in FN - Error
11F8-E1          I  2561 (  9)         POP     HL              ; Get MSB,EXP of old arg
11F9-22 25 23    I  2562 ( 20)         LD      (FNARG),HL      ; Restore it
11FC-E1          I  2563 (  9)         POP     HL              ; Get LSB,NLSB of old arg
11FD-22 27 23    I  2564 ( 20)         LD      (FNARG+2),HL    ; Restore it
1200-E1          I  2565 (  9)         POP     HL              ; Get name of old arg
1201-22 23 23    I  2566 ( 20)         LD      (FNRGNM),HL     ; Restore it
1204-E1          I  2567 (  9)         POP     HL              ; Restore code string address
1205-C9          I  2568 (  9)         RET
1206-            I  2569
1206-E5          I  2570 ( 11) IDTEST: PUSH    HL              ; Save code string address
1207-2A A1 22    I  2571 ( 15)         LD      HL,(LINEAT)     ; Get current line number
120A-23          I  2572 (  4)         INC     HL              ; -1 means direct statement
120B-7C          I  2573 (  4)         LD      A,H
120C-B5          I  2574 (  4)         OR      L
120D-E1          I  2575 (  9)         POP     HL              ; Restore code string address
120E-C0          I  2576 ( 5+)         RET     NZ              ; Return if in program
120F-1E 16       I  2577 (  6)         LD      E,ID            ; ?ID Error
1211-C3 11 05    I  2578 (  9)         JP      ERROR
1214-            I  2579
1214-CD CB 07    I  2580 ( 16) CHEKFN: CALL    CHKSYN          ; Make sure FN follows
1217-A7          I  2581               .DB      ZFN             ; "FN" token
1218-3E 80       I  2582 (  6)         LD      A,80H
121A-32 10 23    I  2583 ( 13)         LD      (FORFLG),A      ; Flag FN name to find
121D-B6          I  2584 (  6)         OR      (HL)            ; FN name has bit 7 set
121E-47          I  2585 (  4)         LD      B,A             ; in first byte of name
121F-CD BD 0F    I  2586 ( 16)         CALL    GTFNAM          ; Get FN name
1222-C3 C5 0D    I  2587 (  9)         JP      TSTNUM          ; Make sure numeric function
1225-            I  2588
1225-CD C5 0D    I  2589 ( 16) STR:    CALL    TSTNUM          ; Make sure it's a number
1228-CD 49 19    I  2590 ( 16)         CALL    NUMASC          ; Turn number into text
122B-CD 59 12    I  2591 ( 16) STR1:   CALL    CRTST           ; Create string entry for it
122E-CD DE 13    I  2592 ( 16)         CALL    GSTRCU          ; Current string to pool
1231-01 39 14    I  2593 (  9)         LD      BC,TOPOOL       ; Save in string pool
1234-C5          I  2594 ( 11)         PUSH    BC              ; Save address on stack
1235-            I  2595
1235-7E          I  2596 (  6) SAVSTR: LD      A,(HL)          ; Get string length
1236-23          I  2597 (  4)         INC     HL
1237-23          I  2598 (  4)         INC     HL
1238-E5          I  2599 ( 11)         PUSH    HL              ; Save pointer to string
1239-CD B4 12    I  2600 ( 16)         CALL    TESTR           ; See if enough string space
123C-E1          I  2601 (  9)         POP     HL              ; Restore pointer to string
123D-4E          I  2602 (  6)         LD      C,(HL)          ; Get LSB of address
123E-23          I  2603 (  4)         INC     HL
123F-46          I  2604 (  6)         LD      B,(HL)          ; Get MSB of address
1240-CD 4D 12    I  2605 ( 16)         CALL    CRTMST          ; Create string entry
1243-E5          I  2606 ( 11)         PUSH    HL              ; Save pointer to MSB of addr
1244-6F          I  2607 (  4)         LD      L,A             ; Length of string
1245-CD D1 13    I  2608 ( 16)         CALL    TOSTRA          ; Move to string area
1248-D1          I  2609 (  9)         POP     DE              ; Restore pointer to MSB
1249-C9          I  2610 (  9)         RET
124A-            I  2611
124A-CD B4 12    I  2612 ( 16) MKTMST: CALL    TESTR           ; See if enough string space
124D-21 04 23    I  2613 (  9) CRTMST: LD      HL,TMPSTR       ; Temporary string
1250-E5          I  2614 ( 11)         PUSH    HL              ; Save it
1251-77          I  2615 (  7)         LD      (HL),A          ; Save length of string
1252-23          I  2616 (  4)         INC     HL
1253-23          I  2617 (  4) SVSTAD: INC     HL
1254-73          I  2618 (  7)         LD      (HL),E          ; Save LSB of address
1255-23          I  2619 (  4)         INC     HL
1256-72          I  2620 (  7)         LD      (HL),D          ; Save MSB of address
1257-E1          I  2621 (  9)         POP     HL              ; Restore pointer
1258-C9          I  2622 (  9)         RET
1259-            I  2623
1259-2B          I  2624 (  4) CRTST:  DEC     HL              ; DEC - INCed after
125A-06 22       I  2625 (  6) QTSTR:  LD      B,'"'           ; Terminating quote
125C-50          I  2626 (  4)         LD      D,B             ; Quote to D
125D-E5          I  2627 ( 11) DTSTR:  PUSH    HL              ; Save start
125E-0E FF       I  2628 (  6)         LD      C,-1            ; Set counter to -1
1260-23          I  2629 (  4) QTSTLP: INC     HL              ; Move on
1261-7E          I  2630 (  6)         LD      A,(HL)          ; Get byte
1262-0C          I  2631 (  4)         INC     C               ; Count bytes
1263-B7          I  2632 (  4)         OR      A               ; End of line?
1264-CA 6F 12    I  2633 ( 6+)         JP      Z,CRTSTE        ; Yes - Create string entry
1267-BA          I  2634 (  4)         CP      D               ; Terminator D found?
1268-CA 6F 12    I  2635 ( 6+)         JP      Z,CRTSTE        ; Yes - Create string entry
126B-B8          I  2636 (  4)         CP      B               ; Terminator B found?
126C-C2 60 12    I  2637 ( 6+)         JP      NZ,QTSTLP       ; No - Keep looking
126F-FE 22       I  2638 (  6) CRTSTE: CP      '"'             ; End with '"'?
1271-CC 55 09    I  2639 ( 6+)         CALL    Z,GETCHR        ; Yes - Get next character
1274-E3          I  2640 ( 16)         EX      (SP),HL         ; Starting quote
1275-23          I  2641 (  4)         INC     HL              ; First byte of string
1276-EB          I  2642 (  3)         EX      DE,HL           ; To DE
1277-79          I  2643 (  4)         LD      A,C             ; Get length
1278-CD 4D 12    I  2644 ( 16)         CALL    CRTMST          ; Create string entry
127B-11 04 23    I  2645 (  9) TSTOPL: LD      DE,TMPSTR       ; Temporary string
127E-2A F6 22    I  2646 ( 15)         LD      HL,(TMSTPT)     ; Temporary string pool pointer
1281-22 29 23    I  2647 ( 20)         LD      (FPREG),HL      ; Save address of string ptr
1284-3E 01       I  2648 (  6)         LD      A,1
1286-32 F2 22    I  2649 ( 13)         LD      (TYPE),A        ; Set type to string
1289-CD FF 17    I  2650 ( 16)         CALL    DETHL4          ; Move string to pool
128C-CD C5 07    I  2651 ( 16)         CALL    CPDEHL          ; Out of string pool?
128F-22 F6 22    I  2652 ( 20)         LD      (TMSTPT),HL     ; Save new pointer
1292-E1          I  2653 (  9)         POP     HL              ; Restore code string address
1293-7E          I  2654 (  6)         LD      A,(HL)          ; Get next code byte
1294-C0          I  2655 ( 5+)         RET     NZ              ; Return if pool OK
1295-1E 1E       I  2656 (  6)         LD      E,ST            ; ?ST Error
1297-C3 11 05    I  2657 (  9)         JP      ERROR           ; String pool overflow
129A-            I  2658
129A-23          I  2659 (  4) PRNUMS: INC     HL              ; Skip leading space
129B-CD 59 12    I  2660 ( 16) PRS:    CALL    CRTST           ; Create string entry for it
129E-CD DE 13    I  2661 ( 16) PRS1:   CALL    GSTRCU          ; Current string to pool
12A1-CD F3 17    I  2662 ( 16)         CALL    LOADFP          ; Move string block to BCDE
12A4-1C          I  2663 (  4)         INC     E               ; Length + 1
12A5-1D          I  2664 (  4) PRSLP:  DEC     E               ; Count characters
12A6-C8          I  2665 ( 5+)         RET     Z               ; End of string
12A7-0A          I  2666 (  6)         LD      A,(BC)          ; Get byte to output
12A8-CD D6 07    I  2667 ( 16)         CALL    OUTC            ; Output character in A
12AB-FE 0D       I  2668 (  6)         CP      CR              ; Return?
12AD-CC 07 0C    I  2669 ( 6+)         CALL    Z,DONULL        ; Yes - Do nulls
12B0-03          I  2670 (  4)         INC     BC              ; Next byte in string
12B1-C3 A5 12    I  2671 (  9)         JP      PRSLP           ; More characters to output
12B4-            I  2672
12B4-B7          I  2673 (  4) TESTR:  OR      A               ; Test if enough room
12B5-0E          I  2674               .DB      0EH             ; No garbage collection done
12B6-F1          I  2675 (  9) GRBDON: POP     AF              ; Garbage collection done
12B7-F5          I  2676 ( 11)         PUSH    AF              ; Save status
12B8-2A 9F 22    I  2677 ( 15)         LD      HL,(STRSPC)     ; Bottom of string space in use
12BB-EB          I  2678 (  3)         EX      DE,HL           ; To DE
12BC-2A 08 23    I  2679 ( 15)         LD      HL,(STRBOT)     ; Bottom of string area
12BF-2F          I  2680 (  3)         CPL                     ; Negate length (Top down)
12C0-4F          I  2681 (  4)         LD      C,A             ; -Length to BC
12C1-06 FF       I  2682 (  6)         LD      B,-1            ; BC = -ve length of string
12C3-09          I  2683 (  7)         ADD     HL,BC           ; Add to bottom of space in use
12C4-23          I  2684 (  4)         INC     HL              ; Plus one for 2's complement
12C5-CD C5 07    I  2685 ( 16)         CALL    CPDEHL          ; Below string RAM area?
12C8-DA D2 12    I  2686 ( 6+)         JP      C,TESTOS        ; Tidy up if not done else err
12CB-22 08 23    I  2687 ( 20)         LD      (STRBOT),HL     ; Save new bottom of area
12CE-23          I  2688 (  4)         INC     HL              ; Point to first byte of string
12CF-EB          I  2689 (  3)         EX      DE,HL           ; Address to DE
12D0-F1          I  2690 (  9) POPAF:  POP     AF              ; Throw away status push
12D1-C9          I  2691 (  9)         RET
12D2-            I  2692
12D2-F1          I  2693 (  9) TESTOS: POP     AF              ; Garbage collect been done?
12D3-1E 1A       I  2694 (  6)         LD      E,OS            ; ?OS Error
12D5-CA 11 05    I  2695 ( 6+)         JP      Z,ERROR         ; Yes - Not enough string apace
12D8-BF          I  2696 (  4)         CP      A               ; Flag garbage collect done
12D9-F5          I  2697 ( 11)         PUSH    AF              ; Save status
12DA-01 B6 12    I  2698 (  9)         LD      BC,GRBDON       ; Garbage collection done
12DD-C5          I  2699 ( 11)         PUSH    BC              ; Save for RETurn
12DE-2A F4 22    I  2700 ( 15) GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
12E1-22 08 23    I  2701 ( 20) GARBLP: LD      (STRBOT),HL     ; Reset string pointer
12E4-21 00 00    I  2702 (  9)         LD      HL,0
12E7-E5          I  2703 ( 11)         PUSH    HL              ; Flag no string found
12E8-2A 9F 22    I  2704 ( 15)         LD      HL,(STRSPC)     ; Get bottom of string space
12EB-E5          I  2705 ( 11)         PUSH    HL              ; Save bottom of string space
12EC-21 F8 22    I  2706 (  9)         LD      HL,TMSTPL       ; Temporary string pool
12EF-EB          I  2707 (  3) GRBLP:  EX      DE,HL
12F0-2A F6 22    I  2708 ( 15)         LD      HL,(TMSTPT)     ; Temporary string pool pointer
12F3-EB          I  2709 (  3)         EX      DE,HL
12F4-CD C5 07    I  2710 ( 16)         CALL    CPDEHL          ; Temporary string pool done?
12F7-01 EF 12    I  2711 (  9)         LD      BC,GRBLP        ; Loop until string pool done
12FA-C2 43 13    I  2712 ( 6+)         JP      NZ,STPOOL       ; No - See if in string area
12FD-2A 1B 23    I  2713 ( 15)         LD      HL,(PROGND)     ; Start of simple variables
1300-EB          I  2714 (  3) SMPVAR: EX      DE,HL
1301-2A 1D 23    I  2715 ( 15)         LD      HL,(VAREND)     ; End of simple variables
1304-EB          I  2716 (  3)         EX      DE,HL
1305-CD C5 07    I  2717 ( 16)         CALL    CPDEHL          ; All simple strings done?
1308-CA 16 13    I  2718 ( 6+)         JP      Z,ARRLP         ; Yes - Do string arrays
130B-7E          I  2719 (  6)         LD      A,(HL)          ; Get type of variable
130C-23          I  2720 (  4)         INC     HL
130D-23          I  2721 (  4)         INC     HL
130E-B7          I  2722 (  4)         OR      A               ; "S" flag set if string
130F-CD 46 13    I  2723 ( 16)         CALL    STRADD          ; See if string in string area
1312-C3 00 13    I  2724 (  9)         JP      SMPVAR          ; Loop until simple ones done
1315-            I  2725
1315-C1          I  2726 (  9) GNXARY: POP     BC              ; Scrap address of this array
1316-EB          I  2727 (  3) ARRLP:  EX      DE,HL
1317-2A 1F 23    I  2728 ( 15)         LD      HL,(ARREND)     ; End of string arrays
131A-EB          I  2729 (  3)         EX      DE,HL
131B-CD C5 07    I  2730 ( 16)         CALL    CPDEHL          ; All string arrays done?
131E-CA 6C 13    I  2731 ( 6+)         JP      Z,SCNEND        ; Yes - Move string if found
1321-CD F3 17    I  2732 ( 16)         CALL    LOADFP          ; Get array name to BCDE
1324-7B          I  2733 (  4)         LD      A,E             ; Get type of array
1325-E5          I  2734 ( 11)         PUSH    HL              ; Save address of num of dim'ns
1326-09          I  2735 (  7)         ADD     HL,BC           ; Start of next array
1327-B7          I  2736 (  4)         OR      A               ; Test type of array
1328-F2 15 13    I  2737 ( 6+)         JP      P,GNXARY        ; Numeric array - Ignore it
132B-22 0A 23    I  2738 ( 20)         LD      (CUROPR),HL     ; Save address of next array
132E-E1          I  2739 (  9)         POP     HL              ; Get address of num of dim'ns
132F-4E          I  2740 (  6)         LD      C,(HL)          ; BC = Number of dimensions
1330-06 00       I  2741 (  6)         LD      B,0
1332-09          I  2742 (  7)         ADD     HL,BC           ; Two bytes per dimension size
1333-09          I  2743 (  7)         ADD     HL,BC
1334-23          I  2744 (  4)         INC     HL              ; Plus one for number of dim'ns
1335-EB          I  2745 (  3) GRBARY: EX      DE,HL
1336-2A 0A 23    I  2746 ( 15)         LD      HL,(CUROPR)     ; Get address of next array
1339-EB          I  2747 (  3)         EX      DE,HL
133A-CD C5 07    I  2748 ( 16)         CALL    CPDEHL          ; Is this array finished?
133D-CA 16 13    I  2749 ( 6+)         JP      Z,ARRLP         ; Yes - Get next one
1340-01 35 13    I  2750 (  9)         LD      BC,GRBARY       ; Loop until array all done
1343-C5          I  2751 ( 11) STPOOL: PUSH    BC              ; Save return address
1344-F6 80       I  2752 (  6)         OR      80H             ; Flag string type
1346-7E          I  2753 (  6) STRADD: LD      A,(HL)          ; Get string length
1347-23          I  2754 (  4)         INC     HL
1348-23          I  2755 (  4)         INC     HL
1349-5E          I  2756 (  6)         LD      E,(HL)          ; Get LSB of string address
134A-23          I  2757 (  4)         INC     HL
134B-56          I  2758 (  6)         LD      D,(HL)          ; Get MSB of string address
134C-23          I  2759 (  4)         INC     HL
134D-F0          I  2760 ( 5+)         RET     P               ; Not a string - Return
134E-B7          I  2761 (  4)         OR      A               ; Set flags on string length
134F-C8          I  2762 ( 5+)         RET     Z               ; Null string - Return
1350-44          I  2763 (  4)         LD      B,H             ; Save variable pointer
1351-4D          I  2764 (  4)         LD      C,L
1352-2A 08 23    I  2765 ( 15)         LD      HL,(STRBOT)     ; Bottom of new area
1355-CD C5 07    I  2766 ( 16)         CALL    CPDEHL          ; String been done?
1358-60          I  2767 (  4)         LD      H,B             ; Restore variable pointer
1359-69          I  2768 (  4)         LD      L,C
135A-D8          I  2769 ( 5+)         RET     C               ; String done - Ignore
135B-E1          I  2770 (  9)         POP     HL              ; Return address
135C-E3          I  2771 ( 16)         EX      (SP),HL         ; Lowest available string area
135D-CD C5 07    I  2772 ( 16)         CALL    CPDEHL          ; String within string area?
1360-E3          I  2773 ( 16)         EX      (SP),HL         ; Lowest available string area
1361-E5          I  2774 ( 11)         PUSH    HL              ; Re-save return address
1362-60          I  2775 (  4)         LD      H,B             ; Restore variable pointer
1363-69          I  2776 (  4)         LD      L,C
1364-D0          I  2777 ( 5+)         RET     NC              ; Outside string area - Ignore
1365-C1          I  2778 (  9)         POP     BC              ; Get return , Throw 2 away
1366-F1          I  2779 (  9)         POP     AF              ;
1367-F1          I  2780 (  9)         POP     AF              ;
1368-E5          I  2781 ( 11)         PUSH    HL              ; Save variable pointer
1369-D5          I  2782 ( 11)         PUSH    DE              ; Save address of current
136A-C5          I  2783 ( 11)         PUSH    BC              ; Put back return address
136B-C9          I  2784 (  9)         RET                     ; Go to it
136C-            I  2785
136C-D1          I  2786 (  9) SCNEND: POP     DE              ; Addresses of strings
136D-E1          I  2787 (  9)         POP     HL              ;
136E-7D          I  2788 (  4)         LD      A,L             ; HL = 0 if no more to do
136F-B4          I  2789 (  4)         OR      H
1370-C8          I  2790 ( 5+)         RET     Z               ; No more to do - Return
1371-2B          I  2791 (  4)         DEC     HL
1372-46          I  2792 (  6)         LD      B,(HL)          ; MSB of address of string
1373-2B          I  2793 (  4)         DEC     HL
1374-4E          I  2794 (  6)         LD      C,(HL)          ; LSB of address of string
1375-E5          I  2795 ( 11)         PUSH    HL              ; Save variable address
1376-2B          I  2796 (  4)         DEC     HL
1377-2B          I  2797 (  4)         DEC     HL
1378-6E          I  2798 (  6)         LD      L,(HL)          ; HL = Length of string
1379-26 00       I  2799 (  6)         LD      H,0
137B-09          I  2800 (  7)         ADD     HL,BC           ; Address of end of string+1
137C-50          I  2801 (  4)         LD      D,B             ; String address to DE
137D-59          I  2802 (  4)         LD      E,C
137E-2B          I  2803 (  4)         DEC     HL              ; Last byte in string
137F-44          I  2804 (  4)         LD      B,H             ; Address to BC
1380-4D          I  2805 (  4)         LD      C,L
1381-2A 08 23    I  2806 ( 15)         LD      HL,(STRBOT)     ; Current bottom of string area
1384-CD CC 04    I  2807 ( 16)         CALL    MOVSTR          ; Move string to new address
1387-E1          I  2808 (  9)         POP     HL              ; Restore variable address
1388-71          I  2809 (  7)         LD      (HL),C          ; Save new LSB of address
1389-23          I  2810 (  4)         INC     HL
138A-70          I  2811 (  7)         LD      (HL),B          ; Save new MSB of address
138B-69          I  2812 (  4)         LD      L,C             ; Next string area+1 to HL
138C-60          I  2813 (  4)         LD      H,B
138D-2B          I  2814 (  4)         DEC     HL              ; Next string area address
138E-C3 E1 12    I  2815 (  9)         JP      GARBLP          ; Look for more strings
1391-            I  2816
1391-C5          I  2817 ( 11) CONCAT: PUSH    BC              ; Save prec' opr & code string
1392-E5          I  2818 ( 11)         PUSH    HL              ;
1393-2A 29 23    I  2819 ( 15)         LD      HL,(FPREG)      ; Get first string
1396-E3          I  2820 ( 16)         EX      (SP),HL         ; Save first string
1397-CD 4B 0E    I  2821 ( 16)         CALL    OPRND           ; Get second string
139A-E3          I  2822 ( 16)         EX      (SP),HL         ; Restore first string
139B-CD C6 0D    I  2823 ( 16)         CALL    TSTSTR          ; Make sure it's a string
139E-7E          I  2824 (  6)         LD      A,(HL)          ; Get length of second string
139F-E5          I  2825 ( 11)         PUSH    HL              ; Save first string
13A0-2A 29 23    I  2826 ( 15)         LD      HL,(FPREG)      ; Get second string
13A3-E5          I  2827 ( 11)         PUSH    HL              ; Save second string
13A4-86          I  2828 (  6)         ADD     A,(HL)          ; Add length of second string
13A5-1E 1C       I  2829 (  6)         LD      E,LS            ; ?LS Error
13A7-DA 11 05    I  2830 ( 6+)         JP      C,ERROR         ; String too long - Error
13AA-CD 4A 12    I  2831 ( 16)         CALL    MKTMST          ; Make temporary string
13AD-D1          I  2832 (  9)         POP     DE              ; Get second string to DE
13AE-CD E2 13    I  2833 ( 16)         CALL    GSTRDE          ; Move to string pool if needed
13B1-E3          I  2834 ( 16)         EX      (SP),HL         ; Get first string
13B2-CD E1 13    I  2835 ( 16)         CALL    GSTRHL          ; Move to string pool if needed
13B5-E5          I  2836 ( 11)         PUSH    HL              ; Save first string
13B6-2A 06 23    I  2837 ( 15)         LD      HL,(TMPSTR+2)   ; Temporary string address
13B9-EB          I  2838 (  3)         EX      DE,HL           ; To DE
13BA-CD C8 13    I  2839 ( 16)         CALL    SSTSA           ; First string to string area
13BD-CD C8 13    I  2840 ( 16)         CALL    SSTSA           ; Second string to string area
13C0-21 E0 0D    I  2841 (  9)         LD      HL,EVAL2        ; Return to evaluation loop
13C3-E3          I  2842 ( 16)         EX      (SP),HL         ; Save return,get code string
13C4-E5          I  2843 ( 11)         PUSH    HL              ; Save code string address
13C5-C3 7B 12    I  2844 (  9)         JP      TSTOPL          ; To temporary string to pool
13C8-            I  2845
13C8-E1          I  2846 (  9) SSTSA:  POP     HL              ; Return address
13C9-E3          I  2847 ( 16)         EX      (SP),HL         ; Get string block,save return
13CA-7E          I  2848 (  6)         LD      A,(HL)          ; Get length of string
13CB-23          I  2849 (  4)         INC     HL
13CC-23          I  2850 (  4)         INC     HL
13CD-4E          I  2851 (  6)         LD      C,(HL)          ; Get LSB of string address
13CE-23          I  2852 (  4)         INC     HL
13CF-46          I  2853 (  6)         LD      B,(HL)          ; Get MSB of string address
13D0-6F          I  2854 (  4)         LD      L,A             ; Length to L
13D1-2C          I  2855 (  4) TOSTRA: INC     L               ; INC - DECed after
13D2-2D          I  2856 (  4) TSALP:  DEC     L               ; Count bytes moved
13D3-C8          I  2857 ( 5+)         RET     Z               ; End of string - Return
13D4-0A          I  2858 (  6)         LD      A,(BC)          ; Get source
13D5-12          I  2859 (  7)         LD      (DE),A          ; Save destination
13D6-03          I  2860 (  4)         INC     BC              ; Next source
13D7-13          I  2861 (  4)         INC     DE              ; Next destination
13D8-C3 D2 13    I  2862 (  9)         JP      TSALP           ; Loop until string moved
13DB-            I  2863
13DB-CD C6 0D    I  2864 ( 16) GETSTR: CALL    TSTSTR          ; Make sure it's a string
13DE-2A 29 23    I  2865 ( 15) GSTRCU: LD      HL,(FPREG)      ; Get current string
13E1-EB          I  2866 (  3) GSTRHL: EX      DE,HL           ; Save DE
13E2-CD FC 13    I  2867 ( 16) GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
13E5-EB          I  2868 (  3)         EX      DE,HL           ; Restore DE
13E6-C0          I  2869 ( 5+)         RET     NZ              ; No - Return
13E7-D5          I  2870 ( 11)         PUSH    DE              ; Save string
13E8-50          I  2871 (  4)         LD      D,B             ; String block address to DE
13E9-59          I  2872 (  4)         LD      E,C
13EA-1B          I  2873 (  4)         DEC     DE              ; Point to length
13EB-4E          I  2874 (  6)         LD      C,(HL)          ; Get string length
13EC-2A 08 23    I  2875 ( 15)         LD      HL,(STRBOT)     ; Current bottom of string area
13EF-CD C5 07    I  2876 ( 16)         CALL    CPDEHL          ; Last one in string area?
13F2-C2 FA 13    I  2877 ( 6+)         JP      NZ,POPHL        ; No - Return
13F5-47          I  2878 (  4)         LD      B,A             ; Clear B (A=0)
13F6-09          I  2879 (  7)         ADD     HL,BC           ; Remove string from str' area
13F7-22 08 23    I  2880 ( 20)         LD      (STRBOT),HL     ; Save new bottom of str' area
13FA-E1          I  2881 (  9) POPHL:  POP     HL              ; Restore string
13FB-C9          I  2882 (  9)         RET
13FC-            I  2883
13FC-2A F6 22    I  2884 ( 15) BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
13FF-2B          I  2885 (  4)         DEC     HL              ; Back
1400-46          I  2886 (  6)         LD      B,(HL)          ; Get MSB of address
1401-2B          I  2887 (  4)         DEC     HL              ; Back
1402-4E          I  2888 (  6)         LD      C,(HL)          ; Get LSB of address
1403-2B          I  2889 (  4)         DEC     HL              ; Back
1404-2B          I  2890 (  4)         DEC     HL              ; Back
1405-CD C5 07    I  2891 ( 16)         CALL    CPDEHL          ; String last in string pool?
1408-C0          I  2892 ( 5+)         RET     NZ              ; Yes - Leave it
1409-22 F6 22    I  2893 ( 20)         LD      (TMSTPT),HL     ; Save new string pool top
140C-C9          I  2894 (  9)         RET
140D-            I  2895
140D-01 8C 11    I  2896 (  9) LEN:    LD      BC,PASSA        ; To return integer A
1410-C5          I  2897 ( 11)         PUSH    BC              ; Save address
1411-CD DB 13    I  2898 ( 16) GETLEN: CALL    GETSTR          ; Get string and its length
1414-AF          I  2899 (  4)         XOR     A
1415-57          I  2900 (  4)         LD      D,A             ; Clear D
1416-32 F2 22    I  2901 ( 13)         LD      (TYPE),A        ; Set type to numeric
1419-7E          I  2902 (  6)         LD      A,(HL)          ; Get length of string
141A-B7          I  2903 (  4)         OR      A               ; Set status flags
141B-C9          I  2904 (  9)         RET
141C-            I  2905
141C-01 8C 11    I  2906 (  9) ASC:    LD      BC,PASSA        ; To return integer A
141F-C5          I  2907 ( 11)         PUSH    BC              ; Save address
1420-CD 11 14    I  2908 ( 16) GTFLNM: CALL    GETLEN          ; Get length of string
1423-CA 1C 0A    I  2909 ( 6+)         JP      Z,FCERR         ; Null string - Error
1426-23          I  2910 (  4)         INC     HL
1427-23          I  2911 (  4)         INC     HL
1428-5E          I  2912 (  6)         LD      E,(HL)          ; Get LSB of address
1429-23          I  2913 (  4)         INC     HL
142A-56          I  2914 (  6)         LD      D,(HL)          ; Get MSB of address
142B-1A          I  2915 (  6)         LD      A,(DE)          ; Get first byte of string
142C-C9          I  2916 (  9)         RET
142D-            I  2917
142D-3E 01       I  2918 (  6) CHR:    LD      A,1             ; One character string
142F-CD 4A 12    I  2919 ( 16)         CALL    MKTMST          ; Make a temporary string
1432-CD 26 15    I  2920 ( 16)         CALL    MAKINT          ; Make it integer A
1435-2A 06 23    I  2921 ( 15)         LD      HL,(TMPSTR+2)   ; Get address of string
1438-73          I  2922 (  7)         LD      (HL),E          ; Save character
1439-C1          I  2923 (  9) TOPOOL: POP     BC              ; Clean up stack
143A-C3 7B 12    I  2924 (  9)         JP      TSTOPL          ; Temporary string to pool
143D-            I  2925
143D-CD D6 14    I  2926 ( 16) LEFT:   CALL    LFRGNM          ; Get number and ending ")"
1440-AF          I  2927 (  4)         XOR     A               ; Start at first byte in string
1441-E3          I  2928 ( 16) RIGHT1: EX      (SP),HL         ; Save code string,Get string
1442-4F          I  2929 (  4)         LD      C,A             ; Starting position in string
1443-E5          I  2930 ( 11) MID1:   PUSH    HL              ; Save string block address
1444-7E          I  2931 (  6)         LD      A,(HL)          ; Get length of string
1445-B8          I  2932 (  4)         CP      B               ; Compare with number given
1446-DA 4B 14    I  2933 ( 6+)         JP      C,ALLFOL        ; All following bytes required
1449-78          I  2934 (  4)         LD      A,B             ; Get new length
144A-11          I  2935               .DB      11H             ; Skip "LD C,0"
144B-0E 00       I  2936 (  6) ALLFOL: LD      C,0             ; First byte of string
144D-C5          I  2937 ( 11)         PUSH    BC              ; Save position in string
144E-CD B4 12    I  2938 ( 16)         CALL    TESTR           ; See if enough string space
1451-C1          I  2939 (  9)         POP     BC              ; Get position in string
1452-E1          I  2940 (  9)         POP     HL              ; Restore string block address
1453-E5          I  2941 ( 11)         PUSH    HL              ; And re-save it
1454-23          I  2942 (  4)         INC     HL
1455-23          I  2943 (  4)         INC     HL
1456-46          I  2944 (  6)         LD      B,(HL)          ; Get LSB of address
1457-23          I  2945 (  4)         INC     HL
1458-66          I  2946 (  6)         LD      H,(HL)          ; Get MSB of address
1459-68          I  2947 (  4)         LD      L,B             ; HL = address of string
145A-06 00       I  2948 (  6)         LD      B,0             ; BC = starting address
145C-09          I  2949 (  7)         ADD     HL,BC           ; Point to that byte
145D-44          I  2950 (  4)         LD      B,H             ; BC = source string
145E-4D          I  2951 (  4)         LD      C,L
145F-CD 4D 12    I  2952 ( 16)         CALL    CRTMST          ; Create a string entry
1462-6F          I  2953 (  4)         LD      L,A             ; Length of new string
1463-CD D1 13    I  2954 ( 16)         CALL    TOSTRA          ; Move string to string area
1466-D1          I  2955 (  9)         POP     DE              ; Clear stack
1467-CD E2 13    I  2956 ( 16)         CALL    GSTRDE          ; Move to string pool if needed
146A-C3 7B 12    I  2957 (  9)         JP      TSTOPL          ; Temporary string to pool
146D-            I  2958
146D-CD D6 14    I  2959 ( 16) RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
1470-D1          I  2960 (  9)         POP     DE              ; Get string length
1471-D5          I  2961 ( 11)         PUSH    DE              ; And re-save
1472-1A          I  2962 (  6)         LD      A,(DE)          ; Get length
1473-90          I  2963 (  4)         SUB     B               ; Move back N bytes
1474-C3 41 14    I  2964 (  9)         JP      RIGHT1          ; Go and get sub-string
1477-            I  2965
1477-EB          I  2966 (  3) MID:    EX      DE,HL           ; Get code string address
1478-7E          I  2967 (  6)         LD      A,(HL)          ; Get next byte ',' or ")"
1479-CD DB 14    I  2968 ( 16)         CALL    MIDNUM          ; Get number supplied
147C-04          I  2969 (  4)         INC     B               ; Is it character zero?
147D-05          I  2970 (  4)         DEC     B
147E-CA 1C 0A    I  2971 ( 6+)         JP      Z,FCERR         ; Yes - Error
1481-C5          I  2972 ( 11)         PUSH    BC              ; Save starting position
1482-1E FF       I  2973 (  6)         LD      E,255           ; All of string
1484-FE 29       I  2974 (  6)         CP      ')'             ; Any length given?
1486-CA 90 14    I  2975 ( 6+)         JP      Z,RSTSTR        ; No - Rest of string
1489-CD CB 07    I  2976 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
148C-2C          I  2977               .DB      ','
148D-CD 23 15    I  2978 ( 16)         CALL    GETINT          ; Get integer 0-255
1490-CD CB 07    I  2979 ( 16) RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
1493-29          I  2980               .DB      ")"
1494-F1          I  2981 (  9)         POP     AF              ; Restore starting position
1495-E3          I  2982 ( 16)         EX      (SP),HL         ; Get string,8ave code string
1496-01 43 14    I  2983 (  9)         LD      BC,MID1         ; Continuation of MID$ routine
1499-C5          I  2984 ( 11)         PUSH    BC              ; Save for return
149A-3D          I  2985 (  4)         DEC     A               ; Starting position-1
149B-BE          I  2986 (  6)         CP      (HL)            ; Compare with length
149C-06 00       I  2987 (  6)         LD      B,0             ; Zero bytes length
149E-D0          I  2988 ( 5+)         RET     NC              ; Null string if start past end
149F-4F          I  2989 (  4)         LD      C,A             ; Save starting position-1
14A0-7E          I  2990 (  6)         LD      A,(HL)          ; Get length of string
14A1-91          I  2991 (  4)         SUB     C               ; Subtract start
14A2-BB          I  2992 (  4)         CP      E               ; Enough string for it?
14A3-47          I  2993 (  4)         LD      B,A             ; Save maximum length available
14A4-D8          I  2994 ( 5+)         RET     C               ; Truncate string if needed
14A5-43          I  2995 (  4)         LD      B,E             ; Set specified length
14A6-C9          I  2996 (  9)         RET                     ; Go and create string
14A7-            I  2997
14A7-CD 11 14    I  2998 ( 16) VAL:    CALL    GETLEN          ; Get length of string
14AA-CA C4 15    I  2999 ( 6+)         JP      Z,RESZER        ; Result zero
14AD-5F          I  3000 (  4)         LD      E,A             ; Save length
14AE-23          I  3001 (  4)         INC     HL
14AF-23          I  3002 (  4)         INC     HL
14B0-7E          I  3003 (  6)         LD      A,(HL)          ; Get LSB of address
14B1-23          I  3004 (  4)         INC     HL
14B2-66          I  3005 (  6)         LD      H,(HL)          ; Get MSB of address
14B3-6F          I  3006 (  4)         LD      L,A             ; HL = String address
14B4-E5          I  3007 ( 11)         PUSH    HL              ; Save string address
14B5-19          I  3008 (  7)         ADD     HL,DE
14B6-46          I  3009 (  6)         LD      B,(HL)          ; Get end of string+1 byte
14B7-72          I  3010 (  7)         LD      (HL),D          ; Zero it to terminate
14B8-E3          I  3011 ( 16)         EX      (SP),HL         ; Save string end,get start
14B9-C5          I  3012 ( 11)         PUSH    BC              ; Save end+1 byte
14BA-7E          I  3013 (  6)         LD      A,(HL)          ; Get starting byte
14BB-FE 24       I  3014 (  6)     CP  '$'             ; Hex number indicated? [function added]
14BD-C2 C5 14    I  3015 ( 6+)     JP  NZ,VAL1
14C0-CD EF 1C    I  3016 ( 16)     CALL        HEXTFP          ; Convert Hex to FPREG
14C3-18 0D       I  3017 (  8)     JR  VAL3
14C5-FE 25       I  3018 (  6) VAL1:   CP      '%'             ; Binary number indicated? [function added]
14C7-C2 CF 14    I  3019 ( 6+)     JP  NZ,VAL2
14CA-CD 5F 1D    I  3020 ( 16)     CALL        BINTFP          ; Convert Bin to FPREG
14CD-18 03       I  3021 (  8)     JR  VAL3
14CF-CD AB 18    I  3022 ( 16) VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
14D2-C1          I  3023 (  9) VAL3:   POP     BC              ; Restore end+1 byte
14D3-E1          I  3024 (  9)         POP     HL              ; Restore end+1 address
14D4-70          I  3025 (  7)         LD      (HL),B          ; Put back original byte
14D5-C9          I  3026 (  9)         RET
14D6-            I  3027
14D6-EB          I  3028 (  3) LFRGNM: EX      DE,HL           ; Code string address to HL
14D7-CD CB 07    I  3029 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
14DA-29          I  3030               .DB      ")"
14DB-C1          I  3031 (  9) MIDNUM: POP     BC              ; Get return address
14DC-D1          I  3032 (  9)         POP     DE              ; Get number supplied
14DD-C5          I  3033 ( 11)         PUSH    BC              ; Re-save return address
14DE-43          I  3034 (  4)         LD      B,E             ; Number to B
14DF-C9          I  3035 (  9)         RET
14E0-            I  3036
14E0-CD 26 15    I  3037 ( 16) INP:    CALL    MAKINT          ; Make it integer A
14E3-32 84 22    I  3038 ( 13)         LD      (INPORT),A      ; Set input port
14E6-CD 83 22    I  3039 ( 16)         CALL    INPSUB          ; Get input from port
14E9-C3 8C 11    I  3040 (  9)         JP      PASSA           ; Return integer A
14EC-            I  3041
14EC-CD 10 15    I  3042 ( 16) POUT:   CALL    SETIO           ; Set up port number
14EF-C3 4B 22    I  3043 (  9)         JP      OUTSUB          ; Output data and return
14F2-            I  3044
14F2-CD 10 15    I  3045 ( 16) WAIT:   CALL    SETIO           ; Set up port number
14F5-F5          I  3046 ( 11)         PUSH    AF              ; Save AND mask
14F6-1E 00       I  3047 (  6)         LD      E,0             ; Assume zero if none given
14F8-2B          I  3048 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
14F9-CD 55 09    I  3049 ( 16)         CALL    GETCHR          ; Get next character
14FC-CA 06 15    I  3050 ( 6+)         JP      Z,NOXOR         ; No XOR byte given
14FF-CD CB 07    I  3051 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1502-2C          I  3052               .DB      ','
1503-CD 23 15    I  3053 ( 16)         CALL    GETINT          ; Get integer 0-255 to XOR with
1506-C1          I  3054 (  9) NOXOR:  POP     BC              ; Restore AND mask
1507-CD 83 22    I  3055 ( 16) WAITLP: CALL    INPSUB          ; Get input
150A-AB          I  3056 (  4)         XOR     E               ; Flip selected bits
150B-A0          I  3057 (  4)         AND     B               ; Result non-zero?
150C-CA 07 15    I  3058 ( 6+)         JP      Z,WAITLP        ; No = keep waiting
150F-C9          I  3059 (  9)         RET
1510-            I  3060
1510-CD 23 15    I  3061 ( 16) SETIO:  CALL    GETINT          ; Get integer 0-255
1513-32 84 22    I  3062 ( 13)         LD      (INPORT),A      ; Set input port
1516-32 4C 22    I  3063 ( 13)         LD      (OTPORT),A      ; Set output port
1519-CD CB 07    I  3064 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
151C-2C          I  3065               .DB      ','
151D-C3 23 15    I  3066 (  9)         JP      GETINT          ; Get integer 0-255 and return
1520-            I  3067
1520-CD 55 09    I  3068 ( 16) FNDNUM: CALL    GETCHR          ; Get next character
1523-CD C2 0D    I  3069 ( 16) GETINT: CALL    GETNUM          ; Get a number from 0 to 255
1526-CD 01 0A    I  3070 ( 16) MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
1529-7A          I  3071 (  4)         LD      A,D             ; Get MSB of number
152A-B7          I  3072 (  4)         OR      A               ; Zero?
152B-C2 1C 0A    I  3073 ( 6+)         JP      NZ,FCERR        ; No - Error
152E-2B          I  3074 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
152F-CD 55 09    I  3075 ( 16)         CALL    GETCHR          ; Get next character
1532-7B          I  3076 (  4)         LD      A,E             ; Get number to A
1533-C9          I  3077 (  9)         RET
1534-            I  3078
1534-CD 07 0A    I  3079 ( 16) PEEK:   CALL    DEINT           ; Get memory address
1537-1A          I  3080 (  6)         LD      A,(DE)          ; Get byte in memory
1538-C3 8C 11    I  3081 (  9)         JP      PASSA           ; Return integer A
153B-            I  3082
153B-CD C2 0D    I  3083 ( 16) POKE:   CALL    GETNUM          ; Get memory address
153E-CD 07 0A    I  3084 ( 16)         CALL    DEINT           ; Get integer -32768 to 3276
1541-D5          I  3085 ( 11)         PUSH    DE              ; Save memory address
1542-CD CB 07    I  3086 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1545-2C          I  3087               .DB      ','
1546-CD 23 15    I  3088 ( 16)         CALL    GETINT          ; Get integer 0-255
1549-D1          I  3089 (  9)         POP     DE              ; Restore memory address
154A-12          I  3090 (  7)         LD      (DE),A          ; Load it into memory
154B-C9          I  3091 (  9)         RET
154C-            I  3092
154C-21 22 1A    I  3093 (  9) ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
154F-CD F3 17    I  3094 ( 16) ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
1552-C3 5E 15    I  3095 (  9)         JP      FPADD           ; Add BCDE to FPREG
1555-            I  3096
1555-CD F3 17    I  3097 ( 16) SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
1558-21          I  3098               .DB      21H             ; Skip "POP BC" and "POP DE"
1559-C1          I  3099 (  9) PSUB:   POP     BC              ; Get FP number from stack
155A-D1          I  3100 (  9)         POP     DE
155B-CD CD 17    I  3101 ( 16) SUBCDE: CALL    INVSGN          ; Negate FPREG
155E-78          I  3102 (  4) FPADD:  LD      A,B             ; Get FP exponent
155F-B7          I  3103 (  4)         OR      A               ; Is number zero?
1560-C8          I  3104 ( 5+)         RET     Z               ; Yes - Nothing to add
1561-3A 2C 23    I  3105 ( 12)         LD      A,(FPEXP)       ; Get FPREG exponent
1564-B7          I  3106 (  4)         OR      A               ; Is this number zero?
1565-CA E5 17    I  3107 ( 6+)         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
1568-90          I  3108 (  4)         SUB     B               ; BCDE number larger?
1569-D2 78 15    I  3109 ( 6+)         JP      NC,NOSWAP       ; No - Don't swap them
156C-2F          I  3110 (  3)         CPL                     ; Two's complement
156D-3C          I  3111 (  4)         INC     A               ;  FP exponent
156E-EB          I  3112 (  3)         EX      DE,HL
156F-CD D5 17    I  3113 ( 16)         CALL    STAKFP          ; Put FPREG on stack
1572-EB          I  3114 (  3)         EX      DE,HL
1573-CD E5 17    I  3115 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
1576-C1          I  3116 (  9)         POP     BC              ; Restore number from stack
1577-D1          I  3117 (  9)         POP     DE
1578-FE 19       I  3118 (  6) NOSWAP: CP      24+1            ; Second number insignificant?
157A-D0          I  3119 ( 5+)         RET     NC              ; Yes - First number is result
157B-F5          I  3120 ( 11)         PUSH    AF              ; Save number of bits to scale
157C-CD 0A 18    I  3121 ( 16)         CALL    SIGNS           ; Set MSBs & sign of result
157F-67          I  3122 (  4)         LD      H,A             ; Save sign of result
1580-F1          I  3123 (  9)         POP     AF              ; Restore scaling factor
1581-CD 23 16    I  3124 ( 16)         CALL    SCALE           ; Scale BCDE to same exponent
1584-B4          I  3125 (  4)         OR      H               ; Result to be positive?
1585-21 29 23    I  3126 (  9)         LD      HL,FPREG        ; Point to FPREG
1588-F2 9E 15    I  3127 ( 6+)         JP      P,MINCDE        ; No - Subtract FPREG from CDE
158B-CD 03 16    I  3128 ( 16)         CALL    PLUCDE          ; Add FPREG to CDE
158E-D2 E4 15    I  3129 ( 6+)         JP      NC,RONDUP       ; No overflow - Round it up
1591-23          I  3130 (  4)         INC     HL              ; Point to exponent
1592-34          I  3131 ( 10)         INC     (HL)            ; Increment it
1593-CA 0C 05    I  3132 ( 6+)         JP      Z,OVERR         ; Number overflowed - Error
1596-2E 01       I  3133 (  6)         LD      L,1             ; 1 bit to shift right
1598-CD 39 16    I  3134 ( 16)         CALL    SHRT1           ; Shift result right
159B-C3 E4 15    I  3135 (  9)         JP      RONDUP          ; Round it up
159E-            I  3136
159E-AF          I  3137 (  4) MINCDE: XOR     A               ; Clear A and carry
159F-90          I  3138 (  4)         SUB     B               ; Negate exponent
15A0-47          I  3139 (  4)         LD      B,A             ; Re-save exponent
15A1-7E          I  3140 (  6)         LD      A,(HL)          ; Get LSB of FPREG
15A2-9B          I  3141 (  4)         SBC     A, E            ; Subtract LSB of BCDE
15A3-5F          I  3142 (  4)         LD      E,A             ; Save LSB of BCDE
15A4-23          I  3143 (  4)         INC     HL
15A5-7E          I  3144 (  6)         LD      A,(HL)          ; Get NMSB of FPREG
15A6-9A          I  3145 (  4)         SBC     A,D             ; Subtract NMSB of BCDE
15A7-57          I  3146 (  4)         LD      D,A             ; Save NMSB of BCDE
15A8-23          I  3147 (  4)         INC     HL
15A9-7E          I  3148 (  6)         LD      A,(HL)          ; Get MSB of FPREG
15AA-99          I  3149 (  4)         SBC     A,C             ; Subtract MSB of BCDE
15AB-4F          I  3150 (  4)         LD      C,A             ; Save MSB of BCDE
15AC-DC 0F 16    I  3151 ( 6+) CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
15AF-            I  3152
15AF-68          I  3153 (  4) BNORM:  LD      L,B             ; L = Exponent
15B0-63          I  3154 (  4)         LD      H,E             ; H = LSB
15B1-AF          I  3155 (  4)         XOR     A
15B2-47          I  3156 (  4) BNRMLP: LD      B,A             ; Save bit count
15B3-79          I  3157 (  4)         LD      A,C             ; Get MSB
15B4-B7          I  3158 (  4)         OR      A               ; Is it zero?
15B5-C2 D1 15    I  3159 ( 6+)         JP      NZ,PNORM        ; No - Do it bit at a time
15B8-4A          I  3160 (  4)         LD      C,D             ; MSB = NMSB
15B9-54          I  3161 (  4)         LD      D,H             ; NMSB= LSB
15BA-65          I  3162 (  4)         LD      H,L             ; LSB = VLSB
15BB-6F          I  3163 (  4)         LD      L,A             ; VLSB= 0
15BC-78          I  3164 (  4)         LD      A,B             ; Get exponent
15BD-D6 08       I  3165 (  6)         SUB     8               ; Count 8 bits
15BF-FE E0       I  3166 (  6)         CP      -24-8           ; Was number zero?
15C1-C2 B2 15    I  3167 ( 6+)         JP      NZ,BNRMLP       ; No - Keep normalising
15C4-AF          I  3168 (  4) RESZER: XOR     A               ; Result is zero
15C5-32 2C 23    I  3169 ( 13) SAVEXP: LD      (FPEXP),A       ; Save result as zero
15C8-C9          I  3170 (  9)         RET
15C9-            I  3171
15C9-05          I  3172 (  4) NORMAL: DEC     B               ; Count bits
15CA-29          I  3173 (  7)         ADD     HL,HL           ; Shift HL left
15CB-7A          I  3174 (  4)         LD      A,D             ; Get NMSB
15CC-17          I  3175 (  3)         RLA                     ; Shift left with last bit
15CD-57          I  3176 (  4)         LD      D,A             ; Save NMSB
15CE-79          I  3177 (  4)         LD      A,C             ; Get MSB
15CF-8F          I  3178 (  4)         ADC     A,A             ; Shift left with last bit
15D0-4F          I  3179 (  4)         LD      C,A             ; Save MSB
15D1-F2 C9 15    I  3180 ( 6+) PNORM:  JP      P,NORMAL        ; Not done - Keep going
15D4-78          I  3181 (  4)         LD      A,B             ; Number of bits shifted
15D5-5C          I  3182 (  4)         LD      E,H             ; Save HL in EB
15D6-45          I  3183 (  4)         LD      B,L
15D7-B7          I  3184 (  4)         OR      A               ; Any shifting done?
15D8-CA E4 15    I  3185 ( 6+)         JP      Z,RONDUP        ; No - Round it up
15DB-21 2C 23    I  3186 (  9)         LD      HL,FPEXP        ; Point to exponent
15DE-86          I  3187 (  6)         ADD     A,(HL)          ; Add shifted bits
15DF-77          I  3188 (  7)         LD      (HL),A          ; Re-save exponent
15E0-D2 C4 15    I  3189 ( 6+)         JP      NC,RESZER       ; Underflow - Result is zero
15E3-C8          I  3190 ( 5+)         RET     Z               ; Result is zero
15E4-78          I  3191 (  4) RONDUP: LD      A,B             ; Get VLSB of number
15E5-21 2C 23    I  3192 (  9) RONDB:  LD      HL,FPEXP        ; Point to exponent
15E8-B7          I  3193 (  4)         OR      A               ; Any rounding?
15E9-FC F6 15    I  3194 ( 6+)         CALL    M,FPROND        ; Yes - Round number up
15EC-46          I  3195 (  6)         LD      B,(HL)          ; B = Exponent
15ED-23          I  3196 (  4)         INC     HL
15EE-7E          I  3197 (  6)         LD      A,(HL)          ; Get sign of result
15EF-E6 80       I  3198 (  6)         AND     10000000B       ; Only bit 7 needed
15F1-A9          I  3199 (  4)         XOR     C               ; Set correct sign
15F2-4F          I  3200 (  4)         LD      C,A             ; Save correct sign in number
15F3-C3 E5 17    I  3201 (  9)         JP      FPBCDE          ; Move BCDE to FPREG
15F6-            I  3202
15F6-1C          I  3203 (  4) FPROND: INC     E               ; Round LSB
15F7-C0          I  3204 ( 5+)         RET     NZ              ; Return if ok
15F8-14          I  3205 (  4)         INC     D               ; Round NMSB
15F9-C0          I  3206 ( 5+)         RET     NZ              ; Return if ok
15FA-0C          I  3207 (  4)         INC     C               ; Round MSB
15FB-C0          I  3208 ( 5+)         RET     NZ              ; Return if ok
15FC-0E 80       I  3209 (  6)         LD      C,80H           ; Set normal value
15FE-34          I  3210 ( 10)         INC     (HL)            ; Increment exponent
15FF-C0          I  3211 ( 5+)         RET     NZ              ; Return if ok
1600-C3 0C 05    I  3212 (  9)         JP      OVERR           ; Overflow error
1603-            I  3213
1603-7E          I  3214 (  6) PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
1604-83          I  3215 (  4)         ADD     A,E             ; Add LSB of BCDE
1605-5F          I  3216 (  4)         LD      E,A             ; Save LSB of BCDE
1606-23          I  3217 (  4)         INC     HL
1607-7E          I  3218 (  6)         LD      A,(HL)          ; Get NMSB of FPREG
1608-8A          I  3219 (  4)         ADC     A,D             ; Add NMSB of BCDE
1609-57          I  3220 (  4)         LD      D,A             ; Save NMSB of BCDE
160A-23          I  3221 (  4)         INC     HL
160B-7E          I  3222 (  6)         LD      A,(HL)          ; Get MSB of FPREG
160C-89          I  3223 (  4)         ADC     A,C             ; Add MSB of BCDE
160D-4F          I  3224 (  4)         LD      C,A             ; Save MSB of BCDE
160E-C9          I  3225 (  9)         RET
160F-            I  3226
160F-21 2D 23    I  3227 (  9) COMPL:  LD      HL,SGNRES       ; Sign of result
1612-7E          I  3228 (  6)         LD      A,(HL)          ; Get sign of result
1613-2F          I  3229 (  3)         CPL                     ; Negate it
1614-77          I  3230 (  7)         LD      (HL),A          ; Put it back
1615-AF          I  3231 (  4)         XOR     A
1616-6F          I  3232 (  4)         LD      L,A             ; Set L to zero
1617-90          I  3233 (  4)         SUB     B               ; Negate exponent,set carry
1618-47          I  3234 (  4)         LD      B,A             ; Re-save exponent
1619-7D          I  3235 (  4)         LD      A,L             ; Load zero
161A-9B          I  3236 (  4)         SBC     A,E             ; Negate LSB
161B-5F          I  3237 (  4)         LD      E,A             ; Re-save LSB
161C-7D          I  3238 (  4)         LD      A,L             ; Load zero
161D-9A          I  3239 (  4)         SBC     A,D             ; Negate NMSB
161E-57          I  3240 (  4)         LD      D,A             ; Re-save NMSB
161F-7D          I  3241 (  4)         LD      A,L             ; Load zero
1620-99          I  3242 (  4)         SBC     A,C             ; Negate MSB
1621-4F          I  3243 (  4)         LD      C,A             ; Re-save MSB
1622-C9          I  3244 (  9)         RET
1623-            I  3245
1623-06 00       I  3246 (  6) SCALE:  LD      B,0             ; Clear underflow
1625-D6 08       I  3247 (  6) SCALLP: SUB     8               ; 8 bits (a whole byte)?
1627-DA 32 16    I  3248 ( 6+)         JP      C,SHRITE        ; No - Shift right A bits
162A-43          I  3249 (  4)         LD      B,E             ; <- Shift
162B-5A          I  3250 (  4)         LD      E,D             ; <- right
162C-51          I  3251 (  4)         LD      D,C             ; <- eight
162D-0E 00       I  3252 (  6)         LD      C,0             ; <- bits
162F-C3 25 16    I  3253 (  9)         JP      SCALLP          ; More bits to shift
1632-            I  3254
1632-C6 09       I  3255 (  6) SHRITE: ADD     A,8+1           ; Adjust count
1634-6F          I  3256 (  4)         LD      L,A             ; Save bits to shift
1635-AF          I  3257 (  4) SHRLP:  XOR     A               ; Flag for all done
1636-2D          I  3258 (  4)         DEC     L               ; All shifting done?
1637-C8          I  3259 ( 5+)         RET     Z               ; Yes - Return
1638-79          I  3260 (  4)         LD      A,C             ; Get MSB
1639-1F          I  3261 (  3) SHRT1:  RRA                     ; Shift it right
163A-4F          I  3262 (  4)         LD      C,A             ; Re-save
163B-7A          I  3263 (  4)         LD      A,D             ; Get NMSB
163C-1F          I  3264 (  3)         RRA                     ; Shift right with last bit
163D-57          I  3265 (  4)         LD      D,A             ; Re-save it
163E-7B          I  3266 (  4)         LD      A,E             ; Get LSB
163F-1F          I  3267 (  3)         RRA                     ; Shift right with last bit
1640-5F          I  3268 (  4)         LD      E,A             ; Re-save it
1641-78          I  3269 (  4)         LD      A,B             ; Get underflow
1642-1F          I  3270 (  3)         RRA                     ; Shift right with last bit
1643-47          I  3271 (  4)         LD      B,A             ; Re-save underflow
1644-C3 35 16    I  3272 (  9)         JP      SHRLP           ; More bits to do
1647-            I  3273
1647-00 00 00 81 I  3274       UNITY:  .DB       000H,000H,000H,081H    ; 1.00000
164B-            I  3275
164B-03          I  3276       LOGTAB: .DB      3                       ; Table used by LOG
164C-AA 56 19 80 I  3277               .DB      0AAH,056H,019H,080H     ; 0.59898
1650-F1 22 76 80 I  3278               .DB      0F1H,022H,076H,080H     ; 0.96147
1654-45 AA 38 82 I  3279               .DB      045H,0AAH,038H,082H     ; 2.88539
1658-            I  3280
1658-CD A4 17    I  3281 ( 16) LOG:    CALL    TSTSGN          ; Test sign of value
165B-B7          I  3282 (  4)         OR      A
165C-EA 1C 0A    I  3283 ( 6+)         JP      PE,FCERR        ; ?FC Error if <= zero
165F-21 2C 23    I  3284 (  9)         LD      HL,FPEXP        ; Point to exponent
1662-7E          I  3285 (  6)         LD      A,(HL)          ; Get exponent
1663-01 35 80    I  3286 (  9)         LD      BC,8035H        ; BCDE = SQR(1/2)
1666-11 F3 04    I  3287 (  9)         LD      DE,04F3H
1669-90          I  3288 (  4)         SUB     B               ; Scale value to be < 1
166A-F5          I  3289 ( 11)         PUSH    AF              ; Save scale factor
166B-70          I  3290 (  7)         LD      (HL),B          ; Save new exponent
166C-D5          I  3291 ( 11)         PUSH    DE              ; Save SQR(1/2)
166D-C5          I  3292 ( 11)         PUSH    BC
166E-CD 5E 15    I  3293 ( 16)         CALL    FPADD           ; Add SQR(1/2) to value
1671-C1          I  3294 (  9)         POP     BC              ; Restore SQR(1/2)
1672-D1          I  3295 (  9)         POP     DE
1673-04          I  3296 (  4)         INC     B               ; Make it SQR(2)
1674-CD FA 16    I  3297 ( 16)         CALL    DVBCDE          ; Divide by SQR(2)
1677-21 47 16    I  3298 (  9)         LD      HL,UNITY        ; Point to 1.
167A-CD 55 15    I  3299 ( 16)         CALL    SUBPHL          ; Subtract FPREG from 1
167D-21 4B 16    I  3300 (  9)         LD      HL,LOGTAB       ; Coefficient table
1680-CD EC 1A    I  3301 ( 16)         CALL    SUMSER          ; Evaluate sum of series
1683-01 80 80    I  3302 (  9)         LD      BC,8080H        ; BCDE = -0.5
1686-11 00 00    I  3303 (  9)         LD      DE,0000H
1689-CD 5E 15    I  3304 ( 16)         CALL    FPADD           ; Subtract 0.5 from FPREG
168C-F1          I  3305 (  9)         POP     AF              ; Restore scale factor
168D-CD 1F 19    I  3306 ( 16)         CALL    RSCALE          ; Re-scale number
1690-01 31 80    I  3307 (  9) MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
1693-11 18 72    I  3308 (  9)         LD      DE,7218H
1696-21          I  3309               .DB      21H             ; Skip "POP BC" and "POP DE"
1697-            I  3310
1697-C1          I  3311 (  9) MULT:   POP     BC              ; Get number from stack
1698-D1          I  3312 (  9)         POP     DE
1699-CD A4 17    I  3313 ( 16) FPMULT: CALL    TSTSGN          ; Test sign of FPREG
169C-C8          I  3314 ( 5+)         RET     Z               ; Return zero if zero
169D-2E 00       I  3315 (  6)         LD      L,0             ; Flag add exponents
169F-CD 62 17    I  3316 ( 16)         CALL    ADDEXP          ; Add exponents
16A2-79          I  3317 (  4)         LD      A,C             ; Get MSB of multiplier
16A3-32 3B 23    I  3318 ( 13)         LD      (MULVAL),A      ; Save MSB of multiplier
16A6-EB          I  3319 (  3)         EX      DE,HL
16A7-22 3C 23    I  3320 ( 20)         LD      (MULVAL+1),HL   ; Save rest of multiplier
16AA-01 00 00    I  3321 (  9)         LD      BC,0            ; Partial product (BCDE) = zero
16AD-50          I  3322 (  4)         LD      D,B
16AE-58          I  3323 (  4)         LD      E,B
16AF-21 AF 15    I  3324 (  9)         LD      HL,BNORM        ; Address of normalise
16B2-E5          I  3325 ( 11)         PUSH    HL              ; Save for return
16B3-21 BB 16    I  3326 (  9)         LD      HL,MULT8        ; Address of 8 bit multiply
16B6-E5          I  3327 ( 11)         PUSH    HL              ; Save for NMSB,MSB
16B7-E5          I  3328 ( 11)         PUSH    HL              ;
16B8-21 29 23    I  3329 (  9)         LD      HL,FPREG        ; Point to number
16BB-7E          I  3330 (  6) MULT8:  LD      A,(HL)          ; Get LSB of number
16BC-23          I  3331 (  4)         INC     HL              ; Point to NMSB
16BD-B7          I  3332 (  4)         OR      A               ; Test LSB
16BE-CA E7 16    I  3333 ( 6+)         JP      Z,BYTSFT        ; Zero - shift to next byte
16C1-E5          I  3334 ( 11)         PUSH    HL              ; Save address of number
16C2-2E 08       I  3335 (  6)         LD      L,8             ; 8 bits to multiply by
16C4-1F          I  3336 (  3) MUL8LP: RRA                     ; Shift LSB right
16C5-67          I  3337 (  4)         LD      H,A             ; Save LSB
16C6-79          I  3338 (  4)         LD      A,C             ; Get MSB
16C7-D2 D5 16    I  3339 ( 6+)         JP      NC,NOMADD       ; Bit was zero - Don't add
16CA-E5          I  3340 ( 11)         PUSH    HL              ; Save LSB and count
16CB-2A 3C 23    I  3341 ( 15)         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
16CE-19          I  3342 (  7)         ADD     HL,DE           ; Add NMSB and LSB
16CF-EB          I  3343 (  3)         EX      DE,HL           ; Leave sum in DE
16D0-E1          I  3344 (  9)         POP     HL              ; Restore MSB and count
16D1-3A 3B 23    I  3345 ( 12)         LD      A,(MULVAL)      ; Get MSB of multiplier
16D4-89          I  3346 (  4)         ADC     A,C             ; Add MSB
16D5-1F          I  3347 (  3) NOMADD: RRA                     ; Shift MSB right
16D6-4F          I  3348 (  4)         LD      C,A             ; Re-save MSB
16D7-7A          I  3349 (  4)         LD      A,D             ; Get NMSB
16D8-1F          I  3350 (  3)         RRA                     ; Shift NMSB right
16D9-57          I  3351 (  4)         LD      D,A             ; Re-save NMSB
16DA-7B          I  3352 (  4)         LD      A,E             ; Get LSB
16DB-1F          I  3353 (  3)         RRA                     ; Shift LSB right
16DC-5F          I  3354 (  4)         LD      E,A             ; Re-save LSB
16DD-78          I  3355 (  4)         LD      A,B             ; Get VLSB
16DE-1F          I  3356 (  3)         RRA                     ; Shift VLSB right
16DF-47          I  3357 (  4)         LD      B,A             ; Re-save VLSB
16E0-2D          I  3358 (  4)         DEC     L               ; Count bits multiplied
16E1-7C          I  3359 (  4)         LD      A,H             ; Get LSB of multiplier
16E2-C2 C4 16    I  3360 ( 6+)         JP      NZ,MUL8LP       ; More - Do it
16E5-E1          I  3361 (  9) POPHRT: POP     HL              ; Restore address of number
16E6-C9          I  3362 (  9)         RET
16E7-            I  3363
16E7-43          I  3364 (  4) BYTSFT: LD      B,E             ; Shift partial product left
16E8-5A          I  3365 (  4)         LD      E,D
16E9-51          I  3366 (  4)         LD      D,C
16EA-4F          I  3367 (  4)         LD      C,A
16EB-C9          I  3368 (  9)         RET
16EC-            I  3369
16EC-CD D5 17    I  3370 ( 16) DIV10:  CALL    STAKFP          ; Save FPREG on stack
16EF-01 20 84    I  3371 (  9)         LD      BC,8420H        ; BCDE = 10.
16F2-11 00 00    I  3372 (  9)         LD      DE,0000H
16F5-CD E5 17    I  3373 ( 16)         CALL    FPBCDE          ; Move 10 to FPREG
16F8-            I  3374
16F8-C1          I  3375 (  9) DIV:    POP     BC              ; Get number from stack
16F9-D1          I  3376 (  9)         POP     DE
16FA-CD A4 17    I  3377 ( 16) DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
16FD-CA 00 05    I  3378 ( 6+)         JP      Z,DZERR         ; Error if division by zero
1700-2E FF       I  3379 (  6)         LD      L,-1            ; Flag subtract exponents
1702-CD 62 17    I  3380 ( 16)         CALL    ADDEXP          ; Subtract exponents
1705-34          I  3381 ( 10)         INC     (HL)            ; Add 2 to exponent to adjust
1706-34          I  3382 ( 10)         INC     (HL)
1707-2B          I  3383 (  4)         DEC     HL              ; Point to MSB
1708-7E          I  3384 (  6)         LD      A,(HL)          ; Get MSB of dividend
1709-32 57 22    I  3385 ( 13)         LD      (DIV3),A        ; Save for subtraction
170C-2B          I  3386 (  4)         DEC     HL
170D-7E          I  3387 (  6)         LD      A,(HL)          ; Get NMSB of dividend
170E-32 53 22    I  3388 ( 13)         LD      (DIV2),A        ; Save for subtraction
1711-2B          I  3389 (  4)         DEC     HL
1712-7E          I  3390 (  6)         LD      A,(HL)          ; Get MSB of dividend
1713-32 4F 22    I  3391 ( 13)         LD      (DIV1),A        ; Save for subtraction
1716-41          I  3392 (  4)         LD      B,C             ; Get MSB
1717-EB          I  3393 (  3)         EX      DE,HL           ; NMSB,LSB to HL
1718-AF          I  3394 (  4)         XOR     A
1719-4F          I  3395 (  4)         LD      C,A             ; Clear MSB of quotient
171A-57          I  3396 (  4)         LD      D,A             ; Clear NMSB of quotient
171B-5F          I  3397 (  4)         LD      E,A             ; Clear LSB of quotient
171C-32 5A 22    I  3398 ( 13)         LD      (DIV4),A        ; Clear overflow count
171F-E5          I  3399 ( 11) DIVLP:  PUSH    HL              ; Save divisor
1720-C5          I  3400 ( 11)         PUSH    BC
1721-7D          I  3401 (  4)         LD      A,L             ; Get LSB of number
1722-CD 4E 22    I  3402 ( 16)         CALL    DIVSUP          ; Subt' divisor from dividend
1725-DE 00       I  3403 (  6)         SBC     A,0             ; Count for overflows
1727-3F          I  3404 (  3)         CCF
1728-D2 32 17    I  3405 ( 6+)         JP      NC,RESDIV       ; Restore divisor if borrow
172B-32 5A 22    I  3406 ( 13)         LD      (DIV4),A        ; Re-save overflow count
172E-F1          I  3407 (  9)         POP     AF              ; Scrap divisor
172F-F1          I  3408 (  9)         POP     AF
1730-37          I  3409 (  3)         SCF                     ; Set carry to
1731-D2          I  3410               .DB      0D2H            ; Skip "POP BC" and "POP HL"
1732-            I  3411
1732-C1          I  3412 (  9) RESDIV: POP     BC              ; Restore divisor
1733-E1          I  3413 (  9)         POP     HL
1734-79          I  3414 (  4)         LD      A,C             ; Get MSB of quotient
1735-3C          I  3415 (  4)         INC     A
1736-3D          I  3416 (  4)         DEC     A
1737-1F          I  3417 (  3)         RRA                     ; Bit 0 to bit 7
1738-FA E5 15    I  3418 ( 6+)         JP      M,RONDB         ; Done - Normalise result
173B-17          I  3419 (  3)         RLA                     ; Restore carry
173C-7B          I  3420 (  4)         LD      A,E             ; Get LSB of quotient
173D-17          I  3421 (  3)         RLA                     ; Double it
173E-5F          I  3422 (  4)         LD      E,A             ; Put it back
173F-7A          I  3423 (  4)         LD      A,D             ; Get NMSB of quotient
1740-17          I  3424 (  3)         RLA                     ; Double it
1741-57          I  3425 (  4)         LD      D,A             ; Put it back
1742-79          I  3426 (  4)         LD      A,C             ; Get MSB of quotient
1743-17          I  3427 (  3)         RLA                     ; Double it
1744-4F          I  3428 (  4)         LD      C,A             ; Put it back
1745-29          I  3429 (  7)         ADD     HL,HL           ; Double NMSB,LSB of divisor
1746-78          I  3430 (  4)         LD      A,B             ; Get MSB of divisor
1747-17          I  3431 (  3)         RLA                     ; Double it
1748-47          I  3432 (  4)         LD      B,A             ; Put it back
1749-3A 5A 22    I  3433 ( 12)         LD      A,(DIV4)        ; Get VLSB of quotient
174C-17          I  3434 (  3)         RLA                     ; Double it
174D-32 5A 22    I  3435 ( 13)         LD      (DIV4),A        ; Put it back
1750-79          I  3436 (  4)         LD      A,C             ; Get MSB of quotient
1751-B2          I  3437 (  4)         OR      D               ; Merge NMSB
1752-B3          I  3438 (  4)         OR      E               ; Merge LSB
1753-C2 1F 17    I  3439 ( 6+)         JP      NZ,DIVLP        ; Not done - Keep dividing
1756-E5          I  3440 ( 11)         PUSH    HL              ; Save divisor
1757-21 2C 23    I  3441 (  9)         LD      HL,FPEXP        ; Point to exponent
175A-35          I  3442 ( 10)         DEC     (HL)            ; Divide by 2
175B-E1          I  3443 (  9)         POP     HL              ; Restore divisor
175C-C2 1F 17    I  3444 ( 6+)         JP      NZ,DIVLP        ; Ok - Keep going
175F-C3 0C 05    I  3445 (  9)         JP      OVERR           ; Overflow error
1762-            I  3446
1762-78          I  3447 (  4) ADDEXP: LD      A,B             ; Get exponent of dividend
1763-B7          I  3448 (  4)         OR      A               ; Test it
1764-CA 86 17    I  3449 ( 6+)         JP      Z,OVTST3        ; Zero - Result zero
1767-7D          I  3450 (  4)         LD      A,L             ; Get add/subtract flag
1768-21 2C 23    I  3451 (  9)         LD      HL,FPEXP        ; Point to exponent
176B-AE          I  3452 (  6)         XOR     (HL)            ; Add or subtract it
176C-80          I  3453 (  4)         ADD     A,B             ; Add the other exponent
176D-47          I  3454 (  4)         LD      B,A             ; Save new exponent
176E-1F          I  3455 (  3)         RRA                     ; Test exponent for overflow
176F-A8          I  3456 (  4)         XOR     B
1770-78          I  3457 (  4)         LD      A,B             ; Get exponent
1771-F2 85 17    I  3458 ( 6+)         JP      P,OVTST2        ; Positive - Test for overflow
1774-C6 80       I  3459 (  6)         ADD     A,80H           ; Add excess 128
1776-77          I  3460 (  7)         LD      (HL),A          ; Save new exponent
1777-CA E5 16    I  3461 ( 6+)         JP      Z,POPHRT        ; Zero - Result zero
177A-CD 0A 18    I  3462 ( 16)         CALL    SIGNS           ; Set MSBs and sign of result
177D-77          I  3463 (  7)         LD      (HL),A          ; Save new exponent
177E-2B          I  3464 (  4)         DEC     HL              ; Point to MSB
177F-C9          I  3465 (  9)         RET
1780-            I  3466
1780-CD A4 17    I  3467 ( 16) OVTST1: CALL    TSTSGN          ; Test sign of FPREG
1783-2F          I  3468 (  3)         CPL                     ; Invert sign
1784-E1          I  3469 (  9)         POP     HL              ; Clean up stack
1785-B7          I  3470 (  4) OVTST2: OR      A               ; Test if new exponent zero
1786-E1          I  3471 (  9) OVTST3: POP     HL              ; Clear off return address
1787-F2 C4 15    I  3472 ( 6+)         JP      P,RESZER        ; Result zero
178A-C3 0C 05    I  3473 (  9)         JP      OVERR           ; Overflow error
178D-            I  3474
178D-CD F0 17    I  3475 ( 16) MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
1790-78          I  3476 (  4)         LD      A,B             ; Get exponent
1791-B7          I  3477 (  4)         OR      A               ; Is it zero?
1792-C8          I  3478 ( 5+)         RET     Z               ; Yes - Result is zero
1793-C6 02       I  3479 (  6)         ADD     A,2             ; Multiply by 4
1795-DA 0C 05    I  3480 ( 6+)         JP      C,OVERR         ; Overflow - ?OV Error
1798-47          I  3481 (  4)         LD      B,A             ; Re-save exponent
1799-CD 5E 15    I  3482 ( 16)         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
179C-21 2C 23    I  3483 (  9)         LD      HL,FPEXP        ; Point to exponent
179F-34          I  3484 ( 10)         INC     (HL)            ; Double number (Times 10)
17A0-C0          I  3485 ( 5+)         RET     NZ              ; Ok - Return
17A1-C3 0C 05    I  3486 (  9)         JP      OVERR           ; Overflow error
17A4-            I  3487
17A4-3A 2C 23    I  3488 ( 12) TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
17A7-B7          I  3489 (  4)         OR      A
17A8-C8          I  3490 ( 5+)         RET     Z               ; RETurn if number is zero
17A9-3A 2B 23    I  3491 ( 12)         LD      A,(FPREG+2)     ; Get MSB of FPREG
17AC-FE          I  3492               .DB      0FEH            ; Test sign
17AD-2F          I  3493 (  3) RETREL: CPL                     ; Invert sign
17AE-17          I  3494 (  3)         RLA                     ; Sign bit to carry
17AF-9F          I  3495 (  4) FLGDIF: SBC     A,A             ; Carry to all bits of A
17B0-C0          I  3496 ( 5+)         RET     NZ              ; Return -1 if negative
17B1-3C          I  3497 (  4)         INC     A               ; Bump to +1
17B2-C9          I  3498 (  9)         RET                     ; Positive - Return +1
17B3-            I  3499
17B3-CD A4 17    I  3500 ( 16) SGN:    CALL    TSTSGN          ; Test sign of FPREG
17B6-06 88       I  3501 (  6) FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
17B8-11 00 00    I  3502 (  9)         LD      DE,0            ; Zero NMSB and LSB
17BB-21 2C 23    I  3503 (  9) RETINT: LD      HL,FPEXP        ; Point to exponent
17BE-4F          I  3504 (  4)         LD      C,A             ; CDE = MSB,NMSB and LSB
17BF-70          I  3505 (  7)         LD      (HL),B          ; Save exponent
17C0-06 00       I  3506 (  6)         LD      B,0             ; CDE = integer to normalise
17C2-23          I  3507 (  4)         INC     HL              ; Point to sign of result
17C3-36 80       I  3508 (  9)         LD      (HL),80H        ; Set sign of result
17C5-17          I  3509 (  3)         RLA                     ; Carry = sign of integer
17C6-C3 AC 15    I  3510 (  9)         JP      CONPOS          ; Set sign of result
17C9-            I  3511
17C9-CD A4 17    I  3512 ( 16) ABS:    CALL    TSTSGN          ; Test sign of FPREG
17CC-F0          I  3513 ( 5+)         RET     P               ; Return if positive
17CD-21 2B 23    I  3514 (  9) INVSGN: LD      HL,FPREG+2      ; Point to MSB
17D0-7E          I  3515 (  6)         LD      A,(HL)          ; Get sign of mantissa
17D1-EE 80       I  3516 (  6)         XOR     80H             ; Invert sign of mantissa
17D3-77          I  3517 (  7)         LD      (HL),A          ; Re-save sign of mantissa
17D4-C9          I  3518 (  9)         RET
17D5-            I  3519
17D5-EB          I  3520 (  3) STAKFP: EX      DE,HL           ; Save code string address
17D6-2A 29 23    I  3521 ( 15)         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
17D9-E3          I  3522 ( 16)         EX      (SP),HL         ; Stack them,get return
17DA-E5          I  3523 ( 11)         PUSH    HL              ; Re-save return
17DB-2A 2B 23    I  3524 ( 15)         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
17DE-E3          I  3525 ( 16)         EX      (SP),HL         ; Stack them,get return
17DF-E5          I  3526 ( 11)         PUSH    HL              ; Re-save return
17E0-EB          I  3527 (  3)         EX      DE,HL           ; Restore code string address
17E1-C9          I  3528 (  9)         RET
17E2-            I  3529
17E2-CD F3 17    I  3530 ( 16) PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
17E5-EB          I  3531 (  3) FPBCDE: EX      DE,HL           ; Save code string address
17E6-22 29 23    I  3532 ( 20)         LD      (FPREG),HL      ; Save LSB,NLSB of number
17E9-60          I  3533 (  4)         LD      H,B             ; Exponent of number
17EA-69          I  3534 (  4)         LD      L,C             ; MSB of number
17EB-22 2B 23    I  3535 ( 20)         LD      (FPREG+2),HL    ; Save MSB and exponent
17EE-EB          I  3536 (  3)         EX      DE,HL           ; Restore code string address
17EF-C9          I  3537 (  9)         RET
17F0-            I  3538
17F0-21 29 23    I  3539 (  9) BCDEFP: LD      HL,FPREG        ; Point to FPREG
17F3-5E          I  3540 (  6) LOADFP: LD      E,(HL)          ; Get LSB of number
17F4-23          I  3541 (  4)         INC     HL
17F5-56          I  3542 (  6)         LD      D,(HL)          ; Get NMSB of number
17F6-23          I  3543 (  4)         INC     HL
17F7-4E          I  3544 (  6)         LD      C,(HL)          ; Get MSB of number
17F8-23          I  3545 (  4)         INC     HL
17F9-46          I  3546 (  6)         LD      B,(HL)          ; Get exponent of number
17FA-23          I  3547 (  4) INCHL:  INC     HL              ; Used for conditional "INC HL"
17FB-C9          I  3548 (  9)         RET
17FC-            I  3549
17FC-11 29 23    I  3550 (  9) FPTHL:  LD      DE,FPREG        ; Point to FPREG
17FF-06 04       I  3551 (  6) DETHL4: LD      B,4             ; 4 bytes to move
1801-1A          I  3552 (  6) DETHLB: LD      A,(DE)          ; Get source
1802-77          I  3553 (  7)         LD      (HL),A          ; Save destination
1803-13          I  3554 (  4)         INC     DE              ; Next source
1804-23          I  3555 (  4)         INC     HL              ; Next destination
1805-05          I  3556 (  4)         DEC     B               ; Count bytes
1806-C2 01 18    I  3557 ( 6+)         JP      NZ,DETHLB       ; Loop if more
1809-C9          I  3558 (  9)         RET
180A-            I  3559
180A-21 2B 23    I  3560 (  9) SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
180D-7E          I  3561 (  6)         LD      A,(HL)          ; Get MSB
180E-07          I  3562 (  3)         RLCA                    ; Old sign to carry
180F-37          I  3563 (  3)         SCF                     ; Set MSBit
1810-1F          I  3564 (  3)         RRA                     ; Set MSBit of MSB
1811-77          I  3565 (  7)         LD      (HL),A          ; Save new MSB
1812-3F          I  3566 (  3)         CCF                     ; Complement sign
1813-1F          I  3567 (  3)         RRA                     ; Old sign to carry
1814-23          I  3568 (  4)         INC     HL
1815-23          I  3569 (  4)         INC     HL
1816-77          I  3570 (  7)         LD      (HL),A          ; Set sign of result
1817-79          I  3571 (  4)         LD      A,C             ; Get MSB
1818-07          I  3572 (  3)         RLCA                    ; Old sign to carry
1819-37          I  3573 (  3)         SCF                     ; Set MSBit
181A-1F          I  3574 (  3)         RRA                     ; Set MSBit of MSB
181B-4F          I  3575 (  4)         LD      C,A             ; Save MSB
181C-1F          I  3576 (  3)         RRA
181D-AE          I  3577 (  6)         XOR     (HL)            ; New sign of result
181E-C9          I  3578 (  9)         RET
181F-            I  3579
181F-78          I  3580 (  4) CMPNUM: LD      A,B             ; Get exponent of number
1820-B7          I  3581 (  4)         OR      A
1821-CA A4 17    I  3582 ( 6+)         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
1824-21 AD 17    I  3583 (  9)         LD      HL,RETREL       ; Return relation routine
1827-E5          I  3584 ( 11)         PUSH    HL              ; Save for return
1828-CD A4 17    I  3585 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
182B-79          I  3586 (  4)         LD      A,C             ; Get MSB of number
182C-C8          I  3587 ( 5+)         RET     Z               ; FPREG zero - Number's MSB
182D-21 2B 23    I  3588 (  9)         LD      HL,FPREG+2      ; MSB of FPREG
1830-AE          I  3589 (  6)         XOR     (HL)            ; Combine signs
1831-79          I  3590 (  4)         LD      A,C             ; Get MSB of number
1832-F8          I  3591 ( 5+)         RET     M               ; Exit if signs different
1833-CD 39 18    I  3592 ( 16)         CALL    CMPFP           ; Compare FP numbers
1836-1F          I  3593 (  3)         RRA                     ; Get carry to sign
1837-A9          I  3594 (  4)         XOR     C               ; Combine with MSB of number
1838-C9          I  3595 (  9)         RET
1839-            I  3596
1839-23          I  3597 (  4) CMPFP:  INC     HL              ; Point to exponent
183A-78          I  3598 (  4)         LD      A,B             ; Get exponent
183B-BE          I  3599 (  6)         CP      (HL)            ; Compare exponents
183C-C0          I  3600 ( 5+)         RET     NZ              ; Different
183D-2B          I  3601 (  4)         DEC     HL              ; Point to MBS
183E-79          I  3602 (  4)         LD      A,C             ; Get MSB
183F-BE          I  3603 (  6)         CP      (HL)            ; Compare MSBs
1840-C0          I  3604 ( 5+)         RET     NZ              ; Different
1841-2B          I  3605 (  4)         DEC     HL              ; Point to NMSB
1842-7A          I  3606 (  4)         LD      A,D             ; Get NMSB
1843-BE          I  3607 (  6)         CP      (HL)            ; Compare NMSBs
1844-C0          I  3608 ( 5+)         RET     NZ              ; Different
1845-2B          I  3609 (  4)         DEC     HL              ; Point to LSB
1846-7B          I  3610 (  4)         LD      A,E             ; Get LSB
1847-96          I  3611 (  6)         SUB     (HL)            ; Compare LSBs
1848-C0          I  3612 ( 5+)         RET     NZ              ; Different
1849-E1          I  3613 (  9)         POP     HL              ; Drop RETurn
184A-E1          I  3614 (  9)         POP     HL              ; Drop another RETurn
184B-C9          I  3615 (  9)         RET
184C-            I  3616
184C-47          I  3617 (  4) FPINT:  LD      B,A             ; <- Move
184D-4F          I  3618 (  4)         LD      C,A             ; <- exponent
184E-57          I  3619 (  4)         LD      D,A             ; <- to all
184F-5F          I  3620 (  4)         LD      E,A             ; <- bits
1850-B7          I  3621 (  4)         OR      A               ; Test exponent
1851-C8          I  3622 ( 5+)         RET     Z               ; Zero - Return zero
1852-E5          I  3623 ( 11)         PUSH    HL              ; Save pointer to number
1853-CD F0 17    I  3624 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1856-CD 0A 18    I  3625 ( 16)         CALL    SIGNS           ; Set MSBs & sign of result
1859-AE          I  3626 (  6)         XOR     (HL)            ; Combine with sign of FPREG
185A-67          I  3627 (  4)         LD      H,A             ; Save combined signs
185B-FC 70 18    I  3628 ( 6+)         CALL    M,DCBCDE        ; Negative - Decrement BCDE
185E-3E 98       I  3629 (  6)         LD      A,80H+24        ; 24 bits
1860-90          I  3630 (  4)         SUB     B               ; Bits to shift
1861-CD 23 16    I  3631 ( 16)         CALL    SCALE           ; Shift BCDE
1864-7C          I  3632 (  4)         LD      A,H             ; Get combined sign
1865-17          I  3633 (  3)         RLA                     ; Sign to carry
1866-DC F6 15    I  3634 ( 6+)         CALL    C,FPROND        ; Negative - Round number up
1869-06 00       I  3635 (  6)         LD      B,0             ; Zero exponent
186B-DC 0F 16    I  3636 ( 6+)         CALL    C,COMPL         ; If negative make positive
186E-E1          I  3637 (  9)         POP     HL              ; Restore pointer to number
186F-C9          I  3638 (  9)         RET
1870-            I  3639
1870-1B          I  3640 (  4) DCBCDE: DEC     DE              ; Decrement BCDE
1871-7A          I  3641 (  4)         LD      A,D             ; Test LSBs
1872-A3          I  3642 (  4)         AND     E
1873-3C          I  3643 (  4)         INC     A
1874-C0          I  3644 ( 5+)         RET     NZ              ; Exit if LSBs not FFFF
1875-0B          I  3645 (  4)         DEC     BC              ; Decrement MSBs
1876-C9          I  3646 (  9)         RET
1877-            I  3647
1877-21 2C 23    I  3648 (  9) INT:    LD      HL,FPEXP        ; Point to exponent
187A-7E          I  3649 (  6)         LD      A,(HL)          ; Get exponent
187B-FE 98       I  3650 (  6)         CP      80H+24          ; Integer accuracy only?
187D-3A 29 23    I  3651 ( 12)         LD      A,(FPREG)       ; Get LSB
1880-D0          I  3652 ( 5+)         RET     NC              ; Yes - Already integer
1881-7E          I  3653 (  6)         LD      A,(HL)          ; Get exponent
1882-CD 4C 18    I  3654 ( 16)         CALL    FPINT           ; F.P to integer
1885-36 98       I  3655 (  9)         LD      (HL),80H+24     ; Save 24 bit integer
1887-7B          I  3656 (  4)         LD      A,E             ; Get LSB of number
1888-F5          I  3657 ( 11)         PUSH    AF              ; Save LSB
1889-79          I  3658 (  4)         LD      A,C             ; Get MSB of number
188A-17          I  3659 (  3)         RLA                     ; Sign to carry
188B-CD AC 15    I  3660 ( 16)         CALL    CONPOS          ; Set sign of result
188E-F1          I  3661 (  9)         POP     AF              ; Restore LSB of number
188F-C9          I  3662 (  9)         RET
1890-            I  3663
1890-21 00 00    I  3664 (  9) MLDEBC: LD      HL,0            ; Clear partial product
1893-78          I  3665 (  4)         LD      A,B             ; Test multiplier
1894-B1          I  3666 (  4)         OR      C
1895-C8          I  3667 ( 5+)         RET     Z               ; Return zero if zero
1896-3E 10       I  3668 (  6)         LD      A,16            ; 16 bits
1898-29          I  3669 (  7) MLDBLP: ADD     HL,HL           ; Shift P.P left
1899-DA D0 10    I  3670 ( 6+)         JP      C,BSERR         ; ?BS Error if overflow
189C-EB          I  3671 (  3)         EX      DE,HL
189D-29          I  3672 (  7)         ADD     HL,HL           ; Shift multiplier left
189E-EB          I  3673 (  3)         EX      DE,HL
189F-D2 A6 18    I  3674 ( 6+)         JP      NC,NOMLAD       ; Bit was zero - No add
18A2-09          I  3675 (  7)         ADD     HL,BC           ; Add multiplicand
18A3-DA D0 10    I  3676 ( 6+)         JP      C,BSERR         ; ?BS Error if overflow
18A6-3D          I  3677 (  4) NOMLAD: DEC     A               ; Count bits
18A7-C2 98 18    I  3678 ( 6+)         JP      NZ,MLDBLP       ; More
18AA-C9          I  3679 (  9)         RET
18AB-            I  3680
18AB-FE 2D       I  3681 (  6) ASCTFP: CP      '-'             ; Negative?
18AD-F5          I  3682 ( 11)         PUSH    AF              ; Save it and flags
18AE-CA B7 18    I  3683 ( 6+)         JP      Z,CNVNUM        ; Yes - Convert number
18B1-FE 2B       I  3684 (  6)         CP      '+'             ; Positive?
18B3-CA B7 18    I  3685 ( 6+)         JP      Z,CNVNUM        ; Yes - Convert number
18B6-2B          I  3686 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
18B7-CD C4 15    I  3687 ( 16) CNVNUM: CALL    RESZER          ; Set result to zero
18BA-47          I  3688 (  4)         LD      B,A             ; Digits after point counter
18BB-57          I  3689 (  4)         LD      D,A             ; Sign of exponent
18BC-5F          I  3690 (  4)         LD      E,A             ; Exponent of ten
18BD-2F          I  3691 (  3)         CPL
18BE-4F          I  3692 (  4)         LD      C,A             ; Before or after point flag
18BF-CD 55 09    I  3693 ( 16) MANLP:  CALL    GETCHR          ; Get next character
18C2-DA 08 19    I  3694 ( 6+)         JP      C,ADDIG         ; Digit - Add to number
18C5-FE 2E       I  3695 (  6)         CP      '.'
18C7-CA E3 18    I  3696 ( 6+)         JP      Z,DPOINT        ; '.' - Flag point
18CA-FE 45       I  3697 (  6)         CP      'E'
18CC-C2 E7 18    I  3698 ( 6+)         JP      NZ,CONEXP       ; Not 'E' - Scale number
18CF-CD 55 09    I  3699 ( 16)         CALL    GETCHR          ; Get next character
18D2-CD FB 0E    I  3700 ( 16)         CALL    SGNEXP          ; Get sign of exponent
18D5-CD 55 09    I  3701 ( 16) EXPLP:  CALL    GETCHR          ; Get next character
18D8-DA 2A 19    I  3702 ( 6+)         JP      C,EDIGIT        ; Digit - Add to exponent
18DB-14          I  3703 (  4)         INC     D               ; Is sign negative?
18DC-C2 E7 18    I  3704 ( 6+)         JP      NZ,CONEXP       ; No - Scale number
18DF-AF          I  3705 (  4)         XOR     A
18E0-93          I  3706 (  4)         SUB     E               ; Negate exponent
18E1-5F          I  3707 (  4)         LD      E,A             ; And re-save it
18E2-0C          I  3708 (  4)         INC     C               ; Flag end of number
18E3-0C          I  3709 (  4) DPOINT: INC     C               ; Flag point passed
18E4-CA BF 18    I  3710 ( 6+)         JP      Z,MANLP         ; Zero - Get another digit
18E7-E5          I  3711 ( 11) CONEXP: PUSH    HL              ; Save code string address
18E8-7B          I  3712 (  4)         LD      A,E             ; Get exponent
18E9-90          I  3713 (  4)         SUB     B               ; Subtract digits after point
18EA-F4 00 19    I  3714 ( 6+) SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
18ED-F2 F6 18    I  3715 ( 6+)         JP      P,ENDCON        ; Positive - All done
18F0-F5          I  3716 ( 11)         PUSH    AF              ; Save number of times to /10
18F1-CD EC 16    I  3717 ( 16)         CALL    DIV10           ; Divide by 10
18F4-F1          I  3718 (  9)         POP     AF              ; Restore count
18F5-3C          I  3719 (  4)         INC     A               ; Count divides
18F6-            I  3720
18F6-C2 EA 18    I  3721 ( 6+) ENDCON: JP      NZ,SCALMI       ; More to do
18F9-D1          I  3722 (  9)         POP     DE              ; Restore code string address
18FA-F1          I  3723 (  9)         POP     AF              ; Restore sign of number
18FB-CC CD 17    I  3724 ( 6+)         CALL    Z,INVSGN        ; Negative - Negate number
18FE-EB          I  3725 (  3)         EX      DE,HL           ; Code string address to HL
18FF-C9          I  3726 (  9)         RET
1900-            I  3727
1900-C8          I  3728 ( 5+) SCALPL: RET     Z               ; Exit if no scaling needed
1901-F5          I  3729 ( 11) MULTEN: PUSH    AF              ; Save count
1902-CD 8D 17    I  3730 ( 16)         CALL    MLSP10          ; Multiply number by 10
1905-F1          I  3731 (  9)         POP     AF              ; Restore count
1906-3D          I  3732 (  4)         DEC     A               ; Count multiplies
1907-C9          I  3733 (  9)         RET
1908-            I  3734
1908-D5          I  3735 ( 11) ADDIG:  PUSH    DE              ; Save sign of exponent
1909-57          I  3736 (  4)         LD      D,A             ; Save digit
190A-78          I  3737 (  4)         LD      A,B             ; Get digits after point
190B-89          I  3738 (  4)         ADC     A,C             ; Add one if after point
190C-47          I  3739 (  4)         LD      B,A             ; Re-save counter
190D-C5          I  3740 ( 11)         PUSH    BC              ; Save point flags
190E-E5          I  3741 ( 11)         PUSH    HL              ; Save code string address
190F-D5          I  3742 ( 11)         PUSH    DE              ; Save digit
1910-CD 8D 17    I  3743 ( 16)         CALL    MLSP10          ; Multiply number by 10
1913-F1          I  3744 (  9)         POP     AF              ; Restore digit
1914-D6 30       I  3745 (  6)         SUB     '0'             ; Make it absolute
1916-CD 1F 19    I  3746 ( 16)         CALL    RSCALE          ; Re-scale number
1919-E1          I  3747 (  9)         POP     HL              ; Restore code string address
191A-C1          I  3748 (  9)         POP     BC              ; Restore point flags
191B-D1          I  3749 (  9)         POP     DE              ; Restore sign of exponent
191C-C3 BF 18    I  3750 (  9)         JP      MANLP           ; Get another digit
191F-            I  3751
191F-CD D5 17    I  3752 ( 16) RSCALE: CALL    STAKFP          ; Put number on stack
1922-CD B6 17    I  3753 ( 16)         CALL    FLGREL          ; Digit to add to FPREG
1925-C1          I  3754 (  9) PADD:   POP     BC              ; Restore number
1926-D1          I  3755 (  9)         POP     DE
1927-C3 5E 15    I  3756 (  9)         JP      FPADD           ; Add BCDE to FPREG and return
192A-            I  3757
192A-7B          I  3758 (  4) EDIGIT: LD      A,E             ; Get digit
192B-07          I  3759 (  3)         RLCA                    ; Times 2
192C-07          I  3760 (  3)         RLCA                    ; Times 4
192D-83          I  3761 (  4)         ADD     A,E             ; Times 5
192E-07          I  3762 (  3)         RLCA                    ; Times 10
192F-86          I  3763 (  6)         ADD     A,(HL)          ; Add next digit
1930-D6 30       I  3764 (  6)         SUB     '0'             ; Make it absolute
1932-5F          I  3765 (  4)         LD      E,A             ; Save new digit
1933-C3 D5 18    I  3766 (  9)         JP      EXPLP           ; Look for another digit
1936-            I  3767
1936-E5          I  3768 ( 11) LINEIN: PUSH    HL              ; Save code string address
1937-21 95 04    I  3769 (  9)         LD      HL,INMSG        ; Output " in "
193A-CD 9B 12    I  3770 ( 16)         CALL    PRS             ; Output string at HL
193D-E1          I  3771 (  9)         POP     HL              ; Restore code string address
193E-EB          I  3772 (  3) PRNTHL: EX      DE,HL           ; Code string address to DE
193F-AF          I  3773 (  4)         XOR     A
1940-06 98       I  3774 (  6)         LD      B,80H+24        ; 24 bits
1942-CD BB 17    I  3775 ( 16)         CALL    RETINT          ; Return the integer
1945-21 9A 12    I  3776 (  9)         LD      HL,PRNUMS       ; Print number string
1948-E5          I  3777 ( 11)         PUSH    HL              ; Save for return
1949-21 2E 23    I  3778 (  9) NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
194C-E5          I  3779 ( 11)         PUSH    HL              ; Save for return
194D-CD A4 17    I  3780 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
1950-36 20       I  3781 (  9)         LD      (HL),' '        ; Space at start
1952-F2 57 19    I  3782 ( 6+)         JP      P,SPCFST        ; Positive - Space to start
1955-36 2D       I  3783 (  9)         LD      (HL),'-'        ; '-' sign at start
1957-23          I  3784 (  4) SPCFST: INC     HL              ; First byte of number
1958-36 30       I  3785 (  9)         LD      (HL),'0'        ; '0' if zero
195A-CA 0D 1A    I  3786 ( 6+)         JP      Z,JSTZER        ; Return '0' if zero
195D-E5          I  3787 ( 11)         PUSH    HL              ; Save buffer address
195E-FC CD 17    I  3788 ( 6+)         CALL    M,INVSGN        ; Negate FPREG if negative
1961-AF          I  3789 (  4)         XOR     A               ; Zero A
1962-F5          I  3790 ( 11)         PUSH    AF              ; Save it
1963-CD 13 1A    I  3791 ( 16)         CALL    RNGTST          ; Test number is in range
1966-01 43 91    I  3792 (  9) SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
1969-11 F8 4F    I  3793 (  9)         LD      DE,4FF8H
196C-CD 1F 18    I  3794 ( 16)         CALL    CMPNUM          ; Compare numbers
196F-B7          I  3795 (  4)         OR      A
1970-E2 84 19    I  3796 ( 6+)         JP      PO,INRNG        ; > 99999.9 - Sort it out
1973-F1          I  3797 (  9)         POP     AF              ; Restore count
1974-CD 01 19    I  3798 ( 16)         CALL    MULTEN          ; Multiply by ten
1977-F5          I  3799 ( 11)         PUSH    AF              ; Re-save count
1978-C3 66 19    I  3800 (  9)         JP      SIXDIG          ; Test it again
197B-            I  3801
197B-CD EC 16    I  3802 ( 16) GTSIXD: CALL    DIV10           ; Divide by 10
197E-F1          I  3803 (  9)         POP     AF              ; Get count
197F-3C          I  3804 (  4)         INC     A               ; Count divides
1980-F5          I  3805 ( 11)         PUSH    AF              ; Re-save count
1981-CD 13 1A    I  3806 ( 16)         CALL    RNGTST          ; Test number is in range
1984-CD 4C 15    I  3807 ( 16) INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
1987-3C          I  3808 (  4)         INC     A
1988-CD 4C 18    I  3809 ( 16)         CALL    FPINT           ; F.P to integer
198B-CD E5 17    I  3810 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
198E-01 06 03    I  3811 (  9)         LD      BC,0306H        ; 1E+06 to 1E-03 range
1991-F1          I  3812 (  9)         POP     AF              ; Restore count
1992-81          I  3813 (  4)         ADD     A,C             ; 6 digits before point
1993-3C          I  3814 (  4)         INC     A               ; Add one
1994-FA A0 19    I  3815 ( 6+)         JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
1997-FE 08       I  3816 (  6)         CP      6+1+1           ; More than 999999 ?
1999-D2 A0 19    I  3817 ( 6+)         JP      NC,MAKNUM       ; Yes - Do it in 'E' form
199C-3C          I  3818 (  4)         INC     A               ; Adjust for exponent
199D-47          I  3819 (  4)         LD      B,A             ; Exponent of number
199E-3E 02       I  3820 (  6)         LD      A,2             ; Make it zero after
19A0-            I  3821
19A0-3D          I  3822 (  4) MAKNUM: DEC     A               ; Adjust for digits to do
19A1-3D          I  3823 (  4)         DEC     A
19A2-E1          I  3824 (  9)         POP     HL              ; Restore buffer address
19A3-F5          I  3825 ( 11)         PUSH    AF              ; Save count
19A4-11 26 1A    I  3826 (  9)         LD      DE,POWERS       ; Powers of ten
19A7-05          I  3827 (  4)         DEC     B               ; Count digits before point
19A8-C2 B1 19    I  3828 ( 6+)         JP      NZ,DIGTXT       ; Not zero - Do number
19AB-36 2E       I  3829 (  9)         LD      (HL),'.'        ; Save point
19AD-23          I  3830 (  4)         INC     HL              ; Move on
19AE-36 30       I  3831 (  9)         LD      (HL),'0'        ; Save zero
19B0-23          I  3832 (  4)         INC     HL              ; Move on
19B1-05          I  3833 (  4) DIGTXT: DEC     B               ; Count digits before point
19B2-36 2E       I  3834 (  9)         LD      (HL),'.'        ; Save point in case
19B4-CC FA 17    I  3835 ( 6+)         CALL    Z,INCHL         ; Last digit - move on
19B7-C5          I  3836 ( 11)         PUSH    BC              ; Save digits before point
19B8-E5          I  3837 ( 11)         PUSH    HL              ; Save buffer address
19B9-D5          I  3838 ( 11)         PUSH    DE              ; Save powers of ten
19BA-CD F0 17    I  3839 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
19BD-E1          I  3840 (  9)         POP     HL              ; Powers of ten table
19BE-06 2F       I  3841 (  6)         LD      B, '0'-1        ; ASCII '0' - 1
19C0-04          I  3842 (  4) TRYAGN: INC     B               ; Count subtractions
19C1-7B          I  3843 (  4)         LD      A,E             ; Get LSB
19C2-96          I  3844 (  6)         SUB     (HL)            ; Subtract LSB
19C3-5F          I  3845 (  4)         LD      E,A             ; Save LSB
19C4-23          I  3846 (  4)         INC     HL
19C5-7A          I  3847 (  4)         LD      A,D             ; Get NMSB
19C6-9E          I  3848 (  6)         SBC     A,(HL)          ; Subtract NMSB
19C7-57          I  3849 (  4)         LD      D,A             ; Save NMSB
19C8-23          I  3850 (  4)         INC     HL
19C9-79          I  3851 (  4)         LD      A,C             ; Get MSB
19CA-9E          I  3852 (  6)         SBC     A,(HL)          ; Subtract MSB
19CB-4F          I  3853 (  4)         LD      C,A             ; Save MSB
19CC-2B          I  3854 (  4)         DEC     HL              ; Point back to start
19CD-2B          I  3855 (  4)         DEC     HL
19CE-D2 C0 19    I  3856 ( 6+)         JP      NC,TRYAGN       ; No overflow - Try again
19D1-CD 03 16    I  3857 ( 16)         CALL    PLUCDE          ; Restore number
19D4-23          I  3858 (  4)         INC     HL              ; Start of next number
19D5-CD E5 17    I  3859 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
19D8-EB          I  3860 (  3)         EX      DE,HL           ; Save point in table
19D9-E1          I  3861 (  9)         POP     HL              ; Restore buffer address
19DA-70          I  3862 (  7)         LD      (HL),B          ; Save digit in buffer
19DB-23          I  3863 (  4)         INC     HL              ; And move on
19DC-C1          I  3864 (  9)         POP     BC              ; Restore digit count
19DD-0D          I  3865 (  4)         DEC     C               ; Count digits
19DE-C2 B1 19    I  3866 ( 6+)         JP      NZ,DIGTXT       ; More - Do them
19E1-05          I  3867 (  4)         DEC     B               ; Any decimal part?
19E2-CA F1 19    I  3868 ( 6+)         JP      Z,DOEBIT        ; No - Do 'E' bit
19E5-2B          I  3869 (  4) SUPTLZ: DEC     HL              ; Move back through buffer
19E6-7E          I  3870 (  6)         LD      A,(HL)          ; Get character
19E7-FE 30       I  3871 (  6)         CP      '0'             ; '0' character?
19E9-CA E5 19    I  3872 ( 6+)         JP      Z,SUPTLZ        ; Yes - Look back for more
19EC-FE 2E       I  3873 (  6)         CP      '.'             ; A decimal point?
19EE-C4 FA 17    I  3874 ( 6+)         CALL    NZ,INCHL        ; Move back over digit
19F1-            I  3875
19F1-F1          I  3876 (  9) DOEBIT: POP     AF              ; Get 'E' flag
19F2-CA 10 1A    I  3877 ( 6+)         JP      Z,NOENED        ; No 'E' needed - End buffer
19F5-36 45       I  3878 (  9)         LD      (HL),'E'        ; Put 'E' in buffer
19F7-23          I  3879 (  4)         INC     HL              ; And move on
19F8-36 2B       I  3880 (  9)         LD      (HL),'+'        ; Put '+' in buffer
19FA-F2 01 1A    I  3881 ( 6+)         JP      P,OUTEXP        ; Positive - Output exponent
19FD-36 2D       I  3882 (  9)         LD      (HL),'-'        ; Put '-' in buffer
19FF-2F          I  3883 (  3)         CPL                     ; Negate exponent
1A00-3C          I  3884 (  4)         INC     A
1A01-06 2F       I  3885 (  6) OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
1A03-04          I  3886 (  4) EXPTEN: INC     B               ; Count subtractions
1A04-D6 0A       I  3887 (  6)         SUB     10              ; Tens digit
1A06-D2 03 1A    I  3888 ( 6+)         JP      NC,EXPTEN       ; More to do
1A09-C6 3A       I  3889 (  6)         ADD     A,'0'+10        ; Restore and make ASCII
1A0B-23          I  3890 (  4)         INC     HL              ; Move on
1A0C-70          I  3891 (  7)         LD      (HL),B          ; Save MSB of exponent
1A0D-23          I  3892 (  4) JSTZER: INC     HL              ;
1A0E-77          I  3893 (  7)         LD      (HL),A          ; Save LSB of exponent
1A0F-23          I  3894 (  4)         INC     HL
1A10-71          I  3895 (  7) NOENED: LD      (HL),C          ; Mark end of buffer
1A11-E1          I  3896 (  9)         POP     HL              ; Restore code string address
1A12-C9          I  3897 (  9)         RET
1A13-            I  3898
1A13-01 74 94    I  3899 (  9) RNGTST: LD      BC,9474H        ; BCDE = 999999.
1A16-11 F7 23    I  3900 (  9)         LD      DE,23F7H
1A19-CD 1F 18    I  3901 ( 16)         CALL    CMPNUM          ; Compare numbers
1A1C-B7          I  3902 (  4)         OR      A
1A1D-E1          I  3903 (  9)         POP     HL              ; Return address to HL
1A1E-E2 7B 19    I  3904 ( 6+)         JP      PO,GTSIXD       ; Too big - Divide by ten
1A21-E9          I  3905 (  3)         JP      (HL)            ; Otherwise return to caller
1A22-            I  3906
1A22-00 00 00 80 I  3907       HALF:   .DB      00H,00H,00H,80H ; 0.5
1A26-            I  3908
1A26-A0 86 01    I  3909       POWERS: .DB      0A0H,086H,001H  ; 100000
1A29-10 27 00    I  3910               .DB      010H,027H,000H  ;  10000
1A2C-E8 03 00    I  3911               .DB      0E8H,003H,000H  ;   1000
1A2F-64 00 00    I  3912               .DB      064H,000H,000H  ;    100
1A32-0A 00 00    I  3913               .DB      00AH,000H,000H  ;     10
1A35-01 00 00    I  3914               .DB      001H,000H,000H  ;      1
1A38-            I  3915
1A38-21 CD 17    I  3916 (  9) NEGAFT: LD  HL,INVSGN           ; Negate result
1A3B-E3          I  3917 ( 16)         EX      (SP),HL         ; To be done after caller
1A3C-E9          I  3918 (  3)         JP      (HL)            ; Return to caller
1A3D-            I  3919
1A3D-CD D5 17    I  3920 ( 16) SQR:    CALL    STAKFP          ; Put value on stack
1A40-21 22 1A    I  3921 (  9)         LD      HL,HALF         ; Set power to 1/2
1A43-CD E2 17    I  3922 ( 16)         CALL    PHLTFP          ; Move 1/2 to FPREG
1A46-            I  3923
1A46-C1          I  3924 (  9) POWER:  POP     BC              ; Get base
1A47-D1          I  3925 (  9)         POP     DE
1A48-CD A4 17    I  3926 ( 16)         CALL    TSTSGN          ; Test sign of power
1A4B-78          I  3927 (  4)         LD      A,B             ; Get exponent of base
1A4C-CA 8B 1A    I  3928 ( 6+)         JP      Z,EXP           ; Make result 1 if zero
1A4F-F2 56 1A    I  3929 ( 6+)         JP      P,POWER1        ; Positive base - Ok
1A52-B7          I  3930 (  4)         OR      A               ; Zero to negative power?
1A53-CA 00 05    I  3931 ( 6+)         JP      Z,DZERR         ; Yes - ?/0 Error
1A56-B7          I  3932 (  4) POWER1: OR      A               ; Base zero?
1A57-CA C5 15    I  3933 ( 6+)         JP      Z,SAVEXP        ; Yes - Return zero
1A5A-D5          I  3934 ( 11)         PUSH    DE              ; Save base
1A5B-C5          I  3935 ( 11)         PUSH    BC
1A5C-79          I  3936 (  4)         LD      A,C             ; Get MSB of base
1A5D-F6 7F       I  3937 (  6)         OR      01111111B       ; Get sign status
1A5F-CD F0 17    I  3938 ( 16)         CALL    BCDEFP          ; Move power to BCDE
1A62-F2 73 1A    I  3939 ( 6+)         JP      P,POWER2        ; Positive base - Ok
1A65-D5          I  3940 ( 11)         PUSH    DE              ; Save power
1A66-C5          I  3941 ( 11)         PUSH    BC
1A67-CD 77 18    I  3942 ( 16)         CALL    INT             ; Get integer of power
1A6A-C1          I  3943 (  9)         POP     BC              ; Restore power
1A6B-D1          I  3944 (  9)         POP     DE
1A6C-F5          I  3945 ( 11)         PUSH    AF              ; MSB of base
1A6D-CD 1F 18    I  3946 ( 16)         CALL    CMPNUM          ; Power an integer?
1A70-E1          I  3947 (  9)         POP     HL              ; Restore MSB of base
1A71-7C          I  3948 (  4)         LD      A,H             ; but don't affect flags
1A72-1F          I  3949 (  3)         RRA                     ; Exponent odd or even?
1A73-E1          I  3950 (  9) POWER2: POP     HL              ; Restore MSB and exponent
1A74-22 2B 23    I  3951 ( 20)         LD      (FPREG+2),HL    ; Save base in FPREG
1A77-E1          I  3952 (  9)         POP     HL              ; LSBs of base
1A78-22 29 23    I  3953 ( 20)         LD      (FPREG),HL      ; Save in FPREG
1A7B-DC 38 1A    I  3954 ( 6+)         CALL    C,NEGAFT        ; Odd power - Negate result
1A7E-CC CD 17    I  3955 ( 6+)         CALL    Z,INVSGN        ; Negative base - Negate it
1A81-D5          I  3956 ( 11)         PUSH    DE              ; Save power
1A82-C5          I  3957 ( 11)         PUSH    BC
1A83-CD 58 16    I  3958 ( 16)         CALL    LOG             ; Get LOG of base
1A86-C1          I  3959 (  9)         POP     BC              ; Restore power
1A87-D1          I  3960 (  9)         POP     DE
1A88-CD 99 16    I  3961 ( 16)         CALL    FPMULT          ; Multiply LOG by power
1A8B-            I  3962
1A8B-CD D5 17    I  3963 ( 16) EXP:    CALL    STAKFP          ; Put value on stack
1A8E-01 38 81    I  3964 (  9)         LD      BC,08138H       ; BCDE = 1/Ln(2)
1A91-11 3B AA    I  3965 (  9)         LD      DE,0AA3BH
1A94-CD 99 16    I  3966 ( 16)         CALL    FPMULT          ; Multiply value by 1/LN(2)
1A97-3A 2C 23    I  3967 ( 12)         LD      A,(FPEXP)       ; Get exponent
1A9A-FE 88       I  3968 (  6)         CP      80H+8           ; Is it in range?
1A9C-D2 80 17    I  3969 ( 6+)         JP      NC,OVTST1       ; No - Test for overflow
1A9F-CD 77 18    I  3970 ( 16)         CALL    INT             ; Get INT of FPREG
1AA2-C6 80       I  3971 (  6)         ADD     A,80H           ; For excess 128
1AA4-C6 02       I  3972 (  6)         ADD     A,2             ; Exponent > 126?
1AA6-DA 80 17    I  3973 ( 6+)         JP      C,OVTST1        ; Yes - Test for overflow
1AA9-F5          I  3974 ( 11)         PUSH    AF              ; Save scaling factor
1AAA-21 47 16    I  3975 (  9)         LD      HL,UNITY        ; Point to 1.
1AAD-CD 4F 15    I  3976 ( 16)         CALL    ADDPHL          ; Add 1 to FPREG
1AB0-CD 90 16    I  3977 ( 16)         CALL    MULLN2          ; Multiply by LN(2)
1AB3-F1          I  3978 (  9)         POP     AF              ; Restore scaling factor
1AB4-C1          I  3979 (  9)         POP     BC              ; Restore exponent
1AB5-D1          I  3980 (  9)         POP     DE
1AB6-F5          I  3981 ( 11)         PUSH    AF              ; Save scaling factor
1AB7-CD 5B 15    I  3982 ( 16)         CALL    SUBCDE          ; Subtract exponent from FPREG
1ABA-CD CD 17    I  3983 ( 16)         CALL    INVSGN          ; Negate result
1ABD-21 CB 1A    I  3984 (  9)         LD      HL,EXPTAB       ; Coefficient table
1AC0-CD FB 1A    I  3985 ( 16)         CALL    SMSER1          ; Sum the series
1AC3-11 00 00    I  3986 (  9)         LD      DE,0            ; Zero LSBs
1AC6-C1          I  3987 (  9)         POP     BC              ; Scaling factor
1AC7-4A          I  3988 (  4)         LD      C,D             ; Zero MSB
1AC8-C3 99 16    I  3989 (  9)         JP      FPMULT          ; Scale result to correct value
1ACB-            I  3990
1ACB-08          I  3991       EXPTAB: .DB      8                       ; Table used by EXP
1ACC-40 2E 94 74 I  3992               .DB      040H,02EH,094H,074H     ; -1/7! (-1/5040)
1AD0-70 4F 2E 77 I  3993               .DB      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
1AD4-6E 02 88 7A I  3994               .DB      06EH,002H,088H,07AH     ; -1/5! (-1/120)
1AD8-E6 A0 2A 7C I  3995               .DB      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
1ADC-50 AA AA 7E I  3996               .DB      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
1AE0-FF FF 7F 7F I  3997               .DB      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
1AE4-00 00 80 81 I  3998               .DB      000H,000H,080H,081H     ; -1/1! (-1/1)
1AE8-00 00 00 81 I  3999               .DB      000H,000H,000H,081H     ;  1/0! ( 1/1)
1AEC-            I  4000
1AEC-CD D5 17    I  4001 ( 16) SUMSER: CALL    STAKFP          ; Put FPREG on stack
1AEF-11 97 16    I  4002 (  9)         LD      DE,MULT         ; Multiply by "X"
1AF2-D5          I  4003 ( 11)         PUSH    DE              ; To be done after
1AF3-E5          I  4004 ( 11)         PUSH    HL              ; Save address of table
1AF4-CD F0 17    I  4005 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1AF7-CD 99 16    I  4006 ( 16)         CALL    FPMULT          ; Square the value
1AFA-E1          I  4007 (  9)         POP     HL              ; Restore address of table
1AFB-CD D5 17    I  4008 ( 16) SMSER1: CALL    STAKFP          ; Put value on stack
1AFE-7E          I  4009 (  6)         LD      A,(HL)          ; Get number of coefficients
1AFF-23          I  4010 (  4)         INC     HL              ; Point to start of table
1B00-CD E2 17    I  4011 ( 16)         CALL    PHLTFP          ; Move coefficient to FPREG
1B03-06          I  4012               .DB      06H             ; Skip "POP AF"
1B04-F1          I  4013 (  9) SUMLP:  POP     AF              ; Restore count
1B05-C1          I  4014 (  9)         POP     BC              ; Restore number
1B06-D1          I  4015 (  9)         POP     DE
1B07-3D          I  4016 (  4)         DEC     A               ; Cont coefficients
1B08-C8          I  4017 ( 5+)         RET     Z               ; All done
1B09-D5          I  4018 ( 11)         PUSH    DE              ; Save number
1B0A-C5          I  4019 ( 11)         PUSH    BC
1B0B-F5          I  4020 ( 11)         PUSH    AF              ; Save count
1B0C-E5          I  4021 ( 11)         PUSH    HL              ; Save address in table
1B0D-CD 99 16    I  4022 ( 16)         CALL    FPMULT          ; Multiply FPREG by BCDE
1B10-E1          I  4023 (  9)         POP     HL              ; Restore address in table
1B11-CD F3 17    I  4024 ( 16)         CALL    LOADFP          ; Number at HL to BCDE
1B14-E5          I  4025 ( 11)         PUSH    HL              ; Save address in table
1B15-CD 5E 15    I  4026 ( 16)         CALL    FPADD           ; Add coefficient to FPREG
1B18-E1          I  4027 (  9)         POP     HL              ; Restore address in table
1B19-C3 04 1B    I  4028 (  9)         JP      SUMLP           ; More coefficients
1B1C-            I  4029
1B1C-CD A4 17    I  4030 ( 16) RND:    CALL    TSTSGN          ; Test sign of FPREG
1B1F-21 5E 22    I  4031 (  9)         LD      HL,SEED+2       ; Random number seed
1B22-FA 7D 1B    I  4032 ( 6+)         JP      M,RESEED        ; Negative - Re-seed
1B25-21 7F 22    I  4033 (  9)         LD      HL,LSTRND       ; Last random number
1B28-CD E2 17    I  4034 ( 16)         CALL    PHLTFP          ; Move last RND to FPREG
1B2B-21 5E 22    I  4035 (  9)         LD      HL,SEED+2       ; Random number seed
1B2E-C8          I  4036 ( 5+)         RET     Z               ; Return if RND(0)
1B2F-86          I  4037 (  6)         ADD     A,(HL)          ; Add (SEED)+2)
1B30-E6 07       I  4038 (  6)         AND     00000111B       ; 0 to 7
1B32-06 00       I  4039 (  6)         LD      B,0
1B34-77          I  4040 (  7)         LD      (HL),A          ; Re-save seed
1B35-23          I  4041 (  4)         INC     HL              ; Move to coefficient table
1B36-87          I  4042 (  4)         ADD     A,A             ; 4 bytes
1B37-87          I  4043 (  4)         ADD     A,A             ; per entry
1B38-4F          I  4044 (  4)         LD      C,A             ; BC = Offset into table
1B39-09          I  4045 (  7)         ADD     HL,BC           ; Point to coefficient
1B3A-CD F3 17    I  4046 ( 16)         CALL    LOADFP          ; Coefficient to BCDE
1B3D-CD 99 16    I  4047 ( 16)         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
1B40-3A 5D 22    I  4048 ( 12)         LD      A,(SEED+1)      ; Get (SEED+1)
1B43-3C          I  4049 (  4)         INC     A               ; Add 1
1B44-E6 03       I  4050 (  6)         AND     00000011B       ; 0 to 3
1B46-06 00       I  4051 (  6)         LD      B,0
1B48-FE 01       I  4052 (  6)         CP      1               ; Is it zero?
1B4A-88          I  4053 (  4)         ADC     A,B             ; Yes - Make it 1
1B4B-32 5D 22    I  4054 ( 13)         LD      (SEED+1),A      ; Re-save seed
1B4E-21 81 1B    I  4055 (  9)         LD      HL,RNDTAB-4     ; Addition table
1B51-87          I  4056 (  4)         ADD     A,A             ; 4 bytes
1B52-87          I  4057 (  4)         ADD     A,A             ; per entry
1B53-4F          I  4058 (  4)         LD      C,A             ; BC = Offset into table
1B54-09          I  4059 (  7)         ADD     HL,BC           ; Point to value
1B55-CD 4F 15    I  4060 ( 16)         CALL    ADDPHL          ; Add value to FPREG
1B58-CD F0 17    I  4061 ( 16) RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
1B5B-7B          I  4062 (  4)         LD      A,E             ; Get LSB
1B5C-59          I  4063 (  4)         LD      E,C             ; LSB = MSB
1B5D-EE 4F       I  4064 (  6)         XOR     01001111B       ; Fiddle around
1B5F-4F          I  4065 (  4)         LD      C,A             ; New MSB
1B60-36 80       I  4066 (  9)         LD      (HL),80H        ; Set exponent
1B62-2B          I  4067 (  4)         DEC     HL              ; Point to MSB
1B63-46          I  4068 (  6)         LD      B,(HL)          ; Get MSB
1B64-36 80       I  4069 (  9)         LD      (HL),80H        ; Make value -0.5
1B66-21 5C 22    I  4070 (  9)         LD      HL,SEED         ; Random number seed
1B69-34          I  4071 ( 10)         INC     (HL)            ; Count seed
1B6A-7E          I  4072 (  6)         LD      A,(HL)          ; Get seed
1B6B-D6 AB       I  4073 (  6)         SUB     171             ; Do it modulo 171
1B6D-C2 74 1B    I  4074 ( 6+)         JP      NZ,RND2         ; Non-zero - Ok
1B70-77          I  4075 (  7)         LD      (HL),A          ; Zero seed
1B71-0C          I  4076 (  4)         INC     C               ; Fillde about
1B72-15          I  4077 (  4)         DEC     D               ; with the
1B73-1C          I  4078 (  4)         INC     E               ; number
1B74-CD AF 15    I  4079 ( 16) RND2:   CALL    BNORM           ; Normalise number
1B77-21 7F 22    I  4080 (  9)         LD      HL,LSTRND       ; Save random number
1B7A-C3 FC 17    I  4081 (  9)         JP      FPTHL           ; Move FPREG to last and return
1B7D-            I  4082
1B7D-77          I  4083 (  7) RESEED: LD      (HL),A          ; Re-seed random numbers
1B7E-2B          I  4084 (  4)         DEC     HL
1B7F-77          I  4085 (  7)         LD      (HL),A
1B80-2B          I  4086 (  4)         DEC     HL
1B81-77          I  4087 (  7)         LD      (HL),A
1B82-C3 58 1B    I  4088 (  9)         JP      RND1            ; Return RND seed
1B85-            I  4089
1B85-68 B1 46 68 I  4090       RNDTAB: .DB   068H,0B1H,046H,068H     ; Table used by RND
1B89-99 E9 92 69 I  4091               .DB   099H,0E9H,092H,069H
1B8D-10 D1 75 68 I  4092               .DB   010H,0D1H,075H,068H
1B91-            I  4093
1B91-21 DB 1B    I  4094 (  9) COS:    LD      HL,HALFPI       ; Point to PI/2
1B94-CD 4F 15    I  4095 ( 16)         CALL    ADDPHL          ; Add it to PPREG
1B97-CD D5 17    I  4096 ( 16) SIN:    CALL    STAKFP          ; Put angle on stack
1B9A-01 49 83    I  4097 (  9)         LD      BC,8349H        ; BCDE = 2 PI
1B9D-11 DB 0F    I  4098 (  9)         LD      DE,0FDBH
1BA0-CD E5 17    I  4099 ( 16)         CALL    FPBCDE          ; Move 2 PI to FPREG
1BA3-C1          I  4100 (  9)         POP     BC              ; Restore angle
1BA4-D1          I  4101 (  9)         POP     DE
1BA5-CD FA 16    I  4102 ( 16)         CALL    DVBCDE          ; Divide angle by 2 PI
1BA8-CD D5 17    I  4103 ( 16)         CALL    STAKFP          ; Put it on stack
1BAB-CD 77 18    I  4104 ( 16)         CALL    INT             ; Get INT of result
1BAE-C1          I  4105 (  9)         POP     BC              ; Restore number
1BAF-D1          I  4106 (  9)         POP     DE
1BB0-CD 5B 15    I  4107 ( 16)         CALL    SUBCDE          ; Make it 0 <= value < 1
1BB3-21 DF 1B    I  4108 (  9)         LD      HL,QUARTR       ; Point to 0.25
1BB6-CD 55 15    I  4109 ( 16)         CALL    SUBPHL          ; Subtract value from 0.25
1BB9-CD A4 17    I  4110 ( 16)         CALL    TSTSGN          ; Test sign of value
1BBC-37          I  4111 (  3)         SCF                     ; Flag positive
1BBD-F2 C7 1B    I  4112 ( 6+)         JP      P,SIN1          ; Positive - Ok
1BC0-CD 4C 15    I  4113 ( 16)         CALL    ROUND           ; Add 0.5 to value
1BC3-CD A4 17    I  4114 ( 16)         CALL    TSTSGN          ; Test sign of value
1BC6-B7          I  4115 (  4)         OR      A               ; Flag negative
1BC7-F5          I  4116 ( 11) SIN1:   PUSH    AF              ; Save sign
1BC8-F4 CD 17    I  4117 ( 6+)         CALL    P,INVSGN        ; Negate value if positive
1BCB-21 DF 1B    I  4118 (  9)         LD      HL,QUARTR       ; Point to 0.25
1BCE-CD 4F 15    I  4119 ( 16)         CALL    ADDPHL          ; Add 0.25 to value
1BD1-F1          I  4120 (  9)         POP     AF              ; Restore sign
1BD2-D4 CD 17    I  4121 ( 6+)         CALL    NC,INVSGN       ; Negative - Make positive
1BD5-21 E3 1B    I  4122 (  9)         LD      HL,SINTAB       ; Coefficient table
1BD8-C3 EC 1A    I  4123 (  9)         JP      SUMSER          ; Evaluate sum of series
1BDB-            I  4124
1BDB-DB 0F 49 81 I  4125       HALFPI: .DB   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
1BDF-            I  4126
1BDF-00 00 00 7F I  4127       QUARTR: .DB   000H,000H,000H,07FH     ; 0.25
1BE3-            I  4128
1BE3-05          I  4129       SINTAB: .DB   5                       ; Table used by SIN
1BE4-BA D7 1E 86 I  4130               .DB   0BAH,0D7H,01EH,086H     ; 39.711
1BE8-64 26 99 87 I  4131               .DB   064H,026H,099H,087H     ;-76.575
1BEC-58 34 23 87 I  4132               .DB   058H,034H,023H,087H     ; 81.602
1BF0-E0 5D A5 86 I  4133               .DB   0E0H,05DH,0A5H,086H     ;-41.342
1BF4-DA 0F 49 83 I  4134               .DB   0DAH,00FH,049H,083H     ;  6.2832
1BF8-            I  4135
1BF8-CD D5 17    I  4136 ( 16) TAN:    CALL    STAKFP          ; Put angle on stack
1BFB-CD 97 1B    I  4137 ( 16)         CALL    SIN             ; Get SIN of angle
1BFE-C1          I  4138 (  9)         POP     BC              ; Restore angle
1BFF-E1          I  4139 (  9)         POP     HL
1C00-CD D5 17    I  4140 ( 16)         CALL    STAKFP          ; Save SIN of angle
1C03-EB          I  4141 (  3)         EX      DE,HL           ; BCDE = Angle
1C04-CD E5 17    I  4142 ( 16)         CALL    FPBCDE          ; Angle to FPREG
1C07-CD 91 1B    I  4143 ( 16)         CALL    COS             ; Get COS of angle
1C0A-C3 F8 16    I  4144 (  9)         JP      DIV             ; TAN = SIN / COS
1C0D-            I  4145
1C0D-CD A4 17    I  4146 ( 16) ATN:    CALL    TSTSGN          ; Test sign of value
1C10-FC 38 1A    I  4147 ( 6+)         CALL    M,NEGAFT        ; Negate result after if -ve
1C13-FC CD 17    I  4148 ( 6+)         CALL    M,INVSGN        ; Negate value if -ve
1C16-3A 2C 23    I  4149 ( 12)         LD      A,(FPEXP)       ; Get exponent
1C19-FE 81       I  4150 (  6)         CP      81H             ; Number less than 1?
1C1B-DA 2A 1C    I  4151 ( 6+)         JP      C,ATN1          ; Yes - Get arc tangnt
1C1E-01 00 81    I  4152 (  9)         LD      BC,8100H        ; BCDE = 1
1C21-51          I  4153 (  4)         LD      D,C
1C22-59          I  4154 (  4)         LD      E,C
1C23-CD FA 16    I  4155 ( 16)         CALL    DVBCDE          ; Get reciprocal of number
1C26-21 55 15    I  4156 (  9)         LD      HL,SUBPHL       ; Sub angle from PI/2
1C29-E5          I  4157 ( 11)         PUSH    HL              ; Save for angle > 1
1C2A-21 34 1C    I  4158 (  9) ATN1:   LD      HL,ATNTAB       ; Coefficient table
1C2D-CD EC 1A    I  4159 ( 16)         CALL    SUMSER          ; Evaluate sum of series
1C30-21 DB 1B    I  4160 (  9)         LD      HL,HALFPI       ; PI/2 - angle in case > 1
1C33-C9          I  4161 (  9)         RET                     ; Number > 1 - Sub from PI/2
1C34-            I  4162
1C34-09          I  4163       ATNTAB: .DB   9                       ; Table used by ATN
1C35-4A D7 3B 78 I  4164               .DB   04AH,0D7H,03BH,078H     ; 1/17
1C39-02 6E 84 7B I  4165               .DB   002H,06EH,084H,07BH     ;-1/15
1C3D-FE C1 2F 7C I  4166               .DB   0FEH,0C1H,02FH,07CH     ; 1/13
1C41-74 31 9A 7D I  4167               .DB   074H,031H,09AH,07DH     ;-1/11
1C45-84 3D 5A 7D I  4168               .DB   084H,03DH,05AH,07DH     ; 1/9
1C49-C8 7F 91 7E I  4169               .DB   0C8H,07FH,091H,07EH     ;-1/7
1C4D-E4 BB 4C 7E I  4170               .DB   0E4H,0BBH,04CH,07EH     ; 1/5
1C51-6C AA AA 7F I  4171               .DB   06CH,0AAH,0AAH,07FH     ;-1/3
1C55-00 00 00 81 I  4172               .DB   000H,000H,000H,081H     ; 1/1
1C59-            I  4173
1C59-            I  4174
1C59-C9          I  4175 (  9) ARET:   RET                     ; A RETurn instruction
1C5A-            I  4176
1C5A-D7          I  4177 ( 11) GETINP: RST         10H             ;input a character
1C5B-C9          I  4178 (  9)         RET
1C5C-            I  4179
1C5C-            I  4180       CLS:
1C5C-3E 0C       I  4181 (  6)         LD      A,CS            ; ASCII Clear screen
1C5E-C3 96 1D    I  4182 (  9)         JP      MONOUT          ; Output character
1C61-            I  4183
1C61-CD 23 15    I  4184 ( 16) WIDTH:  CALL    GETINT          ; Get integer 0-255
1C64-7B          I  4185 (  4)         LD      A,E             ; Width to A
1C65-32 87 22    I  4186 ( 13)         LD      (LWIDTH),A      ; Set width
1C68-C9          I  4187 (  9)         RET
1C69-            I  4188
1C69-CD C2 0D    I  4189 ( 16) LINES:  CALL    GETNUM          ; Get a number
1C6C-CD 07 0A    I  4190 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C6F-ED 53 8B 22 I  4191 ( 20)         LD      (LINESC),DE     ; Set lines counter
1C73-ED 53 8D 22 I  4192 ( 20)         LD      (LINESN),DE     ; Set lines number
1C77-C9          I  4193 (  9)         RET
1C78-            I  4194
1C78-CD 07 0A    I  4195 ( 16) DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
1C7B-D5          I  4196 ( 11)         PUSH    DE              ; Save number
1C7C-E1          I  4197 (  9)         POP     HL              ; Number to HL
1C7D-46          I  4198 (  6)         LD      B,(HL)          ; Get LSB of contents
1C7E-23          I  4199 (  4)         INC     HL
1C7F-7E          I  4200 (  6)         LD      A,(HL)          ; Get MSB of contents
1C80-C3 7D 11    I  4201 (  9)         JP      ABPASS          ; Return integer AB
1C83-            I  4202
1C83-CD C2 0D    I  4203 ( 16) DOKE:   CALL    GETNUM          ; Get a number
1C86-CD 07 0A    I  4204 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C89-D5          I  4205 ( 11)         PUSH    DE              ; Save address
1C8A-CD CB 07    I  4206 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1C8D-2C          I  4207               .DB      ','
1C8E-CD C2 0D    I  4208 ( 16)         CALL    GETNUM          ; Get a number
1C91-CD 07 0A    I  4209 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C94-E3          I  4210 ( 16)         EX      (SP),HL         ; Save value,get address
1C95-73          I  4211 (  7)         LD      (HL),E          ; Save LSB of value
1C96-23          I  4212 (  4)         INC     HL
1C97-72          I  4213 (  7)         LD      (HL),D          ; Save MSB of value
1C98-E1          I  4214 (  9)         POP     HL              ; Restore code string address
1C99-C9          I  4215 (  9)         RET
1C9A-            I  4216
1C9A-            I  4217
1C9A-            I  4218       ; HEX$(nn) Convert 16 bit number to Hexadecimal string
1C9A-            I  4219
1C9A-CD C5 0D    I  4220 ( 16) HEX:    CALL    TSTNUM          ; Verify it's a number
1C9D-CD 07 0A    I  4221 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1CA0-C5          I  4222 ( 11)         PUSH    BC              ; Save contents of BC
1CA1-21 2E 23    I  4223 (  9)         LD          HL,PBUFF
1CA4-7A          I  4224 (  4)         LD          A,D             ; Get high order into A
1CA5-FE 00       I  4225 (  6)         CP      $0
1CA7-28 0C       I  4226 ( 6+)                 JR      Z,HEX2          ; Skip output if both high digits are zero
1CA9-CD D2 1C    I  4227 ( 16)         CALL    BYT2ASC         ; Convert D to ASCII
1CAC-78          I  4228 (  4)                 LD      A,B
1CAD-FE 30       I  4229 (  6)                 CP      '0'
1CAF-28 02       I  4230 ( 6+)                 JR      Z,HEX1          ; Don't store high digit if zero
1CB1-70          I  4231 (  7)         LD          (HL),B          ; Store it to PBUFF
1CB2-23          I  4232 (  4)         INC         HL              ; Next location
1CB3-71          I  4233 (  7) HEX1:   LD          (HL),C          ; Store C to PBUFF+1
1CB4-23          I  4234 (  4)         INC     HL              ; Next location
1CB5-7B          I  4235 (  4) HEX2:   LD          A,E             ; Get lower byte
1CB6-CD D2 1C    I  4236 ( 16)         CALL    BYT2ASC         ; Convert E to ASCII
1CB9-7A          I  4237 (  4)                 LD      A,D
1CBA-FE 00       I  4238 (  6)         CP      $0
1CBC-20 05       I  4239 ( 6+)                 JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
1CBE-78          I  4240 (  4)                 LD      A,B
1CBF-FE 30       I  4241 (  6)                 CP      '0'             ; If high digit of lower byte is zero then don't print
1CC1-28 02       I  4242 ( 6+)                 JR      Z,HEX4
1CC3-70          I  4243 (  7) HEX3:   LD      (HL),B          ; to PBUFF+2
1CC4-23          I  4244 (  4)         INC     HL              ; Next location
1CC5-71          I  4245 (  7) HEX4:   LD      (HL),C          ; to PBUFF+3
1CC6-23          I  4246 (  4)         INC     HL              ; PBUFF+4 to zero
1CC7-AF          I  4247 (  4)         XOR     A               ; Terminating character
1CC8-77          I  4248 (  7)         LD      (HL),A          ; Store zero to terminate
1CC9-23          I  4249 (  4)         INC     HL              ; Make sure PBUFF is terminated
1CCA-77          I  4250 (  7)         LD      (HL),A          ; Store the double zero there
1CCB-C1          I  4251 (  9)         POP     BC              ; Get BC back
1CCC-21 2E 23    I  4252 (  9)         LD      HL,PBUFF        ; Reset to start of PBUFF
1CCF-C3 2B 12    I  4253 (  9)         JP      STR1            ; Convert the PBUFF to a string and return it
1CD2-            I  4254
1CD2-47          I  4255 (  4) BYT2ASC LD      B,A             ; Save original value
1CD3-E6 0F       I  4256 (  6)         AND     $0F             ; Strip off upper nybble
1CD5-FE 0A       I  4257 (  6)         CP      $0A             ; 0-9?
1CD7-38 02       I  4258 ( 6+)         JR      C,ADD30         ; If A-F, add 7 more
1CD9-C6 07       I  4259 (  6)         ADD     A,$07           ; Bring value up to ASCII A-F
1CDB-C6 30       I  4260 (  6) ADD30   ADD     A,$30           ; And make ASCII
1CDD-4F          I  4261 (  4)         LD      C,A             ; Save converted char to C
1CDE-78          I  4262 (  4)         LD      A,B             ; Retrieve original value
1CDF-0F          I  4263 (  3)         RRCA                    ; and Rotate it right
1CE0-0F          I  4264 (  3)         RRCA
1CE1-0F          I  4265 (  3)         RRCA
1CE2-0F          I  4266 (  3)         RRCA
1CE3-E6 0F       I  4267 (  6)         AND     $0F             ; Mask off upper nybble
1CE5-FE 0A       I  4268 (  6)         CP      $0A             ; 0-9? < A hex?
1CE7-38 02       I  4269 ( 6+)         JR      C,ADD301        ; Skip Add 7
1CE9-C6 07       I  4270 (  6)         ADD     A,$07           ; Bring it up to ASCII A-F
1CEB-C6 30       I  4271 (  6) ADD301  ADD     A,$30           ; And make it full ASCII
1CED-47          I  4272 (  4)         LD      B,A             ; Store high order byte
1CEE-C9          I  4273 (  9)         RET
1CEF-            I  4274
1CEF-            I  4275       ; Convert "&Hnnnn" to FPREG
1CEF-            I  4276       ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
1CEF-            I  4277       ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
1CEF-EB          I  4278 (  3) HEXTFP  EX      DE,HL           ; Move code string pointer to DE
1CF0-21 00 00    I  4279 (  9)         LD      HL,$0000        ; Zero out the value
1CF3-CD 08 1D    I  4280 ( 16)         CALL    GETHEX          ; Check the number for valid hex
1CF6-DA 28 1D    I  4281 ( 6+)         JP      C,HXERR         ; First value wasn't hex, HX error
1CF9-18 05       I  4282 (  8)         JR      HEXLP1          ; Convert first character
1CFB-CD 08 1D    I  4283 ( 16) HEXLP   CALL    GETHEX          ; Get second and addtional characters
1CFE-38 1F       I  4284 ( 6+)         JR      C,HEXIT         ; Exit if not a hex character
1D00-29          I  4285 (  7) HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
1D01-29          I  4286 (  7)         ADD     HL,HL
1D02-29          I  4287 (  7)         ADD     HL,HL
1D03-29          I  4288 (  7)         ADD     HL,HL
1D04-B5          I  4289 (  4)         OR      L               ; Add in D0-D3 into L
1D05-6F          I  4290 (  4)         LD      L,A             ; Save new value
1D06-18 F3       I  4291 (  8)         JR      HEXLP           ; And continue until all hex characters are in
1D08-            I  4292
1D08-13          I  4293 (  4) GETHEX  INC     DE              ; Next location
1D09-1A          I  4294 (  6)         LD      A,(DE)          ; Load character at pointer
1D0A-FE 20       I  4295 (  6)         CP      ' '
1D0C-CA 08 1D    I  4296 ( 6+)         JP      Z,GETHEX        ; Skip spaces
1D0F-D6 30       I  4297 (  6)         SUB     $30             ; Get absolute value
1D11-D8          I  4298 ( 5+)         RET     C               ; < "0", error
1D12-FE 0A       I  4299 (  6)         CP      $0A
1D14-38 05       I  4300 ( 6+)         JR      C,NOSUB7        ; Is already in the range 0-9
1D16-D6 07       I  4301 (  6)         SUB     $07             ; Reduce to A-F
1D18-FE 0A       I  4302 (  6)         CP      $0A             ; Value should be $0A-$0F at this point
1D1A-D8          I  4303 ( 5+)         RET     C               ; CY set if was :            ; < = > ? @
1D1B-FE 10       I  4304 (  6) NOSUB7  CP      $10             ; > Greater than "F"?
1D1D-3F          I  4305 (  3)         CCF
1D1E-C9          I  4306 (  9)         RET                     ; CY set if it wasn't valid hex
1D1F-            I  4307
1D1F-EB          I  4308 (  3) HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
1D20-7A          I  4309 (  4)         LD      A,D             ; Load DE into AC
1D21-4B          I  4310 (  4)         LD      C,E             ; For prep to
1D22-E5          I  4311 ( 11)         PUSH    HL
1D23-CD 7C 11    I  4312 ( 16)         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1D26-E1          I  4313 (  9)         POP     HL
1D27-C9          I  4314 (  9)         RET
1D28-            I  4315
1D28-1E 26       I  4316 (  6) HXERR:  LD      E,HX            ; ?HEX Error
1D2A-C3 11 05    I  4317 (  9)         JP      ERROR
1D2D-            I  4318
1D2D-            I  4319       ; BIN$(NN) Convert integer to a 1-16 char binary string
1D2D-CD C5 0D    I  4320 ( 16) BIN:    CALL    TSTNUM          ; Verify it's a number
1D30-CD 07 0A    I  4321 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1D33-C5          I  4322 ( 11) BIN2:   PUSH    BC              ; Save contents of BC
1D34-21 2E 23    I  4323 (  9)         LD      HL,PBUFF
1D37-06 11       I  4324 (  6)         LD      B,17            ; One higher than max char count
1D39-            I  4325       ZEROSUP:                        ; Suppress leading zeros
1D39-05          I  4326 (  4)         DEC     B               ; Max 16 chars
1D3A-78          I  4327 (  4)         LD      A,B
1D3B-FE 01       I  4328 (  6)         CP      $01
1D3D-28 08       I  4329 ( 6+)         JR      Z,BITOUT        ; Always output at least one character
1D3F-CB 13       I  4330 (  7)         RL      E
1D41-CB 12       I  4331 (  7)         RL      D
1D43-30 F4       I  4332 ( 6+)         JR      NC,ZEROSUP
1D45-18 04       I  4333 (  8)         JR      BITOUT2
1D47-            I  4334       BITOUT:
1D47-CB 13       I  4335 (  7)         RL      E
1D49-CB 12       I  4336 (  7)         RL      D               ; Top bit now in carry
1D4B-            I  4337       BITOUT2:
1D4B-3E 30       I  4338 (  6)         LD      A,'0'           ; Char for '0'
1D4D-CE 00       I  4339 (  6)         ADC     A,0             ; If carry set then '0' --> '1'
1D4F-77          I  4340 (  7)         LD      (HL),A
1D50-23          I  4341 (  4)         INC     HL
1D51-05          I  4342 (  4)         DEC     B
1D52-20 F3       I  4343 ( 6+)         JR      NZ,BITOUT
1D54-AF          I  4344 (  4)         XOR     A               ; Terminating character
1D55-77          I  4345 (  7)         LD      (HL),A          ; Store zero to terminate
1D56-23          I  4346 (  4)         INC     HL              ; Make sure PBUFF is terminated
1D57-77          I  4347 (  7)         LD      (HL),A          ; Store the double zero there
1D58-C1          I  4348 (  9)         POP     BC
1D59-21 2E 23    I  4349 (  9)         LD      HL,PBUFF
1D5C-C3 2B 12    I  4350 (  9)         JP      STR1
1D5F-            I  4351
1D5F-            I  4352       ; Convert "&Bnnnn" to FPREG
1D5F-            I  4353       ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1D5F-EB          I  4354 (  3) BINTFP: EX      DE,HL           ; Move code string pointer to DE
1D60-21 00 00    I  4355 (  9)         LD      HL,$0000        ; Zero out the value
1D63-CD 7C 1D    I  4356 ( 16)         CALL    CHKBIN          ; Check the number for valid bin
1D66-DA 8A 1D    I  4357 ( 6+)         JP      C,BINERR        ; First value wasn't bin, HX error
1D69-D6 30       I  4358 (  6) BINIT:  SUB     '0'
1D6B-29          I  4359 (  7)         ADD     HL,HL           ; Rotate HL left
1D6C-B5          I  4360 (  4)         OR      L
1D6D-6F          I  4361 (  4)         LD      L,A
1D6E-CD 7C 1D    I  4362 ( 16)         CALL    CHKBIN          ; Get second and addtional characters
1D71-30 F6       I  4363 ( 6+)         JR      NC,BINIT        ; Process if a bin character
1D73-EB          I  4364 (  3)         EX      DE,HL           ; Value into DE, Code string into HL
1D74-7A          I  4365 (  4)         LD      A,D             ; Load DE into AC
1D75-4B          I  4366 (  4)         LD      C,E             ; For prep to
1D76-E5          I  4367 ( 11)         PUSH    HL
1D77-CD 7C 11    I  4368 ( 16)         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1D7A-E1          I  4369 (  9)         POP     HL
1D7B-C9          I  4370 (  9)         RET
1D7C-            I  4371
1D7C-            I  4372       ; Char is in A, NC if char is 0 or 1
1D7C-13          I  4373 (  4) CHKBIN: INC     DE
1D7D-1A          I  4374 (  6)         LD      A,(DE)
1D7E-FE 20       I  4375 (  6)         CP      ' '
1D80-CA 7C 1D    I  4376 ( 6+)         JP      Z,CHKBIN        ; Skip spaces
1D83-FE 30       I  4377 (  6)         CP      '0'             ; Set C if < '0'
1D85-D8          I  4378 ( 5+)         RET     C
1D86-FE 32       I  4379 (  6)         CP      '2'
1D88-3F          I  4380 (  3)         CCF                     ; Set C if > '1'
1D89-C9          I  4381 (  9)         RET
1D8A-            I  4382
1D8A-1E 28       I  4383 (  6) BINERR: LD      E,BN            ; ?BIN Error
1D8C-C3 11 05    I  4384 (  9)         JP      ERROR
1D8F-            I  4385
1D8F-            I  4386
1D8F-            I  4387       JJUMP1:
1D8F-DD 21 FF FF I  4388 ( 12)         LD      IX,-1           ; Flag cold start
1D93-C3 61 01    I  4389 (  9)         JP      CSTART          ; Go and initialise
1D96-            I  4390
1D96-            I  4391       MONOUT:
1D96-C3 08 00    I  4392 (  9)         JP      $0008           ; output a char
1D99-            I  4393
1D99-            I  4394
1D99-            I  4395       MONITR:
1D99-C3 00 00    I  4396 (  9)         JP      $0000           ; Restart (Normally Monitor Start)
1D9C-            I  4397
1D9C-            I  4398
1D9C-3E 00       I  4399 (  6) INITST: LD      A,0             ; Clear break flag
1D9E-32 92 22    I  4400 ( 13)         LD      (BRKFLG),A
1DA1-C3 68 01    I  4401 (  9)         JP      INIT
1DA4-            I  4402
1DA4-ED 45       I  4403 ( 12) ARETN:  RETN                    ; Return from NMI
1DA6-            I  4404
1DA6-            I  4405
1DA6-F5          I  4406 ( 11) TSTBIT: PUSH    AF              ; Save bit mask
1DA7-A0          I  4407 (  4)         AND     B               ; Get common bits
1DA8-C1          I  4408 (  9)         POP     BC              ; Restore bit mask
1DA9-B8          I  4409 (  4)         CP      B               ; Same bit set?
1DAA-3E 00       I  4410 (  6)         LD      A,0             ; Return 0 in A
1DAC-C9          I  4411 (  9)         RET
1DAD-            I  4412
1DAD-CD D6 07    I  4413 ( 16) OUTNCR: CALL    OUTC            ; Output character in A
1DB0-C3 FD 0B    I  4414 (  9)         JP      PRNTCRLF        ; Output CRLF
1DB3-            I  4415
1DB3-            I  4416       .end
1DB3-            I  4417
