0000-                  6
0000-                  7           .include ../../include/z180_defs.asm
0000-            I     1       ; ------------------------------------
0000-            I     2       ; Z180 constants
0000-            I     3       ; ------------------------------------
0000-            I     4
0000-            I     5       ; ASCI
0000-            I     6       ; ----------
0000-            I     7
0000-            I     8       ; ASCI Control Register A 0 (CNTLA0: 00H)
0000-            I     9       CNTLA0         .equ $00
0000-            I    10
0080-            I    11       CNTLA0_MPE     .equ $80
0040-            I    12       CNTLA0_RE      .equ $40
0020-            I    13       CNTLA0_TE      .equ $20
0010-            I    14       CNTLA0_RTS0    .equ $10
0008-            I    15       CNTLA0_EFR     .equ $08
0004-            I    16       CNTLA0_MOD2    .equ $04
0002-            I    17       CNTLA0_MOD1    .equ $02
0001-            I    18       CNTLA0_MOD0    .equ $01
0000-            I    19
0000-            I    20       ; ASCI Control Register A 1 (CNTLA1: 01H)
0001-            I    21       CNTLA1         .equ $01
0000-            I    22
0080-            I    23       CNTLA1_MPE     .equ $80
0040-            I    24       CNTLA1_RE      .equ $40
0020-            I    25       CNTLA1_TE      .equ $20
0010-            I    26       CNTLA1_CKA1D   .equ $10
0008-            I    27       CNTLA1_EFR     .equ $08
0004-            I    28       CNTLA1_MOD2    .equ $04
0002-            I    29       CNTLA1_MOD1    .equ $02
0001-            I    30       CNTLA1_MOD0    .equ $01
0000-            I    31
0000-            I    32       ; ASCI Control Register B 0 (CNTLB0: 02H)
0002-            I    33       CNTLB0         .equ $02
0000-            I    34
0080-            I    35       CNTLB0_MPBT    .equ $80
0040-            I    36       CNTLB0_MP      .equ $40
0020-            I    37       CNTLB0_CTS     .equ $20
0010-            I    38       CNTLB0_PEO     .equ $10
0008-            I    39       CNTLB0_DR      .equ $08
0004-            I    40       CNTLB0_SS2     .equ $04
0002-            I    41       CNTLB0_SS1     .equ $02
0001-            I    42       CNTLB0_SS0     .equ $01
0000-            I    43
0000-            I    44       ; ASCI Control Register B 1 (CNTLB1: 03H)
0003-            I    45       CNTLB1         .equ $03
0000-            I    46
0080-            I    47       CNTLB1_MPBT    .equ $80
0040-            I    48       CNTLB1_MP      .equ $40
0020-            I    49       CNTLB1_CTS     .equ $20
0010-            I    50       CNTLB1_PEO     .equ $10
0008-            I    51       CNTLB1_DR      .equ $08
0004-            I    52       CNTLB1_SS2     .equ $04
0002-            I    53       CNTLB1_SS1     .equ $02
0001-            I    54       CNTLB1_SS0     .equ $01
0000-            I    55
0000-            I    56       ; ASCI Status Register 0 (STAT0: 04H)
0004-            I    57       STAT0          .equ $04
0000-            I    58
0080-            I    59       STAT0_RDRF     .equ $80
0040-            I    60       STAT0_OVRN     .equ $40
0020-            I    61       STAT0_PE       .equ $20
0010-            I    62       STAT0_FE       .equ $10
0008-            I    63       STAT0_RIE      .equ $08
0004-            I    64       STAT0_DCD0     .equ $04
0002-            I    65       STAT0_TDRE     .equ $02
0001-            I    66       STAT0_TIE      .equ $01
0000-            I    67
0000-            I    68       ; ASCI Status Register 1 (STAT1: 05H)
0005-            I    69       STAT1          .equ $05
0000-            I    70
0080-            I    71       STAT1_RDRF     .equ $80
0040-            I    72       STAT1_OVRN     .equ $40
0020-            I    73       STAT1_PE       .equ $20
0010-            I    74       STAT1_FE       .equ $10
0008-            I    75       STAT1_RIE      .equ $08
0004-            I    76       STAT1_CTS1E    .equ $04
0002-            I    77       STAT1_TDRE     .equ $02
0001-            I    78       STAT1_TIE      .equ $01
0000-            I    79
0000-            I    80       ; ASCI Transmit Data Register Ch. 0 (TDR0: 06H)
0006-            I    81       TDR0           .equ $06
0000-            I    82
0000-            I    83       ; ASCI Transmit Data Register Ch. 1 (TDR1: 07H)
0007-            I    84       TDR1           .equ $07
0000-            I    85
0000-            I    86       ; ASCI Receive Data Register Ch. 0 (RDR0: 08H)
0008-            I    87       RDR0           .equ $08
0000-            I    88
0000-            I    89       ; ASCI Receive Data Register Ch. 1 (RDR1: 09H)
0009-            I    90       RDR1           .equ $09
0000-            I    91
0000-            I    92       ; ASCI0 Extension Control Register 0 (ASEXT0: 12H)
0012-            I    93       ASEXT0         .equ $12
0000-            I    94
0080-            I    95       ASEXT0_RDRFI   .equ $80
0040-            I    96       ASEXT0_DCD0D   .equ $40
0020-            I    97       ASEXT0_CTS0D   .equ $20
0010-            I    98       ASEXT0_X1      .equ $10
0008-            I    99       ASEXT0_BRG0    .equ $08
0004-            I   100       ASEXT0_BRKE    .equ $04
0002-            I   101       ASEXT0_BRK     .equ $02
0001-            I   102       ASEXT0_SBRK    .equ $01
0000-            I   103
0000-            I   104       ; ASCI1 Extension Control Register 1 (ASEXT1: 13H)
0013-            I   105       ASEXT1         .equ $13
0000-            I   106
0080-            I   107       ASEXT1_RDRFI   .equ $80
0010-            I   108       ASEXT1_X1      .equ $10
0008-            I   109       ASEXT1_BRG1    .equ $08
0004-            I   110       ASEXT1_BRKE    .equ $04
0002-            I   111       ASEXT1_BRK     .equ $02
0001-            I   112       ASEXT1_SBRK    .equ $01
0000-            I   113
0000-            I   114       ; ASCI0 Time Constant Low Register (ASTC0L : 1AH)
001A-            I   115       ASTC0L         .equ $1A
0000-            I   116       ; ASCI0 Time Constant High Register (ASTC0H: 1BH)
001B-            I   117       ASTC0H         .equ $1B
0000-            I   118       ; ASCI1 Time Constant Low Register (ASTC1L : 1AH)
001C-            I   119       ASTC1L         .equ $1C
0000-            I   120       ; ASCI1 Time Constant High Register (ASTC1H: 1BH)
001D-            I   121       ASTC1H         .equ $1D
0000-            I   122
0000-            I   123       ; CSI/0
0000-            I   124       ; ------------------------------------
0000-            I   125
0000-            I   126       ; CSI/O Control Register (CNTR: 0AH)
000A-            I   127       CNTR           .equ $0A
0000-            I   128
0080-            I   129       CNTR_EF        .equ $80
0040-            I   130       CNTR_EIE       .equ $40
0020-            I   131       CNTR_RE        .equ $20
0010-            I   132       CNTR_TE        .equ $10
0004-            I   133       CNTR_SS2       .equ $04
0002-            I   134       CNTR_SS1       .equ $02
0001-            I   135       CNTR_SS0       .equ $01
0000-            I   136
0000-            I   137       ; CSI/O Transmit/Receive Data Register (TRD: 0BH)
000B-            I   138       TRDR           .equ $0B
0000-            I   139
0000-            I   140       ; Timer
0000-            I   141       ; ------------------------------------
0000-            I   142
0000-            I   143       ; Data Register Ch 0 L (TMDR0L: 0CH)
000C-            I   144       TMDR0L         .equ $0C
0000-            I   145       ; Data Register Ch 0 H (TMDR0H: 0DH)
000D-            I   146       TMDR0H         .equ $0D
0000-            I   147       ; Reload Register Ch 0 L (RLDR0L: OEH)
000E-            I   148       RLDR0L         .equ $0E
0000-            I   149       ; Reload Register Ch 0 H (RLDR0H: 0FH)
000F-            I   150       RLDR0H         .equ $0F
0000-            I   151
0000-            I   152       ; Timer Control Register (TCR: 10H)
0010-            I   153       TCR            .equ $10
0000-            I   154
0080-            I   155       TCR_TIF1        .equ $80
0040-            I   156       TCR_TIF0        .equ $40
0020-            I   157       TCR_TIE1        .equ $20
0010-            I   158       TCR_TIE0        .equ $10
0008-            I   159       TCR_TOC1       .equ $08
0004-            I   160       TCR_TOC0       .equ $04
0002-            I   161       TCR_TDE1       .equ $02
0001-            I   162       TCR_TDE0       .equ $01
0000-            I   163
0000-            I   164       ; Data Register Ch 1 L (TMDR1L: 14h)
0014-            I   165       TMDR1L         .equ $14
0000-            I   166       ; Data Register Ch 1 H (TMDR1H: 15H)
0015-            I   167       TMDR1H         .equ $15
0000-            I   168       ; Reload Register Ch 1 L (RLDR1L: 16H)
0016-            I   169       RLDR1L         .equ $16
0000-            I   170       ; Reload Register Ch 1 H (RLDR1H: 17H)
0017-            I   171       RLDR1H         .equ $17
0000-            I   172
0000-            I   173       ; Others
0000-            I   174       ; ------------------------------------
0000-            I   175
0000-            I   176       ; Clock Multiplier Register (CMR: 1EH)
001E-            I   177       CMR            .equ $1E
0000-            I   178
0080-            I   179       CMR_X2         .equ $80
0000-            I   180
0000-            I   181       ; Free Running Counter (FRC: 18H)
0018-            I   182       FRC            .equ $18
0000-            I   183
0000-            I   184       ; CPU Control Register (CCR: 1FH)
001F-            I   185       CCR            .equ $1F
0080-            I   186       CCR_CD         .equ $80
0040-            I   187       CCR_SB1        .equ $40
0020-            I   188       CCR_BREXT      .equ $20
0010-            I   189       CCR_LNPHI      .equ $10
0008-            I   190       CCR_SB2        .equ $08
0004-            I   191       CCR_LNIO       .equ $04
0002-            I   192       CCR_LNCPU      .equ $02
0001-            I   193       CCR_LNAD       .equ $01
0000-            I   194
0000-            I   195       ; DMA
0000-            I   196       ; ---------------------------------------------------------------------------
0000-            I   197
0000-            I   198
0000-            I   199       ; DMA/WAIT Control Register (DCNTL: 32H)
0000-            I   200
0000-            I   201       ; INT
0000-            I   202       ; ---------------------------------------------------------------------------
0000-            I   203
0000-            I   204       ; Interrupt Vector Low Register (IL: 33H)
0033-            I   205       IL              .equ $33
0000-            I   206
0000-            I   207       ; INT/TRAP Control Register (ITC: 34H)
0034-            I   208       ITC             .equ $34
0000-            I   209
0080-            I   210       ITC_TRAP        .equ $80
0040-            I   211       ITC_UFO         .equ $40
0004-            I   212       ITC_ITE2        .equ $04
0002-            I   213       ITC_ITE1        .equ $02
0001-            I   214       ITC_ITE0        .equ $01
0000-            I   215
0000-            I   216
0000-            I   217       ; Refresh
0000-            I   218       ; ---------------------------------------------------------------------------
0000-            I   219
0000-            I   220       ; Refresh Control Register (RCR: 36H)
0036-            I   221       RCR            .equ $36
0080-            I   222       RCR_REFE       .equ $80
0040-            I   223       RCR_REFW       .equ $40
0002-            I   224       RCR_CYC1       .equ $02
0001-            I   225       RCR_CYC0       .equ $01
0000-            I   226
0000-            I   227       ; MMU
0000-            I   228       ; ---------------------------------------------------------------------------
0000-            I   229
0000-            I   230       ; MMU Common Base Register (CBR: 38H)
0038-            I   231       CBR            .equ $38
0000-            I   232       ; MMU Bank Base Register (BBR: 39H)
0039-            I   233       BBR            .equ $39
0000-            I   234       ; MMU Common/Bank Register (CBAR: 3AH)
003A-            I   235       CBAR           .equ $3A
0000-            I   236       ; I/O
0000-            I   237       ; ---------------------------------------------------------------------------
0000-            I   238
0000-            I   239       ; Operation Mode Control Register (OMCR: 3EH)
003E-            I   240       OMCR           .equ $3E
0000-            I   241
0080-            I   242       OMCR_M1E       .equ $80
0040-            I   243       OMCR_M1TE      .equ $40
0000-            I   244       ;OMCR_M1E       .equ $20
0000-            I   245
0000-            I   246       ; I/O Control Register (ICR: 3FH)
003F-            I   247       ICR            .equ $3F
0000-            I   248
0080-            I   249       ICR_IOA7       .equ $80
0040-            I   250       ICR_IOA6       .equ $40
0020-            I   251       ICR_IOSTP      .equ $20
0000-                  8
0000-                  9       ; bios entries
E01F-                 10       asci1_putc  .equ $E01F
E019-                 11       asci1_getc  .equ $E019
E01C-                 12       asci1_rx_empty .equ $E01C
E000-                 13       int_noop .equ $E000
E004-                 14       int_asci0 .equ $E004
E016-                 15       int_asci1 .equ $E016
E001-                 16       asci0_init .equ $E001
E013-                 17       asci1_init .equ $E013
0000-                 18
E025-                 19       vdu_init .equ $E025
E028-                 20       int_vdu .equ $E028
E02B-                 21       vdu_set_attr .equ $E02B
E02E-                 22       vdu_cls .equ $E02E
E034-                 23       vdu_putc_term .equ $E034
0000-                 24
E040-                 25       kbd_init .equ $E040
E043-                 26       int_kbd .equ $E043
E046-                 27       kbd_is_empty .equ $E046
E04C-                 28       kbd_wait_get_key .equ $E04C
0000-                 29
E04F-                 30       snd_init .equ $E04F
E052-                 31       int_snd .equ $E052
E055-                 32       snd_beep .equ $E055
0000-                 33
0000-                 34           .org $0000
0000-C3 00 01         35 (  9)     jp  mreset
0003-                 36
0003-                 37       rst08:
0008-                 38           .org $0008
0008-                 39           ;jp asci1_putc
0008-C3 34 E0         40 (  9)     jp vdu_putc_term
000B-                 41
000B-                 42       rst10:
0010-                 43           .org $0010
0010-                 44           ;jp asci1_getc
0010-C3 4C E0         45 (  9)     jp kbd_wait_get_key
0013-                 46
0013-                 47       rst18:
0018-                 48           .org $0018
0018-                 49           ;jp asci1_rx_empty
0018-C3 46 E0         50 (  9)     jp kbd_is_empty
001B-                 51
0038-                 52           .org $0038
0038-C3 00 E0         53 (  9)     jp int_noop    ; INT0
003B-                 54
0066-                 55           .org $0066
0066-C3 00 E0         56 (  9)     jp int_noop    ; NMI
0069-                 57
0069-                 58       ; interrupt vector table
0080-                 59           .org $0080
0080-43 E0            60           .dw int_kbd    ; INT1
0082-00 E0            61           .dw int_noop    ; INT2
0084-28 E0            62           .dw int_vdu    ; PRT0
0086-52 E0            63           .dw int_snd    ; PRT1
0088-00 E0            64           .dw int_noop    ; DMA0
008A-00 E0            65           .dw int_noop    ; DMA1
008C-00 E0            66           .dw int_noop    ; CSIO
008E-04 E0            67           .dw int_asci0   ; ASCI0
0090-16 E0            68           .dw int_asci1    ; ASCI1
0092-                 69
0100-                 70           .org $0100
0100-                 71       mreset:
0100-                 72
0100-F3               73 (  3)     di ; disable interrupts
0101-                 74
0101-                 75           ; CMR_X2 : clock * 2 => xtal 16Mhz ---> 32Mhz, phi 8Mhz --> 16Mhz
0101-                 76           ; ld a,CMR_X2
0101-                 77           ; out0 (CMR),a
0101-                 78
0101-                 79           ; CCR_CD : phi = XTAL/1 => phi 16Mhz ---> 32Mhz !!!
0101-                 80           ; ld a,CCR_CD
0101-                 81           ; out0 (CCR),a
0101-                 82
0101-3E 00            83 (  6)     ld  a,0
0103-ED 39 36         84 ( 13)     out0 (RCR),a    ; Refresh disable
0106-                 85
0106-                 86           ; Temporary stack pointer = $DFFF
0106-31 FF DF         87 (  9)     ld sp,$DFFF
0109-                 88
0109-CD 01 E0         89 ( 16)     call asci0_init
010C-CD 13 E0         90 ( 16)     call asci1_init
010F-                 91
010F-3E CF            92 (  6)     ld a,$CF
0111-CD 2B E0         93 ( 16)     call vdu_set_attr
0114-CD 25 E0         94 ( 16)     call vdu_init
0117-                 95
0117-CD 40 E0         96 ( 16)     call kbd_init
011A-                 97
011A-                 98           ; setup interupts
011A-ED 56            99 (  6)     im 1    ; interrupt mode 1
011C-3E 00           100 (  6)     ld a,0  ; interrupts high order byte : 00H
011E-ED 47           101 (  6)     ld i,a
0120-3E 80           102 (  6)     ld a,0b10000000 ; interrupts low order byte : 80H
0122-ED 39 33        103 ( 13)     out0 (IL),a
0125-                104
0125-FB              105 (  3)     ei      ; enable interrupts
0126-                106
0126-CD 4F E0        107 ( 16)     call snd_init
0129-CD 55 E0        108 ( 16)     call snd_beep
012C-                109
012C-C3 50 01        110 (  9)     jp COLD
012F-                111
012F-                112           .include basic.asm
012F-            I     1       ;==================================================================================
012F-            I     2       ; The updates to the original BASIC within this file are copyright Grant Searle
012F-            I     3       ;
012F-            I     4       ; You have permission to use this for NON COMMERCIAL USE ONLY
012F-            I     5       ; If you wish to use it elsewhere, please include an acknowledgement to myself.
012F-            I     6       ;
012F-            I     7       ; http://searle.hostei.com/grant/index.html
012F-            I     8       ;
012F-            I     9       ; eMail: home.micros01@btinternet.com
012F-            I    10       ;
012F-            I    11       ; If the above don't work, please perform an Internet search to see if I have
012F-            I    12       ; updated the web page hosting service.
012F-            I    13       ;
012F-            I    14       ;==================================================================================
012F-            I    15        ;       .CR z180
012F-            I    16        ;       .TF basic.hex,INT,24
012F-            I    17        ;       .LF basic.lst
012F-            I    18       ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
012F-            I    19       ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
012F-            I    20       ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
012F-            I    21       ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
012F-            I    22       ; the original ROM code (checksum A934H). PA
012F-            I    23
012F-            I    24       ; GENERAL EQUATES
012F-            I    25
0003-            I    26       CTRLC   .EQU    03H             ; Control "C"
0007-            I    27       CTRLG   .EQU    07H             ; Control "G"
0008-            I    28       BKSP    .EQU    08H             ; Back space
000A-            I    29       LF      .EQU    0AH             ; Line feed
000C-            I    30       CS      .EQU    0CH             ; Clear screen
000D-            I    31       CR      .EQU    0DH             ; Carriage return
000F-            I    32       CTRLO   .EQU    0FH             ; Control "O"
0011-            I    33       CTRLQ   .EQU    11H                     ; Control "Q"
0012-            I    34       CTRLR   .EQU    12H             ; Control "R"
0013-            I    35       CTRLS   .EQU    13H             ; Control "S"
0015-            I    36       CTRLU   .EQU    15H             ; Control "U"
001B-            I    37       ESC     .EQU    1BH             ; Escape
007F-            I    38       DEL     .EQU    7FH             ; Delete
012F-            I    39
012F-            I    40       ; BASIC WORK SPACE LOCATIONS
012F-            I    41
2245-            I    42       WRKSPC  .EQU    2245H             ; BASIC Work space
2248-            I    43       USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
224B-            I    44       OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
224C-            I    45       OTPORT  .EQU    WRKSPC+7H           ; Port (p)
224E-            I    46       DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
224F-            I    47       DIV1    .EQU    WRKSPC+0AH           ; <- Values
2253-            I    48       DIV2    .EQU    WRKSPC+0EH           ; <-   to
2257-            I    49       DIV3    .EQU    WRKSPC+12H           ; <-   be
225A-            I    50       DIV4    .EQU    WRKSPC+15H           ; <-inserted
225C-            I    51       SEED    .EQU    WRKSPC+17H           ; Random number seed
227F-            I    52       LSTRND  .EQU    WRKSPC+3AH           ; Last random number
2283-            I    53       INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
2284-            I    54       INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
2286-            I    55       NULLS   .EQU    WRKSPC+41H           ; Number of nulls
2287-            I    56       LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
2288-            I    57       COMMAN  .EQU    WRKSPC+43H           ; Width for commas
2289-            I    58       NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
228A-            I    59       CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
228B-            I    60       LINESC  .EQU    WRKSPC+46H           ; Lines counter
228D-            I    61       LINESN  .EQU    WRKSPC+48H           ; Lines number
228F-            I    62       CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
2291-            I    63       NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
2292-            I    64       BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
2293-            I    65       RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
2296-            I    66       POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
2299-            I    67       PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
229C-            I    68       RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
229F-            I    69       STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
22A1-            I    70       LINEAT  .EQU    WRKSPC+5CH           ; Current line number
22A3-            I    71       BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
22A6-            I    72       BUFFER  .EQU    WRKSPC+61H           ; Input buffer
22AB-            I    73       STACK   .EQU    WRKSPC+66H           ; Initial stack
22F0-            I    74       CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
22F1-            I    75       LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
22F2-            I    76       TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
22F3-            I    77       DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
22F4-            I    78       LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
22F6-            I    79       TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
22F8-            I    80       TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
2304-            I    81       TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
2308-            I    82       STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
230A-            I    83       CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
230C-            I    84       LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
230E-            I    85       DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
2310-            I    86       FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
2311-            I    87       LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
2312-            I    88       READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
2313-            I    89       BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
2315-            I    90       NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
2317-            I    91       ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
2319-            I    92       CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
231B-            I    93       PROGND  .EQU    WRKSPC+0D6H          ; End of program
231D-            I    94       VAREND  .EQU    WRKSPC+0D8H          ; End of variables
231F-            I    95       ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
2321-            I    96       NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
2323-            I    97       FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
2325-            I    98       FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
2329-            I    99       FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
232C-            I   100       FPEXP   .EQU    FPREG+3         ; Floating point exponent
232D-            I   101       SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
232E-            I   102       PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
233B-            I   103       MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
233E-            I   104       PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
23A2-            I   105       STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
012F-            I   106
012F-            I   107       ; BASIC ERROR CODE VALUES
012F-            I   108
0000-            I   109       NF      .EQU    00H             ; NEXT without FOR
0002-            I   110       SN      .EQU    02H             ; Syntax error
0004-            I   111       RG      .EQU    04H             ; RETURN without GOSUB
0006-            I   112       OD      .EQU    06H             ; Out of DATA
0008-            I   113       FC      .EQU    08H             ; Function call error
000A-            I   114       OV      .EQU    0AH             ; Overflow
000C-            I   115       OM      .EQU    0CH             ; Out of memory
000E-            I   116       UL      .EQU    0EH             ; Undefined line number
0010-            I   117       BS      .EQU    10H             ; Bad subscript
0012-            I   118       DD      .EQU    12H             ; Re-DIMensioned array
0014-            I   119       DZ      .EQU    14H             ; Division by zero (/0)
0016-            I   120       ID      .EQU    16H             ; Illegal direct
0018-            I   121       TM      .EQU    18H             ; Type miss-match
001A-            I   122       OS      .EQU    1AH             ; Out of string space
001C-            I   123       LS      .EQU    1CH             ; String too long
001E-            I   124       ST      .EQU    1EH             ; String formula too complex
0020-            I   125       CN      .EQU    20H             ; Can't CONTinue
0022-            I   126       UF      .EQU    22H             ; UnDEFined FN function
0024-            I   127       MO      .EQU    24H             ; Missing operand
0026-            I   128       HX      .EQU    26H             ; HEX error
0028-            I   129       BN      .EQU    28H             ; BIN error
012F-            I   130
0150-            I   131               .ORG    00150H
0150-            I   132
0150-C3 56 01    I   133 (  9) COLD:   JP      STARTB          ; Jump for cold start
0153-C3 C0 01    I   134 (  9) WARM:   JP      WARMST          ; Jump for warm start
0156-            I   135       STARTB:
0156-DD 21 00 00 I   136 ( 12)         LD      IX,0            ; Flag cold start
015A-C3 61 01    I   137 (  9)         JP      CSTART          ; Jump to initialise
015D-            I   138
015D-F1 09       I   139               .DW   DEINT           ; Get integer -32768 to 32767
015F-67 11       I   140               .DW   ABPASS          ; Return integer in AB
0161-            I   141
0161-            I   142
0161-21 45 22    I   143 (  9) CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0164-F9          I   144 (  4)         LD      SP,HL           ; Set up a temporary stack
0165-C3 86 1D    I   145 (  9)         JP      INITST          ; Go to initialise
0168-            I   146
0168-11 00 04    I   147 (  9) INIT:   LD      DE,INITAB       ; Initialise workspace
016B-06 63       I   148 (  6)         LD      B,INITBE-INITAB+3 ; Bytes to copy
016D-21 45 22    I   149 (  9)         LD      HL,WRKSPC       ; Into workspace RAM
0170-1A          I   150 (  6) COPY:   LD      A,(DE)          ; Get source
0171-77          I   151 (  7)         LD      (HL),A          ; To destination
0172-23          I   152 (  4)         INC     HL              ; Next destination
0173-13          I   153 (  4)         INC     DE              ; Next source
0174-05          I   154 (  4)         DEC     B               ; Count bytes
0175-C2 70 01    I   155 ( 6+)         JP      NZ,COPY         ; More to move
0178-F9          I   156 (  4)         LD      SP,HL           ; Temporary stack
0179-CD 19 06    I   157 ( 16)         CALL    CLREG           ; Clear registers and stack
017C-CD E7 0B    I   158 ( 16)         CALL    PRNTCRLF        ; Output CRLF
017F-32 EF 22    I   159 ( 13)         LD      (BUFFER+72+1),A ; Mark end of buffer
0182-32 3E 23    I   160 ( 13)         LD      (PROGST),A      ; Initialise program area
0185-            I   161       MSIZE: ; LD      HL,MEMMSG       ; Point to message
0185-            I   162              ; CALL    PRS             ; Output "Memory size"
0185-            I   163              ; CALL    PROMPT          ; Get input with '?'
0185-            I   164              ; CALL    GETCHR          ; Get next character
0185-            I   165              ; OR      A               ; Set flags
0185-            I   166              ; JP      NZ,TSTMEM       ; If number - Test if RAM there
0185-            I   167              ; LD      HL,STLOOK       ; Point to start of RAM
0185-            I   168       ;MLOOP:  INC     HL              ; Next byte
0185-            I   169              ; LD      A,H             ; Above address FFFF ?
0185-            I   170              ; OR      L
0185-            I   171              ; JP      Z,SETTOP        ; Yes - 64K RAM
0185-            I   172              ; LD      A,(HL)          ; Get contents
0185-            I   173              ; LD      B,A             ; Save it
0185-            I   174              ; CPL                     ; Flip all bits
0185-            I   175              ; LD      (HL),A          ; Put it back
0185-            I   176              ; CP      (HL)            ; RAM there if same
0185-            I   177              ; LD      (HL),B          ; Restore old contents
0185-            I   178              ; JP      Z,MLOOP         ; If RAM - test next byte
0185-            I   179              ; JP      SETTOP          ; Top of RAM found
0185-            I   180
0185-            I   181       ;TSTMEM: CALL    ATOH            ; Get high memory into DE
0185-            I   182              ; OR      A               ; Set flags on last byte
0185-            I   183              ; JP      NZ,SNERR        ; ?SN Error if bad character
0185-            I   184              ; EX      DE,HL           ; Address into HL
0185-            I   185              ; DEC     HL              ; Back one byte
0185-            I   186              ; LD      A,11011001B     ; Test byte
0185-            I   187              ; LD      B,(HL)          ; Get old contents
0185-            I   188              ; LD      (HL),A          ; Load test byte
0185-            I   189              ; CP      (HL)            ; RAM there if same
0185-            I   190              ; LD      (HL),B          ; Restore old contents
0185-            I   191              ; JP      NZ,MSIZE        ; Ask again if no RAM
0185-            I   192
0185-21 FF EF    I   193 (  9)         LD      HL,65535-4096   ; LF - Hardcoded memory top
0188-            I   194
0188-2B          I   195 (  4) SETTOP: DEC     HL              ; Back one byte
0189-11 A1 23    I   196 (  9)         LD      DE,STLOOK-1     ; See if enough RAM
018C-CD AF 07    I   197 ( 16)         CALL    CPDEHL          ; Compare DE with HL
018F-DA 85 01    I   198 ( 6+)         JP      C,MSIZE         ; Ask again if not enough RAM
0192-11 CE FF    I   199 (  9)         LD      DE,0-50         ; 50 Bytes string space
0195-22 F4 22    I   200 ( 20)         LD      (LSTRAM),HL     ; Save last available RAM
0198-19          I   201 (  7)         ADD     HL,DE           ; Allocate string space
0199-22 9F 22    I   202 ( 20)         LD      (STRSPC),HL     ; Save string space
019C-CD F4 05    I   203 ( 16)         CALL    CLRPTR          ; Clear program area
019F-2A 9F 22    I   204 ( 15)         LD      HL,(STRSPC)     ; Get end of memory
01A2-11 EF FF    I   205 (  9)         LD      DE,0-17         ; Offset for free bytes
01A5-19          I   206 (  7)         ADD     HL,DE           ; Adjust HL
01A6-11 3E 23    I   207 (  9)         LD      DE,PROGST       ; Start of program text
01A9-7D          I   208 (  4)         LD      A,L             ; Get LSB
01AA-93          I   209 (  4)         SUB     E               ; Adjust it
01AB-6F          I   210 (  4)         LD      L,A             ; Re-save
01AC-7C          I   211 (  4)         LD      A,H             ; Get MSB
01AD-9A          I   212 (  4)         SBC     A,D             ; Adjust it
01AE-67          I   213 (  4)         LD      H,A             ; Re-save
01AF-E5          I   214 ( 11)         PUSH    HL              ; Save bytes free
01B0-21 DB 01    I   215 (  9)         LD      HL,SIGNON       ; Sign-on message
01B3-CD 85 12    I   216 ( 16)         CALL    PRS             ; Output string
01B6-E1          I   217 (  9)         POP     HL              ; Get bytes free back
01B7-CD 28 19    I   218 ( 16)         CALL    PRNTHL          ; Output amount of free memory
01BA-21 C9 01    I   219 (  9)         LD      HL,BFREE        ; " Bytes free" message
01BD-CD 85 12    I   220 ( 16)         CALL    PRS             ; Output string
01C0-            I   221
01C0-31 AB 22    I   222 (  9) WARMST: LD      SP,STACK        ; Temporary stack
01C3-CD 19 06    I   223 ( 16) BRKRET: CALL    CLREG           ; Clear registers and stack
01C6-C3 32 05    I   224 (  9)         JP      PRNTOK          ; Go to get command line
01C9-            I   225
01C9-20 42 79 74 
     65 73 20 66 
     72 65 65 1B 
     62 0F 0D 0A 
     00 00       I   226       BFREE:  .DB   " Bytes free",27,"b",15,CR,LF,0,0
01DB-            I   227
01DB-1B 62 07 5A 
     38 30 20 42 
     41 53 49 43 
     20 56 65 72 
     20 34 2E 37 
     62 0D 0A    I   228       SIGNON: .DB   27,"b",7,"Z80 BASIC Ver 4.7b",CR,LF
01F2-43 6F 70 79 
     72 69 67 68 
     74 20 28 43 
     29          I   229               .DB   "Copyright ",40,"C",41
01FF-20 31 39 37 
     38 20 62 79 
     20 4D 69 63 
     72 6F 73 6F 
     66 74 0D 0A 
     00 00       I   230               .DB   " 1978 by Microsoft",CR,LF,0,0
0215-            I   231
0215-4D 65 6D 6F 
     72 79 20 74 
     6F 70 00    I   232       MEMMSG: .DB   "Memory top",0
0220-            I   233
0220-            I   234       ; FUNCTION ADDRESS TABLE
0220-            I   235
0220-9D 17       I   236       FNCTAB: .DW   SGN
0222-61 18       I   237               .DW   INT
0224-B3 17       I   238               .DW   ABS
0226-48 22       I   239               .DW   USR
0228-45 11       I   240               .DW   FRE
022A-CA 14       I   241               .DW   INP
022C-73 11       I   242               .DW   POS
022E-27 1A       I   243               .DW   SQR
0230-06 1B       I   244               .DW   RND
0232-42 16       I   245               .DW   LOG
0234-75 1A       I   246               .DW   EXP
0236-7B 1B       I   247               .DW   COS
0238-81 1B       I   248               .DW   SIN
023A-E2 1B       I   249               .DW   TAN
023C-F7 1B       I   250               .DW   ATN
023E-1E 15       I   251               .DW   PEEK
0240-62 1C       I   252               .DW   DEEK
0242-96 22       I   253               .DW   POINT
0244-F7 13       I   254               .DW   LEN
0246-0F 12       I   255               .DW   STR
0248-91 14       I   256               .DW   VAL
024A-06 14       I   257               .DW   ASC
024C-17 14       I   258               .DW   CHR
024E-84 1C       I   259               .DW   HEX
0250-17 1D       I   260               .DW   BIN
0252-27 14       I   261               .DW   LEFT
0254-57 14       I   262               .DW   RIGHT
0256-61 14       I   263               .DW   MID
0258-            I   264
0258-            I   265       ; RESERVED WORD LIST
0258-            I   266
0258-C5          I   267       WORDS:  .AT   'E'
0259-4E 44       I   268               .DB "ND"
025B-C6          I   269               .AT   'F'
025C-4F 52       I   270               .DB "OR"
025E-CE          I   271               .AT   'N'
025F-45 58 54    I   272               .DB "EXT"
0262-C4          I   273               .AT   'D'
0263-41 54 41    I   274               .DB "ATA"
0266-C9          I   275               .AT   'I'
0267-4E 50 55 54 I   276               .DB "NPUT"
026B-C4          I   277               .AT   'D'
026C-49 4D       I   278               .DB "IM"
026E-D2          I   279               .AT   'R'
026F-45 41 44    I   280               .DB "EAD"
0272-CC          I   281               .AT   'L'
0273-45 54       I   282               .DB "ET"
0275-C7          I   283               .AT   'G'
0276-4F 54 4F    I   284               .DB "OTO"
0279-D2          I   285               .AT   'R'
027A-55 4E       I   286               .DB "UN"
027C-C9          I   287               .AT   'I'
027D-46          I   288               .DB "F"
027E-D2          I   289               .AT   'R'
027F-45 53 54 4F 
     52 45       I   290               .DB "ESTORE"
0285-C7          I   291               .AT   'G'
0286-4F 53 55 42 I   292               .DB "OSUB"
028A-D2          I   293               .AT   'R'
028B-45 54 55 52 
     4E          I   294               .DB "ETURN"
0290-D2          I   295               .AT   'R'
0291-45 4D       I   296               .DB "EM"
0293-D3          I   297               .AT   'S'
0294-54 4F 50    I   298               .DB "TOP"
0297-CF          I   299               .AT   'O'
0298-55 54       I   300               .DB "UT"
029A-CF          I   301               .AT   'O'
029B-4E          I   302               .DB "N"
029C-CE          I   303               .AT   'N'
029D-55 4C 4C    I   304               .DB "ULL"
02A0-D7          I   305               .AT   'W'
02A1-41 49 54    I   306               .DB "AIT"
02A4-C4          I   307               .AT   'D'
02A5-45 46       I   308               .DB "EF"
02A7-D0          I   309               .AT   'P'
02A8-4F 4B 45    I   310               .DB "OKE"
02AB-C4          I   311               .AT   'D'
02AC-4F 4B 45    I   312               .DB "OKE"
02AF-D3          I   313               .AT   'S'
02B0-43 52 45 45 
     4E          I   314               .DB "CREEN"
02B5-CC          I   315               .AT   'L'
02B6-49 4E 45 53 I   316               .DB "INES"
02BA-C3          I   317               .AT   'C'
02BB-4C 53       I   318               .DB "LS"
02BD-D7          I   319               .AT   'W'
02BE-49 44 54 48 I   320               .DB "IDTH"
02C2-CD          I   321               .AT   'M'
02C3-4F 4E 49 54 
     4F 52       I   322               .DB "ONITOR"
02C9-D3          I   323               .AT   'S'
02CA-45 54       I   324               .DB "ET"
02CC-D2          I   325               .AT   'R'
02CD-45 53 45 54 I   326               .DB "ESET"
02D1-D0          I   327               .AT   'P'
02D2-52 49 4E 54 I   328               .DB "RINT"
02D6-C3          I   329               .AT   'C'
02D7-4F 4E 54    I   330               .DB "ONT"
02DA-CC          I   331               .AT   'L'
02DB-49 53 54    I   332               .DB "IST"
02DE-C3          I   333               .AT   'C'
02DF-4C 45 41 52 I   334               .DB "LEAR"
02E3-C3          I   335               .AT   'C'
02E4-4C 4F 41 44 I   336               .DB "LOAD"
02E8-C3          I   337               .AT   'C'
02E9-53 41 56 45 I   338               .DB "SAVE"
02ED-CE          I   339               .AT   'N'
02EE-45 57       I   340               .DB "EW"
02F0-            I   341
02F0-D4          I   342               .AT   'T'
02F1-41 42 28    I   343               .DB "AB("
02F4-D4          I   344               .AT   'T'
02F5-4F          I   345               .DB "O"
02F6-C6          I   346               .AT   'F'
02F7-4E          I   347               .DB "N"
02F8-D3          I   348               .AT   'S'
02F9-50 43 28    I   349               .DB "PC("
02FC-D4          I   350               .AT   'T'
02FD-48 45 4E    I   351               .DB "HEN"
0300-CE          I   352               .AT   'N'
0301-4F 54       I   353               .DB "OT"
0303-D3          I   354               .AT   'S'
0304-54 45 50    I   355               .DB "TEP"
0307-            I   356
0307-AB          I   357               .AT   '+'
0308-AD          I   358               .AT   '-'
0309-AA          I   359               .AT   '*'
030A-AF          I   360               .AT   '/'
030B-DE          I   361               .AT   '^'
030C-C1          I   362               .AT   'A'
030D-4E 44       I   363               .DB "ND"
030F-CF          I   364               .AT   'O'
0310-52          I   365               .DB "R"
0311-BE          I   366               .AT   '>'
0312-BD          I   367               .AT   '='
0313-BC          I   368               .AT   '<'
0314-            I   369
0314-D3          I   370               .AT   'S'
0315-47 4E       I   371               .DB "GN"
0317-C9          I   372               .AT   'I'
0318-4E 54       I   373               .DB "NT"
031A-C1          I   374               .AT   'A'
031B-42 53       I   375               .DB "BS"
031D-D5          I   376               .AT   'U'
031E-53 52       I   377               .DB "SR"
0320-C6          I   378               .AT   'F'
0321-52 45       I   379               .DB "RE"
0323-C9          I   380               .AT   'I'
0324-4E 50       I   381               .DB "NP"
0326-D0          I   382               .AT   'P'
0327-4F 53       I   383               .DB "OS"
0329-D3          I   384               .AT   'S'
032A-51 52       I   385               .DB "QR"
032C-D2          I   386               .AT   'R'
032D-4E 44       I   387               .DB "ND"
032F-CC          I   388               .AT   'L'
0330-4F 47       I   389               .DB "OG"
0332-C5          I   390               .AT   'E'
0333-58 50       I   391               .DB "XP"
0335-C3          I   392               .AT   'C'
0336-4F 53       I   393               .DB "OS"
0338-D3          I   394               .AT   'S'
0339-49 4E       I   395               .DB "IN"
033B-D4          I   396               .AT   'T'
033C-41 4E       I   397               .DB "AN"
033E-C1          I   398               .AT   'A'
033F-54 4E       I   399               .DB "TN"
0341-D0          I   400               .AT   'P'
0342-45 45 4B    I   401               .DB "EEK"
0345-C4          I   402               .AT   'D'
0346-45 45 4B    I   403               .DB "EEK"
0349-D0          I   404               .AT   'P'
034A-4F 49 4E 54 I   405               .DB "OINT"
034E-CC          I   406               .AT   'L'
034F-45 4E       I   407               .DB "EN"
0351-D3          I   408               .AT   'S'
0352-54 52 24    I   409               .DB "TR$"
0355-D6          I   410               .AT   'V'
0356-41 4C       I   411               .DB "AL"
0358-C1          I   412               .AT   'A'
0359-53 43       I   413               .DB "SC"
035B-C3          I   414               .AT   'C'
035C-48 52 24    I   415               .DB "HR$"
035F-C8          I   416               .AT   'H'
0360-45 58 24    I   417               .DB "EX$"
0363-C2          I   418               .AT   'B'
0364-49 4E 24    I   419               .DB "IN$"
0367-CC          I   420               .AT   'L'
0368-45 46 54 24 I   421               .DB "EFT$"
036C-D2          I   422               .AT   'R'
036D-49 47 48 54 
     24          I   423               .DB "IGHT$"
0372-CD          I   424               .AT   'M'
0373-49 44 24    I   425               .DB "ID$"
0376-80          I   426               .DB   80H             ; End of list marker
0377-            I   427
0377-            I   428       ; KEYWORD ADDRESS TABLE
0377-            I   429
0377-89 09       I   430       WORDTB: .DW   PEND
0379-86 08       I   431               .DW   FOR
037B-61 0D       I   432               .DW   NEXT
037D-D6 0A       I   433               .DW   DATA
037F-68 0C       I   434               .DW   INPUT
0381-9D 0F       I   435               .DW   DIM
0383-97 0C       I   436               .DW   READ
0385-ED 0A       I   437               .DW   LET
0387-93 0A       I   438               .DW   GOTO
0389-76 0A       I   439               .DW   RUN
038B-65 0B       I   440               .DW   IF
038D-4F 09       I   441               .DW   RESTOR
038F-82 0A       I   442               .DW   GOSUB
0391-B1 0A       I   443               .DW   RETURN
0393-D8 0A       I   444               .DW   REM
0395-87 09       I   445               .DW   STOP
0397-D6 14       I   446               .DW   POUT
0399-47 0B       I   447               .DW   ON
039B-C8 09       I   448               .DW   NULL
039D-DC 14       I   449               .DW   WAIT
039F-7B 11       I   450               .DW   DEF
03A1-25 15       I   451               .DW   POKE
03A3-6D 1C       I   452               .DW   DOKE
03A5-D8 0A       I   453               .DW   REM
03A7-53 1C       I   454               .DW   LINES
03A9-46 1C       I   455               .DW   CLS
03AB-4B 1C       I   456               .DW   WIDTH
03AD-83 1D       I   457               .DW   MONITR
03AF-99 22       I   458               .DW   PSET
03B1-9C 22       I   459               .DW   RESET
03B3-89 0B       I   460               .DW   PRINT
03B5-B5 09       I   461               .DW   CONT
03B7-FB 07       I   462               .DW   LIST
03B9-30 0A       I   463               .DW   CLEAR
03BB-D8 0A       I   464               .DW   REM
03BD-D8 0A       I   465               .DW   REM
03BF-F3 05       I   466               .DW   NEW
03C1-            I   467
03C1-            I   468       ; RESERVED WORD TOKEN VALUES
03C1-            I   469
0080-            I   470       ZEND    .EQU    080H            ; END
0081-            I   471       ZFOR    .EQU    081H            ; FOR
0083-            I   472       ZDATA   .EQU    083H            ; DATA
0088-            I   473       ZGOTO   .EQU    088H            ; GOTO
008C-            I   474       ZGOSUB  .EQU    08CH            ; GOSUB
008E-            I   475       ZREM    .EQU    08EH            ; REM
009E-            I   476       ZPRINT  .EQU    09EH            ; PRINT
00A4-            I   477       ZNEW    .EQU    0A4H            ; NEW
03C1-            I   478
00A5-            I   479       ZTAB    .EQU    0A5H            ; TAB
00A6-            I   480       ZTO     .EQU    0A6H            ; TO
00A7-            I   481       ZFN     .EQU    0A7H            ; FN
00A8-            I   482       ZSPC    .EQU    0A8H            ; SPC
00A9-            I   483       ZTHEN   .EQU    0A9H            ; THEN
00AA-            I   484       ZNOT    .EQU    0AAH            ; NOT
00AB-            I   485       ZSTEP   .EQU    0ABH            ; STEP
03C1-            I   486
00AC-            I   487       ZPLUS   .EQU    0ACH            ; +
00AD-            I   488       ZMINUS  .EQU    0ADH            ; -
00AE-            I   489       ZTIMES  .EQU    0AEH            ; *
00AF-            I   490       ZDIV    .EQU    0AFH            ; /
00B2-            I   491       ZOR     .EQU    0B2H            ; OR
00B3-            I   492       ZGTR    .EQU    0B3H            ; >
00B4-            I   493       ZEQUAL  .EQU    0B4H            ; M
00B5-            I   494       ZLTH    .EQU    0B5H            ; <
00B6-            I   495       ZSGN    .EQU    0B6H            ; SGN
00C7-            I   496       ZPOINT  .EQU    0C7H            ; POINT
00CD-            I   497       ZLEFT   .EQU    0CDH +2         ; LEFT$
03C1-            I   498
03C1-            I   499       ; ARITHMETIC PRECEDENCE TABLE
03C1-            I   500
03C1-79          I   501       PRITAB: .DB   79H             ; Precedence value
03C2-0F 19       I   502               .DW   PADD            ; FPREG = <last> + FPREG
03C4-            I   503
03C4-79          I   504               .DB   79H             ; Precedence value
03C5-43 15       I   505               .DW   PSUB            ; FPREG = <last> - FPREG
03C7-            I   506
03C7-7C          I   507               .DB   7CH             ; Precedence value
03C8-81 16       I   508               .DW   MULT            ; PPREG = <last> * FPREG
03CA-            I   509
03CA-7C          I   510               .DB   7CH             ; Precedence value
03CB-E2 16       I   511               .DW   DIV             ; FPREG = <last> / FPREG
03CD-            I   512
03CD-7F          I   513               .DB   7FH             ; Precedence value
03CE-30 1A       I   514               .DW   POWER           ; FPREG = <last> ^ FPREG
03D0-            I   515
03D0-50          I   516               .DB   50H             ; Precedence value
03D1-F6 0E       I   517               .DW   PAND            ; FPREG = <last> AND FPREG
03D3-            I   518
03D3-46          I   519               .DB   46H             ; Precedence value
03D4-F5 0E       I   520               .DW   POR             ; FPREG = <last> OR FPREG
03D6-            I   521
03D6-            I   522       ; BASIC ERROR CODE LIST
03D6-            I   523
03D6-4E 46       I   524       ERRORS: .DB   "NF"            ; NEXT without FOR
03D8-53 4E       I   525               .DB   "SN"            ; Syntax error
03DA-52 47       I   526               .DB   "RG"            ; RETURN without GOSUB
03DC-4F 44       I   527               .DB   "OD"            ; Out of DATA
03DE-46 43       I   528               .DB   "FC"            ; Illegal function call
03E0-4F 56       I   529               .DB   "OV"            ; Overflow error
03E2-4F 4D       I   530               .DB   "OM"            ; Out of memory
03E4-55 4C       I   531               .DB   "UL"            ; Undefined line
03E6-42 53       I   532               .DB   "BS"            ; Bad subscript
03E8-44 44       I   533               .DB   "DD"            ; Re-DIMensioned array
03EA-2F 30       I   534               .DB   "/0"            ; Division by zero
03EC-49 44       I   535               .DB   "ID"            ; Illegal direct
03EE-54 4D       I   536               .DB   "TM"            ; Type mis-match
03F0-4F 53       I   537               .DB   "OS"            ; Out of string space
03F2-4C 53       I   538               .DB   "LS"            ; String too long
03F4-53 54       I   539               .DB   "ST"            ; String formula too complex
03F6-43 4E       I   540               .DB   "CN"            ; Can't CONTinue
03F8-55 46       I   541               .DB   "UF"            ; Undefined FN function
03FA-4D 4F       I   542               .DB   "MO"            ; Missing operand
03FC-48 58       I   543               .DB   "HX"            ; HEX error
03FE-42 4E       I   544               .DB   "BN"            ; BIN error
0400-            I   545
0400-            I   546       ; INITIALISATION TABLE -------------------------------------------------------
0400-            I   547
0400-C3 C0 01    I   548 (  9) INITAB: JP      WARMST          ; Warm start jump
0403-C3 06 0A    I   549 (  9)         JP      FCERR           ; "USR (X)" jump (Set to Error)
0406-D3 00       I   550 ( 10)         OUT     (0),A           ; "OUT p,n" skeleton
0408-C9          I   551 (  9)         RET
0409-D6 00       I   552 (  6)         SUB     0               ; Division support routine
040B-6F          I   553 (  4)         LD      L,A
040C-7C          I   554 (  4)         LD      A,H
040D-DE 00       I   555 (  6)         SBC     A,0
040F-67          I   556 (  4)         LD      H,A
0410-78          I   557 (  4)         LD      A,B
0411-DE 00       I   558 (  6)         SBC     A,0
0413-47          I   559 (  4)         LD      B,A
0414-3E 00       I   560 (  6)         LD      A,0
0416-C9          I   561 (  9)         RET
0417-00 00 00    I   562               .DB   0,0,0                   ; Random number seed table used by RND
041A-35 4A CA 99 I   563               .DB   035H,04AH,0CAH,099H     ;-2.65145E+07
041E-39 1C 76 98 I   564               .DB   039H,01CH,076H,098H     ; 1.61291E+07
0422-22 95 B3 98 I   565               .DB   022H,095H,0B3H,098H     ;-1.17691E+07
0426-0A DD 47 98 I   566               .DB   00AH,0DDH,047H,098H     ; 1.30983E+07
042A-53 D1 99 99 I   567               .DB   053H,0D1H,099H,099H     ;-2-01612E+07
042E-0A 1A 9F 98 I   568               .DB   00AH,01AH,09FH,098H     ;-1.04269E+07
0432-65 BC CD 98 I   569               .DB   065H,0BCH,0CDH,098H     ;-1.34831E+07
0436-D6 77 3E 98 I   570               .DB   0D6H,077H,03EH,098H     ; 1.24825E+07
043A-52 C7 4F 80 I   571               .DB   052H,0C7H,04FH,080H     ; Last random number
043E-DB 00       I   572 (  9)         IN      A,(0)           ; INP (x) skeleton
0440-C9          I   573 (  9)         RET
0441-01          I   574               .DB   1               ; POS (x) number (1)
0442-FF          I   575               .DB   255             ; Terminal width (255 = no auto CRLF)
0443-1C          I   576               .DB   28              ; Width for commas (3 columns)
0444-00          I   577               .DB   0               ; No nulls after input bytes
0445-00          I   578               .DB   0               ; Output enabled (^O off)
0446-14 00       I   579               .DW   20              ; Initial lines counter
0448-14 00       I   580               .DW   20              ; Initial lines number
044A-00 00       I   581               .DW   0               ; Array load/save check sum
044C-00          I   582               .DB   0               ; Break not by NMI
044D-00          I   583               .DB   0               ; Break flag
044E-C3 2C 07    I   584 (  9)         JP      TTYLIN          ; Input reflection (set to TTY)
0451-C3 00 00    I   585 (  9)         JP      $0000           ; POINT reflection unused
0454-C3 00 00    I   586 (  9)         JP      $0000           ; SET reflection
0457-C3 00 00    I   587 (  9)         JP      $0000           ; RESET reflection
045A-A2 23       I   588               .DW   STLOOK          ; Temp string space
045C-FE FF       I   589               .DW   -2              ; Current line number (cold)
045E-3F 23       I   590               .DW   PROGST+1        ; Start of program text
0460-            I   591       INITBE:
0460-            I   592
0460-            I   593       ; END OF INITIALISATION TABLE ---------------------------------------------------
0460-            I   594
0460-20 45 72 72 
     6F 72 1B 62 
     0F 00       I   595       ERRMSG: .DB   " Error",27,"b",15,0
046A-20 69 6E 20 
     00          I   596       INMSG:  .DB   " in ",0
046E-            I   597       ZERBYT  .EQU    $-1             ; A zero byte
046F-1B 62 0B 4F 
     6B 1B 62 0F 
     0D 0A 00 00 I   598       OKMSG:  .DB   27,"b",11,"Ok",27,"b",15,CR,LF,0,0
047B-42 72 65 61 
     6B 00       I   599       BRKMSG: .DB   "Break",0
0481-            I   600
0481-21 04 00    I   601 (  9) BAKSTK: LD      HL,4            ; Look for "FOR" block with
0484-39          I   602 (  7)         ADD     HL,SP           ; same index as specified
0485-7E          I   603 (  6) LOKFOR: LD      A,(HL)          ; Get block ID
0486-23          I   604 (  4)         INC     HL              ; Point to index address
0487-FE 81       I   605 (  6)         CP      ZFOR            ; Is it a "FOR" token
0489-C0          I   606 ( 5+)         RET     NZ              ; No - exit
048A-4E          I   607 (  6)         LD      C,(HL)          ; BC = Address of "FOR" index
048B-23          I   608 (  4)         INC     HL
048C-46          I   609 (  6)         LD      B,(HL)
048D-23          I   610 (  4)         INC     HL              ; Point to sign of STEP
048E-E5          I   611 ( 11)         PUSH    HL              ; Save pointer to sign
048F-69          I   612 (  4)         LD      L,C             ; HL = address of "FOR" index
0490-60          I   613 (  4)         LD      H,B
0491-7A          I   614 (  4)         LD      A,D             ; See if an index was specified
0492-B3          I   615 (  4)         OR      E               ; DE = 0 if no index specified
0493-EB          I   616 (  3)         EX      DE,HL           ; Specified index into HL
0494-CA 9B 04    I   617 ( 6+)         JP      Z,INDFND        ; Skip if no index given
0497-EB          I   618 (  3)         EX      DE,HL           ; Index back into DE
0498-CD AF 07    I   619 ( 16)         CALL    CPDEHL          ; Compare index with one given
049B-01 0D 00    I   620 (  9) INDFND: LD      BC,16-3         ; Offset to next block
049E-E1          I   621 (  9)         POP     HL              ; Restore pointer to sign
049F-C8          I   622 ( 5+)         RET     Z               ; Return if block found
04A0-09          I   623 (  7)         ADD     HL,BC           ; Point to next block
04A1-C3 85 04    I   624 (  9)         JP      LOKFOR          ; Keep on looking
04A4-            I   625
04A4-CD BE 04    I   626 ( 16) MOVUP:  CALL    ENFMEM          ; See if enough memory
04A7-C5          I   627 ( 11) MOVSTR: PUSH    BC              ; Save end of source
04A8-E3          I   628 ( 16)         EX      (SP),HL         ; Swap source and dest" end
04A9-C1          I   629 (  9)         POP     BC              ; Get end of destination
04AA-CD AF 07    I   630 ( 16) MOVLP:  CALL    CPDEHL          ; See if list moved
04AD-7E          I   631 (  6)         LD      A,(HL)          ; Get byte
04AE-02          I   632 (  7)         LD      (BC),A          ; Move it
04AF-C8          I   633 ( 5+)         RET     Z               ; Exit if all done
04B0-0B          I   634 (  4)         DEC     BC              ; Next byte to move to
04B1-2B          I   635 (  4)         DEC     HL              ; Next byte to move
04B2-C3 AA 04    I   636 (  9)         JP      MOVLP           ; Loop until all bytes moved
04B5-            I   637
04B5-E5          I   638 ( 11) CHKSTK: PUSH    HL              ; Save code string address
04B6-2A 1F 23    I   639 ( 15)         LD      HL,(ARREND)     ; Lowest free memory
04B9-06 00       I   640 (  6)         LD      B,0             ; BC = Number of levels to test
04BB-09          I   641 (  7)         ADD     HL,BC           ; 2 Bytes for each level
04BC-09          I   642 (  7)         ADD     HL,BC
04BD-3E          I   643               .DB   3EH             ; Skip "PUSH HL"
04BE-E5          I   644 ( 11) ENFMEM: PUSH    HL              ; Save code string address
04BF-3E D0       I   645 (  6)         LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
04C1-95          I   646 (  4)         SUB     L
04C2-6F          I   647 (  4)         LD      L,A
04C3-3E FF       I   648 (  6)         LD      A,0FFH ;HIGH (-48) ; 48 Bytes minimum RAM
04C5-9C          I   649 (  4)         SBC     A,H
04C6-DA CD 04    I   650 ( 6+)         JP      C,OMERR         ; Not enough - ?OM Error
04C9-67          I   651 (  4)         LD      H,A
04CA-39          I   652 (  7)         ADD     HL,SP           ; Test if stack is overflowed
04CB-E1          I   653 (  9)         POP     HL              ; Restore code string address
04CC-D8          I   654 ( 5+)         RET     C               ; Return if enough mmory
04CD-1E 0C       I   655 (  6) OMERR:  LD      E,OM            ; ?OM Error
04CF-C3 EC 04    I   656 (  9)         JP      ERROR
04D2-            I   657
04D2-2A 0E 23    I   658 ( 15) DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
04D5-22 A1 22    I   659 ( 20)         LD      (LINEAT),HL     ; Save as current line
04D8-1E 02       I   660 (  6) SNERR:  LD      E,SN            ; ?SN Error
04DA-01          I   661               .DB   01H             ; Skip "LD E,DZ"
04DB-1E 14       I   662 (  6) DZERR:  LD      E,DZ            ; ?/0 Error
04DD-01          I   663               .DB   01H             ; Skip "LD E,NF"
04DE-1E 00       I   664 (  6) NFERR:  LD      E,NF            ; ?NF Error
04E0-01          I   665               .DB   01H             ; Skip "LD E,DD"
04E1-1E 12       I   666 (  6) DDERR:  LD      E,DD            ; ?DD Error
04E3-01          I   667               .DB   01H             ; Skip "LD E,UF"
04E4-1E 22       I   668 (  6) UFERR:  LD      E,UF            ; ?UF Error
04E6-01          I   669               .DB   01H             ; Skip "LD E,OV
04E7-1E 0A       I   670 (  6) OVERR:  LD      E,OV            ; ?OV Error
04E9-01          I   671               .DB   01H             ; Skip "LD E,TM"
04EA-1E 18       I   672 (  6) TMERR:  LD      E,TM            ; ?TM Error
04EC-            I   673
04EC-CD 19 06    I   674 ( 16) ERROR:  CALL    CLREG           ; Clear registers and stack
04EF-32 8A 22    I   675 ( 13)         LD      (CTLOFG),A      ; Enable output (A is 0)
04F2-CD DA 0B    I   676 ( 16)         CALL    STTLIN          ; Start new line
04F5-21 D6 03    I   677 (  9)         LD      HL,ERRORS       ; Point to error codes
04F8-57          I   678 (  4)         LD      D,A             ; D = 0 (A is 0)
04F9-3E 1B       I   679 (  6)         LD      A,27            ; LF - Error msg in RED
04FB-CD C0 07    I   680 ( 16)         CALL    OUTC            ; LF
04FE-3E 62       I   681 (  6)         LD      A,'b'           ; LF
0500-CD C0 07    I   682 ( 16)         CALL    OUTC            ; LF
0503-3E 09       I   683 (  6)         LD      A,9             ; LF
0505-CD C0 07    I   684 ( 16)         CALL    OUTC            ; LF
0508-3E 3F       I   685 (  6)         LD      A,'?'
050A-CD C0 07    I   686 ( 16)         CALL    OUTC            ; Output '?'
050D-19          I   687 (  7)         ADD     HL,DE           ; Offset to correct error code
050E-7E          I   688 (  6)         LD      A,(HL)          ; First character
050F-CD C0 07    I   689 ( 16)         CALL    OUTC            ; Output it
0512-CD 3F 09    I   690 ( 16)         CALL    GETCHR          ; Get next character
0515-CD C0 07    I   691 ( 16)         CALL    OUTC            ; Output it
0518-21 60 04    I   692 (  9)         LD      HL,ERRMSG       ; "Error" message
051B-CD 85 12    I   693 ( 16) ERRIN:  CALL    PRS             ; Output message
051E-2A A1 22    I   694 ( 15)         LD      HL,(LINEAT)     ; Get line of error
0521-11 FE FF    I   695 (  9)         LD      DE,-2           ; Cold start error if -2
0524-CD AF 07    I   696 ( 16)         CALL    CPDEHL          ; See if cold start error
0527-CA 61 01    I   697 ( 6+)         JP      Z,CSTART        ; Cold start error - Restart
052A-7C          I   698 (  4)         LD      A,H             ; Was it a direct error?
052B-A5          I   699 (  4)         AND     L               ; Line = -1 if direct error
052C-3C          I   700 (  4)         INC     A
052D-C4 20 19    I   701 ( 6+)         CALL    NZ,LINEIN       ; No - output line of error
0530-3E          I   702               .DB   3EH             ; Skip "POP BC"
0531-C1          I   703 (  9) POPNOK: POP     BC              ; Drop address in input buffer
0532-            I   704
0532-AF          I   705 (  4) PRNTOK: XOR     A               ; Output "Ok" and get command
0533-32 8A 22    I   706 ( 13)         LD      (CTLOFG),A      ; Enable output
0536-CD DA 0B    I   707 ( 16)         CALL    STTLIN          ; Start new line
0539-21 6F 04    I   708 (  9)         LD      HL,OKMSG        ; "Ok" message
053C-CD 85 12    I   709 ( 16)         CALL    PRS             ; Output "Ok"
053F-21 FF FF    I   710 (  9) GETCMD: LD      HL,-1           ; Flag direct mode
0542-22 A1 22    I   711 ( 20)         LD      (LINEAT),HL     ; Save as current line
0545-CD 2C 07    I   712 ( 16)         CALL    GETLIN          ; Get an input line
0548-DA 3F 05    I   713 ( 6+)         JP      C,GETCMD        ; Get line again if break
054B-CD 3F 09    I   714 ( 16)         CALL    GETCHR          ; Get first character
054E-3C          I   715 (  4)         INC     A               ; Test if end of line
054F-3D          I   716 (  4)         DEC     A               ; Without affecting Carry
0550-CA 3F 05    I   717 ( 6+)         JP      Z,GETCMD        ; Nothing entered - Get another
0553-F5          I   718 ( 11)         PUSH    AF              ; Save Carry status
0554-CD 0B 0A    I   719 ( 16)         CALL    ATOH            ; Get line number into DE
0557-D5          I   720 ( 11)         PUSH    DE              ; Save line number
0558-CD 43 06    I   721 ( 16)         CALL    CRUNCH          ; Tokenise rest of line
055B-47          I   722 (  4)         LD      B,A             ; Length of tokenised line
055C-D1          I   723 (  9)         POP     DE              ; Restore line number
055D-F1          I   724 (  9)         POP     AF              ; Restore Carry
055E-D2 1F 09    I   725 ( 6+)         JP      NC,EXCUTE       ; No line number - Direct mode
0561-D5          I   726 ( 11)         PUSH    DE              ; Save line number
0562-C5          I   727 ( 11)         PUSH    BC              ; Save length of tokenised line
0563-AF          I   728 (  4)         XOR     A
0564-32 11 23    I   729 ( 13)         LD      (LSTBIN),A      ; Clear last byte input
0567-CD 3F 09    I   730 ( 16)         CALL    GETCHR          ; Get next character
056A-B7          I   731 (  4)         OR      A               ; Set flags
056B-F5          I   732 ( 11)         PUSH    AF              ; And save them
056C-CD D3 05    I   733 ( 16)         CALL    SRCHLN          ; Search for line number in DE
056F-DA 78 05    I   734 ( 6+)         JP      C,LINFND        ; Jump if line found
0572-F1          I   735 (  9)         POP     AF              ; Get status
0573-F5          I   736 ( 11)         PUSH    AF              ; And re-save
0574-CA AC 0A    I   737 ( 6+)         JP      Z,ULERR         ; Nothing after number - Error
0577-B7          I   738 (  4)         OR      A               ; Clear Carry
0578-C5          I   739 ( 11) LINFND: PUSH    BC              ; Save address of line in prog
0579-D2 8F 05    I   740 ( 6+)         JP      NC,INEWLN       ; Line not found - Insert new
057C-EB          I   741 (  3)         EX      DE,HL           ; Next line address in DE
057D-2A 1B 23    I   742 ( 15)         LD      HL,(PROGND)     ; End of program
0580-1A          I   743 (  6) SFTPRG: LD      A,(DE)          ; Shift rest of program down
0581-02          I   744 (  7)         LD      (BC),A
0582-03          I   745 (  4)         INC     BC              ; Next destination
0583-13          I   746 (  4)         INC     DE              ; Next source
0584-CD AF 07    I   747 ( 16)         CALL    CPDEHL          ; All done?
0587-C2 80 05    I   748 ( 6+)         JP      NZ,SFTPRG       ; More to do
058A-60          I   749 (  4)         LD      H,B             ; HL - New end of program
058B-69          I   750 (  4)         LD      L,C
058C-22 1B 23    I   751 ( 20)         LD      (PROGND),HL     ; Update end of program
058F-            I   752
058F-D1          I   753 (  9) INEWLN: POP     DE              ; Get address of line,
0590-F1          I   754 (  9)         POP     AF              ; Get status
0591-CA B6 05    I   755 ( 6+)         JP      Z,SETPTR        ; No text - Set up pointers
0594-2A 1B 23    I   756 ( 15)         LD      HL,(PROGND)     ; Get end of program
0597-E3          I   757 ( 16)         EX      (SP),HL         ; Get length of input line
0598-C1          I   758 (  9)         POP     BC              ; End of program to BC
0599-09          I   759 (  7)         ADD     HL,BC           ; Find new end
059A-E5          I   760 ( 11)         PUSH    HL              ; Save new end
059B-CD A4 04    I   761 ( 16)         CALL    MOVUP           ; Make space for line
059E-E1          I   762 (  9)         POP     HL              ; Restore new end
059F-22 1B 23    I   763 ( 20)         LD      (PROGND),HL     ; Update end of program pointer
05A2-EB          I   764 (  3)         EX      DE,HL           ; Get line to move up in HL
05A3-74          I   765 (  7)         LD      (HL),H          ; Save MSB
05A4-D1          I   766 (  9)         POP     DE              ; Get new line number
05A5-23          I   767 (  4)         INC     HL              ; Skip pointer
05A6-23          I   768 (  4)         INC     HL
05A7-73          I   769 (  7)         LD      (HL),E          ; Save LSB of line number
05A8-23          I   770 (  4)         INC     HL
05A9-72          I   771 (  7)         LD      (HL),D          ; Save MSB of line number
05AA-23          I   772 (  4)         INC     HL              ; To first byte in line
05AB-11 A6 22    I   773 (  9)         LD      DE,BUFFER       ; Copy buffer to program
05AE-1A          I   774 (  6) MOVBUF: LD      A,(DE)          ; Get source
05AF-77          I   775 (  7)         LD      (HL),A          ; Save destinations
05B0-23          I   776 (  4)         INC     HL              ; Next source
05B1-13          I   777 (  4)         INC     DE              ; Next destination
05B2-B7          I   778 (  4)         OR      A               ; Done?
05B3-C2 AE 05    I   779 ( 6+)         JP      NZ,MOVBUF       ; No - Repeat
05B6-CD FF 05    I   780 ( 16) SETPTR: CALL    RUNFST          ; Set line pointers
05B9-23          I   781 (  4)         INC     HL              ; To LSB of pointer
05BA-EB          I   782 (  3)         EX      DE,HL           ; Address to DE
05BB-62          I   783 (  4) PTRLP:  LD      H,D             ; Address to HL
05BC-6B          I   784 (  4)         LD      L,E
05BD-7E          I   785 (  6)         LD      A,(HL)          ; Get LSB of pointer
05BE-23          I   786 (  4)         INC     HL              ; To MSB of pointer
05BF-B6          I   787 (  6)         OR      (HL)            ; Compare with MSB pointer
05C0-CA 3F 05    I   788 ( 6+)         JP      Z,GETCMD        ; Get command line if end
05C3-23          I   789 (  4)         INC     HL              ; To LSB of line number
05C4-23          I   790 (  4)         INC     HL              ; Skip line number
05C5-23          I   791 (  4)         INC     HL              ; Point to first byte in line
05C6-AF          I   792 (  4)         XOR     A               ; Looking for 00 byte
05C7-BE          I   793 (  6) FNDEND: CP      (HL)            ; Found end of line?
05C8-23          I   794 (  4)         INC     HL              ; Move to next byte
05C9-C2 C7 05    I   795 ( 6+)         JP      NZ,FNDEND       ; No - Keep looking
05CC-EB          I   796 (  3)         EX      DE,HL           ; Next line address to HL
05CD-73          I   797 (  7)         LD      (HL),E          ; Save LSB of pointer
05CE-23          I   798 (  4)         INC     HL
05CF-72          I   799 (  7)         LD      (HL),D          ; Save MSB of pointer
05D0-C3 BB 05    I   800 (  9)         JP      PTRLP           ; Do next line
05D3-            I   801
05D3-2A A3 22    I   802 ( 15) SRCHLN: LD      HL,(BASTXT)     ; Start of program text
05D6-44          I   803 (  4) SRCHLP: LD      B,H             ; BC = Address to look at
05D7-4D          I   804 (  4)         LD      C,L
05D8-7E          I   805 (  6)         LD      A,(HL)          ; Get address of next line
05D9-23          I   806 (  4)         INC     HL
05DA-B6          I   807 (  6)         OR      (HL)            ; End of program found?
05DB-2B          I   808 (  4)         DEC     HL
05DC-C8          I   809 ( 5+)         RET     Z               ; Yes - Line not found
05DD-23          I   810 (  4)         INC     HL
05DE-23          I   811 (  4)         INC     HL
05DF-7E          I   812 (  6)         LD      A,(HL)          ; Get LSB of line number
05E0-23          I   813 (  4)         INC     HL
05E1-66          I   814 (  6)         LD      H,(HL)          ; Get MSB of line number
05E2-6F          I   815 (  4)         LD      L,A
05E3-CD AF 07    I   816 ( 16)         CALL    CPDEHL          ; Compare with line in DE
05E6-60          I   817 (  4)         LD      H,B             ; HL = Start of this line
05E7-69          I   818 (  4)         LD      L,C
05E8-7E          I   819 (  6)         LD      A,(HL)          ; Get LSB of next line address
05E9-23          I   820 (  4)         INC     HL
05EA-66          I   821 (  6)         LD      H,(HL)          ; Get MSB of next line address
05EB-6F          I   822 (  4)         LD      L,A             ; Next line to HL
05EC-3F          I   823 (  3)         CCF
05ED-C8          I   824 ( 5+)         RET     Z               ; Lines found - Exit
05EE-3F          I   825 (  3)         CCF
05EF-D0          I   826 ( 5+)         RET     NC              ; Line not found,at line after
05F0-C3 D6 05    I   827 (  9)         JP      SRCHLP          ; Keep looking
05F3-            I   828
05F3-C0          I   829 ( 5+) NEW:    RET     NZ              ; Return if any more on line
05F4-2A A3 22    I   830 ( 15) CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
05F7-AF          I   831 (  4)         XOR     A               ; Set program area to empty
05F8-77          I   832 (  7)         LD      (HL),A          ; Save LSB = 00
05F9-23          I   833 (  4)         INC     HL
05FA-77          I   834 (  7)         LD      (HL),A          ; Save MSB = 00
05FB-23          I   835 (  4)         INC     HL
05FC-22 1B 23    I   836 ( 20)         LD      (PROGND),HL     ; Set program end
05FF-            I   837
05FF-2A A3 22    I   838 ( 15) RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0602-2B          I   839 (  4)         DEC     HL
0603-            I   840
0603-22 13 23    I   841 ( 20) INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0606-2A F4 22    I   842 ( 15)         LD      HL,(LSTRAM)     ; Get end of RAM
0609-22 08 23    I   843 ( 20)         LD      (STRBOT),HL     ; Clear string space
060C-AF          I   844 (  4)         XOR     A
060D-CD 4F 09    I   845 ( 16)         CALL    RESTOR          ; Reset DATA pointers
0610-2A 1B 23    I   846 ( 15)         LD      HL,(PROGND)     ; Get end of program
0613-22 1D 23    I   847 ( 20)         LD      (VAREND),HL     ; Clear variables
0616-22 1F 23    I   848 ( 20)         LD      (ARREND),HL     ; Clear arrays
0619-            I   849
0619-C1          I   850 (  9) CLREG:  POP     BC              ; Save return address
061A-2A 9F 22    I   851 ( 15)         LD      HL,(STRSPC)     ; Get end of working RAN
061D-F9          I   852 (  4)         LD      SP,HL           ; Set stack
061E-21 F8 22    I   853 (  9)         LD      HL,TMSTPL       ; Temporary string pool
0621-22 F6 22    I   854 ( 20)         LD      (TMSTPT),HL     ; Reset temporary string ptr
0624-AF          I   855 (  4)         XOR     A               ; A = 00
0625-6F          I   856 (  4)         LD      L,A             ; HL = 0000
0626-67          I   857 (  4)         LD      H,A
0627-22 19 23    I   858 ( 20)         LD      (CONTAD),HL     ; No CONTinue
062A-32 10 23    I   859 ( 13)         LD      (FORFLG),A      ; Clear FOR flag
062D-22 23 23    I   860 ( 20)         LD      (FNRGNM),HL     ; Clear FN argument
0630-E5          I   861 ( 11)         PUSH    HL              ; HL = 0000
0631-C5          I   862 ( 11)         PUSH    BC              ; Put back return
0632-2A 13 23    I   863 ( 15) DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0635-C9          I   864 (  9)         RET                     ; Return to execution driver
0636-            I   865
0636-3E 3F       I   866 (  6) PROMPT: LD      A,'?'           ; '?'
0638-CD C0 07    I   867 ( 16)         CALL    OUTC            ; Output character
063B-3E 20       I   868 (  6)         LD      A,' '           ; Space
063D-CD C0 07    I   869 ( 16)         CALL    OUTC            ; Output character
0640-C3 93 22    I   870 (  9)         JP      RINPUT          ; Get input line
0643-            I   871
0643-AF          I   872 (  4) CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0644-32 F3 22    I   873 ( 13)         LD      (DATFLG),A      ; Reset literal flag
0647-0E 05       I   874 (  6)         LD      C,2+3           ; 2 byte number and 3 nulls
0649-11 A6 22    I   875 (  9)         LD      DE,BUFFER       ; Start of input buffer
064C-7E          I   876 (  6) CRNCLP: LD      A,(HL)          ; Get byte
064D-FE 20       I   877 (  6)         CP      ' '             ; Is it a space?
064F-CA CB 06    I   878 ( 6+)         JP      Z,MOVDIR        ; Yes - Copy direct
0652-47          I   879 (  4)         LD      B,A             ; Save character
0653-FE 22       I   880 (  6)         CP      '"'             ; Is it a quote?
0655-CA EB 06    I   881 ( 6+)         JP      Z,CPYLIT        ; Yes - Copy literal string
0658-B7          I   882 (  4)         OR      A               ; Is it end of buffer?
0659-CA F2 06    I   883 ( 6+)         JP      Z,ENDBUF        ; Yes - End buffer
065C-3A F3 22    I   884 ( 12)         LD      A,(DATFLG)      ; Get data type
065F-B7          I   885 (  4)         OR      A               ; Literal?
0660-7E          I   886 (  6)         LD      A,(HL)          ; Get byte to copy
0661-C2 CB 06    I   887 ( 6+)         JP      NZ,MOVDIR       ; Literal - Copy direct
0664-FE 3F       I   888 (  6)         CP      '?'             ; Is it '?' short for PRINT
0666-3E 9E       I   889 (  6)         LD      A,ZPRINT        ; "PRINT" token
0668-CA CB 06    I   890 ( 6+)         JP      Z,MOVDIR        ; Yes - replace it
066B-7E          I   891 (  6)         LD      A,(HL)          ; Get byte again
066C-FE 30       I   892 (  6)         CP      '0'             ; Is it less than '0'
066E-DA 76 06    I   893 ( 6+)         JP      C,FNDWRD        ; Yes - Look for reserved words
0671-FE 3C       I   894 (  6)         CP      60 ; ";"+1           ; Is it "0123456789:;" ?
0673-DA CB 06    I   895 ( 6+)         JP      C,MOVDIR        ; Yes - copy it direct
0676-D5          I   896 ( 11) FNDWRD: PUSH    DE              ; Look for reserved words
0677-11 57 02    I   897 (  9)         LD      DE,WORDS-1      ; Point to table
067A-C5          I   898 ( 11)         PUSH    BC              ; Save count
067B-01 C7 06    I   899 (  9)         LD      BC,RETNAD       ; Where to return to
067E-C5          I   900 ( 11)         PUSH    BC              ; Save return address
067F-06 7F       I   901 (  6)         LD      B,ZEND-1        ; First token value -1
0681-7E          I   902 (  6)         LD      A,(HL)          ; Get byte
0682-FE 61       I   903 (  6)         CP      'a'             ; Less than 'a' ?
0684-DA 8F 06    I   904 ( 6+)         JP      C,SEARCH        ; Yes - search for words
0687-FE 7B       I   905 (  6)         CP      'z'+1           ; Greater than 'z' ?
0689-D2 8F 06    I   906 ( 6+)         JP      NC,SEARCH       ; Yes - search for words
068C-E6 5F       I   907 (  6)         AND     01011111B       ; Force upper case
068E-77          I   908 (  7)         LD      (HL),A          ; Replace byte
068F-4E          I   909 (  6) SEARCH: LD      C,(HL)          ; Search for a word
0690-EB          I   910 (  3)         EX      DE,HL
0691-23          I   911 (  4) GETNXT: INC     HL              ; Get next reserved word
0692-B6          I   912 (  6)         OR      (HL)            ; Start of word?
0693-F2 91 06    I   913 ( 6+)         JP      P,GETNXT        ; No - move on
0696-04          I   914 (  4)         INC     B               ; Increment token value
0697-7E          I   915 (  6)         LD      A, (HL)         ; Get byte from table
0698-E6 7F       I   916 (  6)         AND     01111111B       ; Strip bit 7
069A-C8          I   917 ( 5+)         RET     Z               ; Return if end of list
069B-B9          I   918 (  4)         CP      C               ; Same character as in buffer?
069C-C2 91 06    I   919 ( 6+)         JP      NZ,GETNXT       ; No - get next word
069F-EB          I   920 (  3)         EX      DE,HL
06A0-E5          I   921 ( 11)         PUSH    HL              ; Save start of word
06A1-            I   922
06A1-13          I   923 (  4) NXTBYT: INC     DE              ; Look through rest of word
06A2-1A          I   924 (  6)         LD      A,(DE)          ; Get byte from table
06A3-B7          I   925 (  4)         OR      A               ; End of word ?
06A4-FA C3 06    I   926 ( 6+)         JP      M,MATCH         ; Yes - Match found
06A7-4F          I   927 (  4)         LD      C,A             ; Save it
06A8-78          I   928 (  4)         LD      A,B             ; Get token value
06A9-FE 88       I   929 (  6)         CP      ZGOTO           ; Is it "GOTO" token ?
06AB-C2 B2 06    I   930 ( 6+)         JP      NZ,NOSPC        ; No - Don't allow spaces
06AE-CD 3F 09    I   931 ( 16)         CALL    GETCHR          ; Get next character
06B1-2B          I   932 (  4)         DEC     HL              ; Cancel increment from GETCHR
06B2-23          I   933 (  4) NOSPC:  INC     HL              ; Next byte
06B3-7E          I   934 (  6)         LD      A,(HL)          ; Get byte
06B4-FE 61       I   935 (  6)         CP      'a'             ; Less than 'a' ?
06B6-DA BB 06    I   936 ( 6+)         JP      C,NOCHNG        ; Yes - don't change
06B9-E6 5F       I   937 (  6)         AND     01011111B       ; Make upper case
06BB-B9          I   938 (  4) NOCHNG: CP      C               ; Same as in buffer ?
06BC-CA A1 06    I   939 ( 6+)         JP      Z,NXTBYT        ; Yes - keep testing
06BF-E1          I   940 (  9)         POP     HL              ; Get back start of word
06C0-C3 8F 06    I   941 (  9)         JP      SEARCH          ; Look at next word
06C3-            I   942
06C3-48          I   943 (  4) MATCH:  LD      C,B             ; Word found - Save token value
06C4-F1          I   944 (  9)         POP     AF              ; Throw away return
06C5-EB          I   945 (  3)         EX      DE,HL
06C6-C9          I   946 (  9)         RET                     ; Return to "RETNAD"
06C7-EB          I   947 (  3) RETNAD: EX      DE,HL           ; Get address in string
06C8-79          I   948 (  4)         LD      A,C             ; Get token value
06C9-C1          I   949 (  9)         POP     BC              ; Restore buffer length
06CA-D1          I   950 (  9)         POP     DE              ; Get destination address
06CB-23          I   951 (  4) MOVDIR: INC     HL              ; Next source in buffer
06CC-12          I   952 (  7)         LD      (DE),A          ; Put byte in buffer
06CD-13          I   953 (  4)         INC     DE              ; Move up buffer
06CE-0C          I   954 (  4)         INC     C               ; Increment length of buffer
06CF-D6 3A       I   955 (  6)         SUB     ':'             ; End of statement?
06D1-CA D9 06    I   956 ( 6+)         JP      Z,SETLIT        ; Jump if multi-statement line
06D4-FE 49       I   957 (  6)         CP      ZDATA-3AH       ; Is it DATA statement ?
06D6-C2 DC 06    I   958 ( 6+)         JP      NZ,TSTREM       ; No - see if REM
06D9-32 F3 22    I   959 ( 13) SETLIT: LD      (DATFLG),A      ; Set literal flag
06DC-D6 54       I   960 (  6) TSTREM: SUB     ZREM-3AH        ; Is it REM?
06DE-C2 4C 06    I   961 ( 6+)         JP      NZ,CRNCLP       ; No - Leave flag
06E1-47          I   962 (  4)         LD      B,A             ; Copy rest of buffer
06E2-7E          I   963 (  6) NXTCHR: LD      A,(HL)          ; Get byte
06E3-B7          I   964 (  4)         OR      A               ; End of line ?
06E4-CA F2 06    I   965 ( 6+)         JP      Z,ENDBUF        ; Yes - Terminate buffer
06E7-B8          I   966 (  4)         CP      B               ; End of statement ?
06E8-CA CB 06    I   967 ( 6+)         JP      Z,MOVDIR        ; Yes - Get next one
06EB-23          I   968 (  4) CPYLIT: INC     HL              ; Move up source string
06EC-12          I   969 (  7)         LD      (DE),A          ; Save in destination
06ED-0C          I   970 (  4)         INC     C               ; Increment length
06EE-13          I   971 (  4)         INC     DE              ; Move up destination
06EF-C3 E2 06    I   972 (  9)         JP      NXTCHR          ; Repeat
06F2-            I   973
06F2-21 A5 22    I   974 (  9) ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
06F5-12          I   975 (  7)         LD      (DE),A          ; Mark end of buffer (A = 00)
06F6-13          I   976 (  4)         INC     DE
06F7-12          I   977 (  7)         LD      (DE),A          ; A = 00
06F8-13          I   978 (  4)         INC     DE
06F9-12          I   979 (  7)         LD      (DE),A          ; A = 00
06FA-C9          I   980 (  9)         RET
06FB-            I   981
06FB-3A 89 22    I   982 ( 12) DODEL:  LD      A,(NULFLG)      ; Get null flag status
06FE-B7          I   983 (  4)         OR      A               ; Is it zero?
06FF-3E 00       I   984 (  6)         LD      A,0             ; Zero A - Leave flags
0701-32 89 22    I   985 ( 13)         LD      (NULFLG),A      ; Zero null flag
0704-C2 0F 07    I   986 ( 6+)         JP      NZ,ECHDEL       ; Set - Echo it
0707-05          I   987 (  4)         DEC     B               ; Decrement length
0708-CA 2C 07    I   988 ( 6+)         JP      Z,GETLIN        ; Get line again if empty
070B-CD C0 07    I   989 ( 16)         CALL    OUTC            ; Output null character
070E-3E          I   990               .DB   3EH             ; Skip "DEC B"
070F-05          I   991 (  4) ECHDEL: DEC     B               ; Count bytes in buffer
0710-2B          I   992 (  4)         DEC     HL              ; Back space buffer
0711-CA 23 07    I   993 ( 6+)         JP      Z,OTKLN         ; No buffer - Try again
0714-7E          I   994 (  6)         LD      A,(HL)          ; Get deleted byte
0715-CD C0 07    I   995 ( 16)         CALL    OUTC            ; Echo it
0718-C3 35 07    I   996 (  9)         JP      MORINP          ; Get more input
071B-            I   997
071B-05          I   998 (  4) DELCHR: DEC     B               ; Count bytes in buffer
071C-2B          I   999 (  4)         DEC     HL              ; Back space buffer
071D-CD C0 07    I  1000 ( 16)         CALL    OUTC            ; Output character in A
0720-C2 35 07    I  1001 ( 6+)         JP      NZ,MORINP       ; Not end - Get more
0723-CD C0 07    I  1002 ( 16) OTKLN:  CALL    OUTC            ; Output character in A
0726-CD E7 0B    I  1003 ( 16) KILIN:  CALL    PRNTCRLF        ; Output CRLF
0729-C3 2C 07    I  1004 (  9)         JP      TTYLIN          ; Get line again
072C-            I  1005
072C-            I  1006       GETLIN:
072C-21 A6 22    I  1007 (  9) TTYLIN: LD      HL,BUFFER       ; Get a line by character
072F-06 01       I  1008 (  6)         LD      B,1             ; Set buffer as empty
0731-AF          I  1009 (  4)         XOR     A
0732-32 89 22    I  1010 ( 13)         LD      (NULFLG),A      ; Clear null flag
0735-CD EA 07    I  1011 ( 16) MORINP: CALL    CLOTST          ; Get character and test ^O
0738-4F          I  1012 (  4)         LD      C,A             ; Save character in C
0739-FE 7F       I  1013 (  6)         CP      DEL             ; Delete character?
073B-CA FB 06    I  1014 ( 6+)         JP      Z,DODEL         ; Yes - Process it
073E-3A 89 22    I  1015 ( 12)         LD      A,(NULFLG)      ; Get null flag
0741-B7          I  1016 (  4)         OR      A               ; Test null flag status
0742-CA 4E 07    I  1017 ( 6+)         JP      Z,PROCES        ; Reset - Process character
0745-3E 00       I  1018 (  6)         LD      A,0             ; Set a null
0747-CD C0 07    I  1019 ( 16)         CALL    OUTC            ; Output null
074A-AF          I  1020 (  4)         XOR     A               ; Clear A
074B-32 89 22    I  1021 ( 13)         LD      (NULFLG),A      ; Reset null flag
074E-79          I  1022 (  4) PROCES: LD      A,C             ; Get character
074F-FE 07       I  1023 (  6)         CP      CTRLG           ; Bell?
0751-CA 92 07    I  1024 ( 6+)         JP      Z,PUTCTL        ; Yes - Save it
0754-FE 03       I  1025 (  6)         CP      CTRLC           ; Is it control "C"?
0756-CC E7 0B    I  1026 ( 6+)         CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0759-37          I  1027 (  3)         SCF                     ; Flag break
075A-C8          I  1028 ( 5+)         RET     Z               ; Return if control "C"
075B-FE 0D       I  1029 (  6)         CP      CR              ; Is it enter?
075D-CA E2 0B    I  1030 ( 6+)         JP      Z,ENDINP        ; Yes - Terminate input
0760-FE 15       I  1031 (  6)         CP      CTRLU           ; Is it control "U"?
0762-CA 26 07    I  1032 ( 6+)         JP      Z,KILIN         ; Yes - Get another line
0765-FE 40       I  1033 (  6)         CP      '@'             ; Is it "kill line"?
0767-CA 23 07    I  1034 ( 6+)         JP      Z,OTKLN         ; Yes - Kill line
076A-FE 5F       I  1035 (  6)         CP      '_'             ; Is it delete?
076C-CA 1B 07    I  1036 ( 6+)         JP      Z,DELCHR        ; Yes - Delete character
076F-FE 08       I  1037 (  6)         CP      BKSP            ; Is it backspace?
0771-CA 1B 07    I  1038 ( 6+)         JP      Z,DELCHR        ; Yes - Delete character
0774-FE 12       I  1039 (  6)         CP      CTRLR           ; Is it control "R"?
0776-C2 8D 07    I  1040 ( 6+)         JP      NZ,PUTBUF       ; No - Put in buffer
0779-C5          I  1041 ( 11)         PUSH    BC              ; Save buffer length
077A-D5          I  1042 ( 11)         PUSH    DE              ; Save DE
077B-E5          I  1043 ( 11)         PUSH    HL              ; Save buffer address
077C-36 00       I  1044 (  9)         LD      (HL),0          ; Mark end of buffer
077E-CD 97 1D    I  1045 ( 16)         CALL    OUTNCR          ; Output and do CRLF
0781-21 A6 22    I  1046 (  9)         LD      HL,BUFFER       ; Point to buffer start
0784-CD 85 12    I  1047 ( 16)         CALL    PRS             ; Output buffer
0787-E1          I  1048 (  9)         POP     HL              ; Restore buffer address
0788-D1          I  1049 (  9)         POP     DE              ; Restore DE
0789-C1          I  1050 (  9)         POP     BC              ; Restore buffer length
078A-C3 35 07    I  1051 (  9)         JP      MORINP          ; Get another character
078D-            I  1052
078D-FE 20       I  1053 (  6) PUTBUF: CP      ' '             ; Is it a control code?
078F-DA 35 07    I  1054 ( 6+)         JP      C,MORINP        ; Yes - Ignore
0792-78          I  1055 (  4) PUTCTL: LD      A,B             ; Get number of bytes in buffer
0793-FE 49       I  1056 (  6)         CP      72+1            ; Test for line overflow
0795-3E 07       I  1057 (  6)         LD      A,CTRLG         ; Set a bell
0797-D2 A7 07    I  1058 ( 6+)         JP      NC,OUTNBS       ; Ring bell if buffer full
079A-79          I  1059 (  4)         LD      A,C             ; Get character
079B-71          I  1060 (  7)         LD      (HL),C          ; Save in buffer
079C-32 11 23    I  1061 ( 13)         LD      (LSTBIN),A      ; Save last input byte
079F-23          I  1062 (  4)         INC     HL              ; Move up buffer
07A0-04          I  1063 (  4)         INC     B               ; Increment length
07A1-CD C0 07    I  1064 ( 16) OUTIT:  CALL    OUTC            ; Output the character entered
07A4-C3 35 07    I  1065 (  9)         JP      MORINP          ; Get another character
07A7-            I  1066
07A7-CD C0 07    I  1067 ( 16) OUTNBS: CALL    OUTC            ; Output bell and back over it
07AA-3E 08       I  1068 (  6)         LD      A,BKSP          ; Set back space
07AC-C3 A1 07    I  1069 (  9)         JP      OUTIT           ; Output it and get more
07AF-            I  1070
07AF-7C          I  1071 (  4) CPDEHL: LD      A,H             ; Get H
07B0-92          I  1072 (  4)         SUB     D               ; Compare with D
07B1-C0          I  1073 ( 5+)         RET     NZ              ; Different - Exit
07B2-7D          I  1074 (  4)         LD      A,L             ; Get L
07B3-93          I  1075 (  4)         SUB     E               ; Compare with E
07B4-C9          I  1076 (  9)         RET                     ; Return status
07B5-            I  1077
07B5-7E          I  1078 (  6) CHKSYN: LD      A,(HL)          ; Check syntax of character
07B6-E3          I  1079 ( 16)         EX      (SP),HL         ; Address of test byte
07B7-BE          I  1080 (  6)         CP      (HL)            ; Same as in code string?
07B8-23          I  1081 (  4)         INC     HL              ; Return address
07B9-E3          I  1082 ( 16)         EX      (SP),HL         ; Put it back
07BA-CA 3F 09    I  1083 ( 6+)         JP      Z,GETCHR        ; Yes - Get next character
07BD-C3 D8 04    I  1084 (  9)         JP      SNERR           ; Different - ?SN Error
07C0-            I  1085
07C0-F5          I  1086 ( 11) OUTC:   PUSH    AF              ; Save character
07C1-3A 8A 22    I  1087 ( 12)         LD      A,(CTLOFG)      ; Get control "O" flag
07C4-B7          I  1088 (  4)         OR      A               ; Is it set?
07C5-C2 BA 12    I  1089 ( 6+)         JP      NZ,POPAF        ; Yes - don't output
07C8-F1          I  1090 (  9)         POP     AF              ; Restore character
07C9-C5          I  1091 ( 11)         PUSH    BC              ; Save buffer length
07CA-F5          I  1092 ( 11)         PUSH    AF              ; Save character
07CB-FE 20       I  1093 (  6)         CP      ' '             ; Is it a control code?
07CD-DA E4 07    I  1094 ( 6+)         JP      C,DINPOS        ; Yes - Don't INC POS(X)
07D0-3A 87 22    I  1095 ( 12)         LD      A,(LWIDTH)      ; Get line width
07D3-47          I  1096 (  4)         LD      B,A             ; To B
07D4-3A F0 22    I  1097 ( 12)         LD      A,(CURPOS)      ; Get cursor position
07D7-04          I  1098 (  4)         INC     B               ; Width 255?
07D8-CA E0 07    I  1099 ( 6+)         JP      Z,INCLEN        ; Yes - No width limit
07DB-05          I  1100 (  4)         DEC     B               ; Restore width
07DC-B8          I  1101 (  4)         CP      B               ; At end of line?
07DD-CC E7 0B    I  1102 ( 6+)         CALL    Z,PRNTCRLF      ; Yes - output CRLF
07E0-3C          I  1103 (  4) INCLEN: INC     A               ; Move on one character
07E1-32 F0 22    I  1104 ( 13)         LD      (CURPOS),A      ; Save new position
07E4-F1          I  1105 (  9) DINPOS: POP     AF              ; Restore character
07E5-C1          I  1106 (  9)         POP     BC              ; Restore buffer length
07E6-CD 80 1D    I  1107 ( 16)         CALL    MONOUT          ; Send it
07E9-C9          I  1108 (  9)         RET
07EA-            I  1109
07EA-CD 44 1C    I  1110 ( 16) CLOTST: CALL    GETINP          ; Get input character
07ED-E6 7F       I  1111 (  6)         AND     01111111B       ; Strip bit 7
07EF-FE 0F       I  1112 (  6)         CP      CTRLO           ; Is it control "O"?
07F1-C0          I  1113 ( 5+)         RET     NZ              ; No don't flip flag
07F2-3A 8A 22    I  1114 ( 12)         LD      A,(CTLOFG)      ; Get flag
07F5-2F          I  1115 (  3)         CPL                     ; Flip it
07F6-32 8A 22    I  1116 ( 13)         LD      (CTLOFG),A      ; Put it back
07F9-AF          I  1117 (  4)         XOR     A               ; Null character
07FA-C9          I  1118 (  9)         RET
07FB-            I  1119
07FB-CD 0B 0A    I  1120 ( 16) LIST:   CALL    ATOH            ; ASCII number to DE
07FE-C0          I  1121 ( 5+)         RET     NZ              ; Return if anything extra
07FF-C1          I  1122 (  9)         POP     BC              ; Rubbish - Not needed
0800-CD D3 05    I  1123 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0803-C5          I  1124 ( 11)         PUSH    BC              ; Save address of line
0804-CD 51 08    I  1125 ( 16)         CALL    SETLIN          ; Set up lines counter
0807-E1          I  1126 (  9) LISTLP: POP     HL              ; Restore address of line
0808-4E          I  1127 (  6)         LD      C,(HL)          ; Get LSB of next line
0809-23          I  1128 (  4)         INC     HL
080A-46          I  1129 (  6)         LD      B,(HL)          ; Get MSB of next line
080B-23          I  1130 (  4)         INC     HL
080C-78          I  1131 (  4)         LD      A,B             ; BC = 0 (End of program)?
080D-B1          I  1132 (  4)         OR      C
080E-CA 32 05    I  1133 ( 6+)         JP      Z,PRNTOK        ; Yes - Go to command mode
0811-CD 5A 08    I  1134 ( 16)         CALL    COUNT           ; Count lines
0814-CD 6A 09    I  1135 ( 16)         CALL    TSTBRK          ; Test for break key
0817-C5          I  1136 ( 11)         PUSH    BC              ; Save address of next line
0818-CD E7 0B    I  1137 ( 16)         CALL    PRNTCRLF        ; Output CRLF
081B-5E          I  1138 (  6)         LD      E,(HL)          ; Get LSB of line number
081C-23          I  1139 (  4)         INC     HL
081D-56          I  1140 (  6)         LD      D,(HL)          ; Get MSB of line number
081E-23          I  1141 (  4)         INC     HL
081F-E5          I  1142 ( 11)         PUSH    HL              ; Save address of line start
0820-EB          I  1143 (  3)         EX      DE,HL           ; Line number to HL
0821-CD 28 19    I  1144 ( 16)         CALL    PRNTHL          ; Output line number in decimal
0824-3E 20       I  1145 (  6)         LD      A,' '           ; Space after line number
0826-E1          I  1146 (  9)         POP     HL              ; Restore start of line address
0827-CD C0 07    I  1147 ( 16) LSTLP2: CALL    OUTC            ; Output character in A
082A-7E          I  1148 (  6) LSTLP3: LD      A,(HL)          ; Get next byte in line
082B-B7          I  1149 (  4)         OR      A               ; End of line?
082C-23          I  1150 (  4)         INC     HL              ; To next byte in line
082D-CA 07 08    I  1151 ( 6+)         JP      Z,LISTLP        ; Yes - get next line
0830-F2 27 08    I  1152 ( 6+)         JP      P,LSTLP2        ; No token - output it
0833-D6 7F       I  1153 (  6)         SUB     ZEND-1          ; Find and output word
0835-4F          I  1154 (  4)         LD      C,A             ; Token offset+1 to C
0836-11 58 02    I  1155 (  9)         LD      DE,WORDS        ; Reserved word list
0839-1A          I  1156 (  6) FNDTOK: LD      A,(DE)          ; Get character in list
083A-13          I  1157 (  4)         INC     DE              ; Move on to next
083B-B7          I  1158 (  4)         OR      A               ; Is it start of word?
083C-F2 39 08    I  1159 ( 6+)         JP      P,FNDTOK        ; No - Keep looking for word
083F-0D          I  1160 (  4)         DEC     C               ; Count words
0840-C2 39 08    I  1161 ( 6+)         JP      NZ,FNDTOK       ; Not there - keep looking
0843-E6 7F       I  1162 (  6) OUTWRD: AND     01111111B       ; Strip bit 7
0845-CD C0 07    I  1163 ( 16)         CALL    OUTC            ; Output first character
0848-1A          I  1164 (  6)         LD      A,(DE)          ; Get next character
0849-13          I  1165 (  4)         INC     DE              ; Move on to next
084A-B7          I  1166 (  4)         OR      A               ; Is it end of word?
084B-F2 43 08    I  1167 ( 6+)         JP      P,OUTWRD        ; No - output the rest
084E-C3 2A 08    I  1168 (  9)         JP      LSTLP3          ; Next byte in line
0851-            I  1169
0851-E5          I  1170 ( 11) SETLIN: PUSH    HL              ; Set up LINES counter
0852-2A 8D 22    I  1171 ( 15)         LD      HL,(LINESN)     ; Get LINES number
0855-22 8B 22    I  1172 ( 20)         LD      (LINESC),HL     ; Save in LINES counter
0858-E1          I  1173 (  9)         POP     HL
0859-C9          I  1174 (  9)         RET
085A-            I  1175
085A-E5          I  1176 ( 11) COUNT:  PUSH    HL              ; Save code string address
085B-D5          I  1177 ( 11)         PUSH    DE
085C-2A 8B 22    I  1178 ( 15)         LD      HL,(LINESC)     ; Get LINES counter
085F-11 FF FF    I  1179 (  9)         LD      DE,-1
0862-ED 5A       I  1180 ( 10)         ADC     HL,DE           ; Decrement
0864-22 8B 22    I  1181 ( 20)         LD      (LINESC),HL     ; Put it back
0867-D1          I  1182 (  9)         POP     DE
0868-E1          I  1183 (  9)         POP     HL              ; Restore code string address
0869-F0          I  1184 ( 5+)         RET     P               ; Return if more lines to go
086A-E5          I  1185 ( 11)         PUSH    HL              ; Save code string address
086B-2A 8D 22    I  1186 ( 15)         LD      HL,(LINESN)     ; Get LINES number
086E-22 8B 22    I  1187 ( 20)         LD      (LINESC),HL     ; Reset LINES counter
0871-CD 44 1C    I  1188 ( 16)         CALL    GETINP          ; Get input character
0874-FE 03       I  1189 (  6)         CP      CTRLC           ; Is it control "C"?
0876-CA 7D 08    I  1190 ( 6+)         JP      Z,RSLNBK        ; Yes - Reset LINES and break
0879-E1          I  1191 (  9)         POP     HL              ; Restore code string address
087A-C3 5A 08    I  1192 (  9)         JP      COUNT           ; Keep on counting
087D-            I  1193
087D-2A 8D 22    I  1194 ( 15) RSLNBK: LD      HL,(LINESN)     ; Get LINES number
0880-22 8B 22    I  1195 ( 20)         LD      (LINESC),HL     ; Reset LINES counter
0883-C3 C3 01    I  1196 (  9)         JP      BRKRET          ; Go and output "Break"
0886-            I  1197
0886-3E 64       I  1198 (  6) FOR:    LD      A,64H           ; Flag "FOR" assignment
0888-32 10 23    I  1199 ( 13)         LD      (FORFLG),A      ; Save "FOR" flag
088B-CD ED 0A    I  1200 ( 16)         CALL    LET             ; Set up initial index
088E-C1          I  1201 (  9)         POP     BC              ; Drop RETurn address
088F-E5          I  1202 ( 11)         PUSH    HL              ; Save code string address
0890-CD D6 0A    I  1203 ( 16)         CALL    DATA            ; Get next statement address
0893-22 0C 23    I  1204 ( 20)         LD      (LOOPST),HL     ; Save it for start of loop
0896-21 02 00    I  1205 (  9)         LD      HL,2            ; Offset for "FOR" block
0899-39          I  1206 (  7)         ADD     HL,SP           ; Point to it
089A-CD 85 04    I  1207 ( 16) FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
089D-D1          I  1208 (  9)         POP     DE              ; Get code string address
089E-C2 B6 08    I  1209 ( 6+)         JP      NZ,FORFND       ; No nesting found
08A1-09          I  1210 (  7)         ADD     HL,BC           ; Move into "FOR" block
08A2-D5          I  1211 ( 11)         PUSH    DE              ; Save code string address
08A3-2B          I  1212 (  4)         DEC     HL
08A4-56          I  1213 (  6)         LD      D,(HL)          ; Get MSB of loop statement
08A5-2B          I  1214 (  4)         DEC     HL
08A6-5E          I  1215 (  6)         LD      E,(HL)          ; Get LSB of loop statement
08A7-23          I  1216 (  4)         INC     HL
08A8-23          I  1217 (  4)         INC     HL
08A9-E5          I  1218 ( 11)         PUSH    HL              ; Save block address
08AA-2A 0C 23    I  1219 ( 15)         LD      HL,(LOOPST)     ; Get address of loop statement
08AD-CD AF 07    I  1220 ( 16)         CALL    CPDEHL          ; Compare the FOR loops
08B0-E1          I  1221 (  9)         POP     HL              ; Restore block address
08B1-C2 9A 08    I  1222 ( 6+)         JP      NZ,FORSLP       ; Different FORs - Find another
08B4-D1          I  1223 (  9)         POP     DE              ; Restore code string address
08B5-F9          I  1224 (  4)         LD      SP,HL           ; Remove all nested loops
08B6-            I  1225
08B6-EB          I  1226 (  3) FORFND: EX      DE,HL           ; Code string address to HL
08B7-0E 08       I  1227 (  6)         LD      C,8
08B9-CD B5 04    I  1228 ( 16)         CALL    CHKSTK          ; Check for 8 levels of stack
08BC-E5          I  1229 ( 11)         PUSH    HL              ; Save code string address
08BD-2A 0C 23    I  1230 ( 15)         LD      HL,(LOOPST)     ; Get first statement of loop
08C0-E3          I  1231 ( 16)         EX      (SP),HL         ; Save and restore code string
08C1-E5          I  1232 ( 11)         PUSH    HL              ; Re-save code string address
08C2-2A A1 22    I  1233 ( 15)         LD      HL,(LINEAT)     ; Get current line number
08C5-E3          I  1234 ( 16)         EX      (SP),HL         ; Save and restore code string
08C6-CD AF 0D    I  1235 ( 16)         CALL    TSTNUM          ; Make sure it's a number
08C9-CD B5 07    I  1236 ( 16)         CALL    CHKSYN          ; Make sure "TO" is next
08CC-A6          I  1237               .DB   ZTO          ; "TO" token
08CD-CD AC 0D    I  1238 ( 16)         CALL    GETNUM          ; Get "TO" expression value
08D0-E5          I  1239 ( 11)         PUSH    HL              ; Save code string address
08D1-CD DA 17    I  1240 ( 16)         CALL    BCDEFP          ; Move "TO" value to BCDE
08D4-E1          I  1241 (  9)         POP     HL              ; Restore code string address
08D5-C5          I  1242 ( 11)         PUSH    BC              ; Save "TO" value in block
08D6-D5          I  1243 ( 11)         PUSH    DE
08D7-01 00 81    I  1244 (  9)         LD      BC,8100H        ; BCDE - 1 (default STEP)
08DA-51          I  1245 (  4)         LD      D,C             ; C=0
08DB-5A          I  1246 (  4)         LD      E,D             ; D=0
08DC-7E          I  1247 (  6)         LD      A,(HL)          ; Get next byte in code string
08DD-FE AB       I  1248 (  6)         CP      ZSTEP           ; See if "STEP" is stated
08DF-3E 01       I  1249 (  6)         LD      A,1             ; Sign of step = 1
08E1-C2 F2 08    I  1250 ( 6+)         JP      NZ,SAVSTP       ; No STEP given - Default to 1
08E4-CD 3F 09    I  1251 ( 16)         CALL    GETCHR          ; Jump over "STEP" token
08E7-CD AC 0D    I  1252 ( 16)         CALL    GETNUM          ; Get step value
08EA-E5          I  1253 ( 11)         PUSH    HL              ; Save code string address
08EB-CD DA 17    I  1254 ( 16)         CALL    BCDEFP          ; Move STEP to BCDE
08EE-CD 8E 17    I  1255 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
08F1-E1          I  1256 (  9)         POP     HL              ; Restore code string address
08F2-C5          I  1257 ( 11) SAVSTP: PUSH    BC              ; Save the STEP value in block
08F3-D5          I  1258 ( 11)         PUSH    DE
08F4-F5          I  1259 ( 11)         PUSH    AF              ; Save sign of STEP
08F5-33          I  1260 (  4)         INC     SP              ; Don't save flags
08F6-E5          I  1261 ( 11)         PUSH    HL              ; Save code string address
08F7-2A 13 23    I  1262 ( 15)         LD      HL,(BRKLIN)     ; Get address of index variable
08FA-E3          I  1263 ( 16)         EX      (SP),HL         ; Save and restore code string
08FB-06 81       I  1264 (  6) PUTFID: LD      B,ZFOR          ; "FOR" block marker
08FD-C5          I  1265 ( 11)         PUSH    BC              ; Save it
08FE-33          I  1266 (  4)         INC     SP              ; Don't save C
08FF-            I  1267
08FF-CD 6A 09    I  1268 ( 16) RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
0902-22 13 23    I  1269 ( 20)         LD      (BRKLIN),HL     ; Save code address for break
0905-7E          I  1270 (  6)         LD      A,(HL)          ; Get next byte in code string
0906-FE 3A       I  1271 (  6)         CP      ':'             ; Multi statement line?
0908-CA 1F 09    I  1272 ( 6+)         JP      Z,EXCUTE        ; Yes - Execute it
090B-B7          I  1273 (  4)         OR      A               ; End of line?
090C-C2 D8 04    I  1274 ( 6+)         JP      NZ,SNERR        ; No - Syntax error
090F-23          I  1275 (  4)         INC     HL              ; Point to address of next line
0910-7E          I  1276 (  6)         LD      A,(HL)          ; Get LSB of line pointer
0911-23          I  1277 (  4)         INC     HL
0912-B6          I  1278 (  6)         OR      (HL)            ; Is it zero (End of prog)?
0913-CA 91 09    I  1279 ( 6+)         JP      Z,ENDPRG        ; Yes - Terminate execution
0916-23          I  1280 (  4)         INC     HL              ; Point to line number
0917-5E          I  1281 (  6)         LD      E,(HL)          ; Get LSB of line number
0918-23          I  1282 (  4)         INC     HL
0919-56          I  1283 (  6)         LD      D,(HL)          ; Get MSB of line number
091A-EB          I  1284 (  3)         EX      DE,HL           ; Line number to HL
091B-22 A1 22    I  1285 ( 20)         LD      (LINEAT),HL     ; Save as current line number
091E-EB          I  1286 (  3)         EX      DE,HL           ; Line number back to DE
091F-CD 3F 09    I  1287 ( 16) EXCUTE: CALL    GETCHR          ; Get key word
0922-11 FF 08    I  1288 (  9)         LD      DE,RUNCNT       ; Where to RETurn to
0925-D5          I  1289 ( 11)         PUSH    DE              ; Save for RETurn
0926-C8          I  1290 ( 5+) IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
0927-D6 80       I  1291 (  6) ONJMP:  SUB     ZEND            ; Is it a token?
0929-DA ED 0A    I  1292 ( 6+)         JP      C,LET           ; No - try to assign it
092C-FE 25       I  1293 (  6)         CP      ZNEW+1-ZEND     ; END to NEW ?
092E-D2 D8 04    I  1294 ( 6+)         JP      NC,SNERR        ; Not a key word - ?SN Error
0931-07          I  1295 (  3)         RLCA                    ; Double it
0932-4F          I  1296 (  4)         LD      C,A             ; BC = Offset into table
0933-06 00       I  1297 (  6)         LD      B,0
0935-EB          I  1298 (  3)         EX      DE,HL           ; Save code string address
0936-21 77 03    I  1299 (  9)         LD      HL,WORDTB       ; Keyword address table
0939-09          I  1300 (  7)         ADD     HL,BC           ; Point to routine address
093A-4E          I  1301 (  6)         LD      C,(HL)          ; Get LSB of routine address
093B-23          I  1302 (  4)         INC     HL
093C-46          I  1303 (  6)         LD      B,(HL)          ; Get MSB of routine address
093D-C5          I  1304 ( 11)         PUSH    BC              ; Save routine address
093E-EB          I  1305 (  3)         EX      DE,HL           ; Restore code string address
093F-            I  1306
093F-23          I  1307 (  4) GETCHR: INC     HL              ; Point to next character
0940-7E          I  1308 (  6)         LD      A,(HL)          ; Get next code string byte
0941-FE 3A       I  1309 (  6)         CP      ':'             ; Z if ':'
0943-D0          I  1310 ( 5+)         RET     NC              ; NC if > "9"
0944-FE 20       I  1311 (  6)         CP      ' '
0946-CA 3F 09    I  1312 ( 6+)         JP      Z,GETCHR        ; Skip over spaces
0949-FE 30       I  1313 (  6)         CP      '0'
094B-3F          I  1314 (  3)         CCF                     ; NC if < '0'
094C-3C          I  1315 (  4)         INC     A               ; Test for zero - Leave carry
094D-3D          I  1316 (  4)         DEC     A               ; Z if Null
094E-C9          I  1317 (  9)         RET
094F-            I  1318
094F-EB          I  1319 (  3) RESTOR: EX      DE,HL           ; Save code string address
0950-2A A3 22    I  1320 ( 15)         LD      HL,(BASTXT)     ; Point to start of program
0953-CA 64 09    I  1321 ( 6+)         JP      Z,RESTNL        ; Just RESTORE - reset pointer
0956-EB          I  1322 (  3)         EX      DE,HL           ; Restore code string address
0957-CD 0B 0A    I  1323 ( 16)         CALL    ATOH            ; Get line number to DE
095A-E5          I  1324 ( 11)         PUSH    HL              ; Save code string address
095B-CD D3 05    I  1325 ( 16)         CALL    SRCHLN          ; Search for line number in DE
095E-60          I  1326 (  4)         LD      H,B             ; HL = Address of line
095F-69          I  1327 (  4)         LD      L,C
0960-D1          I  1328 (  9)         POP     DE              ; Restore code string address
0961-D2 AC 0A    I  1329 ( 6+)         JP      NC,ULERR        ; ?UL Error if not found
0964-2B          I  1330 (  4) RESTNL: DEC     HL              ; Byte before DATA statement
0965-22 21 23    I  1331 ( 20) UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
0968-EB          I  1332 (  3)         EX      DE,HL           ; Restore code string address
0969-C9          I  1333 (  9)         RET
096A-            I  1334
096A-            I  1335
096A-DF          I  1336 ( 11) TSTBRK: RST     18H             ; Check input status
096B-C8          I  1337 ( 5+)         RET     Z               ; No key, go back
096C-D7          I  1338 ( 11)         RST     10H             ; Get the key into A
096D-FE 1B       I  1339 (  6)         CP      ESC             ; Escape key?
096F-28 11       I  1340 ( 6+)         JR      Z,BRK           ; Yes, break
0971-FE 03       I  1341 (  6)         CP      CTRLC           ; <Ctrl-C>
0973-28 0D       I  1342 ( 6+)         JR      Z,BRK           ; Yes, break
0975-FE 13       I  1343 (  6)         CP      CTRLS           ; Stop scrolling?
0977-C0          I  1344 ( 5+)         RET     NZ              ; Other key, ignore
0978-            I  1345
0978-            I  1346
0978-D7          I  1347 ( 11) STALL:  RST     10H             ; Wait for key
0979-FE 11       I  1348 (  6)         CP      CTRLQ           ; Resume scrolling?
097B-C8          I  1349 ( 5+)         RET      Z              ; Release the chokehold
097C-FE 03       I  1350 (  6)         CP      CTRLC           ; Second break?
097E-28 07       I  1351 ( 6+)         JR      Z,STOP          ; Break during hold exits prog
0980-18 F6       I  1352 (  8)         JR      STALL           ; Loop until <Ctrl-Q> or <brk>
0982-            I  1353
0982-3E FF       I  1354 (  6) BRK     LD      A,$FF           ; Set BRKFLG
0984-32 92 22    I  1355 ( 13)         LD      (BRKFLG),A      ; Store it
0987-            I  1356
0987-            I  1357
0987-C0          I  1358 ( 5+) STOP:   RET     NZ              ; Exit if anything else
0988-F6          I  1359               .DB   0F6H            ; Flag "STOP"
0989-C0          I  1360 ( 5+) PEND:   RET     NZ              ; Exit if anything else
098A-22 13 23    I  1361 ( 20)         LD      (BRKLIN),HL     ; Save point of break
098D-21          I  1362               .DB   21H             ; Skip "OR 11111111B"
098E-F6 FF       I  1363 (  6) INPBRK: OR      11111111B       ; Flag "Break" wanted
0990-C1          I  1364 (  9)         POP     BC              ; Return not needed and more
0991-2A A1 22    I  1365 ( 15) ENDPRG: LD      HL,(LINEAT)     ; Get current line number
0994-F5          I  1366 ( 11)         PUSH    AF              ; Save STOP / END status
0995-7D          I  1367 (  4)         LD      A,L             ; Is it direct break?
0996-A4          I  1368 (  4)         AND     H
0997-3C          I  1369 (  4)         INC     A               ; Line is -1 if direct break
0998-CA A4 09    I  1370 ( 6+)         JP      Z,NOLIN         ; Yes - No line number
099B-22 17 23    I  1371 ( 20)         LD      (ERRLIN),HL     ; Save line of break
099E-2A 13 23    I  1372 ( 15)         LD      HL,(BRKLIN)     ; Get point of break
09A1-22 19 23    I  1373 ( 20)         LD      (CONTAD),HL     ; Save point to CONTinue
09A4-AF          I  1374 (  4) NOLIN:  XOR     A
09A5-32 8A 22    I  1375 ( 13)         LD      (CTLOFG),A      ; Enable output
09A8-CD DA 0B    I  1376 ( 16)         CALL    STTLIN          ; Start a new line
09AB-F1          I  1377 (  9)         POP     AF              ; Restore STOP / END status
09AC-21 7B 04    I  1378 (  9)         LD      HL,BRKMSG       ; "Break" message
09AF-C2 1B 05    I  1379 ( 6+)         JP      NZ,ERRIN        ; "in line" wanted?
09B2-C3 32 05    I  1380 (  9)         JP      PRNTOK          ; Go to command mode
09B5-            I  1381
09B5-2A 19 23    I  1382 ( 15) CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
09B8-7C          I  1383 (  4)         LD      A,H             ; Is it zero?
09B9-B5          I  1384 (  4)         OR      L
09BA-1E 20       I  1385 (  6)         LD      E,CN            ; ?CN Error
09BC-CA EC 04    I  1386 ( 6+)         JP      Z,ERROR         ; Yes - output "?CN Error"
09BF-EB          I  1387 (  3)         EX      DE,HL           ; Save code string address
09C0-2A 17 23    I  1388 ( 15)         LD      HL,(ERRLIN)     ; Get line of last break
09C3-22 A1 22    I  1389 ( 20)         LD      (LINEAT),HL     ; Set up current line number
09C6-EB          I  1390 (  3)         EX      DE,HL           ; Restore code string address
09C7-C9          I  1391 (  9)         RET                     ; CONTinue where left off
09C8-            I  1392
09C8-CD 0D 15    I  1393 ( 16) NULL:   CALL    GETINT          ; Get integer 0-255
09CB-C0          I  1394 ( 5+)         RET     NZ              ; Return if bad value
09CC-32 86 22    I  1395 ( 13)         LD      (NULLS),A       ; Set nulls number
09CF-C9          I  1396 (  9)         RET
09D0-            I  1397
09D0-            I  1398
09D0-E5          I  1399 ( 11) ACCSUM: PUSH    HL              ; Save address in array
09D1-2A 8F 22    I  1400 ( 15)         LD      HL,(CHKSUM)     ; Get check sum
09D4-06 00       I  1401 (  6)         LD      B,0             ; BC - Value of byte
09D6-4F          I  1402 (  4)         LD      C,A
09D7-09          I  1403 (  7)         ADD     HL,BC           ; Add byte to check sum
09D8-22 8F 22    I  1404 ( 20)         LD      (CHKSUM),HL     ; Re-save check sum
09DB-E1          I  1405 (  9)         POP     HL              ; Restore address in array
09DC-C9          I  1406 (  9)         RET
09DD-            I  1407
09DD-7E          I  1408 (  6) CHKLTR: LD      A,(HL)          ; Get byte
09DE-FE 41       I  1409 (  6)         CP      'A'             ; < 'a' ?
09E0-D8          I  1410 ( 5+)         RET     C               ; Carry set if not letter
09E1-FE 5B       I  1411 (  6)         CP      'Z'+1           ; > 'z' ?
09E3-3F          I  1412 (  3)         CCF
09E4-C9          I  1413 (  9)         RET                     ; Carry set if not letter
09E5-            I  1414
09E5-CD 3F 09    I  1415 ( 16) FPSINT: CALL    GETCHR          ; Get next character
09E8-CD AC 0D    I  1416 ( 16) POSINT: CALL    GETNUM          ; Get integer 0 to 32767
09EB-CD 8E 17    I  1417 ( 16) DEPINT: CALL    TSTSGN          ; Test sign of FPREG
09EE-FA 06 0A    I  1418 ( 6+)         JP      M,FCERR         ; Negative - ?FC Error
09F1-3A 2C 23    I  1419 ( 12) DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
09F4-FE 90       I  1420 (  6)         CP      80H+16          ; Exponent in range (16 bits)?
09F6-DA 36 18    I  1421 ( 6+)         JP      C,FPINT         ; Yes - convert it
09F9-01 80 90    I  1422 (  9)         LD      BC,9080H        ; BCDE = -32768
09FC-11 00 00    I  1423 (  9)         LD      DE,0000
09FF-E5          I  1424 ( 11)         PUSH    HL              ; Save code string address
0A00-CD 09 18    I  1425 ( 16)         CALL    CMPNUM          ; Compare FPREG with BCDE
0A03-E1          I  1426 (  9)         POP     HL              ; Restore code string address
0A04-51          I  1427 (  4)         LD      D,C             ; MSB to D
0A05-C8          I  1428 ( 5+)         RET     Z               ; Return if in range
0A06-1E 08       I  1429 (  6) FCERR:  LD      E,FC            ; ?FC Error
0A08-C3 EC 04    I  1430 (  9)         JP      ERROR           ; Output error-
0A0B-            I  1431
0A0B-2B          I  1432 (  4) ATOH:   DEC     HL              ; ASCII number to DE binary
0A0C-11 00 00    I  1433 (  9) GETLN:  LD      DE,0            ; Get number to DE
0A0F-CD 3F 09    I  1434 ( 16) GTLNLP: CALL    GETCHR          ; Get next character
0A12-D0          I  1435 ( 5+)         RET     NC              ; Exit if not a digit
0A13-E5          I  1436 ( 11)         PUSH    HL              ; Save code string address
0A14-F5          I  1437 ( 11)         PUSH    AF              ; Save digit
0A15-21 98 19    I  1438 (  9)         LD      HL,65529/10     ; Largest number 65529
0A18-CD AF 07    I  1439 ( 16)         CALL    CPDEHL          ; Number in range?
0A1B-DA D8 04    I  1440 ( 6+)         JP      C,SNERR         ; No - ?SN Error
0A1E-62          I  1441 (  4)         LD      H,D             ; HL = Number
0A1F-6B          I  1442 (  4)         LD      L,E
0A20-19          I  1443 (  7)         ADD     HL,DE           ; Times 2
0A21-29          I  1444 (  7)         ADD     HL,HL           ; Times 4
0A22-19          I  1445 (  7)         ADD     HL,DE           ; Times 5
0A23-29          I  1446 (  7)         ADD     HL,HL           ; Times 10
0A24-F1          I  1447 (  9)         POP     AF              ; Restore digit
0A25-D6 30       I  1448 (  6)         SUB     '0'             ; Make it 0 to 9
0A27-5F          I  1449 (  4)         LD      E,A             ; DE = Value of digit
0A28-16 00       I  1450 (  6)         LD      D,0
0A2A-19          I  1451 (  7)         ADD     HL,DE           ; Add to number
0A2B-EB          I  1452 (  3)         EX      DE,HL           ; Number to DE
0A2C-E1          I  1453 (  9)         POP     HL              ; Restore code string address
0A2D-C3 0F 0A    I  1454 (  9)         JP      GTLNLP          ; Go to next character
0A30-            I  1455
0A30-CA 03 06    I  1456 ( 6+) CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
0A33-CD E8 09    I  1457 ( 16)         CALL    POSINT          ; Get integer 0 to 32767 to DE
0A36-2B          I  1458 (  4)         DEC     HL              ; Cancel increment
0A37-CD 3F 09    I  1459 ( 16)         CALL    GETCHR          ; Get next character
0A3A-E5          I  1460 ( 11)         PUSH    HL              ; Save code string address
0A3B-2A F4 22    I  1461 ( 15)         LD      HL,(LSTRAM)     ; Get end of RAM
0A3E-CA 53 0A    I  1462 ( 6+)         JP      Z,STORED        ; No value given - Use stored
0A41-E1          I  1463 (  9)         POP     HL              ; Restore code string address
0A42-CD B5 07    I  1464 ( 16)         CALL    CHKSYN          ; Check for comma
0A45-2C          I  1465               .DB      ','
0A46-D5          I  1466 ( 11)         PUSH    DE              ; Save number
0A47-CD E8 09    I  1467 ( 16)         CALL    POSINT          ; Get integer 0 to 32767
0A4A-2B          I  1468 (  4)         DEC     HL              ; Cancel increment
0A4B-CD 3F 09    I  1469 ( 16)         CALL    GETCHR          ; Get next character
0A4E-C2 D8 04    I  1470 ( 6+)         JP      NZ,SNERR        ; ?SN Error if more on line
0A51-E3          I  1471 ( 16)         EX      (SP),HL         ; Save code string address
0A52-EB          I  1472 (  3)         EX      DE,HL           ; Number to DE
0A53-7D          I  1473 (  4) STORED: LD      A,L             ; Get LSB of new RAM top
0A54-93          I  1474 (  4)         SUB     E               ; Subtract LSB of string space
0A55-5F          I  1475 (  4)         LD      E,A             ; Save LSB
0A56-7C          I  1476 (  4)         LD      A,H             ; Get MSB of new RAM top
0A57-9A          I  1477 (  4)         SBC     A,D             ; Subtract MSB of string space
0A58-57          I  1478 (  4)         LD      D,A             ; Save MSB
0A59-DA CD 04    I  1479 ( 6+)         JP      C,OMERR         ; ?OM Error if not enough mem
0A5C-E5          I  1480 ( 11)         PUSH    HL              ; Save RAM top
0A5D-2A 1B 23    I  1481 ( 15)         LD      HL,(PROGND)     ; Get program end
0A60-01 28 00    I  1482 (  9)         LD      BC,40           ; 40 Bytes minimum working RAM
0A63-09          I  1483 (  7)         ADD     HL,BC           ; Get lowest address
0A64-CD AF 07    I  1484 ( 16)         CALL    CPDEHL          ; Enough memory?
0A67-D2 CD 04    I  1485 ( 6+)         JP      NC,OMERR        ; No - ?OM Error
0A6A-EB          I  1486 (  3)         EX      DE,HL           ; RAM top to HL
0A6B-22 9F 22    I  1487 ( 20)         LD      (STRSPC),HL     ; Set new string space
0A6E-E1          I  1488 (  9)         POP     HL              ; End of memory to use
0A6F-22 F4 22    I  1489 ( 20)         LD      (LSTRAM),HL     ; Set new top of RAM
0A72-E1          I  1490 (  9)         POP     HL              ; Restore code string address
0A73-C3 03 06    I  1491 (  9)         JP      INTVAR          ; Initialise variables
0A76-            I  1492
0A76-CA FF 05    I  1493 ( 6+) RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
0A79-CD 03 06    I  1494 ( 16)         CALL    INTVAR          ; Initialise variables
0A7C-01 FF 08    I  1495 (  9)         LD      BC,RUNCNT       ; Execution driver loop
0A7F-C3 92 0A    I  1496 (  9)         JP      RUNLIN          ; RUN from line number
0A82-            I  1497
0A82-0E 03       I  1498 (  6) GOSUB:  LD      C,3             ; 3 Levels of stack needed
0A84-CD B5 04    I  1499 ( 16)         CALL    CHKSTK          ; Check for 3 levels of stack
0A87-C1          I  1500 (  9)         POP     BC              ; Get return address
0A88-E5          I  1501 ( 11)         PUSH    HL              ; Save code string for RETURN
0A89-E5          I  1502 ( 11)         PUSH    HL              ; And for GOSUB routine
0A8A-2A A1 22    I  1503 ( 15)         LD      HL,(LINEAT)     ; Get current line
0A8D-E3          I  1504 ( 16)         EX      (SP),HL         ; Into stack - Code string out
0A8E-3E 8C       I  1505 (  6)         LD      A,ZGOSUB        ; "GOSUB" token
0A90-F5          I  1506 ( 11)         PUSH    AF              ; Save token
0A91-33          I  1507 (  4)         INC     SP              ; Don't save flags
0A92-            I  1508
0A92-C5          I  1509 ( 11) RUNLIN: PUSH    BC              ; Save return address
0A93-CD 0B 0A    I  1510 ( 16) GOTO:   CALL    ATOH            ; ASCII number to DE binary
0A96-CD D8 0A    I  1511 ( 16)         CALL    REM             ; Get end of line
0A99-E5          I  1512 ( 11)         PUSH    HL              ; Save end of line
0A9A-2A A1 22    I  1513 ( 15)         LD      HL,(LINEAT)     ; Get current line
0A9D-CD AF 07    I  1514 ( 16)         CALL    CPDEHL          ; Line after current?
0AA0-E1          I  1515 (  9)         POP     HL              ; Restore end of line
0AA1-23          I  1516 (  4)         INC     HL              ; Start of next line
0AA2-DC D6 05    I  1517 ( 6+)         CALL    C,SRCHLP        ; Line is after current line
0AA5-D4 D3 05    I  1518 ( 6+)         CALL    NC,SRCHLN       ; Line is before current line
0AA8-60          I  1519 (  4)         LD      H,B             ; Set up code string address
0AA9-69          I  1520 (  4)         LD      L,C
0AAA-2B          I  1521 (  4)         DEC     HL              ; Incremented after
0AAB-D8          I  1522 ( 5+)         RET     C               ; Line found
0AAC-1E 0E       I  1523 (  6) ULERR:  LD      E,UL            ; ?UL Error
0AAE-C3 EC 04    I  1524 (  9)         JP      ERROR           ; Output error message
0AB1-            I  1525
0AB1-C0          I  1526 ( 5+) RETURN: RET     NZ              ; Return if not just RETURN
0AB2-16 FF       I  1527 (  6)         LD      D,-1            ; Flag "GOSUB" search
0AB4-CD 81 04    I  1528 ( 16)         CALL    BAKSTK          ; Look "GOSUB" block
0AB7-F9          I  1529 (  4)         LD      SP,HL           ; Kill all FORs in subroutine
0AB8-FE 8C       I  1530 (  6)         CP      ZGOSUB          ; Test for "GOSUB" token
0ABA-1E 04       I  1531 (  6)         LD      E,RG            ; ?RG Error
0ABC-C2 EC 04    I  1532 ( 6+)         JP      NZ,ERROR        ; Error if no "GOSUB" found
0ABF-E1          I  1533 (  9)         POP     HL              ; Get RETURN line number
0AC0-22 A1 22    I  1534 ( 20)         LD      (LINEAT),HL     ; Save as current
0AC3-23          I  1535 (  4)         INC     HL              ; Was it from direct statement?
0AC4-7C          I  1536 (  4)         LD      A,H
0AC5-B5          I  1537 (  4)         OR      L               ; Return to line
0AC6-C2 D0 0A    I  1538 ( 6+)         JP      NZ,RETLIN       ; No - Return to line
0AC9-3A 11 23    I  1539 ( 12)         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
0ACC-B7          I  1540 (  4)         OR      A               ; If so buffer is corrupted
0ACD-C2 31 05    I  1541 ( 6+)         JP      NZ,POPNOK       ; Yes - Go to command mode
0AD0-21 FF 08    I  1542 (  9) RETLIN: LD      HL,RUNCNT       ; Execution driver loop
0AD3-E3          I  1543 ( 16)         EX      (SP),HL         ; Into stack - Code string out
0AD4-3E          I  1544               .DB      3EH             ; Skip "POP HL"
0AD5-E1          I  1545 (  9) NXTDTA: POP     HL              ; Restore code string address
0AD6-            I  1546
0AD6-01 3A       I  1547       DATA:   .DB      01H,3AH         ; ':' End of statement
0AD8-0E 00       I  1548 (  6) REM:    LD      C,0             ; 00  End of statement
0ADA-06 00       I  1549 (  6)         LD      B,0
0ADC-79          I  1550 (  4) NXTSTL: LD      A,C             ; Statement and byte
0ADD-48          I  1551 (  4)         LD      C,B
0ADE-47          I  1552 (  4)         LD      B,A             ; Statement end byte
0ADF-7E          I  1553 (  6) NXTSTT: LD      A,(HL)          ; Get byte
0AE0-B7          I  1554 (  4)         OR      A               ; End of line?
0AE1-C8          I  1555 ( 5+)         RET     Z               ; Yes - Exit
0AE2-B8          I  1556 (  4)         CP      B               ; End of statement?
0AE3-C8          I  1557 ( 5+)         RET     Z               ; Yes - Exit
0AE4-23          I  1558 (  4)         INC     HL              ; Next byte
0AE5-FE 22       I  1559 (  6)         CP      '"'             ; Literal string?
0AE7-CA DC 0A    I  1560 ( 6+)         JP      Z,NXTSTL        ; Yes - Look for another '"'
0AEA-C3 DF 0A    I  1561 (  9)         JP      NXTSTT          ; Keep looking
0AED-            I  1562
0AED-CD A2 0F    I  1563 ( 16) LET:    CALL    GETVAR          ; Get variable name
0AF0-CD B5 07    I  1564 ( 16)         CALL    CHKSYN          ; Make sure "=" follows
0AF3-B4          I  1565               .DB      ZEQUAL          ; "=" token
0AF4-D5          I  1566 ( 11)         PUSH    DE              ; Save address of variable
0AF5-3A F2 22    I  1567 ( 12)         LD      A,(TYPE)        ; Get data type
0AF8-F5          I  1568 ( 11)         PUSH    AF              ; Save type
0AF9-CD BE 0D    I  1569 ( 16)         CALL    EVAL            ; Evaluate expression
0AFC-F1          I  1570 (  9)         POP     AF              ; Restore type
0AFD-E3          I  1571 ( 16)         EX      (SP),HL         ; Save code - Get var addr
0AFE-22 13 23    I  1572 ( 20)         LD      (BRKLIN),HL     ; Save address of variable
0B01-1F          I  1573 (  3)         RRA                     ; Adjust type
0B02-CD B1 0D    I  1574 ( 16)         CALL    CHKTYP          ; Check types are the same
0B05-CA 40 0B    I  1575 ( 6+)         JP      Z,LETNUM        ; Numeric - Move value
0B08-E5          I  1576 ( 11) LETSTR: PUSH    HL              ; Save address of string var
0B09-2A 29 23    I  1577 ( 15)         LD      HL,(FPREG)      ; Pointer to string entry
0B0C-E5          I  1578 ( 11)         PUSH    HL              ; Save it on stack
0B0D-23          I  1579 (  4)         INC     HL              ; Skip over length
0B0E-23          I  1580 (  4)         INC     HL
0B0F-5E          I  1581 (  6)         LD      E,(HL)          ; LSB of string address
0B10-23          I  1582 (  4)         INC     HL
0B11-56          I  1583 (  6)         LD      D,(HL)          ; MSB of string address
0B12-2A A3 22    I  1584 ( 15)         LD      HL,(BASTXT)     ; Point to start of program
0B15-CD AF 07    I  1585 ( 16)         CALL    CPDEHL          ; Is string before program?
0B18-D2 2F 0B    I  1586 ( 6+)         JP      NC,CRESTR       ; Yes - Create string entry
0B1B-2A 9F 22    I  1587 ( 15)         LD      HL,(STRSPC)     ; Point to string space
0B1E-CD AF 07    I  1588 ( 16)         CALL    CPDEHL          ; Is string literal in program?
0B21-D1          I  1589 (  9)         POP     DE              ; Restore address of string
0B22-D2 37 0B    I  1590 ( 6+)         JP      NC,MVSTPT       ; Yes - Set up pointer
0B25-21 04 23    I  1591 (  9)         LD      HL,TMPSTR       ; Temporary string pool
0B28-CD AF 07    I  1592 ( 16)         CALL    CPDEHL          ; Is string in temporary pool?
0B2B-D2 37 0B    I  1593 ( 6+)         JP      NC,MVSTPT       ; No - Set up pointer
0B2E-3E          I  1594               .DB   3EH             ; Skip "POP DE"
0B2F-D1          I  1595 (  9) CRESTR: POP     DE              ; Restore address of string
0B30-CD E6 13    I  1596 ( 16)         CALL    BAKTMP          ; Back to last tmp-str entry
0B33-EB          I  1597 (  3)         EX      DE,HL           ; Address of string entry
0B34-CD 1F 12    I  1598 ( 16)         CALL    SAVSTR          ; Save string in string area
0B37-CD E6 13    I  1599 ( 16) MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
0B3A-E1          I  1600 (  9)         POP     HL              ; Get string pointer
0B3B-CD E9 17    I  1601 ( 16)         CALL    DETHL4          ; Move string pointer to var
0B3E-E1          I  1602 (  9)         POP     HL              ; Restore code string address
0B3F-C9          I  1603 (  9)         RET
0B40-            I  1604
0B40-E5          I  1605 ( 11) LETNUM: PUSH    HL              ; Save address of variable
0B41-CD E6 17    I  1606 ( 16)         CALL    FPTHL           ; Move value to variable
0B44-D1          I  1607 (  9)         POP     DE              ; Restore address of variable
0B45-E1          I  1608 (  9)         POP     HL              ; Restore code string address
0B46-C9          I  1609 (  9)         RET
0B47-            I  1610
0B47-CD 0D 15    I  1611 ( 16) ON:     CALL    GETINT          ; Get integer 0-255
0B4A-7E          I  1612 (  6)         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
0B4B-47          I  1613 (  4)         LD      B,A             ; Save in B
0B4C-FE 8C       I  1614 (  6)         CP      ZGOSUB          ; "GOSUB" token?
0B4E-CA 56 0B    I  1615 ( 6+)         JP      Z,ONGO          ; Yes - Find line number
0B51-CD B5 07    I  1616 ( 16)         CALL    CHKSYN          ; Make sure it's "GOTO"
0B54-88          I  1617               .DB   ZGOTO           ; "GOTO" token
0B55-2B          I  1618 (  4)         DEC     HL              ; Cancel increment
0B56-4B          I  1619 (  4) ONGO:   LD      C,E             ; Integer of branch value
0B57-0D          I  1620 (  4) ONGOLP: DEC     C               ; Count branches
0B58-78          I  1621 (  4)         LD      A,B             ; Get "GOTO" or "GOSUB" token
0B59-CA 27 09    I  1622 ( 6+)         JP      Z,ONJMP         ; Go to that line if right one
0B5C-CD 0C 0A    I  1623 ( 16)         CALL    GETLN           ; Get line number to DE
0B5F-FE 2C       I  1624 (  6)         CP      ','             ; Another line number?
0B61-C0          I  1625 ( 5+)         RET     NZ              ; No - Drop through
0B62-C3 57 0B    I  1626 (  9)         JP      ONGOLP          ; Yes - loop
0B65-            I  1627
0B65-CD BE 0D    I  1628 ( 16) IF:     CALL    EVAL            ; Evaluate expression
0B68-7E          I  1629 (  6)         LD      A,(HL)          ; Get token
0B69-FE 88       I  1630 (  6)         CP      ZGOTO           ; "GOTO" token?
0B6B-CA 73 0B    I  1631 ( 6+)         JP      Z,IFGO          ; Yes - Get line
0B6E-CD B5 07    I  1632 ( 16)         CALL    CHKSYN          ; Make sure it's "THEN"
0B71-A9          I  1633               .DB      ZTHEN           ; "THEN" token
0B72-2B          I  1634 (  4)         DEC     HL              ; Cancel increment
0B73-CD AF 0D    I  1635 ( 16) IFGO:   CALL    TSTNUM          ; Make sure it's numeric
0B76-CD 8E 17    I  1636 ( 16)         CALL    TSTSGN          ; Test state of expression
0B79-CA D8 0A    I  1637 ( 6+)         JP      Z,REM           ; False - Drop through
0B7C-CD 3F 09    I  1638 ( 16)         CALL    GETCHR          ; Get next character
0B7F-DA 93 0A    I  1639 ( 6+)         JP      C,GOTO          ; Number - GOTO that line
0B82-C3 26 09    I  1640 (  9)         JP      IFJMP           ; Otherwise do statement
0B85-            I  1641
0B85-2B          I  1642 (  4) MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
0B86-CD 3F 09    I  1643 ( 16)         CALL    GETCHR          ; Get next character
0B89-CA E7 0B    I  1644 ( 6+) PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
0B8C-C8          I  1645 ( 5+) PRNTLP: RET     Z               ; End of list - Exit
0B8D-FE A5       I  1646 (  6)         CP      ZTAB            ; "TAB(" token?
0B8F-CA 1A 0C    I  1647 ( 6+)         JP      Z,DOTAB         ; Yes - Do TAB routine
0B92-FE A8       I  1648 (  6)         CP      ZSPC            ; "SPC(" token?
0B94-CA 1A 0C    I  1649 ( 6+)         JP      Z,DOTAB         ; Yes - Do SPC routine
0B97-E5          I  1650 ( 11)         PUSH    HL              ; Save code string address
0B98-FE 2C       I  1651 (  6)         CP      ','             ; Comma?
0B9A-CA 03 0C    I  1652 ( 6+)         JP      Z,DOCOM         ; Yes - Move to next zone
0B9D-FE 3B       I  1653 (  6)         CP      59 ;";"         ; Semi-colon?
0B9F-CA 3D 0C    I  1654 ( 6+)         JP      Z,NEXITM        ; Do semi-colon routine
0BA2-C1          I  1655 (  9)         POP     BC              ; Code string address to BC
0BA3-CD BE 0D    I  1656 ( 16)         CALL    EVAL            ; Evaluate expression
0BA6-E5          I  1657 ( 11)         PUSH    HL              ; Save code string address
0BA7-3A F2 22    I  1658 ( 12)         LD      A,(TYPE)        ; Get variable type
0BAA-B7          I  1659 (  4)         OR      A               ; Is it a string variable?
0BAB-C2 D3 0B    I  1660 ( 6+)         JP      NZ,PRNTST       ; Yes - Output string contents
0BAE-CD 33 19    I  1661 ( 16)         CALL    NUMASC          ; Convert number to text
0BB1-CD 43 12    I  1662 ( 16)         CALL    CRTST           ; Create temporary string
0BB4-36 20       I  1663 (  9)         LD      (HL),' '        ; Followed by a space
0BB6-2A 29 23    I  1664 ( 15)         LD      HL,(FPREG)      ; Get length of output
0BB9-34          I  1665 ( 10)         INC     (HL)            ; Plus 1 for the space
0BBA-2A 29 23    I  1666 ( 15)         LD      HL,(FPREG)      ; < Not needed >
0BBD-3A 87 22    I  1667 ( 12)         LD      A,(LWIDTH)      ; Get width of line
0BC0-47          I  1668 (  4)         LD      B,A             ; To B
0BC1-04          I  1669 (  4)         INC     B               ; Width 255 (No limit)?
0BC2-CA CF 0B    I  1670 ( 6+)         JP      Z,PRNTNB        ; Yes - Output number string
0BC5-04          I  1671 (  4)         INC     B               ; Adjust it
0BC6-3A F0 22    I  1672 ( 12)         LD      A,(CURPOS)      ; Get cursor position
0BC9-86          I  1673 (  6)         ADD     A,(HL)          ; Add length of string
0BCA-3D          I  1674 (  4)         DEC     A               ; Adjust it
0BCB-B8          I  1675 (  4)         CP      B               ; Will output fit on this line?
0BCC-D4 E7 0B    I  1676 ( 6+)         CALL    NC,PRNTCRLF     ; No - CRLF first
0BCF-CD 88 12    I  1677 ( 16) PRNTNB: CALL    PRS1            ; Output string at (HL)
0BD2-AF          I  1678 (  4)         XOR     A               ; Skip CALL by setting 'z' flag
0BD3-C4 88 12    I  1679 ( 6+) PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
0BD6-E1          I  1680 (  9)         POP     HL              ; Restore code string address
0BD7-C3 85 0B    I  1681 (  9)         JP      MRPRNT          ; See if more to PRINT
0BDA-            I  1682
0BDA-3A F0 22    I  1683 ( 12) STTLIN: LD      A,(CURPOS)      ; Make sure on new line
0BDD-B7          I  1684 (  4)         OR      A               ; Already at start?
0BDE-C8          I  1685 ( 5+)         RET     Z               ; Yes - Do nothing
0BDF-C3 E7 0B    I  1686 (  9)         JP      PRNTCRLF        ; Start a new line
0BE2-            I  1687
0BE2-36 00       I  1688 (  9) ENDINP: LD      (HL),0          ; Mark end of buffer
0BE4-21 A5 22    I  1689 (  9)         LD      HL,BUFFER-1     ; Point to buffer
0BE7-3E 0D       I  1690 (  6) PRNTCRLF: LD    A,CR            ; Load a CR
0BE9-CD C0 07    I  1691 ( 16)         CALL    OUTC            ; Output character
0BEC-3E 0A       I  1692 (  6)         LD      A,LF            ; Load a LF
0BEE-CD C0 07    I  1693 ( 16)         CALL    OUTC            ; Output character
0BF1-AF          I  1694 (  4) DONULL: XOR     A               ; Set to position 0
0BF2-32 F0 22    I  1695 ( 13)         LD      (CURPOS),A      ; Store it
0BF5-3A 86 22    I  1696 ( 12)         LD      A,(NULLS)       ; Get number of nulls
0BF8-3D          I  1697 (  4) NULLP:  DEC     A               ; Count them
0BF9-C8          I  1698 ( 5+)         RET     Z               ; Return if done
0BFA-F5          I  1699 ( 11)         PUSH    AF              ; Save count
0BFB-AF          I  1700 (  4)         XOR     A               ; Load a null
0BFC-CD C0 07    I  1701 ( 16)         CALL    OUTC            ; Output it
0BFF-F1          I  1702 (  9)         POP     AF              ; Restore count
0C00-C3 F8 0B    I  1703 (  9)         JP      NULLP           ; Keep counting
0C03-            I  1704
0C03-3A 88 22    I  1705 ( 12) DOCOM:  LD      A,(COMMAN)      ; Get comma width
0C06-47          I  1706 (  4)         LD      B,A             ; Save in B
0C07-3A F0 22    I  1707 ( 12)         LD      A,(CURPOS)      ; Get current position
0C0A-B8          I  1708 (  4)         CP      B               ; Within the limit?
0C0B-D4 E7 0B    I  1709 ( 6+)         CALL    NC,PRNTCRLF     ; No - output CRLF
0C0E-D2 3D 0C    I  1710 ( 6+)         JP      NC,NEXITM       ; Get next item
0C11-D6 0E       I  1711 (  6) ZONELP: SUB     14              ; Next zone of 14 characters
0C13-D2 11 0C    I  1712 ( 6+)         JP      NC,ZONELP       ; Repeat if more zones
0C16-2F          I  1713 (  3)         CPL                     ; Number of spaces to output
0C17-C3 32 0C    I  1714 (  9)         JP      ASPCS           ; Output them
0C1A-            I  1715
0C1A-F5          I  1716 ( 11) DOTAB:  PUSH    AF              ; Save token
0C1B-CD 0A 15    I  1717 ( 16)         CALL    FNDNUM          ; Evaluate expression
0C1E-CD B5 07    I  1718 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
0C21-29          I  1719               .DB   ")"
0C22-2B          I  1720 (  4)         DEC     HL              ; Back space on to ")"
0C23-F1          I  1721 (  9)         POP     AF              ; Restore token
0C24-D6 A8       I  1722 (  6)         SUB     ZSPC            ; Was it "SPC(" ?
0C26-E5          I  1723 ( 11)         PUSH    HL              ; Save code string address
0C27-CA 2D 0C    I  1724 ( 6+)         JP      Z,DOSPC         ; Yes - Do 'E' spaces
0C2A-3A F0 22    I  1725 ( 12)         LD      A,(CURPOS)      ; Get current position
0C2D-2F          I  1726 (  3) DOSPC:  CPL                     ; Number of spaces to print to
0C2E-83          I  1727 (  4)         ADD     A,E             ; Total number to print
0C2F-D2 3D 0C    I  1728 ( 6+)         JP      NC,NEXITM       ; TAB < Current POS(X)
0C32-3C          I  1729 (  4) ASPCS:  INC     A               ; Output A spaces
0C33-47          I  1730 (  4)         LD      B,A             ; Save number to print
0C34-3E 20       I  1731 (  6)         LD      A,' '           ; Space
0C36-CD C0 07    I  1732 ( 16) SPCLP:  CALL    OUTC            ; Output character in A
0C39-05          I  1733 (  4)         DEC     B               ; Count them
0C3A-C2 36 0C    I  1734 ( 6+)         JP      NZ,SPCLP        ; Repeat if more
0C3D-E1          I  1735 (  9) NEXITM: POP     HL              ; Restore code string address
0C3E-CD 3F 09    I  1736 ( 16)         CALL    GETCHR          ; Get next character
0C41-C3 8C 0B    I  1737 (  9)         JP      PRNTLP          ; More to print
0C44-            I  1738
0C44-3F 52 65 64 
     6F 20 66 72 
     6F 6D 20 73 
     74 61 72 74 
     0D 0A 00    I  1739       REDO:   .DB   "?Redo from start",CR,LF,0
0C57-            I  1740
0C57-3A 12 23    I  1741 ( 12) BADINP: LD      A,(READFG)      ; READ or INPUT?
0C5A-B7          I  1742 (  4)         OR      A
0C5B-C2 D2 04    I  1743 ( 6+)         JP      NZ,DATSNR       ; READ - ?SN Error
0C5E-C1          I  1744 (  9)         POP     BC              ; Throw away code string addr
0C5F-21 44 0C    I  1745 (  9)         LD      HL,REDO         ; "Redo from start" message
0C62-CD 85 12    I  1746 ( 16)         CALL    PRS             ; Output string
0C65-C3 32 06    I  1747 (  9)         JP      DOAGN           ; Do last INPUT again
0C68-            I  1748
0C68-CD F0 11    I  1749 ( 16) INPUT:  CALL    IDTEST          ; Test for illegal direct
0C6B-7E          I  1750 (  6)         LD      A,(HL)          ; Get character after "INPUT"
0C6C-FE 22       I  1751 (  6)         CP      '"'             ; Is there a prompt string?
0C6E-3E 00       I  1752 (  6)         LD      A,0             ; Clear A and leave flags
0C70-32 8A 22    I  1753 ( 13)         LD      (CTLOFG),A      ; Enable output
0C73-C2 82 0C    I  1754 ( 6+)         JP      NZ,NOPMPT       ; No prompt - get input
0C76-CD 44 12    I  1755 ( 16)         CALL    QTSTR           ; Get string terminated by '"'
0C79-CD B5 07    I  1756 ( 16)         CALL    CHKSYN          ; Check for ';' after prompt
0C7C-3B          I  1757               .DB   ';'
0C7D-E5          I  1758 ( 11)         PUSH    HL              ; Save code string address
0C7E-CD 88 12    I  1759 ( 16)         CALL    PRS1            ; Output prompt string
0C81-3E          I  1760               .DB   3EH             ; Skip "PUSH HL"
0C82-E5          I  1761 ( 11) NOPMPT: PUSH    HL              ; Save code string address
0C83-CD 36 06    I  1762 ( 16)         CALL    PROMPT          ; Get input with "? " prompt
0C86-C1          I  1763 (  9)         POP     BC              ; Restore code string address
0C87-DA 8E 09    I  1764 ( 6+)         JP      C,INPBRK        ; Break pressed - Exit
0C8A-23          I  1765 (  4)         INC     HL              ; Next byte
0C8B-7E          I  1766 (  6)         LD      A,(HL)          ; Get it
0C8C-B7          I  1767 (  4)         OR      A               ; End of line?
0C8D-2B          I  1768 (  4)         DEC     HL              ; Back again
0C8E-C5          I  1769 ( 11)         PUSH    BC              ; Re-save code string address
0C8F-CA D5 0A    I  1770 ( 6+)         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
0C92-36 2C       I  1771 (  9)         LD      (HL),','        ; Store comma as separator
0C94-C3 9C 0C    I  1772 (  9)         JP      NXTITM          ; Get next item
0C97-            I  1773
0C97-E5          I  1774 ( 11) READ:   PUSH    HL              ; Save code string address
0C98-2A 21 23    I  1775 ( 15)         LD      HL,(NXTDAT)     ; Next DATA statement
0C9B-F6          I  1776               .DB   0F6H            ; Flag "READ"
0C9C-AF          I  1777 (  4) NXTITM: XOR     A               ; Flag "INPUT"
0C9D-32 12 23    I  1778 ( 13)         LD      (READFG),A      ; Save "READ"/"INPUT" flag
0CA0-E3          I  1779 ( 16)         EX      (SP),HL         ; Get code str' , Save pointer
0CA1-C3 A8 0C    I  1780 (  9)         JP      GTVLUS          ; Get values
0CA4-            I  1781
0CA4-CD B5 07    I  1782 ( 16) NEDMOR: CALL    CHKSYN          ; Check for comma between items
0CA7-2C          I  1783               .DB      ','
0CA8-CD A2 0F    I  1784 ( 16) GTVLUS: CALL    GETVAR          ; Get variable name
0CAB-E3          I  1785 ( 16)         EX      (SP),HL         ; Save code str" , Get pointer
0CAC-D5          I  1786 ( 11)         PUSH    DE              ; Save variable address
0CAD-7E          I  1787 (  6)         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
0CAE-FE 2C       I  1788 (  6)         CP      ','             ; Comma?
0CB0-CA D0 0C    I  1789 ( 6+)         JP      Z,ANTVLU        ; Yes - Get another value
0CB3-3A 12 23    I  1790 ( 12)         LD      A,(READFG)      ; Is it READ?
0CB6-B7          I  1791 (  4)         OR      A
0CB7-C2 3D 0D    I  1792 ( 6+)         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
0CBA-3E 3F       I  1793 (  6)         LD      A,'?'           ; More INPUT needed
0CBC-CD C0 07    I  1794 ( 16)         CALL    OUTC            ; Output character
0CBF-CD 36 06    I  1795 ( 16)         CALL    PROMPT          ; Get INPUT with prompt
0CC2-D1          I  1796 (  9)         POP     DE              ; Variable address
0CC3-C1          I  1797 (  9)         POP     BC              ; Code string address
0CC4-DA 8E 09    I  1798 ( 6+)         JP      C,INPBRK        ; Break pressed
0CC7-23          I  1799 (  4)         INC     HL              ; Point to next DATA byte
0CC8-7E          I  1800 (  6)         LD      A,(HL)          ; Get byte
0CC9-B7          I  1801 (  4)         OR      A               ; Is it zero (No input) ?
0CCA-2B          I  1802 (  4)         DEC     HL              ; Back space INPUT pointer
0CCB-C5          I  1803 ( 11)         PUSH    BC              ; Save code string address
0CCC-CA D5 0A    I  1804 ( 6+)         JP      Z,NXTDTA        ; Find end of buffer
0CCF-D5          I  1805 ( 11)         PUSH    DE              ; Save variable address
0CD0-3A F2 22    I  1806 ( 12) ANTVLU: LD      A,(TYPE)        ; Check data type
0CD3-B7          I  1807 (  4)         OR      A               ; Is it numeric?
0CD4-CA FA 0C    I  1808 ( 6+)         JP      Z,INPBIN        ; Yes - Convert to binary
0CD7-CD 3F 09    I  1809 ( 16)         CALL    GETCHR          ; Get next character
0CDA-57          I  1810 (  4)         LD      D,A             ; Save input character
0CDB-47          I  1811 (  4)         LD      B,A             ; Again
0CDC-FE 22       I  1812 (  6)         CP      '"'             ; Start of literal sting?"
0CDE-CA EE 0C    I  1813 ( 6+)         JP      Z,STRENT        ; Yes - Create string entry
0CE1-3A 12 23    I  1814 ( 12)         LD      A,(READFG)      ; "READ" or "INPUT" ?
0CE4-B7          I  1815 (  4)         OR      A
0CE5-57          I  1816 (  4)         LD      D,A             ; Save 00 if "INPUT"
0CE6-CA EB 0C    I  1817 ( 6+)         JP      Z,ITMSEP        ; "INPUT" - End with 00
0CE9-16 3A       I  1818 (  6)         LD      D,':'           ; "DATA" - End with 00 or ':'
0CEB-06 2C       I  1819 (  6) ITMSEP: LD      B,','           ; Item separator
0CED-2B          I  1820 (  4)         DEC     HL              ; Back space for DTSTR
0CEE-CD 47 12    I  1821 ( 16) STRENT: CALL    DTSTR           ; Get string terminated by D
0CF1-EB          I  1822 (  3)         EX      DE,HL           ; String address to DE
0CF2-21 05 0D    I  1823 (  9)         LD      HL,LTSTND       ; Where to go after LETSTR
0CF5-E3          I  1824 ( 16)         EX      (SP),HL         ; Save HL , get input pointer
0CF6-D5          I  1825 ( 11)         PUSH    DE              ; Save address of string
0CF7-C3 08 0B    I  1826 (  9)         JP      LETSTR          ; Assign string to variable
0CFA-            I  1827
0CFA-CD 3F 09    I  1828 ( 16) INPBIN: CALL    GETCHR          ; Get next character
0CFD-CD 95 18    I  1829 ( 16)         CALL    ASCTFP          ; Convert ASCII to FP number
0D00-E3          I  1830 ( 16)         EX      (SP),HL         ; Save input ptr, Get var addr
0D01-CD E6 17    I  1831 ( 16)         CALL    FPTHL           ; Move FPREG to variable
0D04-E1          I  1832 (  9)         POP     HL              ; Restore input pointer
0D05-2B          I  1833 (  4) LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
0D06-CD 3F 09    I  1834 ( 16)         CALL    GETCHR          ; Get next character
0D09-CA 11 0D    I  1835 ( 6+)         JP      Z,MORDT         ; End of line - More needed?
0D0C-FE 2C       I  1836 (  6)         CP      ','             ; Another value?
0D0E-C2 57 0C    I  1837 ( 6+)         JP      NZ,BADINP       ; No - Bad input
0D11-E3          I  1838 ( 16) MORDT:  EX      (SP),HL         ; Get code string address
0D12-2B          I  1839 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
0D13-CD 3F 09    I  1840 ( 16)         CALL    GETCHR          ; Get next character
0D16-C2 A4 0C    I  1841 ( 6+)         JP      NZ,NEDMOR       ; More needed - Get it
0D19-D1          I  1842 (  9)         POP     DE              ; Restore DATA pointer
0D1A-3A 12 23    I  1843 ( 12)         LD      A,(READFG)      ; "READ" or "INPUT" ?
0D1D-B7          I  1844 (  4)         OR      A
0D1E-EB          I  1845 (  3)         EX      DE,HL           ; DATA pointer to HL
0D1F-C2 65 09    I  1846 ( 6+)         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
0D22-D5          I  1847 ( 11)         PUSH    DE              ; Save code string address
0D23-B6          I  1848 (  6)         OR      (HL)            ; More input given?
0D24-21 2C 0D    I  1849 (  9)         LD      HL,EXTIG        ; "?Extra ignored" message
0D27-C4 85 12    I  1850 ( 6+)         CALL    NZ,PRS          ; Output string if extra given
0D2A-E1          I  1851 (  9)         POP     HL              ; Restore code string address
0D2B-C9          I  1852 (  9)         RET
0D2C-            I  1853
0D2C-3F 45 78 74 
     72 61 20 69 
     67 6E 6F 72 
     65 64 0D 0A 
     00          I  1854       EXTIG:  .DB   "?Extra ignored",CR,LF,0
0D3D-            I  1855
0D3D-CD D6 0A    I  1856 ( 16) FDTLP:  CALL    DATA            ; Get next statement
0D40-B7          I  1857 (  4)         OR      A               ; End of line?
0D41-C2 56 0D    I  1858 ( 6+)         JP      NZ,FANDT        ; No - See if DATA statement
0D44-23          I  1859 (  4)         INC     HL
0D45-7E          I  1860 (  6)         LD      A,(HL)          ; End of program?
0D46-23          I  1861 (  4)         INC     HL
0D47-B6          I  1862 (  6)         OR      (HL)            ; 00 00 Ends program
0D48-1E 06       I  1863 (  6)         LD      E,OD            ; ?OD Error
0D4A-CA EC 04    I  1864 ( 6+)         JP      Z,ERROR         ; Yes - Out of DATA
0D4D-23          I  1865 (  4)         INC     HL
0D4E-5E          I  1866 (  6)         LD      E,(HL)          ; LSB of line number
0D4F-23          I  1867 (  4)         INC     HL
0D50-56          I  1868 (  6)         LD      D,(HL)          ; MSB of line number
0D51-EB          I  1869 (  3)         EX      DE,HL
0D52-22 0E 23    I  1870 ( 20)         LD      (DATLIN),HL     ; Set line of current DATA item
0D55-EB          I  1871 (  3)         EX      DE,HL
0D56-CD 3F 09    I  1872 ( 16) FANDT:  CALL    GETCHR          ; Get next character
0D59-FE 83       I  1873 (  6)         CP      ZDATA           ; "DATA" token
0D5B-C2 3D 0D    I  1874 ( 6+)         JP      NZ,FDTLP        ; No "DATA" - Keep looking
0D5E-C3 D0 0C    I  1875 (  9)         JP      ANTVLU          ; Found - Convert input
0D61-            I  1876
0D61-11 00 00    I  1877 (  9) NEXT:   LD      DE,0            ; In case no index given
0D64-C4 A2 0F    I  1878 ( 6+) NEXT1:  CALL    NZ,GETVAR       ; Get index address
0D67-22 13 23    I  1879 ( 20)         LD      (BRKLIN),HL     ; Save code string address
0D6A-CD 81 04    I  1880 ( 16)         CALL    BAKSTK          ; Look for "FOR" block
0D6D-C2 DE 04    I  1881 ( 6+)         JP      NZ,NFERR        ; No "FOR" - ?NF Error
0D70-F9          I  1882 (  4)         LD      SP,HL           ; Clear nested loops
0D71-D5          I  1883 ( 11)         PUSH    DE              ; Save index address
0D72-7E          I  1884 (  6)         LD      A,(HL)          ; Get sign of STEP
0D73-23          I  1885 (  4)         INC     HL
0D74-F5          I  1886 ( 11)         PUSH    AF              ; Save sign of STEP
0D75-D5          I  1887 ( 11)         PUSH    DE              ; Save index address
0D76-CD CC 17    I  1888 ( 16)         CALL    PHLTFP          ; Move index value to FPREG
0D79-E3          I  1889 ( 16)         EX      (SP),HL         ; Save address of TO value
0D7A-E5          I  1890 ( 11)         PUSH    HL              ; Save address of index
0D7B-CD 39 15    I  1891 ( 16)         CALL    ADDPHL          ; Add STEP to index value
0D7E-E1          I  1892 (  9)         POP     HL              ; Restore address of index
0D7F-CD E6 17    I  1893 ( 16)         CALL    FPTHL           ; Move value to index variable
0D82-E1          I  1894 (  9)         POP     HL              ; Restore address of TO value
0D83-CD DD 17    I  1895 ( 16)         CALL    LOADFP          ; Move TO value to BCDE
0D86-E5          I  1896 ( 11)         PUSH    HL              ; Save address of line of FOR
0D87-CD 09 18    I  1897 ( 16)         CALL    CMPNUM          ; Compare index with TO value
0D8A-E1          I  1898 (  9)         POP     HL              ; Restore address of line num
0D8B-C1          I  1899 (  9)         POP     BC              ; Address of sign of STEP
0D8C-90          I  1900 (  4)         SUB     B               ; Compare with expected sign
0D8D-CD DD 17    I  1901 ( 16)         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
0D90-CA 9C 0D    I  1902 ( 6+)         JP      Z,KILFOR        ; Loop finished - Terminate it
0D93-EB          I  1903 (  3)         EX      DE,HL           ; Loop statement line number
0D94-22 A1 22    I  1904 ( 20)         LD      (LINEAT),HL     ; Set loop line number
0D97-69          I  1905 (  4)         LD      L,C             ; Set code string to loop
0D98-60          I  1906 (  4)         LD      H,B
0D99-C3 FB 08    I  1907 (  9)         JP      PUTFID          ; Put back "FOR" and continue
0D9C-            I  1908
0D9C-F9          I  1909 (  4) KILFOR: LD      SP,HL           ; Remove "FOR" block
0D9D-2A 13 23    I  1910 ( 15)         LD      HL,(BRKLIN)     ; Code string after "NEXT"
0DA0-7E          I  1911 (  6)         LD      A,(HL)          ; Get next byte in code string
0DA1-FE 2C       I  1912 (  6)         CP      ','             ; More NEXTs ?
0DA3-C2 FF 08    I  1913 ( 6+)         JP      NZ,RUNCNT       ; No - Do next statement
0DA6-CD 3F 09    I  1914 ( 16)         CALL    GETCHR          ; Position to index name
0DA9-CD 64 0D    I  1915 ( 16)         CALL    NEXT1           ; Re-enter NEXT routine
0DAC-            I  1916       ; < will not RETurn to here , Exit to RUNCNT or Loop >
0DAC-            I  1917
0DAC-CD BE 0D    I  1918 ( 16) GETNUM: CALL    EVAL            ; Get a numeric expression
0DAF-F6          I  1919       TSTNUM: .DB      0F6H            ; Clear carry (numeric)
0DB0-37          I  1920 (  3) TSTSTR: SCF                     ; Set carry (string)
0DB1-3A F2 22    I  1921 ( 12) CHKTYP: LD      A,(TYPE)        ; Check types match
0DB4-8F          I  1922 (  4)         ADC     A,A             ; Expected + actual
0DB5-B7          I  1923 (  4)         OR      A               ; Clear carry , set parity
0DB6-E8          I  1924 ( 5+)         RET     PE              ; Even parity - Types match
0DB7-C3 EA 04    I  1925 (  9)         JP      TMERR           ; Different types - Error
0DBA-            I  1926
0DBA-CD B5 07    I  1927 ( 16) OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
0DBD-28          I  1928               .DB   "("
0DBE-2B          I  1929 (  4) EVAL:   DEC     HL              ; Evaluate expression & save
0DBF-16 00       I  1930 (  6)         LD      D,0             ; Precedence value
0DC1-D5          I  1931 ( 11) EVAL1:  PUSH    DE              ; Save precedence
0DC2-0E 01       I  1932 (  6)         LD      C,1
0DC4-CD B5 04    I  1933 ( 16)         CALL    CHKSTK          ; Check for 1 level of stack
0DC7-CD 35 0E    I  1934 ( 16)         CALL    OPRND           ; Get next expression value
0DCA-22 15 23    I  1935 ( 20) EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
0DCD-2A 15 23    I  1936 ( 15) EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
0DD0-C1          I  1937 (  9)         POP     BC              ; Precedence value and operator
0DD1-78          I  1938 (  4)         LD      A,B             ; Get precedence value
0DD2-FE 78       I  1939 (  6)         CP      78H             ; "AND" or "OR" ?
0DD4-D4 AF 0D    I  1940 ( 6+)         CALL    NC,TSTNUM       ; No - Make sure it's a number
0DD7-7E          I  1941 (  6)         LD      A,(HL)          ; Get next operator / function
0DD8-16 00       I  1942 (  6)         LD      D,0             ; Clear Last relation
0DDA-D6 B3       I  1943 (  6) RLTLP:  SUB     ZGTR            ; ">" Token
0DDC-DA F6 0D    I  1944 ( 6+)         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
0DDF-FE 03       I  1945 (  6)         CP      ZLTH+1-ZGTR     ; < = >
0DE1-D2 F6 0D    I  1946 ( 6+)         JP      NC,FOPRND       ; Function - Call it
0DE4-FE 01       I  1947 (  6)         CP      ZEQUAL-ZGTR     ; "="
0DE6-17          I  1948 (  3)         RLA                     ; <- Test for legal
0DE7-AA          I  1949 (  4)         XOR     D               ; <- combinations of < = >
0DE8-BA          I  1950 (  4)         CP      D               ; <- by combining last token
0DE9-57          I  1951 (  4)         LD      D,A             ; <- with current one
0DEA-DA D8 04    I  1952 ( 6+)         JP      C,SNERR         ; Error if "<<' '==" or ">>"
0DED-22 0A 23    I  1953 ( 20)         LD      (CUROPR),HL     ; Save address of current token
0DF0-CD 3F 09    I  1954 ( 16)         CALL    GETCHR          ; Get next character
0DF3-C3 DA 0D    I  1955 (  9)         JP      RLTLP           ; Treat the two as one
0DF6-            I  1956
0DF6-7A          I  1957 (  4) FOPRND: LD      A,D             ; < = > found ?
0DF7-B7          I  1958 (  4)         OR      A
0DF8-C2 1D 0F    I  1959 ( 6+)         JP      NZ,TSTRED       ; Yes - Test for reduction
0DFB-7E          I  1960 (  6)         LD      A,(HL)          ; Get operator token
0DFC-22 0A 23    I  1961 ( 20)         LD      (CUROPR),HL     ; Save operator address
0DFF-D6 AC       I  1962 (  6)         SUB     ZPLUS           ; Operator or function?
0E01-D8          I  1963 ( 5+)         RET     C               ; Neither - Exit
0E02-FE 07       I  1964 (  6)         CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
0E04-D0          I  1965 ( 5+)         RET     NC              ; No - Exit
0E05-5F          I  1966 (  4)         LD      E,A             ; Coded operator
0E06-3A F2 22    I  1967 ( 12)         LD      A,(TYPE)        ; Get data type
0E09-3D          I  1968 (  4)         DEC     A               ; FF = numeric , 00 = string
0E0A-B3          I  1969 (  4)         OR      E               ; Combine with coded operator
0E0B-7B          I  1970 (  4)         LD      A,E             ; Get coded operator
0E0C-CA 7B 13    I  1971 ( 6+)         JP      Z,CONCAT        ; String concatenation
0E0F-07          I  1972 (  3)         RLCA                    ; Times 2
0E10-83          I  1973 (  4)         ADD     A,E             ; Times 3
0E11-5F          I  1974 (  4)         LD      E,A             ; To DE (D is 0)
0E12-21 C1 03    I  1975 (  9)         LD      HL,PRITAB       ; Precedence table
0E15-19          I  1976 (  7)         ADD     HL,DE           ; To the operator concerned
0E16-78          I  1977 (  4)         LD      A,B             ; Last operator precedence
0E17-56          I  1978 (  6)         LD      D,(HL)          ; Get evaluation precedence
0E18-BA          I  1979 (  4)         CP      D               ; Compare with eval precedence
0E19-D0          I  1980 ( 5+)         RET     NC              ; Exit if higher precedence
0E1A-23          I  1981 (  4)         INC     HL              ; Point to routine address
0E1B-CD AF 0D    I  1982 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0E1E-            I  1983
0E1E-C5          I  1984 ( 11) STKTHS: PUSH    BC              ; Save last precedence & token
0E1F-01 CD 0D    I  1985 (  9)         LD      BC,EVAL3        ; Where to go on prec' break
0E22-C5          I  1986 ( 11)         PUSH    BC              ; Save on stack for return
0E23-43          I  1987 (  4)         LD      B,E             ; Save operator
0E24-4A          I  1988 (  4)         LD      C,D             ; Save precedence
0E25-CD BF 17    I  1989 ( 16)         CALL    STAKFP          ; Move value to stack
0E28-58          I  1990 (  4)         LD      E,B             ; Restore operator
0E29-51          I  1991 (  4)         LD      D,C             ; Restore precedence
0E2A-4E          I  1992 (  6)         LD      C,(HL)          ; Get LSB of routine address
0E2B-23          I  1993 (  4)         INC     HL
0E2C-46          I  1994 (  6)         LD      B,(HL)          ; Get MSB of routine address
0E2D-23          I  1995 (  4)         INC     HL
0E2E-C5          I  1996 ( 11)         PUSH    BC              ; Save routine address
0E2F-2A 0A 23    I  1997 ( 15)         LD      HL,(CUROPR)     ; Address of current operator
0E32-C3 C1 0D    I  1998 (  9)         JP      EVAL1           ; Loop until prec' break
0E35-            I  1999
0E35-AF          I  2000 (  4) OPRND:  XOR     A               ; Get operand routine
0E36-32 F2 22    I  2001 ( 13)         LD      (TYPE),A        ; Set numeric expected
0E39-CD 3F 09    I  2002 ( 16)         CALL    GETCHR          ; Get next character
0E3C-1E 24       I  2003 (  6)         LD      E,MO            ; ?MO Error
0E3E-CA EC 04    I  2004 ( 6+)         JP      Z,ERROR         ; No operand - Error
0E41-DA 95 18    I  2005 ( 6+)         JP      C,ASCTFP        ; Number - Get value
0E44-CD DD 09    I  2006 ( 16)         CALL    CHKLTR          ; See if a letter
0E47-D2 9C 0E    I  2007 ( 6+)         JP      NC,CONVAR       ; Letter - Find variable
0E4A-FE 26       I  2008 (  6)         CP      '&'                             ; &H = HEX, &B = BINARY
0E4C-20 12       I  2009 ( 6+)         JR      NZ,NOTAMP
0E4E-CD 3F 09    I  2010 ( 16)         CALL    GETCHR          ; Get next character
0E51-FE 48       I  2011 (  6)         CP      'H'             ; Hex number indicated? [function added]
0E53-CA D9 1C    I  2012 ( 6+)         JP      Z,HEXTFP        ; Convert Hex to FPREG
0E56-FE 42       I  2013 (  6)         CP      'B'             ; Binary number indicated? [function added]
0E58-CA 49 1D    I  2014 ( 6+)         JP      Z,BINTFP        ; Convert Bin to FPREG
0E5B-1E 02       I  2015 (  6)         LD      E,SN            ; If neither then a ?SN Error
0E5D-CA EC 04    I  2016 ( 6+)         JP      Z,ERROR         ;
0E60-FE AC       I  2017 (  6) NOTAMP: CP      ZPLUS           ; '+' Token ?
0E62-CA 35 0E    I  2018 ( 6+)         JP      Z,OPRND         ; Yes - Look for operand
0E65-FE 2E       I  2019 (  6)         CP      '.'             ; '.' ?
0E67-CA 95 18    I  2020 ( 6+)         JP      Z,ASCTFP        ; Yes - Create FP number
0E6A-FE AD       I  2021 (  6)         CP      ZMINUS          ; '-' Token ?
0E6C-CA 8B 0E    I  2022 ( 6+)         JP      Z,MINUS         ; Yes - Do minus
0E6F-FE 22       I  2023 (  6)         CP      '"'             ; Literal string ?
0E71-CA 44 12    I  2024 ( 6+)         JP      Z,QTSTR         ; Get string terminated by '"'
0E74-FE AA       I  2025 (  6)         CP      ZNOT            ; "NOT" Token ?
0E76-CA 7D 0F    I  2026 ( 6+)         JP      Z,EVNOT         ; Yes - Eval NOT expression
0E79-FE A7       I  2027 (  6)         CP      ZFN             ; "FN" Token ?
0E7B-CA A8 11    I  2028 ( 6+)         JP      Z,DOFN          ; Yes - Do FN routine
0E7E-D6 B6       I  2029 (  6)         SUB     ZSGN            ; Is it a function?
0E80-D2 AD 0E    I  2030 ( 6+)         JP      NC,FNOFST       ; Yes - Evaluate function
0E83-CD BA 0D    I  2031 ( 16) EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
0E86-CD B5 07    I  2032 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
0E89-29          I  2033               .DB   ")"
0E8A-C9          I  2034 (  9)         RET
0E8B-            I  2035
0E8B-16 7D       I  2036 (  6) MINUS:  LD      D,7DH           ; '-' precedence
0E8D-CD C1 0D    I  2037 ( 16)         CALL    EVAL1           ; Evaluate until prec' break
0E90-2A 15 23    I  2038 ( 15)         LD      HL,(NXTOPR)     ; Get next operator address
0E93-E5          I  2039 ( 11)         PUSH    HL              ; Save next operator address
0E94-CD B7 17    I  2040 ( 16)         CALL    INVSGN          ; Negate value
0E97-CD AF 0D    I  2041 ( 16) RETNUM: CALL    TSTNUM          ; Make sure it's a number
0E9A-E1          I  2042 (  9)         POP     HL              ; Restore next operator address
0E9B-C9          I  2043 (  9)         RET
0E9C-            I  2044
0E9C-CD A2 0F    I  2045 ( 16) CONVAR: CALL    GETVAR          ; Get variable address to DE
0E9F-E5          I  2046 ( 11) FRMEVL: PUSH    HL              ; Save code string address
0EA0-EB          I  2047 (  3)         EX      DE,HL           ; Variable address to HL
0EA1-22 29 23    I  2048 ( 20)         LD      (FPREG),HL      ; Save address of variable
0EA4-3A F2 22    I  2049 ( 12)         LD      A,(TYPE)        ; Get type
0EA7-B7          I  2050 (  4)         OR      A               ; Numeric?
0EA8-CC CC 17    I  2051 ( 6+)         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
0EAB-E1          I  2052 (  9)         POP     HL              ; Restore code string address
0EAC-C9          I  2053 (  9)         RET
0EAD-            I  2054
0EAD-06 00       I  2055 (  6) FNOFST: LD      B,0             ; Get address of function
0EAF-07          I  2056 (  3)         RLCA                    ; Double function offset
0EB0-4F          I  2057 (  4)         LD      C,A             ; BC = Offset in function table
0EB1-C5          I  2058 ( 11)         PUSH    BC              ; Save adjusted token value
0EB2-CD 3F 09    I  2059 ( 16)         CALL    GETCHR          ; Get next character
0EB5-79          I  2060 (  4)         LD      A,C             ; Get adjusted token value
0EB6-FE 31       I  2061 (  6)         CP      031H ; 2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT$ or MID$ ?
0EB8-DA D4 0E    I  2062 ( 6+)         JP      C,FNVAL         ; No - Do function
0EBB-CD BA 0D    I  2063 ( 16)         CALL    OPNPAR          ; Evaluate expression  (X,...
0EBE-CD B5 07    I  2064 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
0EC1-2C          I  2065               .DB      ','
0EC2-CD B0 0D    I  2066 ( 16)         CALL    TSTSTR          ; Make sure it's a string
0EC5-EB          I  2067 (  3)         EX      DE,HL           ; Save code string address
0EC6-2A 29 23    I  2068 ( 15)         LD      HL,(FPREG)      ; Get address of string
0EC9-E3          I  2069 ( 16)         EX      (SP),HL         ; Save address of string
0ECA-E5          I  2070 ( 11)         PUSH    HL              ; Save adjusted token value
0ECB-EB          I  2071 (  3)         EX      DE,HL           ; Restore code string address
0ECC-CD 0D 15    I  2072 ( 16)         CALL    GETINT          ; Get integer 0-255
0ECF-EB          I  2073 (  3)         EX      DE,HL           ; Save code string address
0ED0-E3          I  2074 ( 16)         EX      (SP),HL         ; Save integer,HL = adj' token
0ED1-C3 DC 0E    I  2075 (  9)         JP      GOFUNC          ; Jump to string function
0ED4-            I  2076
0ED4-CD 83 0E    I  2077 ( 16) FNVAL:  CALL    EVLPAR          ; Evaluate expression
0ED7-E3          I  2078 ( 16)         EX      (SP),HL         ; HL = Adjusted token value
0ED8-11 97 0E    I  2079 (  9)         LD      DE,RETNUM       ; Return number from function
0EDB-D5          I  2080 ( 11)         PUSH    DE              ; Save on stack
0EDC-01 20 02    I  2081 (  9) GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
0EDF-09          I  2082 (  7)         ADD     HL,BC           ; Point to right address
0EE0-4E          I  2083 (  6)         LD      C,(HL)          ; Get LSB of address
0EE1-23          I  2084 (  4)         INC     HL              ;
0EE2-66          I  2085 (  6)         LD      H,(HL)          ; Get MSB of address
0EE3-69          I  2086 (  4)         LD      L,C             ; Address to HL
0EE4-E9          I  2087 (  3)         JP      (HL)            ; Jump to function
0EE5-            I  2088
0EE5-15          I  2089 (  4) SGNEXP: DEC     D               ; Dee to flag negative exponent
0EE6-FE AD       I  2090 (  6)         CP      ZMINUS          ; '-' token ?
0EE8-C8          I  2091 ( 5+)         RET     Z               ; Yes - Return
0EE9-FE 2D       I  2092 (  6)         CP      '-'             ; '-' ASCII ?
0EEB-C8          I  2093 ( 5+)         RET     Z               ; Yes - Return
0EEC-14          I  2094 (  4)         INC     D               ; Inc to flag positive exponent
0EED-FE 2B       I  2095 (  6)         CP      '+'             ; '+' ASCII ?
0EEF-C8          I  2096 ( 5+)         RET     Z               ; Yes - Return
0EF0-FE AC       I  2097 (  6)         CP      ZPLUS           ; '+' token ?
0EF2-C8          I  2098 ( 5+)         RET     Z               ; Yes - Return
0EF3-2B          I  2099 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
0EF4-C9          I  2100 (  9)         RET                     ; Return "NZ"
0EF5-            I  2101
0EF5-F6          I  2102       POR:    .DB      0F6H            ; Flag "OR"
0EF6-AF          I  2103 (  4) PAND:   XOR     A               ; Flag "AND"
0EF7-F5          I  2104 ( 11)         PUSH    AF              ; Save "AND" / "OR" flag
0EF8-CD AF 0D    I  2105 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0EFB-CD F1 09    I  2106 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
0EFE-F1          I  2107 (  9)         POP     AF              ; Restore "AND" / "OR" flag
0EFF-EB          I  2108 (  3)         EX      DE,HL           ; <- Get last
0F00-C1          I  2109 (  9)         POP     BC              ; <-  value
0F01-E3          I  2110 ( 16)         EX      (SP),HL         ; <-  from
0F02-EB          I  2111 (  3)         EX      DE,HL           ; <-  stack
0F03-CD CF 17    I  2112 ( 16)         CALL    FPBCDE          ; Move last value to FPREG
0F06-F5          I  2113 ( 11)         PUSH    AF              ; Save "AND" / "OR" flag
0F07-CD F1 09    I  2114 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
0F0A-F1          I  2115 (  9)         POP     AF              ; Restore "AND" / "OR" flag
0F0B-C1          I  2116 (  9)         POP     BC              ; Get value
0F0C-79          I  2117 (  4)         LD      A,C             ; Get LSB
0F0D-21 66 11    I  2118 (  9)         LD      HL,ACPASS       ; Address of save AC as current
0F10-C2 18 0F    I  2119 ( 6+)         JP      NZ,POR1         ; Jump if OR
0F13-A3          I  2120 (  4)         AND     E               ; "AND" LSBs
0F14-4F          I  2121 (  4)         LD      C,A             ; Save LSB
0F15-78          I  2122 (  4)         LD      A,B             ; Get MBS
0F16-A2          I  2123 (  4)         AND     D               ; "AND" MSBs
0F17-E9          I  2124 (  3)         JP      (HL)            ; Save AC as current (ACPASS)
0F18-            I  2125
0F18-B3          I  2126 (  4) POR1:   OR      E               ; "OR" LSBs
0F19-4F          I  2127 (  4)         LD      C,A             ; Save LSB
0F1A-78          I  2128 (  4)         LD      A,B             ; Get MSB
0F1B-B2          I  2129 (  4)         OR      D               ; "OR" MSBs
0F1C-E9          I  2130 (  3)         JP      (HL)            ; Save AC as current (ACPASS)
0F1D-            I  2131
0F1D-21 2F 0F    I  2132 (  9) TSTRED: LD      HL,CMPLOG       ; Logical compare routine
0F20-3A F2 22    I  2133 ( 12)         LD      A,(TYPE)        ; Get data type
0F23-1F          I  2134 (  3)         RRA                     ; Carry set = string
0F24-7A          I  2135 (  4)         LD      A,D             ; Get last precedence value
0F25-17          I  2136 (  3)         RLA                     ; Times 2 plus carry
0F26-5F          I  2137 (  4)         LD      E,A             ; To E
0F27-16 64       I  2138 (  6)         LD      D,64H           ; Relational precedence
0F29-78          I  2139 (  4)         LD      A,B             ; Get current precedence
0F2A-BA          I  2140 (  4)         CP      D               ; Compare with last
0F2B-D0          I  2141 ( 5+)         RET     NC              ; Eval if last was rel' or log'
0F2C-C3 1E 0E    I  2142 (  9)         JP      STKTHS          ; Stack this one and get next
0F2F-            I  2143
0F2F-31 0F       I  2144       CMPLOG: .DW   CMPLG1          ; Compare two values / strings
0F31-79          I  2145 (  4) CMPLG1: LD      A,C             ; Get data type
0F32-B7          I  2146 (  4)         OR      A
0F33-1F          I  2147 (  3)         RRA
0F34-C1          I  2148 (  9)         POP     BC              ; Get last expression to BCDE
0F35-D1          I  2149 (  9)         POP     DE
0F36-F5          I  2150 ( 11)         PUSH    AF              ; Save status
0F37-CD B1 0D    I  2151 ( 16)         CALL    CHKTYP          ; Check that types match
0F3A-21 73 0F    I  2152 (  9)         LD      HL,CMPRES       ; Result to comparison
0F3D-E5          I  2153 ( 11)         PUSH    HL              ; Save for RETurn
0F3E-CA 09 18    I  2154 ( 6+)         JP      Z,CMPNUM        ; Compare values if numeric
0F41-AF          I  2155 (  4)         XOR     A               ; Compare two strings
0F42-32 F2 22    I  2156 ( 13)         LD      (TYPE),A        ; Set type to numeric
0F45-D5          I  2157 ( 11)         PUSH    DE              ; Save string name
0F46-CD C8 13    I  2158 ( 16)         CALL    GSTRCU          ; Get current string
0F49-7E          I  2159 (  6)         LD      A,(HL)          ; Get length of string
0F4A-23          I  2160 (  4)         INC     HL
0F4B-23          I  2161 (  4)         INC     HL
0F4C-4E          I  2162 (  6)         LD      C,(HL)          ; Get LSB of address
0F4D-23          I  2163 (  4)         INC     HL
0F4E-46          I  2164 (  6)         LD      B,(HL)          ; Get MSB of address
0F4F-D1          I  2165 (  9)         POP     DE              ; Restore string name
0F50-C5          I  2166 ( 11)         PUSH    BC              ; Save address of string
0F51-F5          I  2167 ( 11)         PUSH    AF              ; Save length of string
0F52-CD CC 13    I  2168 ( 16)         CALL    GSTRDE          ; Get second string
0F55-CD DD 17    I  2169 ( 16)         CALL    LOADFP          ; Get address of second string
0F58-F1          I  2170 (  9)         POP     AF              ; Restore length of string 1
0F59-57          I  2171 (  4)         LD      D,A             ; Length to D
0F5A-E1          I  2172 (  9)         POP     HL              ; Restore address of string 1
0F5B-7B          I  2173 (  4) CMPSTR: LD      A,E             ; Bytes of string 2 to do
0F5C-B2          I  2174 (  4)         OR      D               ; Bytes of string 1 to do
0F5D-C8          I  2175 ( 5+)         RET     Z               ; Exit if all bytes compared
0F5E-7A          I  2176 (  4)         LD      A,D             ; Get bytes of string 1 to do
0F5F-D6 01       I  2177 (  6)         SUB     1
0F61-D8          I  2178 ( 5+)         RET     C               ; Exit if end of string 1
0F62-AF          I  2179 (  4)         XOR     A
0F63-BB          I  2180 (  4)         CP      E               ; Bytes of string 2 to do
0F64-3C          I  2181 (  4)         INC     A
0F65-D0          I  2182 ( 5+)         RET     NC              ; Exit if end of string 2
0F66-15          I  2183 (  4)         DEC     D               ; Count bytes in string 1
0F67-1D          I  2184 (  4)         DEC     E               ; Count bytes in string 2
0F68-0A          I  2185 (  6)         LD      A,(BC)          ; Byte in string 2
0F69-BE          I  2186 (  6)         CP      (HL)            ; Compare to byte in string 1
0F6A-23          I  2187 (  4)         INC     HL              ; Move up string 1
0F6B-03          I  2188 (  4)         INC     BC              ; Move up string 2
0F6C-CA 5B 0F    I  2189 ( 6+)         JP      Z,CMPSTR        ; Same - Try next bytes
0F6F-3F          I  2190 (  3)         CCF                     ; Flag difference (">" or "<")
0F70-C3 99 17    I  2191 (  9)         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
0F73-            I  2192
0F73-3C          I  2193 (  4) CMPRES: INC     A               ; Increment current value
0F74-8F          I  2194 (  4)         ADC     A,A             ; Double plus carry
0F75-C1          I  2195 (  9)         POP     BC              ; Get other value
0F76-A0          I  2196 (  4)         AND     B               ; Combine them
0F77-C6 FF       I  2197 (  6)         ADD     A,-1            ; Carry set if different
0F79-9F          I  2198 (  4)         SBC     A,A             ; 00 - Equal , FF - Different
0F7A-C3 A0 17    I  2199 (  9)         JP      FLGREL          ; Set current value & continue
0F7D-            I  2200
0F7D-16 5A       I  2201 (  6) EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
0F7F-CD C1 0D    I  2202 ( 16)         CALL    EVAL1           ; Eval until precedence break
0F82-CD AF 0D    I  2203 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0F85-CD F1 09    I  2204 ( 16)         CALL    DEINT           ; Get integer -32768 - 32767
0F88-7B          I  2205 (  4)         LD      A,E             ; Get LSB
0F89-2F          I  2206 (  3)         CPL                     ; Invert LSB
0F8A-4F          I  2207 (  4)         LD      C,A             ; Save "NOT" of LSB
0F8B-7A          I  2208 (  4)         LD      A,D             ; Get MSB
0F8C-2F          I  2209 (  3)         CPL                     ; Invert MSB
0F8D-CD 66 11    I  2210 ( 16)         CALL    ACPASS          ; Save AC as current
0F90-C1          I  2211 (  9)         POP     BC              ; Clean up stack
0F91-C3 CD 0D    I  2212 (  9)         JP      EVAL3           ; Continue evaluation
0F94-            I  2213
0F94-2B          I  2214 (  4) DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
0F95-CD 3F 09    I  2215 ( 16)         CALL    GETCHR          ; Get next character
0F98-C8          I  2216 ( 5+)         RET     Z               ; End of DIM statement
0F99-CD B5 07    I  2217 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
0F9C-2C          I  2218               .DB      ','
0F9D-01 94 0F    I  2219 (  9) DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
0FA0-C5          I  2220 ( 11)         PUSH    BC              ; Save on stack
0FA1-F6          I  2221               .DB      0F6H            ; Flag "Create" variable
0FA2-AF          I  2222 (  4) GETVAR: XOR     A               ; Find variable address,to DE
0FA3-32 F1 22    I  2223 ( 13)         LD      (LCRFLG),A      ; Set locate / create flag
0FA6-46          I  2224 (  6)         LD      B,(HL)          ; Get First byte of name
0FA7-CD DD 09    I  2225 ( 16) GTFNAM: CALL    CHKLTR          ; See if a letter
0FAA-DA D8 04    I  2226 ( 6+)         JP      C,SNERR         ; ?SN Error if not a letter
0FAD-AF          I  2227 (  4)         XOR     A
0FAE-4F          I  2228 (  4)         LD      C,A             ; Clear second byte of name
0FAF-32 F2 22    I  2229 ( 13)         LD      (TYPE),A        ; Set type to numeric
0FB2-CD 3F 09    I  2230 ( 16)         CALL    GETCHR          ; Get next character
0FB5-DA BE 0F    I  2231 ( 6+)         JP      C,SVNAM2        ; Numeric - Save in name
0FB8-CD DD 09    I  2232 ( 16)         CALL    CHKLTR          ; See if a letter
0FBB-DA CB 0F    I  2233 ( 6+)         JP      C,CHARTY        ; Not a letter - Check type
0FBE-4F          I  2234 (  4) SVNAM2: LD      C,A             ; Save second byte of name
0FBF-CD 3F 09    I  2235 ( 16) ENDNAM: CALL    GETCHR          ; Get next character
0FC2-DA BF 0F    I  2236 ( 6+)         JP      C,ENDNAM        ; Numeric - Get another
0FC5-CD DD 09    I  2237 ( 16)         CALL    CHKLTR          ; See if a letter
0FC8-D2 BF 0F    I  2238 ( 6+)         JP      NC,ENDNAM       ; Letter - Get another
0FCB-D6 24       I  2239 (  6) CHARTY: SUB     '$'             ; String variable?
0FCD-C2 DA 0F    I  2240 ( 6+)         JP      NZ,NOTSTR       ; No - Numeric variable
0FD0-3C          I  2241 (  4)         INC     A               ; A = 1 (string type)
0FD1-32 F2 22    I  2242 ( 13)         LD      (TYPE),A        ; Set type to string
0FD4-0F          I  2243 (  3)         RRCA                    ; A = 80H , Flag for string
0FD5-81          I  2244 (  4)         ADD     A,C             ; 2nd byte of name has bit 7 on
0FD6-4F          I  2245 (  4)         LD      C,A             ; Resave second byte on name
0FD7-CD 3F 09    I  2246 ( 16)         CALL    GETCHR          ; Get next character
0FDA-3A 10 23    I  2247 ( 12) NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
0FDD-3D          I  2248 (  4)         DEC     A
0FDE-CA 87 10    I  2249 ( 6+)         JP      Z,ARLDSV        ; Yes - Get array name
0FE1-F2 EA 0F    I  2250 ( 6+)         JP      P,NSCFOR        ; No array with "FOR" or "FN"
0FE4-7E          I  2251 (  6)         LD      A,(HL)          ; Get byte again
0FE5-D6 28       I  2252 (  6)         SUB     '('             ; Subscripted variable?
0FE7-CA 5F 10    I  2253 ( 6+)         JP      Z,SBSCPT        ; Yes - Sort out subscript
0FEA-            I  2254
0FEA-AF          I  2255 (  4) NSCFOR: XOR     A               ; Simple variable
0FEB-32 10 23    I  2256 ( 13)         LD      (FORFLG),A      ; Clear "FOR" flag
0FEE-E5          I  2257 ( 11)         PUSH    HL              ; Save code string address
0FEF-50          I  2258 (  4)         LD      D,B             ; DE = Variable name to find
0FF0-59          I  2259 (  4)         LD      E,C
0FF1-2A 23 23    I  2260 ( 15)         LD      HL,(FNRGNM)     ; FN argument name
0FF4-CD AF 07    I  2261 ( 16)         CALL    CPDEHL          ; Is it the FN argument?
0FF7-11 25 23    I  2262 (  9)         LD      DE,FNARG        ; Point to argument value
0FFA-CA CF 16    I  2263 ( 6+)         JP      Z,POPHRT        ; Yes - Return FN argument value
0FFD-2A 1D 23    I  2264 ( 15)         LD      HL,(VAREND)     ; End of variables
1000-EB          I  2265 (  3)         EX      DE,HL           ; Address of end of search
1001-2A 1B 23    I  2266 ( 15)         LD      HL,(PROGND)     ; Start of variables address
1004-CD AF 07    I  2267 ( 16) FNDVAR: CALL    CPDEHL          ; End of variable list table?
1007-CA 1D 10    I  2268 ( 6+)         JP      Z,CFEVAL        ; Yes - Called from EVAL?
100A-79          I  2269 (  4)         LD      A,C             ; Get second byte of name
100B-96          I  2270 (  6)         SUB     (HL)            ; Compare with name in list
100C-23          I  2271 (  4)         INC     HL              ; Move on to first byte
100D-C2 12 10    I  2272 ( 6+)         JP      NZ,FNTHR        ; Different - Find another
1010-78          I  2273 (  4)         LD      A,B             ; Get first byte of name
1011-96          I  2274 (  6)         SUB     (HL)            ; Compare with name in list
1012-23          I  2275 (  4) FNTHR:  INC     HL              ; Move on to LSB of value
1013-CA 51 10    I  2276 ( 6+)         JP      Z,RETADR        ; Found - Return address
1016-23          I  2277 (  4)         INC     HL              ; <- Skip
1017-23          I  2278 (  4)         INC     HL              ; <- over
1018-23          I  2279 (  4)         INC     HL              ; <- F.P.
1019-23          I  2280 (  4)         INC     HL              ; <- value
101A-C3 04 10    I  2281 (  9)         JP      FNDVAR          ; Keep looking
101D-            I  2282
101D-E1          I  2283 (  9) CFEVAL: POP     HL              ; Restore code string address
101E-E3          I  2284 ( 16)         EX      (SP),HL         ; Get return address
101F-D5          I  2285 ( 11)         PUSH    DE              ; Save address of variable
1020-11 9F 0E    I  2286 (  9)         LD      DE,FRMEVL       ; Return address in EVAL
1023-CD AF 07    I  2287 ( 16)         CALL    CPDEHL          ; Called from EVAL ?
1026-D1          I  2288 (  9)         POP     DE              ; Restore address of variable
1027-CA 54 10    I  2289 ( 6+)         JP      Z,RETNUL        ; Yes - Return null variable
102A-E3          I  2290 ( 16)         EX      (SP),HL         ; Put back return
102B-E5          I  2291 ( 11)         PUSH    HL              ; Save code string address
102C-C5          I  2292 ( 11)         PUSH    BC              ; Save variable name
102D-01 06 00    I  2293 (  9)         LD      BC,6            ; 2 byte name plus 4 byte data
1030-2A 1F 23    I  2294 ( 15)         LD      HL,(ARREND)     ; End of arrays
1033-E5          I  2295 ( 11)         PUSH    HL              ; Save end of arrays
1034-09          I  2296 (  7)         ADD     HL,BC           ; Move up 6 bytes
1035-C1          I  2297 (  9)         POP     BC              ; Source address in BC
1036-E5          I  2298 ( 11)         PUSH    HL              ; Save new end address
1037-CD A4 04    I  2299 ( 16)         CALL    MOVUP           ; Move arrays up
103A-E1          I  2300 (  9)         POP     HL              ; Restore new end address
103B-22 1F 23    I  2301 ( 20)         LD      (ARREND),HL     ; Set new end address
103E-60          I  2302 (  4)         LD      H,B             ; End of variables to HL
103F-69          I  2303 (  4)         LD      L,C
1040-22 1D 23    I  2304 ( 20)         LD      (VAREND),HL     ; Set new end address
1043-            I  2305
1043-2B          I  2306 (  4) ZEROLP: DEC     HL              ; Back through to zero variable
1044-36 00       I  2307 (  9)         LD      (HL),0          ; Zero byte in variable
1046-CD AF 07    I  2308 ( 16)         CALL    CPDEHL          ; Done them all?
1049-C2 43 10    I  2309 ( 6+)         JP      NZ,ZEROLP       ; No - Keep on going
104C-D1          I  2310 (  9)         POP     DE              ; Get variable name
104D-73          I  2311 (  7)         LD      (HL),E          ; Store second character
104E-23          I  2312 (  4)         INC     HL
104F-72          I  2313 (  7)         LD      (HL),D          ; Store first character
1050-23          I  2314 (  4)         INC     HL
1051-EB          I  2315 (  3) RETADR: EX      DE,HL           ; Address of variable in DE
1052-E1          I  2316 (  9)         POP     HL              ; Restore code string address
1053-C9          I  2317 (  9)         RET
1054-            I  2318
1054-32 2C 23    I  2319 ( 13) RETNUL: LD      (FPEXP),A       ; Set result to zero
1057-21 6E 04    I  2320 (  9)         LD      HL,ZERBYT       ; Also set a null string
105A-22 29 23    I  2321 ( 20)         LD      (FPREG),HL      ; Save for EVAL
105D-E1          I  2322 (  9)         POP     HL              ; Restore code string address
105E-C9          I  2323 (  9)         RET
105F-            I  2324
105F-E5          I  2325 ( 11) SBSCPT: PUSH    HL              ; Save code string address
1060-2A F1 22    I  2326 ( 15)         LD      HL,(LCRFLG)     ; Locate/Create and Type
1063-E3          I  2327 ( 16)         EX      (SP),HL         ; Save and get code string
1064-57          I  2328 (  4)         LD      D,A             ; Zero number of dimensions
1065-D5          I  2329 ( 11) SCPTLP: PUSH    DE              ; Save number of dimensions
1066-C5          I  2330 ( 11)         PUSH    BC              ; Save array name
1067-CD E5 09    I  2331 ( 16)         CALL    FPSINT          ; Get subscript (0-32767)
106A-C1          I  2332 (  9)         POP     BC              ; Restore array name
106B-F1          I  2333 (  9)         POP     AF              ; Get number of dimensions
106C-EB          I  2334 (  3)         EX      DE,HL
106D-E3          I  2335 ( 16)         EX      (SP),HL         ; Save subscript value
106E-E5          I  2336 ( 11)         PUSH    HL              ; Save LCRFLG and TYPE
106F-EB          I  2337 (  3)         EX      DE,HL
1070-3C          I  2338 (  4)         INC     A               ; Count dimensions
1071-57          I  2339 (  4)         LD      D,A             ; Save in D
1072-7E          I  2340 (  6)         LD      A,(HL)          ; Get next byte in code string
1073-FE 2C       I  2341 (  6)         CP      ','             ; Comma (more to come)?
1075-CA 65 10    I  2342 ( 6+)         JP      Z,SCPTLP        ; Yes - More subscripts
1078-CD B5 07    I  2343 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
107B-29          I  2344               .DB      ")"
107C-22 15 23    I  2345 ( 20)         LD      (NXTOPR),HL     ; Save code string address
107F-E1          I  2346 (  9)         POP     HL              ; Get LCRFLG and TYPE
1080-22 F1 22    I  2347 ( 20)         LD      (LCRFLG),HL     ; Restore Locate/create & type
1083-1E 00       I  2348 (  6)         LD      E,0             ; Flag not CSAVE* or CLOAD*
1085-D5          I  2349 ( 11)         PUSH    DE              ; Save number of dimensions (D)
1086-11          I  2350               .DB      11H             ; Skip "PUSH HL" and "PUSH AF'
1087-            I  2351
1087-E5          I  2352 ( 11) ARLDSV: PUSH    HL              ; Save code string address
1088-F5          I  2353 ( 11)         PUSH    AF              ; A = 00 , Flags set = Z,N
1089-2A 1D 23    I  2354 ( 15)         LD      HL,(VAREND)     ; Start of arrays
108C-3E          I  2355               .DB      3EH             ; Skip "ADD HL,DE"
108D-19          I  2356 (  7) FNDARY: ADD     HL,DE           ; Move to next array start
108E-EB          I  2357 (  3)         EX      DE,HL
108F-2A 1F 23    I  2358 ( 15)         LD      HL,(ARREND)     ; End of arrays
1092-EB          I  2359 (  3)         EX      DE,HL           ; Current array pointer
1093-CD AF 07    I  2360 ( 16)         CALL    CPDEHL          ; End of arrays found?
1096-CA BF 10    I  2361 ( 6+)         JP      Z,CREARY        ; Yes - Create array
1099-7E          I  2362 (  6)         LD      A,(HL)          ; Get second byte of name
109A-B9          I  2363 (  4)         CP      C               ; Compare with name given
109B-23          I  2364 (  4)         INC     HL              ; Move on
109C-C2 A1 10    I  2365 ( 6+)         JP      NZ,NXTARY       ; Different - Find next array
109F-7E          I  2366 (  6)         LD      A,(HL)          ; Get first byte of name
10A0-B8          I  2367 (  4)         CP      B               ; Compare with name given
10A1-23          I  2368 (  4) NXTARY: INC     HL              ; Move on
10A2-5E          I  2369 (  6)         LD      E,(HL)          ; Get LSB of next array address
10A3-23          I  2370 (  4)         INC     HL
10A4-56          I  2371 (  6)         LD      D,(HL)          ; Get MSB of next array address
10A5-23          I  2372 (  4)         INC     HL
10A6-C2 8D 10    I  2373 ( 6+)         JP      NZ,FNDARY       ; Not found - Keep looking
10A9-3A F1 22    I  2374 ( 12)         LD      A,(LCRFLG)      ; Found Locate or Create it?
10AC-B7          I  2375 (  4)         OR      A
10AD-C2 E1 04    I  2376 ( 6+)         JP      NZ,DDERR        ; Create - ?DD Error
10B0-F1          I  2377 (  9)         POP     AF              ; Locate - Get number of dim'ns
10B1-44          I  2378 (  4)         LD      B,H             ; BC Points to array dim'ns
10B2-4D          I  2379 (  4)         LD      C,L
10B3-CA CF 16    I  2380 ( 6+)         JP      Z,POPHRT        ; Jump if array load/save
10B6-96          I  2381 (  6)         SUB     (HL)            ; Same number of dimensions?
10B7-CA 1D 11    I  2382 ( 6+)         JP      Z,FINDEL        ; Yes - Find element
10BA-1E 10       I  2383 (  6) BSERR:  LD      E,BS            ; ?BS Error
10BC-C3 EC 04    I  2384 (  9)         JP      ERROR           ; Output error
10BF-            I  2385
10BF-11 04 00    I  2386 (  9) CREARY: LD      DE,4            ; 4 Bytes per entry
10C2-F1          I  2387 (  9)         POP     AF              ; Array to save or 0 dim'ns?
10C3-CA 06 0A    I  2388 ( 6+)         JP      Z,FCERR         ; Yes - ?FC Error
10C6-71          I  2389 (  7)         LD      (HL),C          ; Save second byte of name
10C7-23          I  2390 (  4)         INC     HL
10C8-70          I  2391 (  7)         LD      (HL),B          ; Save first byte of name
10C9-23          I  2392 (  4)         INC     HL
10CA-4F          I  2393 (  4)         LD      C,A             ; Number of dimensions to C
10CB-CD B5 04    I  2394 ( 16)         CALL    CHKSTK          ; Check if enough memory
10CE-23          I  2395 (  4)         INC     HL              ; Point to number of dimensions
10CF-23          I  2396 (  4)         INC     HL
10D0-22 0A 23    I  2397 ( 20)         LD      (CUROPR),HL     ; Save address of pointer
10D3-71          I  2398 (  7)         LD      (HL),C          ; Set number of dimensions
10D4-23          I  2399 (  4)         INC     HL
10D5-3A F1 22    I  2400 ( 12)         LD      A,(LCRFLG)      ; Locate of Create?
10D8-17          I  2401 (  3)         RLA                     ; Carry set = Create
10D9-79          I  2402 (  4)         LD      A,C             ; Get number of dimensions
10DA-01 0B 00    I  2403 (  9) CRARLP: LD      BC,10+1         ; Default dimension size 10
10DD-D2 E2 10    I  2404 ( 6+)         JP      NC,DEFSIZ       ; Locate - Set default size
10E0-C1          I  2405 (  9)         POP     BC              ; Get specified dimension size
10E1-03          I  2406 (  4)         INC     BC              ; Include zero element
10E2-71          I  2407 (  7) DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
10E3-23          I  2408 (  4)         INC     HL
10E4-70          I  2409 (  7)         LD      (HL),B          ; Save MSB of dimension size
10E5-23          I  2410 (  4)         INC     HL
10E6-F5          I  2411 ( 11)         PUSH    AF              ; Save num' of dim'ns an status
10E7-E5          I  2412 ( 11)         PUSH    HL              ; Save address of dim'n size
10E8-CD 7A 18    I  2413 ( 16)         CALL    MLDEBC          ; Multiply DE by BC to find
10EB-EB          I  2414 (  3)         EX      DE,HL           ; amount of mem needed (to DE)
10EC-E1          I  2415 (  9)         POP     HL              ; Restore address of dimension
10ED-F1          I  2416 (  9)         POP     AF              ; Restore number of dimensions
10EE-3D          I  2417 (  4)         DEC     A               ; Count them
10EF-C2 DA 10    I  2418 ( 6+)         JP      NZ,CRARLP       ; Do next dimension if more
10F2-F5          I  2419 ( 11)         PUSH    AF              ; Save locate/create flag
10F3-42          I  2420 (  4)         LD      B,D             ; MSB of memory needed
10F4-4B          I  2421 (  4)         LD      C,E             ; LSB of memory needed
10F5-EB          I  2422 (  3)         EX      DE,HL
10F6-19          I  2423 (  7)         ADD     HL,DE           ; Add bytes to array start
10F7-DA CD 04    I  2424 ( 6+)         JP      C,OMERR         ; Too big - Error
10FA-CD BE 04    I  2425 ( 16)         CALL    ENFMEM          ; See if enough memory
10FD-22 1F 23    I  2426 ( 20)         LD      (ARREND),HL     ; Save new end of array
1100-            I  2427
1100-2B          I  2428 (  4) ZERARY: DEC     HL              ; Back through array data
1101-36 00       I  2429 (  9)         LD      (HL),0          ; Set array element to zero
1103-CD AF 07    I  2430 ( 16)         CALL    CPDEHL          ; All elements zeroed?
1106-C2 00 11    I  2431 ( 6+)         JP      NZ,ZERARY       ; No - Keep on going
1109-03          I  2432 (  4)         INC     BC              ; Number of bytes + 1
110A-57          I  2433 (  4)         LD      D,A             ; A=0
110B-2A 0A 23    I  2434 ( 15)         LD      HL,(CUROPR)     ; Get address of array
110E-5E          I  2435 (  6)         LD      E,(HL)          ; Number of dimensions
110F-EB          I  2436 (  3)         EX      DE,HL           ; To HL
1110-29          I  2437 (  7)         ADD     HL,HL           ; Two bytes per dimension size
1111-09          I  2438 (  7)         ADD     HL,BC           ; Add number of bytes
1112-EB          I  2439 (  3)         EX      DE,HL           ; Bytes needed to DE
1113-2B          I  2440 (  4)         DEC     HL
1114-2B          I  2441 (  4)         DEC     HL
1115-73          I  2442 (  7)         LD      (HL),E          ; Save LSB of bytes needed
1116-23          I  2443 (  4)         INC     HL
1117-72          I  2444 (  7)         LD      (HL),D          ; Save MSB of bytes needed
1118-23          I  2445 (  4)         INC     HL
1119-F1          I  2446 (  9)         POP     AF              ; Locate / Create?
111A-DA 41 11    I  2447 ( 6+)         JP      C,ENDDIM        ; A is 0 , End if create
111D-47          I  2448 (  4) FINDEL: LD      B,A             ; Find array element
111E-4F          I  2449 (  4)         LD      C,A
111F-7E          I  2450 (  6)         LD      A,(HL)          ; Number of dimensions
1120-23          I  2451 (  4)         INC     HL
1121-16          I  2452               .DB      16H             ; Skip "POP HL"
1122-E1          I  2453 (  9) FNDELP: POP     HL              ; Address of next dim' size
1123-5E          I  2454 (  6)         LD      E,(HL)          ; Get LSB of dim'n size
1124-23          I  2455 (  4)         INC     HL
1125-56          I  2456 (  6)         LD      D,(HL)          ; Get MSB of dim'n size
1126-23          I  2457 (  4)         INC     HL
1127-E3          I  2458 ( 16)         EX      (SP),HL         ; Save address - Get index
1128-F5          I  2459 ( 11)         PUSH    AF              ; Save number of dim'ns
1129-CD AF 07    I  2460 ( 16)         CALL    CPDEHL          ; Dimension too large?
112C-D2 BA 10    I  2461 ( 6+)         JP      NC,BSERR        ; Yes - ?BS Error
112F-E5          I  2462 ( 11)         PUSH    HL              ; Save index
1130-CD 7A 18    I  2463 ( 16)         CALL    MLDEBC          ; Multiply previous by size
1133-D1          I  2464 (  9)         POP     DE              ; Index supplied to DE
1134-19          I  2465 (  7)         ADD     HL,DE           ; Add index to pointer
1135-F1          I  2466 (  9)         POP     AF              ; Number of dimensions
1136-3D          I  2467 (  4)         DEC     A               ; Count them
1137-44          I  2468 (  4)         LD      B,H             ; MSB of pointer
1138-4D          I  2469 (  4)         LD      C,L             ; LSB of pointer
1139-C2 22 11    I  2470 ( 6+)         JP      NZ,FNDELP       ; More - Keep going
113C-29          I  2471 (  7)         ADD     HL,HL           ; 4 Bytes per element
113D-29          I  2472 (  7)         ADD     HL,HL
113E-C1          I  2473 (  9)         POP     BC              ; Start of array
113F-09          I  2474 (  7)         ADD     HL,BC           ; Point to element
1140-EB          I  2475 (  3)         EX      DE,HL           ; Address of element to DE
1141-2A 15 23    I  2476 ( 15) ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
1144-C9          I  2477 (  9)         RET
1145-            I  2478
1145-2A 1F 23    I  2479 ( 15) FRE:    LD      HL,(ARREND)     ; Start of free memory
1148-EB          I  2480 (  3)         EX      DE,HL           ; To DE
1149-21 00 00    I  2481 (  9)         LD      HL,0            ; End of free memory
114C-39          I  2482 (  7)         ADD     HL,SP           ; Current stack value
114D-3A F2 22    I  2483 ( 12)         LD      A,(TYPE)        ; Dummy argument type
1150-B7          I  2484 (  4)         OR      A
1151-CA 61 11    I  2485 ( 6+)         JP      Z,FRENUM        ; Numeric - Free variable space
1154-CD C8 13    I  2486 ( 16)         CALL    GSTRCU          ; Current string to pool
1157-CD C8 12    I  2487 ( 16)         CALL    GARBGE          ; Garbage collection
115A-2A 9F 22    I  2488 ( 15)         LD      HL,(STRSPC)     ; Bottom of string space in use
115D-EB          I  2489 (  3)         EX      DE,HL           ; To DE
115E-2A 08 23    I  2490 ( 15)         LD      HL,(STRBOT)     ; Bottom of string space
1161-7D          I  2491 (  4) FRENUM: LD      A,L             ; Get LSB of end
1162-93          I  2492 (  4)         SUB     E               ; Subtract LSB of beginning
1163-4F          I  2493 (  4)         LD      C,A             ; Save difference if C
1164-7C          I  2494 (  4)         LD      A,H             ; Get MSB of end
1165-9A          I  2495 (  4)         SBC     A,D             ; Subtract MSB of beginning
1166-41          I  2496 (  4) ACPASS: LD      B,C             ; Return integer AC
1167-50          I  2497 (  4) ABPASS: LD      D,B             ; Return integer AB
1168-1E 00       I  2498 (  6)         LD      E,0
116A-21 F2 22    I  2499 (  9)         LD      HL,TYPE         ; Point to type
116D-73          I  2500 (  7)         LD      (HL),E          ; Set type to numeric
116E-06 90       I  2501 (  6)         LD      B,80H+16        ; 16 bit integer
1170-C3 A5 17    I  2502 (  9)         JP      RETINT          ; Return the integr
1173-            I  2503
1173-3A F0 22    I  2504 ( 12) POS:    LD      A,(CURPOS)      ; Get cursor position
1176-47          I  2505 (  4) PASSA:  LD      B,A             ; Put A into AB
1177-AF          I  2506 (  4)         XOR     A               ; Zero A
1178-C3 67 11    I  2507 (  9)         JP      ABPASS          ; Return integer AB
117B-            I  2508
117B-CD FE 11    I  2509 ( 16) DEF:    CALL    CHEKFN          ; Get "FN" and name
117E-CD F0 11    I  2510 ( 16)         CALL    IDTEST          ; Test for illegal direct
1181-01 D6 0A    I  2511 (  9)         LD      BC,DATA         ; To get next statement
1184-C5          I  2512 ( 11)         PUSH    BC              ; Save address for RETurn
1185-D5          I  2513 ( 11)         PUSH    DE              ; Save address of function ptr
1186-CD B5 07    I  2514 ( 16)         CALL    CHKSYN          ; Make sure "(" follows
1189-28          I  2515               .DB      "("
118A-CD A2 0F    I  2516 ( 16)         CALL    GETVAR          ; Get argument variable name
118D-E5          I  2517 ( 11)         PUSH    HL              ; Save code string address
118E-EB          I  2518 (  3)         EX      DE,HL           ; Argument address to HL
118F-2B          I  2519 (  4)         DEC     HL
1190-56          I  2520 (  6)         LD      D,(HL)          ; Get first byte of arg name
1191-2B          I  2521 (  4)         DEC     HL
1192-5E          I  2522 (  6)         LD      E,(HL)          ; Get second byte of arg name
1193-E1          I  2523 (  9)         POP     HL              ; Restore code string address
1194-CD AF 0D    I  2524 ( 16)         CALL    TSTNUM          ; Make sure numeric argument
1197-CD B5 07    I  2525 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
119A-29          I  2526               .DB      ")"
119B-CD B5 07    I  2527 ( 16)         CALL    CHKSYN          ; Make sure "=" follows
119E-B4          I  2528               .DB      ZEQUAL          ; "=" token
119F-44          I  2529 (  4)         LD      B,H             ; Code string address to BC
11A0-4D          I  2530 (  4)         LD      C,L
11A1-E3          I  2531 ( 16)         EX      (SP),HL         ; Save code str , Get FN ptr
11A2-71          I  2532 (  7)         LD      (HL),C          ; Save LSB of FN code string
11A3-23          I  2533 (  4)         INC     HL
11A4-70          I  2534 (  7)         LD      (HL),B          ; Save MSB of FN code string
11A5-C3 3D 12    I  2535 (  9)         JP      SVSTAD          ; Save address and do function
11A8-            I  2536
11A8-CD FE 11    I  2537 ( 16) DOFN:   CALL    CHEKFN          ; Make sure FN follows
11AB-D5          I  2538 ( 11)         PUSH    DE              ; Save function pointer address
11AC-CD 83 0E    I  2539 ( 16)         CALL    EVLPAR          ; Evaluate expression in "()"
11AF-CD AF 0D    I  2540 ( 16)         CALL    TSTNUM          ; Make sure numeric result
11B2-E3          I  2541 ( 16)         EX      (SP),HL         ; Save code str , Get FN ptr
11B3-5E          I  2542 (  6)         LD      E,(HL)          ; Get LSB of FN code string
11B4-23          I  2543 (  4)         INC     HL
11B5-56          I  2544 (  6)         LD      D,(HL)          ; Get MSB of FN code string
11B6-23          I  2545 (  4)         INC     HL
11B7-7A          I  2546 (  4)         LD      A,D             ; And function DEFined?
11B8-B3          I  2547 (  4)         OR      E
11B9-CA E4 04    I  2548 ( 6+)         JP      Z,UFERR         ; No - ?UF Error
11BC-7E          I  2549 (  6)         LD      A,(HL)          ; Get LSB of argument address
11BD-23          I  2550 (  4)         INC     HL
11BE-66          I  2551 (  6)         LD      H,(HL)          ; Get MSB of argument address
11BF-6F          I  2552 (  4)         LD      L,A             ; HL = Arg variable address
11C0-E5          I  2553 ( 11)         PUSH    HL              ; Save it
11C1-2A 23 23    I  2554 ( 15)         LD      HL,(FNRGNM)     ; Get old argument name
11C4-E3          I  2555 ( 16)         EX      (SP),HL ;       ; Save old , Get new
11C5-22 23 23    I  2556 ( 20)         LD      (FNRGNM),HL     ; Set new argument name
11C8-2A 27 23    I  2557 ( 15)         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
11CB-E5          I  2558 ( 11)         PUSH    HL              ; Save it
11CC-2A 25 23    I  2559 ( 15)         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
11CF-E5          I  2560 ( 11)         PUSH    HL              ; Save it
11D0-21 25 23    I  2561 (  9)         LD      HL,FNARG        ; HL = Value of argument
11D3-D5          I  2562 ( 11)         PUSH    DE              ; Save FN code string address
11D4-CD E6 17    I  2563 ( 16)         CALL    FPTHL           ; Move FPREG to argument
11D7-E1          I  2564 (  9)         POP     HL              ; Get FN code string address
11D8-CD AC 0D    I  2565 ( 16)         CALL    GETNUM          ; Get value from function
11DB-2B          I  2566 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
11DC-CD 3F 09    I  2567 ( 16)         CALL    GETCHR          ; Get next character
11DF-C2 D8 04    I  2568 ( 6+)         JP      NZ,SNERR        ; Bad character in FN - Error
11E2-E1          I  2569 (  9)         POP     HL              ; Get MSB,EXP of old arg
11E3-22 25 23    I  2570 ( 20)         LD      (FNARG),HL      ; Restore it
11E6-E1          I  2571 (  9)         POP     HL              ; Get LSB,NLSB of old arg
11E7-22 27 23    I  2572 ( 20)         LD      (FNARG+2),HL    ; Restore it
11EA-E1          I  2573 (  9)         POP     HL              ; Get name of old arg
11EB-22 23 23    I  2574 ( 20)         LD      (FNRGNM),HL     ; Restore it
11EE-E1          I  2575 (  9)         POP     HL              ; Restore code string address
11EF-C9          I  2576 (  9)         RET
11F0-            I  2577
11F0-E5          I  2578 ( 11) IDTEST: PUSH    HL              ; Save code string address
11F1-2A A1 22    I  2579 ( 15)         LD      HL,(LINEAT)     ; Get current line number
11F4-23          I  2580 (  4)         INC     HL              ; -1 means direct statement
11F5-7C          I  2581 (  4)         LD      A,H
11F6-B5          I  2582 (  4)         OR      L
11F7-E1          I  2583 (  9)         POP     HL              ; Restore code string address
11F8-C0          I  2584 ( 5+)         RET     NZ              ; Return if in program
11F9-1E 16       I  2585 (  6)         LD      E,ID            ; ?ID Error
11FB-C3 EC 04    I  2586 (  9)         JP      ERROR
11FE-            I  2587
11FE-CD B5 07    I  2588 ( 16) CHEKFN: CALL    CHKSYN          ; Make sure FN follows
1201-A7          I  2589               .DB      ZFN             ; "FN" token
1202-3E 80       I  2590 (  6)         LD      A,80H
1204-32 10 23    I  2591 ( 13)         LD      (FORFLG),A      ; Flag FN name to find
1207-B6          I  2592 (  6)         OR      (HL)            ; FN name has bit 7 set
1208-47          I  2593 (  4)         LD      B,A             ; in first byte of name
1209-CD A7 0F    I  2594 ( 16)         CALL    GTFNAM          ; Get FN name
120C-C3 AF 0D    I  2595 (  9)         JP      TSTNUM          ; Make sure numeric function
120F-            I  2596
120F-CD AF 0D    I  2597 ( 16) STR:    CALL    TSTNUM          ; Make sure it's a number
1212-CD 33 19    I  2598 ( 16)         CALL    NUMASC          ; Turn number into text
1215-CD 43 12    I  2599 ( 16) STR1:   CALL    CRTST           ; Create string entry for it
1218-CD C8 13    I  2600 ( 16)         CALL    GSTRCU          ; Current string to pool
121B-01 23 14    I  2601 (  9)         LD      BC,TOPOOL       ; Save in string pool
121E-C5          I  2602 ( 11)         PUSH    BC              ; Save address on stack
121F-            I  2603
121F-7E          I  2604 (  6) SAVSTR: LD      A,(HL)          ; Get string length
1220-23          I  2605 (  4)         INC     HL
1221-23          I  2606 (  4)         INC     HL
1222-E5          I  2607 ( 11)         PUSH    HL              ; Save pointer to string
1223-CD 9E 12    I  2608 ( 16)         CALL    TESTR           ; See if enough string space
1226-E1          I  2609 (  9)         POP     HL              ; Restore pointer to string
1227-4E          I  2610 (  6)         LD      C,(HL)          ; Get LSB of address
1228-23          I  2611 (  4)         INC     HL
1229-46          I  2612 (  6)         LD      B,(HL)          ; Get MSB of address
122A-CD 37 12    I  2613 ( 16)         CALL    CRTMST          ; Create string entry
122D-E5          I  2614 ( 11)         PUSH    HL              ; Save pointer to MSB of addr
122E-6F          I  2615 (  4)         LD      L,A             ; Length of string
122F-CD BB 13    I  2616 ( 16)         CALL    TOSTRA          ; Move to string area
1232-D1          I  2617 (  9)         POP     DE              ; Restore pointer to MSB
1233-C9          I  2618 (  9)         RET
1234-            I  2619
1234-CD 9E 12    I  2620 ( 16) MKTMST: CALL    TESTR           ; See if enough string space
1237-21 04 23    I  2621 (  9) CRTMST: LD      HL,TMPSTR       ; Temporary string
123A-E5          I  2622 ( 11)         PUSH    HL              ; Save it
123B-77          I  2623 (  7)         LD      (HL),A          ; Save length of string
123C-23          I  2624 (  4)         INC     HL
123D-23          I  2625 (  4) SVSTAD: INC     HL
123E-73          I  2626 (  7)         LD      (HL),E          ; Save LSB of address
123F-23          I  2627 (  4)         INC     HL
1240-72          I  2628 (  7)         LD      (HL),D          ; Save MSB of address
1241-E1          I  2629 (  9)         POP     HL              ; Restore pointer
1242-C9          I  2630 (  9)         RET
1243-            I  2631
1243-2B          I  2632 (  4) CRTST:  DEC     HL              ; DEC - INCed after
1244-06 22       I  2633 (  6) QTSTR:  LD      B,'"'           ; Terminating quote
1246-50          I  2634 (  4)         LD      D,B             ; Quote to D
1247-E5          I  2635 ( 11) DTSTR:  PUSH    HL              ; Save start
1248-0E FF       I  2636 (  6)         LD      C,-1            ; Set counter to -1
124A-23          I  2637 (  4) QTSTLP: INC     HL              ; Move on
124B-7E          I  2638 (  6)         LD      A,(HL)          ; Get byte
124C-0C          I  2639 (  4)         INC     C               ; Count bytes
124D-B7          I  2640 (  4)         OR      A               ; End of line?
124E-CA 59 12    I  2641 ( 6+)         JP      Z,CRTSTE        ; Yes - Create string entry
1251-BA          I  2642 (  4)         CP      D               ; Terminator D found?
1252-CA 59 12    I  2643 ( 6+)         JP      Z,CRTSTE        ; Yes - Create string entry
1255-B8          I  2644 (  4)         CP      B               ; Terminator B found?
1256-C2 4A 12    I  2645 ( 6+)         JP      NZ,QTSTLP       ; No - Keep looking
1259-FE 22       I  2646 (  6) CRTSTE: CP      '"'             ; End with '"'?
125B-CC 3F 09    I  2647 ( 6+)         CALL    Z,GETCHR        ; Yes - Get next character
125E-E3          I  2648 ( 16)         EX      (SP),HL         ; Starting quote
125F-23          I  2649 (  4)         INC     HL              ; First byte of string
1260-EB          I  2650 (  3)         EX      DE,HL           ; To DE
1261-79          I  2651 (  4)         LD      A,C             ; Get length
1262-CD 37 12    I  2652 ( 16)         CALL    CRTMST          ; Create string entry
1265-11 04 23    I  2653 (  9) TSTOPL: LD      DE,TMPSTR       ; Temporary string
1268-2A F6 22    I  2654 ( 15)         LD      HL,(TMSTPT)     ; Temporary string pool pointer
126B-22 29 23    I  2655 ( 20)         LD      (FPREG),HL      ; Save address of string ptr
126E-3E 01       I  2656 (  6)         LD      A,1
1270-32 F2 22    I  2657 ( 13)         LD      (TYPE),A        ; Set type to string
1273-CD E9 17    I  2658 ( 16)         CALL    DETHL4          ; Move string to pool
1276-CD AF 07    I  2659 ( 16)         CALL    CPDEHL          ; Out of string pool?
1279-22 F6 22    I  2660 ( 20)         LD      (TMSTPT),HL     ; Save new pointer
127C-E1          I  2661 (  9)         POP     HL              ; Restore code string address
127D-7E          I  2662 (  6)         LD      A,(HL)          ; Get next code byte
127E-C0          I  2663 ( 5+)         RET     NZ              ; Return if pool OK
127F-1E 1E       I  2664 (  6)         LD      E,ST            ; ?ST Error
1281-C3 EC 04    I  2665 (  9)         JP      ERROR           ; String pool overflow
1284-            I  2666
1284-23          I  2667 (  4) PRNUMS: INC     HL              ; Skip leading space
1285-CD 43 12    I  2668 ( 16) PRS:    CALL    CRTST           ; Create string entry for it
1288-CD C8 13    I  2669 ( 16) PRS1:   CALL    GSTRCU          ; Current string to pool
128B-CD DD 17    I  2670 ( 16)         CALL    LOADFP          ; Move string block to BCDE
128E-1C          I  2671 (  4)         INC     E               ; Length + 1
128F-1D          I  2672 (  4) PRSLP:  DEC     E               ; Count characters
1290-C8          I  2673 ( 5+)         RET     Z               ; End of string
1291-0A          I  2674 (  6)         LD      A,(BC)          ; Get byte to output
1292-CD C0 07    I  2675 ( 16)         CALL    OUTC            ; Output character in A
1295-FE 0D       I  2676 (  6)         CP      CR              ; Return?
1297-CC F1 0B    I  2677 ( 6+)         CALL    Z,DONULL        ; Yes - Do nulls
129A-03          I  2678 (  4)         INC     BC              ; Next byte in string
129B-C3 8F 12    I  2679 (  9)         JP      PRSLP           ; More characters to output
129E-            I  2680
129E-B7          I  2681 (  4) TESTR:  OR      A               ; Test if enough room
129F-0E          I  2682               .DB      0EH             ; No garbage collection done
12A0-F1          I  2683 (  9) GRBDON: POP     AF              ; Garbage collection done
12A1-F5          I  2684 ( 11)         PUSH    AF              ; Save status
12A2-2A 9F 22    I  2685 ( 15)         LD      HL,(STRSPC)     ; Bottom of string space in use
12A5-EB          I  2686 (  3)         EX      DE,HL           ; To DE
12A6-2A 08 23    I  2687 ( 15)         LD      HL,(STRBOT)     ; Bottom of string area
12A9-2F          I  2688 (  3)         CPL                     ; Negate length (Top down)
12AA-4F          I  2689 (  4)         LD      C,A             ; -Length to BC
12AB-06 FF       I  2690 (  6)         LD      B,-1            ; BC = -ve length of string
12AD-09          I  2691 (  7)         ADD     HL,BC           ; Add to bottom of space in use
12AE-23          I  2692 (  4)         INC     HL              ; Plus one for 2's complement
12AF-CD AF 07    I  2693 ( 16)         CALL    CPDEHL          ; Below string RAM area?
12B2-DA BC 12    I  2694 ( 6+)         JP      C,TESTOS        ; Tidy up if not done else err
12B5-22 08 23    I  2695 ( 20)         LD      (STRBOT),HL     ; Save new bottom of area
12B8-23          I  2696 (  4)         INC     HL              ; Point to first byte of string
12B9-EB          I  2697 (  3)         EX      DE,HL           ; Address to DE
12BA-F1          I  2698 (  9) POPAF:  POP     AF              ; Throw away status push
12BB-C9          I  2699 (  9)         RET
12BC-            I  2700
12BC-F1          I  2701 (  9) TESTOS: POP     AF              ; Garbage collect been done?
12BD-1E 1A       I  2702 (  6)         LD      E,OS            ; ?OS Error
12BF-CA EC 04    I  2703 ( 6+)         JP      Z,ERROR         ; Yes - Not enough string apace
12C2-BF          I  2704 (  4)         CP      A               ; Flag garbage collect done
12C3-F5          I  2705 ( 11)         PUSH    AF              ; Save status
12C4-01 A0 12    I  2706 (  9)         LD      BC,GRBDON       ; Garbage collection done
12C7-C5          I  2707 ( 11)         PUSH    BC              ; Save for RETurn
12C8-2A F4 22    I  2708 ( 15) GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
12CB-22 08 23    I  2709 ( 20) GARBLP: LD      (STRBOT),HL     ; Reset string pointer
12CE-21 00 00    I  2710 (  9)         LD      HL,0
12D1-E5          I  2711 ( 11)         PUSH    HL              ; Flag no string found
12D2-2A 9F 22    I  2712 ( 15)         LD      HL,(STRSPC)     ; Get bottom of string space
12D5-E5          I  2713 ( 11)         PUSH    HL              ; Save bottom of string space
12D6-21 F8 22    I  2714 (  9)         LD      HL,TMSTPL       ; Temporary string pool
12D9-EB          I  2715 (  3) GRBLP:  EX      DE,HL
12DA-2A F6 22    I  2716 ( 15)         LD      HL,(TMSTPT)     ; Temporary string pool pointer
12DD-EB          I  2717 (  3)         EX      DE,HL
12DE-CD AF 07    I  2718 ( 16)         CALL    CPDEHL          ; Temporary string pool done?
12E1-01 D9 12    I  2719 (  9)         LD      BC,GRBLP        ; Loop until string pool done
12E4-C2 2D 13    I  2720 ( 6+)         JP      NZ,STPOOL       ; No - See if in string area
12E7-2A 1B 23    I  2721 ( 15)         LD      HL,(PROGND)     ; Start of simple variables
12EA-EB          I  2722 (  3) SMPVAR: EX      DE,HL
12EB-2A 1D 23    I  2723 ( 15)         LD      HL,(VAREND)     ; End of simple variables
12EE-EB          I  2724 (  3)         EX      DE,HL
12EF-CD AF 07    I  2725 ( 16)         CALL    CPDEHL          ; All simple strings done?
12F2-CA 00 13    I  2726 ( 6+)         JP      Z,ARRLP         ; Yes - Do string arrays
12F5-7E          I  2727 (  6)         LD      A,(HL)          ; Get type of variable
12F6-23          I  2728 (  4)         INC     HL
12F7-23          I  2729 (  4)         INC     HL
12F8-B7          I  2730 (  4)         OR      A               ; "S" flag set if string
12F9-CD 30 13    I  2731 ( 16)         CALL    STRADD          ; See if string in string area
12FC-C3 EA 12    I  2732 (  9)         JP      SMPVAR          ; Loop until simple ones done
12FF-            I  2733
12FF-C1          I  2734 (  9) GNXARY: POP     BC              ; Scrap address of this array
1300-EB          I  2735 (  3) ARRLP:  EX      DE,HL
1301-2A 1F 23    I  2736 ( 15)         LD      HL,(ARREND)     ; End of string arrays
1304-EB          I  2737 (  3)         EX      DE,HL
1305-CD AF 07    I  2738 ( 16)         CALL    CPDEHL          ; All string arrays done?
1308-CA 56 13    I  2739 ( 6+)         JP      Z,SCNEND        ; Yes - Move string if found
130B-CD DD 17    I  2740 ( 16)         CALL    LOADFP          ; Get array name to BCDE
130E-7B          I  2741 (  4)         LD      A,E             ; Get type of array
130F-E5          I  2742 ( 11)         PUSH    HL              ; Save address of num of dim'ns
1310-09          I  2743 (  7)         ADD     HL,BC           ; Start of next array
1311-B7          I  2744 (  4)         OR      A               ; Test type of array
1312-F2 FF 12    I  2745 ( 6+)         JP      P,GNXARY        ; Numeric array - Ignore it
1315-22 0A 23    I  2746 ( 20)         LD      (CUROPR),HL     ; Save address of next array
1318-E1          I  2747 (  9)         POP     HL              ; Get address of num of dim'ns
1319-4E          I  2748 (  6)         LD      C,(HL)          ; BC = Number of dimensions
131A-06 00       I  2749 (  6)         LD      B,0
131C-09          I  2750 (  7)         ADD     HL,BC           ; Two bytes per dimension size
131D-09          I  2751 (  7)         ADD     HL,BC
131E-23          I  2752 (  4)         INC     HL              ; Plus one for number of dim'ns
131F-EB          I  2753 (  3) GRBARY: EX      DE,HL
1320-2A 0A 23    I  2754 ( 15)         LD      HL,(CUROPR)     ; Get address of next array
1323-EB          I  2755 (  3)         EX      DE,HL
1324-CD AF 07    I  2756 ( 16)         CALL    CPDEHL          ; Is this array finished?
1327-CA 00 13    I  2757 ( 6+)         JP      Z,ARRLP         ; Yes - Get next one
132A-01 1F 13    I  2758 (  9)         LD      BC,GRBARY       ; Loop until array all done
132D-C5          I  2759 ( 11) STPOOL: PUSH    BC              ; Save return address
132E-F6 80       I  2760 (  6)         OR      80H             ; Flag string type
1330-7E          I  2761 (  6) STRADD: LD      A,(HL)          ; Get string length
1331-23          I  2762 (  4)         INC     HL
1332-23          I  2763 (  4)         INC     HL
1333-5E          I  2764 (  6)         LD      E,(HL)          ; Get LSB of string address
1334-23          I  2765 (  4)         INC     HL
1335-56          I  2766 (  6)         LD      D,(HL)          ; Get MSB of string address
1336-23          I  2767 (  4)         INC     HL
1337-F0          I  2768 ( 5+)         RET     P               ; Not a string - Return
1338-B7          I  2769 (  4)         OR      A               ; Set flags on string length
1339-C8          I  2770 ( 5+)         RET     Z               ; Null string - Return
133A-44          I  2771 (  4)         LD      B,H             ; Save variable pointer
133B-4D          I  2772 (  4)         LD      C,L
133C-2A 08 23    I  2773 ( 15)         LD      HL,(STRBOT)     ; Bottom of new area
133F-CD AF 07    I  2774 ( 16)         CALL    CPDEHL          ; String been done?
1342-60          I  2775 (  4)         LD      H,B             ; Restore variable pointer
1343-69          I  2776 (  4)         LD      L,C
1344-D8          I  2777 ( 5+)         RET     C               ; String done - Ignore
1345-E1          I  2778 (  9)         POP     HL              ; Return address
1346-E3          I  2779 ( 16)         EX      (SP),HL         ; Lowest available string area
1347-CD AF 07    I  2780 ( 16)         CALL    CPDEHL          ; String within string area?
134A-E3          I  2781 ( 16)         EX      (SP),HL         ; Lowest available string area
134B-E5          I  2782 ( 11)         PUSH    HL              ; Re-save return address
134C-60          I  2783 (  4)         LD      H,B             ; Restore variable pointer
134D-69          I  2784 (  4)         LD      L,C
134E-D0          I  2785 ( 5+)         RET     NC              ; Outside string area - Ignore
134F-C1          I  2786 (  9)         POP     BC              ; Get return , Throw 2 away
1350-F1          I  2787 (  9)         POP     AF              ;
1351-F1          I  2788 (  9)         POP     AF              ;
1352-E5          I  2789 ( 11)         PUSH    HL              ; Save variable pointer
1353-D5          I  2790 ( 11)         PUSH    DE              ; Save address of current
1354-C5          I  2791 ( 11)         PUSH    BC              ; Put back return address
1355-C9          I  2792 (  9)         RET                     ; Go to it
1356-            I  2793
1356-D1          I  2794 (  9) SCNEND: POP     DE              ; Addresses of strings
1357-E1          I  2795 (  9)         POP     HL              ;
1358-7D          I  2796 (  4)         LD      A,L             ; HL = 0 if no more to do
1359-B4          I  2797 (  4)         OR      H
135A-C8          I  2798 ( 5+)         RET     Z               ; No more to do - Return
135B-2B          I  2799 (  4)         DEC     HL
135C-46          I  2800 (  6)         LD      B,(HL)          ; MSB of address of string
135D-2B          I  2801 (  4)         DEC     HL
135E-4E          I  2802 (  6)         LD      C,(HL)          ; LSB of address of string
135F-E5          I  2803 ( 11)         PUSH    HL              ; Save variable address
1360-2B          I  2804 (  4)         DEC     HL
1361-2B          I  2805 (  4)         DEC     HL
1362-6E          I  2806 (  6)         LD      L,(HL)          ; HL = Length of string
1363-26 00       I  2807 (  6)         LD      H,0
1365-09          I  2808 (  7)         ADD     HL,BC           ; Address of end of string+1
1366-50          I  2809 (  4)         LD      D,B             ; String address to DE
1367-59          I  2810 (  4)         LD      E,C
1368-2B          I  2811 (  4)         DEC     HL              ; Last byte in string
1369-44          I  2812 (  4)         LD      B,H             ; Address to BC
136A-4D          I  2813 (  4)         LD      C,L
136B-2A 08 23    I  2814 ( 15)         LD      HL,(STRBOT)     ; Current bottom of string area
136E-CD A7 04    I  2815 ( 16)         CALL    MOVSTR          ; Move string to new address
1371-E1          I  2816 (  9)         POP     HL              ; Restore variable address
1372-71          I  2817 (  7)         LD      (HL),C          ; Save new LSB of address
1373-23          I  2818 (  4)         INC     HL
1374-70          I  2819 (  7)         LD      (HL),B          ; Save new MSB of address
1375-69          I  2820 (  4)         LD      L,C             ; Next string area+1 to HL
1376-60          I  2821 (  4)         LD      H,B
1377-2B          I  2822 (  4)         DEC     HL              ; Next string area address
1378-C3 CB 12    I  2823 (  9)         JP      GARBLP          ; Look for more strings
137B-            I  2824
137B-C5          I  2825 ( 11) CONCAT: PUSH    BC              ; Save prec' opr & code string
137C-E5          I  2826 ( 11)         PUSH    HL              ;
137D-2A 29 23    I  2827 ( 15)         LD      HL,(FPREG)      ; Get first string
1380-E3          I  2828 ( 16)         EX      (SP),HL         ; Save first string
1381-CD 35 0E    I  2829 ( 16)         CALL    OPRND           ; Get second string
1384-E3          I  2830 ( 16)         EX      (SP),HL         ; Restore first string
1385-CD B0 0D    I  2831 ( 16)         CALL    TSTSTR          ; Make sure it's a string
1388-7E          I  2832 (  6)         LD      A,(HL)          ; Get length of second string
1389-E5          I  2833 ( 11)         PUSH    HL              ; Save first string
138A-2A 29 23    I  2834 ( 15)         LD      HL,(FPREG)      ; Get second string
138D-E5          I  2835 ( 11)         PUSH    HL              ; Save second string
138E-86          I  2836 (  6)         ADD     A,(HL)          ; Add length of second string
138F-1E 1C       I  2837 (  6)         LD      E,LS            ; ?LS Error
1391-DA EC 04    I  2838 ( 6+)         JP      C,ERROR         ; String too long - Error
1394-CD 34 12    I  2839 ( 16)         CALL    MKTMST          ; Make temporary string
1397-D1          I  2840 (  9)         POP     DE              ; Get second string to DE
1398-CD CC 13    I  2841 ( 16)         CALL    GSTRDE          ; Move to string pool if needed
139B-E3          I  2842 ( 16)         EX      (SP),HL         ; Get first string
139C-CD CB 13    I  2843 ( 16)         CALL    GSTRHL          ; Move to string pool if needed
139F-E5          I  2844 ( 11)         PUSH    HL              ; Save first string
13A0-2A 06 23    I  2845 ( 15)         LD      HL,(TMPSTR+2)   ; Temporary string address
13A3-EB          I  2846 (  3)         EX      DE,HL           ; To DE
13A4-CD B2 13    I  2847 ( 16)         CALL    SSTSA           ; First string to string area
13A7-CD B2 13    I  2848 ( 16)         CALL    SSTSA           ; Second string to string area
13AA-21 CA 0D    I  2849 (  9)         LD      HL,EVAL2        ; Return to evaluation loop
13AD-E3          I  2850 ( 16)         EX      (SP),HL         ; Save return,get code string
13AE-E5          I  2851 ( 11)         PUSH    HL              ; Save code string address
13AF-C3 65 12    I  2852 (  9)         JP      TSTOPL          ; To temporary string to pool
13B2-            I  2853
13B2-E1          I  2854 (  9) SSTSA:  POP     HL              ; Return address
13B3-E3          I  2855 ( 16)         EX      (SP),HL         ; Get string block,save return
13B4-7E          I  2856 (  6)         LD      A,(HL)          ; Get length of string
13B5-23          I  2857 (  4)         INC     HL
13B6-23          I  2858 (  4)         INC     HL
13B7-4E          I  2859 (  6)         LD      C,(HL)          ; Get LSB of string address
13B8-23          I  2860 (  4)         INC     HL
13B9-46          I  2861 (  6)         LD      B,(HL)          ; Get MSB of string address
13BA-6F          I  2862 (  4)         LD      L,A             ; Length to L
13BB-2C          I  2863 (  4) TOSTRA: INC     L               ; INC - DECed after
13BC-2D          I  2864 (  4) TSALP:  DEC     L               ; Count bytes moved
13BD-C8          I  2865 ( 5+)         RET     Z               ; End of string - Return
13BE-0A          I  2866 (  6)         LD      A,(BC)          ; Get source
13BF-12          I  2867 (  7)         LD      (DE),A          ; Save destination
13C0-03          I  2868 (  4)         INC     BC              ; Next source
13C1-13          I  2869 (  4)         INC     DE              ; Next destination
13C2-C3 BC 13    I  2870 (  9)         JP      TSALP           ; Loop until string moved
13C5-            I  2871
13C5-CD B0 0D    I  2872 ( 16) GETSTR: CALL    TSTSTR          ; Make sure it's a string
13C8-2A 29 23    I  2873 ( 15) GSTRCU: LD      HL,(FPREG)      ; Get current string
13CB-EB          I  2874 (  3) GSTRHL: EX      DE,HL           ; Save DE
13CC-CD E6 13    I  2875 ( 16) GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
13CF-EB          I  2876 (  3)         EX      DE,HL           ; Restore DE
13D0-C0          I  2877 ( 5+)         RET     NZ              ; No - Return
13D1-D5          I  2878 ( 11)         PUSH    DE              ; Save string
13D2-50          I  2879 (  4)         LD      D,B             ; String block address to DE
13D3-59          I  2880 (  4)         LD      E,C
13D4-1B          I  2881 (  4)         DEC     DE              ; Point to length
13D5-4E          I  2882 (  6)         LD      C,(HL)          ; Get string length
13D6-2A 08 23    I  2883 ( 15)         LD      HL,(STRBOT)     ; Current bottom of string area
13D9-CD AF 07    I  2884 ( 16)         CALL    CPDEHL          ; Last one in string area?
13DC-C2 E4 13    I  2885 ( 6+)         JP      NZ,POPHL        ; No - Return
13DF-47          I  2886 (  4)         LD      B,A             ; Clear B (A=0)
13E0-09          I  2887 (  7)         ADD     HL,BC           ; Remove string from str' area
13E1-22 08 23    I  2888 ( 20)         LD      (STRBOT),HL     ; Save new bottom of str' area
13E4-E1          I  2889 (  9) POPHL:  POP     HL              ; Restore string
13E5-C9          I  2890 (  9)         RET
13E6-            I  2891
13E6-2A F6 22    I  2892 ( 15) BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
13E9-2B          I  2893 (  4)         DEC     HL              ; Back
13EA-46          I  2894 (  6)         LD      B,(HL)          ; Get MSB of address
13EB-2B          I  2895 (  4)         DEC     HL              ; Back
13EC-4E          I  2896 (  6)         LD      C,(HL)          ; Get LSB of address
13ED-2B          I  2897 (  4)         DEC     HL              ; Back
13EE-2B          I  2898 (  4)         DEC     HL              ; Back
13EF-CD AF 07    I  2899 ( 16)         CALL    CPDEHL          ; String last in string pool?
13F2-C0          I  2900 ( 5+)         RET     NZ              ; Yes - Leave it
13F3-22 F6 22    I  2901 ( 20)         LD      (TMSTPT),HL     ; Save new string pool top
13F6-C9          I  2902 (  9)         RET
13F7-            I  2903
13F7-01 76 11    I  2904 (  9) LEN:    LD      BC,PASSA        ; To return integer A
13FA-C5          I  2905 ( 11)         PUSH    BC              ; Save address
13FB-CD C5 13    I  2906 ( 16) GETLEN: CALL    GETSTR          ; Get string and its length
13FE-AF          I  2907 (  4)         XOR     A
13FF-57          I  2908 (  4)         LD      D,A             ; Clear D
1400-32 F2 22    I  2909 ( 13)         LD      (TYPE),A        ; Set type to numeric
1403-7E          I  2910 (  6)         LD      A,(HL)          ; Get length of string
1404-B7          I  2911 (  4)         OR      A               ; Set status flags
1405-C9          I  2912 (  9)         RET
1406-            I  2913
1406-01 76 11    I  2914 (  9) ASC:    LD      BC,PASSA        ; To return integer A
1409-C5          I  2915 ( 11)         PUSH    BC              ; Save address
140A-CD FB 13    I  2916 ( 16) GTFLNM: CALL    GETLEN          ; Get length of string
140D-CA 06 0A    I  2917 ( 6+)         JP      Z,FCERR         ; Null string - Error
1410-23          I  2918 (  4)         INC     HL
1411-23          I  2919 (  4)         INC     HL
1412-5E          I  2920 (  6)         LD      E,(HL)          ; Get LSB of address
1413-23          I  2921 (  4)         INC     HL
1414-56          I  2922 (  6)         LD      D,(HL)          ; Get MSB of address
1415-1A          I  2923 (  6)         LD      A,(DE)          ; Get first byte of string
1416-C9          I  2924 (  9)         RET
1417-            I  2925
1417-3E 01       I  2926 (  6) CHR:    LD      A,1             ; One character string
1419-CD 34 12    I  2927 ( 16)         CALL    MKTMST          ; Make a temporary string
141C-CD 10 15    I  2928 ( 16)         CALL    MAKINT          ; Make it integer A
141F-2A 06 23    I  2929 ( 15)         LD      HL,(TMPSTR+2)   ; Get address of string
1422-73          I  2930 (  7)         LD      (HL),E          ; Save character
1423-C1          I  2931 (  9) TOPOOL: POP     BC              ; Clean up stack
1424-C3 65 12    I  2932 (  9)         JP      TSTOPL          ; Temporary string to pool
1427-            I  2933
1427-CD C0 14    I  2934 ( 16) LEFT:   CALL    LFRGNM          ; Get number and ending ")"
142A-AF          I  2935 (  4)         XOR     A               ; Start at first byte in string
142B-E3          I  2936 ( 16) RIGHT1: EX      (SP),HL         ; Save code string,Get string
142C-4F          I  2937 (  4)         LD      C,A             ; Starting position in string
142D-E5          I  2938 ( 11) MID1:   PUSH    HL              ; Save string block address
142E-7E          I  2939 (  6)         LD      A,(HL)          ; Get length of string
142F-B8          I  2940 (  4)         CP      B               ; Compare with number given
1430-DA 35 14    I  2941 ( 6+)         JP      C,ALLFOL        ; All following bytes required
1433-78          I  2942 (  4)         LD      A,B             ; Get new length
1434-11          I  2943               .DB      11H             ; Skip "LD C,0"
1435-0E 00       I  2944 (  6) ALLFOL: LD      C,0             ; First byte of string
1437-C5          I  2945 ( 11)         PUSH    BC              ; Save position in string
1438-CD 9E 12    I  2946 ( 16)         CALL    TESTR           ; See if enough string space
143B-C1          I  2947 (  9)         POP     BC              ; Get position in string
143C-E1          I  2948 (  9)         POP     HL              ; Restore string block address
143D-E5          I  2949 ( 11)         PUSH    HL              ; And re-save it
143E-23          I  2950 (  4)         INC     HL
143F-23          I  2951 (  4)         INC     HL
1440-46          I  2952 (  6)         LD      B,(HL)          ; Get LSB of address
1441-23          I  2953 (  4)         INC     HL
1442-66          I  2954 (  6)         LD      H,(HL)          ; Get MSB of address
1443-68          I  2955 (  4)         LD      L,B             ; HL = address of string
1444-06 00       I  2956 (  6)         LD      B,0             ; BC = starting address
1446-09          I  2957 (  7)         ADD     HL,BC           ; Point to that byte
1447-44          I  2958 (  4)         LD      B,H             ; BC = source string
1448-4D          I  2959 (  4)         LD      C,L
1449-CD 37 12    I  2960 ( 16)         CALL    CRTMST          ; Create a string entry
144C-6F          I  2961 (  4)         LD      L,A             ; Length of new string
144D-CD BB 13    I  2962 ( 16)         CALL    TOSTRA          ; Move string to string area
1450-D1          I  2963 (  9)         POP     DE              ; Clear stack
1451-CD CC 13    I  2964 ( 16)         CALL    GSTRDE          ; Move to string pool if needed
1454-C3 65 12    I  2965 (  9)         JP      TSTOPL          ; Temporary string to pool
1457-            I  2966
1457-CD C0 14    I  2967 ( 16) RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
145A-D1          I  2968 (  9)         POP     DE              ; Get string length
145B-D5          I  2969 ( 11)         PUSH    DE              ; And re-save
145C-1A          I  2970 (  6)         LD      A,(DE)          ; Get length
145D-90          I  2971 (  4)         SUB     B               ; Move back N bytes
145E-C3 2B 14    I  2972 (  9)         JP      RIGHT1          ; Go and get sub-string
1461-            I  2973
1461-EB          I  2974 (  3) MID:    EX      DE,HL           ; Get code string address
1462-7E          I  2975 (  6)         LD      A,(HL)          ; Get next byte ',' or ")"
1463-CD C5 14    I  2976 ( 16)         CALL    MIDNUM          ; Get number supplied
1466-04          I  2977 (  4)         INC     B               ; Is it character zero?
1467-05          I  2978 (  4)         DEC     B
1468-CA 06 0A    I  2979 ( 6+)         JP      Z,FCERR         ; Yes - Error
146B-C5          I  2980 ( 11)         PUSH    BC              ; Save starting position
146C-1E FF       I  2981 (  6)         LD      E,255           ; All of string
146E-FE 29       I  2982 (  6)         CP      ')'             ; Any length given?
1470-CA 7A 14    I  2983 ( 6+)         JP      Z,RSTSTR        ; No - Rest of string
1473-CD B5 07    I  2984 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1476-2C          I  2985               .DB      ','
1477-CD 0D 15    I  2986 ( 16)         CALL    GETINT          ; Get integer 0-255
147A-CD B5 07    I  2987 ( 16) RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
147D-29          I  2988               .DB      ")"
147E-F1          I  2989 (  9)         POP     AF              ; Restore starting position
147F-E3          I  2990 ( 16)         EX      (SP),HL         ; Get string,8ave code string
1480-01 2D 14    I  2991 (  9)         LD      BC,MID1         ; Continuation of MID$ routine
1483-C5          I  2992 ( 11)         PUSH    BC              ; Save for return
1484-3D          I  2993 (  4)         DEC     A               ; Starting position-1
1485-BE          I  2994 (  6)         CP      (HL)            ; Compare with length
1486-06 00       I  2995 (  6)         LD      B,0             ; Zero bytes length
1488-D0          I  2996 ( 5+)         RET     NC              ; Null string if start past end
1489-4F          I  2997 (  4)         LD      C,A             ; Save starting position-1
148A-7E          I  2998 (  6)         LD      A,(HL)          ; Get length of string
148B-91          I  2999 (  4)         SUB     C               ; Subtract start
148C-BB          I  3000 (  4)         CP      E               ; Enough string for it?
148D-47          I  3001 (  4)         LD      B,A             ; Save maximum length available
148E-D8          I  3002 ( 5+)         RET     C               ; Truncate string if needed
148F-43          I  3003 (  4)         LD      B,E             ; Set specified length
1490-C9          I  3004 (  9)         RET                     ; Go and create string
1491-            I  3005
1491-CD FB 13    I  3006 ( 16) VAL:    CALL    GETLEN          ; Get length of string
1494-CA AE 15    I  3007 ( 6+)         JP      Z,RESZER        ; Result zero
1497-5F          I  3008 (  4)         LD      E,A             ; Save length
1498-23          I  3009 (  4)         INC     HL
1499-23          I  3010 (  4)         INC     HL
149A-7E          I  3011 (  6)         LD      A,(HL)          ; Get LSB of address
149B-23          I  3012 (  4)         INC     HL
149C-66          I  3013 (  6)         LD      H,(HL)          ; Get MSB of address
149D-6F          I  3014 (  4)         LD      L,A             ; HL = String address
149E-E5          I  3015 ( 11)         PUSH    HL              ; Save string address
149F-19          I  3016 (  7)         ADD     HL,DE
14A0-46          I  3017 (  6)         LD      B,(HL)          ; Get end of string+1 byte
14A1-72          I  3018 (  7)         LD      (HL),D          ; Zero it to terminate
14A2-E3          I  3019 ( 16)         EX      (SP),HL         ; Save string end,get start
14A3-C5          I  3020 ( 11)         PUSH    BC              ; Save end+1 byte
14A4-7E          I  3021 (  6)         LD      A,(HL)          ; Get starting byte
14A5-FE 24       I  3022 (  6)     CP  '$'             ; Hex number indicated? [function added]
14A7-C2 AF 14    I  3023 ( 6+)     JP  NZ,VAL1
14AA-CD D9 1C    I  3024 ( 16)     CALL        HEXTFP          ; Convert Hex to FPREG
14AD-18 0D       I  3025 (  8)     JR  VAL3
14AF-FE 25       I  3026 (  6) VAL1:   CP      '%'             ; Binary number indicated? [function added]
14B1-C2 B9 14    I  3027 ( 6+)     JP  NZ,VAL2
14B4-CD 49 1D    I  3028 ( 16)     CALL        BINTFP          ; Convert Bin to FPREG
14B7-18 03       I  3029 (  8)     JR  VAL3
14B9-CD 95 18    I  3030 ( 16) VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
14BC-C1          I  3031 (  9) VAL3:   POP     BC              ; Restore end+1 byte
14BD-E1          I  3032 (  9)         POP     HL              ; Restore end+1 address
14BE-70          I  3033 (  7)         LD      (HL),B          ; Put back original byte
14BF-C9          I  3034 (  9)         RET
14C0-            I  3035
14C0-EB          I  3036 (  3) LFRGNM: EX      DE,HL           ; Code string address to HL
14C1-CD B5 07    I  3037 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
14C4-29          I  3038               .DB      ")"
14C5-C1          I  3039 (  9) MIDNUM: POP     BC              ; Get return address
14C6-D1          I  3040 (  9)         POP     DE              ; Get number supplied
14C7-C5          I  3041 ( 11)         PUSH    BC              ; Re-save return address
14C8-43          I  3042 (  4)         LD      B,E             ; Number to B
14C9-C9          I  3043 (  9)         RET
14CA-            I  3044
14CA-CD 10 15    I  3045 ( 16) INP:    CALL    MAKINT          ; Make it integer A
14CD-32 84 22    I  3046 ( 13)         LD      (INPORT),A      ; Set input port
14D0-CD 83 22    I  3047 ( 16)         CALL    INPSUB          ; Get input from port
14D3-C3 76 11    I  3048 (  9)         JP      PASSA           ; Return integer A
14D6-            I  3049
14D6-CD FA 14    I  3050 ( 16) POUT:   CALL    SETIO           ; Set up port number
14D9-C3 4B 22    I  3051 (  9)         JP      OUTSUB          ; Output data and return
14DC-            I  3052
14DC-CD FA 14    I  3053 ( 16) WAIT:   CALL    SETIO           ; Set up port number
14DF-F5          I  3054 ( 11)         PUSH    AF              ; Save AND mask
14E0-1E 00       I  3055 (  6)         LD      E,0             ; Assume zero if none given
14E2-2B          I  3056 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
14E3-CD 3F 09    I  3057 ( 16)         CALL    GETCHR          ; Get next character
14E6-CA F0 14    I  3058 ( 6+)         JP      Z,NOXOR         ; No XOR byte given
14E9-CD B5 07    I  3059 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
14EC-2C          I  3060               .DB      ','
14ED-CD 0D 15    I  3061 ( 16)         CALL    GETINT          ; Get integer 0-255 to XOR with
14F0-C1          I  3062 (  9) NOXOR:  POP     BC              ; Restore AND mask
14F1-CD 83 22    I  3063 ( 16) WAITLP: CALL    INPSUB          ; Get input
14F4-AB          I  3064 (  4)         XOR     E               ; Flip selected bits
14F5-A0          I  3065 (  4)         AND     B               ; Result non-zero?
14F6-CA F1 14    I  3066 ( 6+)         JP      Z,WAITLP        ; No = keep waiting
14F9-C9          I  3067 (  9)         RET
14FA-            I  3068
14FA-CD 0D 15    I  3069 ( 16) SETIO:  CALL    GETINT          ; Get integer 0-255
14FD-32 84 22    I  3070 ( 13)         LD      (INPORT),A      ; Set input port
1500-32 4C 22    I  3071 ( 13)         LD      (OTPORT),A      ; Set output port
1503-CD B5 07    I  3072 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1506-2C          I  3073               .DB      ','
1507-C3 0D 15    I  3074 (  9)         JP      GETINT          ; Get integer 0-255 and return
150A-            I  3075
150A-CD 3F 09    I  3076 ( 16) FNDNUM: CALL    GETCHR          ; Get next character
150D-CD AC 0D    I  3077 ( 16) GETINT: CALL    GETNUM          ; Get a number from 0 to 255
1510-CD EB 09    I  3078 ( 16) MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
1513-7A          I  3079 (  4)         LD      A,D             ; Get MSB of number
1514-B7          I  3080 (  4)         OR      A               ; Zero?
1515-C2 06 0A    I  3081 ( 6+)         JP      NZ,FCERR        ; No - Error
1518-2B          I  3082 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
1519-CD 3F 09    I  3083 ( 16)         CALL    GETCHR          ; Get next character
151C-7B          I  3084 (  4)         LD      A,E             ; Get number to A
151D-C9          I  3085 (  9)         RET
151E-            I  3086
151E-CD F1 09    I  3087 ( 16) PEEK:   CALL    DEINT           ; Get memory address
1521-1A          I  3088 (  6)         LD      A,(DE)          ; Get byte in memory
1522-C3 76 11    I  3089 (  9)         JP      PASSA           ; Return integer A
1525-            I  3090
1525-CD AC 0D    I  3091 ( 16) POKE:   CALL    GETNUM          ; Get memory address
1528-CD F1 09    I  3092 ( 16)         CALL    DEINT           ; Get integer -32768 to 3276
152B-D5          I  3093 ( 11)         PUSH    DE              ; Save memory address
152C-CD B5 07    I  3094 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
152F-2C          I  3095               .DB      ','
1530-CD 0D 15    I  3096 ( 16)         CALL    GETINT          ; Get integer 0-255
1533-D1          I  3097 (  9)         POP     DE              ; Restore memory address
1534-12          I  3098 (  7)         LD      (DE),A          ; Load it into memory
1535-C9          I  3099 (  9)         RET
1536-            I  3100
1536-21 0C 1A    I  3101 (  9) ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
1539-CD DD 17    I  3102 ( 16) ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
153C-C3 48 15    I  3103 (  9)         JP      FPADD           ; Add BCDE to FPREG
153F-            I  3104
153F-CD DD 17    I  3105 ( 16) SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
1542-21          I  3106               .DB      21H             ; Skip "POP BC" and "POP DE"
1543-C1          I  3107 (  9) PSUB:   POP     BC              ; Get FP number from stack
1544-D1          I  3108 (  9)         POP     DE
1545-CD B7 17    I  3109 ( 16) SUBCDE: CALL    INVSGN          ; Negate FPREG
1548-78          I  3110 (  4) FPADD:  LD      A,B             ; Get FP exponent
1549-B7          I  3111 (  4)         OR      A               ; Is number zero?
154A-C8          I  3112 ( 5+)         RET     Z               ; Yes - Nothing to add
154B-3A 2C 23    I  3113 ( 12)         LD      A,(FPEXP)       ; Get FPREG exponent
154E-B7          I  3114 (  4)         OR      A               ; Is this number zero?
154F-CA CF 17    I  3115 ( 6+)         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
1552-90          I  3116 (  4)         SUB     B               ; BCDE number larger?
1553-D2 62 15    I  3117 ( 6+)         JP      NC,NOSWAP       ; No - Don't swap them
1556-2F          I  3118 (  3)         CPL                     ; Two's complement
1557-3C          I  3119 (  4)         INC     A               ;  FP exponent
1558-EB          I  3120 (  3)         EX      DE,HL
1559-CD BF 17    I  3121 ( 16)         CALL    STAKFP          ; Put FPREG on stack
155C-EB          I  3122 (  3)         EX      DE,HL
155D-CD CF 17    I  3123 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
1560-C1          I  3124 (  9)         POP     BC              ; Restore number from stack
1561-D1          I  3125 (  9)         POP     DE
1562-FE 19       I  3126 (  6) NOSWAP: CP      24+1            ; Second number insignificant?
1564-D0          I  3127 ( 5+)         RET     NC              ; Yes - First number is result
1565-F5          I  3128 ( 11)         PUSH    AF              ; Save number of bits to scale
1566-CD F4 17    I  3129 ( 16)         CALL    SIGNS           ; Set MSBs & sign of result
1569-67          I  3130 (  4)         LD      H,A             ; Save sign of result
156A-F1          I  3131 (  9)         POP     AF              ; Restore scaling factor
156B-CD 0D 16    I  3132 ( 16)         CALL    SCALE           ; Scale BCDE to same exponent
156E-B4          I  3133 (  4)         OR      H               ; Result to be positive?
156F-21 29 23    I  3134 (  9)         LD      HL,FPREG        ; Point to FPREG
1572-F2 88 15    I  3135 ( 6+)         JP      P,MINCDE        ; No - Subtract FPREG from CDE
1575-CD ED 15    I  3136 ( 16)         CALL    PLUCDE          ; Add FPREG to CDE
1578-D2 CE 15    I  3137 ( 6+)         JP      NC,RONDUP       ; No overflow - Round it up
157B-23          I  3138 (  4)         INC     HL              ; Point to exponent
157C-34          I  3139 ( 10)         INC     (HL)            ; Increment it
157D-CA E7 04    I  3140 ( 6+)         JP      Z,OVERR         ; Number overflowed - Error
1580-2E 01       I  3141 (  6)         LD      L,1             ; 1 bit to shift right
1582-CD 23 16    I  3142 ( 16)         CALL    SHRT1           ; Shift result right
1585-C3 CE 15    I  3143 (  9)         JP      RONDUP          ; Round it up
1588-            I  3144
1588-AF          I  3145 (  4) MINCDE: XOR     A               ; Clear A and carry
1589-90          I  3146 (  4)         SUB     B               ; Negate exponent
158A-47          I  3147 (  4)         LD      B,A             ; Re-save exponent
158B-7E          I  3148 (  6)         LD      A,(HL)          ; Get LSB of FPREG
158C-9B          I  3149 (  4)         SBC     A, E            ; Subtract LSB of BCDE
158D-5F          I  3150 (  4)         LD      E,A             ; Save LSB of BCDE
158E-23          I  3151 (  4)         INC     HL
158F-7E          I  3152 (  6)         LD      A,(HL)          ; Get NMSB of FPREG
1590-9A          I  3153 (  4)         SBC     A,D             ; Subtract NMSB of BCDE
1591-57          I  3154 (  4)         LD      D,A             ; Save NMSB of BCDE
1592-23          I  3155 (  4)         INC     HL
1593-7E          I  3156 (  6)         LD      A,(HL)          ; Get MSB of FPREG
1594-99          I  3157 (  4)         SBC     A,C             ; Subtract MSB of BCDE
1595-4F          I  3158 (  4)         LD      C,A             ; Save MSB of BCDE
1596-DC F9 15    I  3159 ( 6+) CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
1599-            I  3160
1599-68          I  3161 (  4) BNORM:  LD      L,B             ; L = Exponent
159A-63          I  3162 (  4)         LD      H,E             ; H = LSB
159B-AF          I  3163 (  4)         XOR     A
159C-47          I  3164 (  4) BNRMLP: LD      B,A             ; Save bit count
159D-79          I  3165 (  4)         LD      A,C             ; Get MSB
159E-B7          I  3166 (  4)         OR      A               ; Is it zero?
159F-C2 BB 15    I  3167 ( 6+)         JP      NZ,PNORM        ; No - Do it bit at a time
15A2-4A          I  3168 (  4)         LD      C,D             ; MSB = NMSB
15A3-54          I  3169 (  4)         LD      D,H             ; NMSB= LSB
15A4-65          I  3170 (  4)         LD      H,L             ; LSB = VLSB
15A5-6F          I  3171 (  4)         LD      L,A             ; VLSB= 0
15A6-78          I  3172 (  4)         LD      A,B             ; Get exponent
15A7-D6 08       I  3173 (  6)         SUB     8               ; Count 8 bits
15A9-FE E0       I  3174 (  6)         CP      -24-8           ; Was number zero?
15AB-C2 9C 15    I  3175 ( 6+)         JP      NZ,BNRMLP       ; No - Keep normalising
15AE-AF          I  3176 (  4) RESZER: XOR     A               ; Result is zero
15AF-32 2C 23    I  3177 ( 13) SAVEXP: LD      (FPEXP),A       ; Save result as zero
15B2-C9          I  3178 (  9)         RET
15B3-            I  3179
15B3-05          I  3180 (  4) NORMAL: DEC     B               ; Count bits
15B4-29          I  3181 (  7)         ADD     HL,HL           ; Shift HL left
15B5-7A          I  3182 (  4)         LD      A,D             ; Get NMSB
15B6-17          I  3183 (  3)         RLA                     ; Shift left with last bit
15B7-57          I  3184 (  4)         LD      D,A             ; Save NMSB
15B8-79          I  3185 (  4)         LD      A,C             ; Get MSB
15B9-8F          I  3186 (  4)         ADC     A,A             ; Shift left with last bit
15BA-4F          I  3187 (  4)         LD      C,A             ; Save MSB
15BB-F2 B3 15    I  3188 ( 6+) PNORM:  JP      P,NORMAL        ; Not done - Keep going
15BE-78          I  3189 (  4)         LD      A,B             ; Number of bits shifted
15BF-5C          I  3190 (  4)         LD      E,H             ; Save HL in EB
15C0-45          I  3191 (  4)         LD      B,L
15C1-B7          I  3192 (  4)         OR      A               ; Any shifting done?
15C2-CA CE 15    I  3193 ( 6+)         JP      Z,RONDUP        ; No - Round it up
15C5-21 2C 23    I  3194 (  9)         LD      HL,FPEXP        ; Point to exponent
15C8-86          I  3195 (  6)         ADD     A,(HL)          ; Add shifted bits
15C9-77          I  3196 (  7)         LD      (HL),A          ; Re-save exponent
15CA-D2 AE 15    I  3197 ( 6+)         JP      NC,RESZER       ; Underflow - Result is zero
15CD-C8          I  3198 ( 5+)         RET     Z               ; Result is zero
15CE-78          I  3199 (  4) RONDUP: LD      A,B             ; Get VLSB of number
15CF-21 2C 23    I  3200 (  9) RONDB:  LD      HL,FPEXP        ; Point to exponent
15D2-B7          I  3201 (  4)         OR      A               ; Any rounding?
15D3-FC E0 15    I  3202 ( 6+)         CALL    M,FPROND        ; Yes - Round number up
15D6-46          I  3203 (  6)         LD      B,(HL)          ; B = Exponent
15D7-23          I  3204 (  4)         INC     HL
15D8-7E          I  3205 (  6)         LD      A,(HL)          ; Get sign of result
15D9-E6 80       I  3206 (  6)         AND     10000000B       ; Only bit 7 needed
15DB-A9          I  3207 (  4)         XOR     C               ; Set correct sign
15DC-4F          I  3208 (  4)         LD      C,A             ; Save correct sign in number
15DD-C3 CF 17    I  3209 (  9)         JP      FPBCDE          ; Move BCDE to FPREG
15E0-            I  3210
15E0-1C          I  3211 (  4) FPROND: INC     E               ; Round LSB
15E1-C0          I  3212 ( 5+)         RET     NZ              ; Return if ok
15E2-14          I  3213 (  4)         INC     D               ; Round NMSB
15E3-C0          I  3214 ( 5+)         RET     NZ              ; Return if ok
15E4-0C          I  3215 (  4)         INC     C               ; Round MSB
15E5-C0          I  3216 ( 5+)         RET     NZ              ; Return if ok
15E6-0E 80       I  3217 (  6)         LD      C,80H           ; Set normal value
15E8-34          I  3218 ( 10)         INC     (HL)            ; Increment exponent
15E9-C0          I  3219 ( 5+)         RET     NZ              ; Return if ok
15EA-C3 E7 04    I  3220 (  9)         JP      OVERR           ; Overflow error
15ED-            I  3221
15ED-7E          I  3222 (  6) PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
15EE-83          I  3223 (  4)         ADD     A,E             ; Add LSB of BCDE
15EF-5F          I  3224 (  4)         LD      E,A             ; Save LSB of BCDE
15F0-23          I  3225 (  4)         INC     HL
15F1-7E          I  3226 (  6)         LD      A,(HL)          ; Get NMSB of FPREG
15F2-8A          I  3227 (  4)         ADC     A,D             ; Add NMSB of BCDE
15F3-57          I  3228 (  4)         LD      D,A             ; Save NMSB of BCDE
15F4-23          I  3229 (  4)         INC     HL
15F5-7E          I  3230 (  6)         LD      A,(HL)          ; Get MSB of FPREG
15F6-89          I  3231 (  4)         ADC     A,C             ; Add MSB of BCDE
15F7-4F          I  3232 (  4)         LD      C,A             ; Save MSB of BCDE
15F8-C9          I  3233 (  9)         RET
15F9-            I  3234
15F9-21 2D 23    I  3235 (  9) COMPL:  LD      HL,SGNRES       ; Sign of result
15FC-7E          I  3236 (  6)         LD      A,(HL)          ; Get sign of result
15FD-2F          I  3237 (  3)         CPL                     ; Negate it
15FE-77          I  3238 (  7)         LD      (HL),A          ; Put it back
15FF-AF          I  3239 (  4)         XOR     A
1600-6F          I  3240 (  4)         LD      L,A             ; Set L to zero
1601-90          I  3241 (  4)         SUB     B               ; Negate exponent,set carry
1602-47          I  3242 (  4)         LD      B,A             ; Re-save exponent
1603-7D          I  3243 (  4)         LD      A,L             ; Load zero
1604-9B          I  3244 (  4)         SBC     A,E             ; Negate LSB
1605-5F          I  3245 (  4)         LD      E,A             ; Re-save LSB
1606-7D          I  3246 (  4)         LD      A,L             ; Load zero
1607-9A          I  3247 (  4)         SBC     A,D             ; Negate NMSB
1608-57          I  3248 (  4)         LD      D,A             ; Re-save NMSB
1609-7D          I  3249 (  4)         LD      A,L             ; Load zero
160A-99          I  3250 (  4)         SBC     A,C             ; Negate MSB
160B-4F          I  3251 (  4)         LD      C,A             ; Re-save MSB
160C-C9          I  3252 (  9)         RET
160D-            I  3253
160D-06 00       I  3254 (  6) SCALE:  LD      B,0             ; Clear underflow
160F-D6 08       I  3255 (  6) SCALLP: SUB     8               ; 8 bits (a whole byte)?
1611-DA 1C 16    I  3256 ( 6+)         JP      C,SHRITE        ; No - Shift right A bits
1614-43          I  3257 (  4)         LD      B,E             ; <- Shift
1615-5A          I  3258 (  4)         LD      E,D             ; <- right
1616-51          I  3259 (  4)         LD      D,C             ; <- eight
1617-0E 00       I  3260 (  6)         LD      C,0             ; <- bits
1619-C3 0F 16    I  3261 (  9)         JP      SCALLP          ; More bits to shift
161C-            I  3262
161C-C6 09       I  3263 (  6) SHRITE: ADD     A,8+1           ; Adjust count
161E-6F          I  3264 (  4)         LD      L,A             ; Save bits to shift
161F-AF          I  3265 (  4) SHRLP:  XOR     A               ; Flag for all done
1620-2D          I  3266 (  4)         DEC     L               ; All shifting done?
1621-C8          I  3267 ( 5+)         RET     Z               ; Yes - Return
1622-79          I  3268 (  4)         LD      A,C             ; Get MSB
1623-1F          I  3269 (  3) SHRT1:  RRA                     ; Shift it right
1624-4F          I  3270 (  4)         LD      C,A             ; Re-save
1625-7A          I  3271 (  4)         LD      A,D             ; Get NMSB
1626-1F          I  3272 (  3)         RRA                     ; Shift right with last bit
1627-57          I  3273 (  4)         LD      D,A             ; Re-save it
1628-7B          I  3274 (  4)         LD      A,E             ; Get LSB
1629-1F          I  3275 (  3)         RRA                     ; Shift right with last bit
162A-5F          I  3276 (  4)         LD      E,A             ; Re-save it
162B-78          I  3277 (  4)         LD      A,B             ; Get underflow
162C-1F          I  3278 (  3)         RRA                     ; Shift right with last bit
162D-47          I  3279 (  4)         LD      B,A             ; Re-save underflow
162E-C3 1F 16    I  3280 (  9)         JP      SHRLP           ; More bits to do
1631-            I  3281
1631-00 00 00 81 I  3282       UNITY:  .DB       000H,000H,000H,081H    ; 1.00000
1635-            I  3283
1635-03          I  3284       LOGTAB: .DB      3                       ; Table used by LOG
1636-AA 56 19 80 I  3285               .DB      0AAH,056H,019H,080H     ; 0.59898
163A-F1 22 76 80 I  3286               .DB      0F1H,022H,076H,080H     ; 0.96147
163E-45 AA 38 82 I  3287               .DB      045H,0AAH,038H,082H     ; 2.88539
1642-            I  3288
1642-CD 8E 17    I  3289 ( 16) LOG:    CALL    TSTSGN          ; Test sign of value
1645-B7          I  3290 (  4)         OR      A
1646-EA 06 0A    I  3291 ( 6+)         JP      PE,FCERR        ; ?FC Error if <= zero
1649-21 2C 23    I  3292 (  9)         LD      HL,FPEXP        ; Point to exponent
164C-7E          I  3293 (  6)         LD      A,(HL)          ; Get exponent
164D-01 35 80    I  3294 (  9)         LD      BC,8035H        ; BCDE = SQR(1/2)
1650-11 F3 04    I  3295 (  9)         LD      DE,04F3H
1653-90          I  3296 (  4)         SUB     B               ; Scale value to be < 1
1654-F5          I  3297 ( 11)         PUSH    AF              ; Save scale factor
1655-70          I  3298 (  7)         LD      (HL),B          ; Save new exponent
1656-D5          I  3299 ( 11)         PUSH    DE              ; Save SQR(1/2)
1657-C5          I  3300 ( 11)         PUSH    BC
1658-CD 48 15    I  3301 ( 16)         CALL    FPADD           ; Add SQR(1/2) to value
165B-C1          I  3302 (  9)         POP     BC              ; Restore SQR(1/2)
165C-D1          I  3303 (  9)         POP     DE
165D-04          I  3304 (  4)         INC     B               ; Make it SQR(2)
165E-CD E4 16    I  3305 ( 16)         CALL    DVBCDE          ; Divide by SQR(2)
1661-21 31 16    I  3306 (  9)         LD      HL,UNITY        ; Point to 1.
1664-CD 3F 15    I  3307 ( 16)         CALL    SUBPHL          ; Subtract FPREG from 1
1667-21 35 16    I  3308 (  9)         LD      HL,LOGTAB       ; Coefficient table
166A-CD D6 1A    I  3309 ( 16)         CALL    SUMSER          ; Evaluate sum of series
166D-01 80 80    I  3310 (  9)         LD      BC,8080H        ; BCDE = -0.5
1670-11 00 00    I  3311 (  9)         LD      DE,0000H
1673-CD 48 15    I  3312 ( 16)         CALL    FPADD           ; Subtract 0.5 from FPREG
1676-F1          I  3313 (  9)         POP     AF              ; Restore scale factor
1677-CD 09 19    I  3314 ( 16)         CALL    RSCALE          ; Re-scale number
167A-01 31 80    I  3315 (  9) MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
167D-11 18 72    I  3316 (  9)         LD      DE,7218H
1680-21          I  3317               .DB      21H             ; Skip "POP BC" and "POP DE"
1681-            I  3318
1681-C1          I  3319 (  9) MULT:   POP     BC              ; Get number from stack
1682-D1          I  3320 (  9)         POP     DE
1683-CD 8E 17    I  3321 ( 16) FPMULT: CALL    TSTSGN          ; Test sign of FPREG
1686-C8          I  3322 ( 5+)         RET     Z               ; Return zero if zero
1687-2E 00       I  3323 (  6)         LD      L,0             ; Flag add exponents
1689-CD 4C 17    I  3324 ( 16)         CALL    ADDEXP          ; Add exponents
168C-79          I  3325 (  4)         LD      A,C             ; Get MSB of multiplier
168D-32 3B 23    I  3326 ( 13)         LD      (MULVAL),A      ; Save MSB of multiplier
1690-EB          I  3327 (  3)         EX      DE,HL
1691-22 3C 23    I  3328 ( 20)         LD      (MULVAL+1),HL   ; Save rest of multiplier
1694-01 00 00    I  3329 (  9)         LD      BC,0            ; Partial product (BCDE) = zero
1697-50          I  3330 (  4)         LD      D,B
1698-58          I  3331 (  4)         LD      E,B
1699-21 99 15    I  3332 (  9)         LD      HL,BNORM        ; Address of normalise
169C-E5          I  3333 ( 11)         PUSH    HL              ; Save for return
169D-21 A5 16    I  3334 (  9)         LD      HL,MULT8        ; Address of 8 bit multiply
16A0-E5          I  3335 ( 11)         PUSH    HL              ; Save for NMSB,MSB
16A1-E5          I  3336 ( 11)         PUSH    HL              ;
16A2-21 29 23    I  3337 (  9)         LD      HL,FPREG        ; Point to number
16A5-7E          I  3338 (  6) MULT8:  LD      A,(HL)          ; Get LSB of number
16A6-23          I  3339 (  4)         INC     HL              ; Point to NMSB
16A7-B7          I  3340 (  4)         OR      A               ; Test LSB
16A8-CA D1 16    I  3341 ( 6+)         JP      Z,BYTSFT        ; Zero - shift to next byte
16AB-E5          I  3342 ( 11)         PUSH    HL              ; Save address of number
16AC-2E 08       I  3343 (  6)         LD      L,8             ; 8 bits to multiply by
16AE-1F          I  3344 (  3) MUL8LP: RRA                     ; Shift LSB right
16AF-67          I  3345 (  4)         LD      H,A             ; Save LSB
16B0-79          I  3346 (  4)         LD      A,C             ; Get MSB
16B1-D2 BF 16    I  3347 ( 6+)         JP      NC,NOMADD       ; Bit was zero - Don't add
16B4-E5          I  3348 ( 11)         PUSH    HL              ; Save LSB and count
16B5-2A 3C 23    I  3349 ( 15)         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
16B8-19          I  3350 (  7)         ADD     HL,DE           ; Add NMSB and LSB
16B9-EB          I  3351 (  3)         EX      DE,HL           ; Leave sum in DE
16BA-E1          I  3352 (  9)         POP     HL              ; Restore MSB and count
16BB-3A 3B 23    I  3353 ( 12)         LD      A,(MULVAL)      ; Get MSB of multiplier
16BE-89          I  3354 (  4)         ADC     A,C             ; Add MSB
16BF-1F          I  3355 (  3) NOMADD: RRA                     ; Shift MSB right
16C0-4F          I  3356 (  4)         LD      C,A             ; Re-save MSB
16C1-7A          I  3357 (  4)         LD      A,D             ; Get NMSB
16C2-1F          I  3358 (  3)         RRA                     ; Shift NMSB right
16C3-57          I  3359 (  4)         LD      D,A             ; Re-save NMSB
16C4-7B          I  3360 (  4)         LD      A,E             ; Get LSB
16C5-1F          I  3361 (  3)         RRA                     ; Shift LSB right
16C6-5F          I  3362 (  4)         LD      E,A             ; Re-save LSB
16C7-78          I  3363 (  4)         LD      A,B             ; Get VLSB
16C8-1F          I  3364 (  3)         RRA                     ; Shift VLSB right
16C9-47          I  3365 (  4)         LD      B,A             ; Re-save VLSB
16CA-2D          I  3366 (  4)         DEC     L               ; Count bits multiplied
16CB-7C          I  3367 (  4)         LD      A,H             ; Get LSB of multiplier
16CC-C2 AE 16    I  3368 ( 6+)         JP      NZ,MUL8LP       ; More - Do it
16CF-E1          I  3369 (  9) POPHRT: POP     HL              ; Restore address of number
16D0-C9          I  3370 (  9)         RET
16D1-            I  3371
16D1-43          I  3372 (  4) BYTSFT: LD      B,E             ; Shift partial product left
16D2-5A          I  3373 (  4)         LD      E,D
16D3-51          I  3374 (  4)         LD      D,C
16D4-4F          I  3375 (  4)         LD      C,A
16D5-C9          I  3376 (  9)         RET
16D6-            I  3377
16D6-CD BF 17    I  3378 ( 16) DIV10:  CALL    STAKFP          ; Save FPREG on stack
16D9-01 20 84    I  3379 (  9)         LD      BC,8420H        ; BCDE = 10.
16DC-11 00 00    I  3380 (  9)         LD      DE,0000H
16DF-CD CF 17    I  3381 ( 16)         CALL    FPBCDE          ; Move 10 to FPREG
16E2-            I  3382
16E2-C1          I  3383 (  9) DIV:    POP     BC              ; Get number from stack
16E3-D1          I  3384 (  9)         POP     DE
16E4-CD 8E 17    I  3385 ( 16) DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
16E7-CA DB 04    I  3386 ( 6+)         JP      Z,DZERR         ; Error if division by zero
16EA-2E FF       I  3387 (  6)         LD      L,-1            ; Flag subtract exponents
16EC-CD 4C 17    I  3388 ( 16)         CALL    ADDEXP          ; Subtract exponents
16EF-34          I  3389 ( 10)         INC     (HL)            ; Add 2 to exponent to adjust
16F0-34          I  3390 ( 10)         INC     (HL)
16F1-2B          I  3391 (  4)         DEC     HL              ; Point to MSB
16F2-7E          I  3392 (  6)         LD      A,(HL)          ; Get MSB of dividend
16F3-32 57 22    I  3393 ( 13)         LD      (DIV3),A        ; Save for subtraction
16F6-2B          I  3394 (  4)         DEC     HL
16F7-7E          I  3395 (  6)         LD      A,(HL)          ; Get NMSB of dividend
16F8-32 53 22    I  3396 ( 13)         LD      (DIV2),A        ; Save for subtraction
16FB-2B          I  3397 (  4)         DEC     HL
16FC-7E          I  3398 (  6)         LD      A,(HL)          ; Get MSB of dividend
16FD-32 4F 22    I  3399 ( 13)         LD      (DIV1),A        ; Save for subtraction
1700-41          I  3400 (  4)         LD      B,C             ; Get MSB
1701-EB          I  3401 (  3)         EX      DE,HL           ; NMSB,LSB to HL
1702-AF          I  3402 (  4)         XOR     A
1703-4F          I  3403 (  4)         LD      C,A             ; Clear MSB of quotient
1704-57          I  3404 (  4)         LD      D,A             ; Clear NMSB of quotient
1705-5F          I  3405 (  4)         LD      E,A             ; Clear LSB of quotient
1706-32 5A 22    I  3406 ( 13)         LD      (DIV4),A        ; Clear overflow count
1709-E5          I  3407 ( 11) DIVLP:  PUSH    HL              ; Save divisor
170A-C5          I  3408 ( 11)         PUSH    BC
170B-7D          I  3409 (  4)         LD      A,L             ; Get LSB of number
170C-CD 4E 22    I  3410 ( 16)         CALL    DIVSUP          ; Subt' divisor from dividend
170F-DE 00       I  3411 (  6)         SBC     A,0             ; Count for overflows
1711-3F          I  3412 (  3)         CCF
1712-D2 1C 17    I  3413 ( 6+)         JP      NC,RESDIV       ; Restore divisor if borrow
1715-32 5A 22    I  3414 ( 13)         LD      (DIV4),A        ; Re-save overflow count
1718-F1          I  3415 (  9)         POP     AF              ; Scrap divisor
1719-F1          I  3416 (  9)         POP     AF
171A-37          I  3417 (  3)         SCF                     ; Set carry to
171B-D2          I  3418               .DB      0D2H            ; Skip "POP BC" and "POP HL"
171C-            I  3419
171C-C1          I  3420 (  9) RESDIV: POP     BC              ; Restore divisor
171D-E1          I  3421 (  9)         POP     HL
171E-79          I  3422 (  4)         LD      A,C             ; Get MSB of quotient
171F-3C          I  3423 (  4)         INC     A
1720-3D          I  3424 (  4)         DEC     A
1721-1F          I  3425 (  3)         RRA                     ; Bit 0 to bit 7
1722-FA CF 15    I  3426 ( 6+)         JP      M,RONDB         ; Done - Normalise result
1725-17          I  3427 (  3)         RLA                     ; Restore carry
1726-7B          I  3428 (  4)         LD      A,E             ; Get LSB of quotient
1727-17          I  3429 (  3)         RLA                     ; Double it
1728-5F          I  3430 (  4)         LD      E,A             ; Put it back
1729-7A          I  3431 (  4)         LD      A,D             ; Get NMSB of quotient
172A-17          I  3432 (  3)         RLA                     ; Double it
172B-57          I  3433 (  4)         LD      D,A             ; Put it back
172C-79          I  3434 (  4)         LD      A,C             ; Get MSB of quotient
172D-17          I  3435 (  3)         RLA                     ; Double it
172E-4F          I  3436 (  4)         LD      C,A             ; Put it back
172F-29          I  3437 (  7)         ADD     HL,HL           ; Double NMSB,LSB of divisor
1730-78          I  3438 (  4)         LD      A,B             ; Get MSB of divisor
1731-17          I  3439 (  3)         RLA                     ; Double it
1732-47          I  3440 (  4)         LD      B,A             ; Put it back
1733-3A 5A 22    I  3441 ( 12)         LD      A,(DIV4)        ; Get VLSB of quotient
1736-17          I  3442 (  3)         RLA                     ; Double it
1737-32 5A 22    I  3443 ( 13)         LD      (DIV4),A        ; Put it back
173A-79          I  3444 (  4)         LD      A,C             ; Get MSB of quotient
173B-B2          I  3445 (  4)         OR      D               ; Merge NMSB
173C-B3          I  3446 (  4)         OR      E               ; Merge LSB
173D-C2 09 17    I  3447 ( 6+)         JP      NZ,DIVLP        ; Not done - Keep dividing
1740-E5          I  3448 ( 11)         PUSH    HL              ; Save divisor
1741-21 2C 23    I  3449 (  9)         LD      HL,FPEXP        ; Point to exponent
1744-35          I  3450 ( 10)         DEC     (HL)            ; Divide by 2
1745-E1          I  3451 (  9)         POP     HL              ; Restore divisor
1746-C2 09 17    I  3452 ( 6+)         JP      NZ,DIVLP        ; Ok - Keep going
1749-C3 E7 04    I  3453 (  9)         JP      OVERR           ; Overflow error
174C-            I  3454
174C-78          I  3455 (  4) ADDEXP: LD      A,B             ; Get exponent of dividend
174D-B7          I  3456 (  4)         OR      A               ; Test it
174E-CA 70 17    I  3457 ( 6+)         JP      Z,OVTST3        ; Zero - Result zero
1751-7D          I  3458 (  4)         LD      A,L             ; Get add/subtract flag
1752-21 2C 23    I  3459 (  9)         LD      HL,FPEXP        ; Point to exponent
1755-AE          I  3460 (  6)         XOR     (HL)            ; Add or subtract it
1756-80          I  3461 (  4)         ADD     A,B             ; Add the other exponent
1757-47          I  3462 (  4)         LD      B,A             ; Save new exponent
1758-1F          I  3463 (  3)         RRA                     ; Test exponent for overflow
1759-A8          I  3464 (  4)         XOR     B
175A-78          I  3465 (  4)         LD      A,B             ; Get exponent
175B-F2 6F 17    I  3466 ( 6+)         JP      P,OVTST2        ; Positive - Test for overflow
175E-C6 80       I  3467 (  6)         ADD     A,80H           ; Add excess 128
1760-77          I  3468 (  7)         LD      (HL),A          ; Save new exponent
1761-CA CF 16    I  3469 ( 6+)         JP      Z,POPHRT        ; Zero - Result zero
1764-CD F4 17    I  3470 ( 16)         CALL    SIGNS           ; Set MSBs and sign of result
1767-77          I  3471 (  7)         LD      (HL),A          ; Save new exponent
1768-2B          I  3472 (  4)         DEC     HL              ; Point to MSB
1769-C9          I  3473 (  9)         RET
176A-            I  3474
176A-CD 8E 17    I  3475 ( 16) OVTST1: CALL    TSTSGN          ; Test sign of FPREG
176D-2F          I  3476 (  3)         CPL                     ; Invert sign
176E-E1          I  3477 (  9)         POP     HL              ; Clean up stack
176F-B7          I  3478 (  4) OVTST2: OR      A               ; Test if new exponent zero
1770-E1          I  3479 (  9) OVTST3: POP     HL              ; Clear off return address
1771-F2 AE 15    I  3480 ( 6+)         JP      P,RESZER        ; Result zero
1774-C3 E7 04    I  3481 (  9)         JP      OVERR           ; Overflow error
1777-            I  3482
1777-CD DA 17    I  3483 ( 16) MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
177A-78          I  3484 (  4)         LD      A,B             ; Get exponent
177B-B7          I  3485 (  4)         OR      A               ; Is it zero?
177C-C8          I  3486 ( 5+)         RET     Z               ; Yes - Result is zero
177D-C6 02       I  3487 (  6)         ADD     A,2             ; Multiply by 4
177F-DA E7 04    I  3488 ( 6+)         JP      C,OVERR         ; Overflow - ?OV Error
1782-47          I  3489 (  4)         LD      B,A             ; Re-save exponent
1783-CD 48 15    I  3490 ( 16)         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
1786-21 2C 23    I  3491 (  9)         LD      HL,FPEXP        ; Point to exponent
1789-34          I  3492 ( 10)         INC     (HL)            ; Double number (Times 10)
178A-C0          I  3493 ( 5+)         RET     NZ              ; Ok - Return
178B-C3 E7 04    I  3494 (  9)         JP      OVERR           ; Overflow error
178E-            I  3495
178E-3A 2C 23    I  3496 ( 12) TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
1791-B7          I  3497 (  4)         OR      A
1792-C8          I  3498 ( 5+)         RET     Z               ; RETurn if number is zero
1793-3A 2B 23    I  3499 ( 12)         LD      A,(FPREG+2)     ; Get MSB of FPREG
1796-FE          I  3500               .DB      0FEH            ; Test sign
1797-2F          I  3501 (  3) RETREL: CPL                     ; Invert sign
1798-17          I  3502 (  3)         RLA                     ; Sign bit to carry
1799-9F          I  3503 (  4) FLGDIF: SBC     A,A             ; Carry to all bits of A
179A-C0          I  3504 ( 5+)         RET     NZ              ; Return -1 if negative
179B-3C          I  3505 (  4)         INC     A               ; Bump to +1
179C-C9          I  3506 (  9)         RET                     ; Positive - Return +1
179D-            I  3507
179D-CD 8E 17    I  3508 ( 16) SGN:    CALL    TSTSGN          ; Test sign of FPREG
17A0-06 88       I  3509 (  6) FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
17A2-11 00 00    I  3510 (  9)         LD      DE,0            ; Zero NMSB and LSB
17A5-21 2C 23    I  3511 (  9) RETINT: LD      HL,FPEXP        ; Point to exponent
17A8-4F          I  3512 (  4)         LD      C,A             ; CDE = MSB,NMSB and LSB
17A9-70          I  3513 (  7)         LD      (HL),B          ; Save exponent
17AA-06 00       I  3514 (  6)         LD      B,0             ; CDE = integer to normalise
17AC-23          I  3515 (  4)         INC     HL              ; Point to sign of result
17AD-36 80       I  3516 (  9)         LD      (HL),80H        ; Set sign of result
17AF-17          I  3517 (  3)         RLA                     ; Carry = sign of integer
17B0-C3 96 15    I  3518 (  9)         JP      CONPOS          ; Set sign of result
17B3-            I  3519
17B3-CD 8E 17    I  3520 ( 16) ABS:    CALL    TSTSGN          ; Test sign of FPREG
17B6-F0          I  3521 ( 5+)         RET     P               ; Return if positive
17B7-21 2B 23    I  3522 (  9) INVSGN: LD      HL,FPREG+2      ; Point to MSB
17BA-7E          I  3523 (  6)         LD      A,(HL)          ; Get sign of mantissa
17BB-EE 80       I  3524 (  6)         XOR     80H             ; Invert sign of mantissa
17BD-77          I  3525 (  7)         LD      (HL),A          ; Re-save sign of mantissa
17BE-C9          I  3526 (  9)         RET
17BF-            I  3527
17BF-EB          I  3528 (  3) STAKFP: EX      DE,HL           ; Save code string address
17C0-2A 29 23    I  3529 ( 15)         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
17C3-E3          I  3530 ( 16)         EX      (SP),HL         ; Stack them,get return
17C4-E5          I  3531 ( 11)         PUSH    HL              ; Re-save return
17C5-2A 2B 23    I  3532 ( 15)         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
17C8-E3          I  3533 ( 16)         EX      (SP),HL         ; Stack them,get return
17C9-E5          I  3534 ( 11)         PUSH    HL              ; Re-save return
17CA-EB          I  3535 (  3)         EX      DE,HL           ; Restore code string address
17CB-C9          I  3536 (  9)         RET
17CC-            I  3537
17CC-CD DD 17    I  3538 ( 16) PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
17CF-EB          I  3539 (  3) FPBCDE: EX      DE,HL           ; Save code string address
17D0-22 29 23    I  3540 ( 20)         LD      (FPREG),HL      ; Save LSB,NLSB of number
17D3-60          I  3541 (  4)         LD      H,B             ; Exponent of number
17D4-69          I  3542 (  4)         LD      L,C             ; MSB of number
17D5-22 2B 23    I  3543 ( 20)         LD      (FPREG+2),HL    ; Save MSB and exponent
17D8-EB          I  3544 (  3)         EX      DE,HL           ; Restore code string address
17D9-C9          I  3545 (  9)         RET
17DA-            I  3546
17DA-21 29 23    I  3547 (  9) BCDEFP: LD      HL,FPREG        ; Point to FPREG
17DD-5E          I  3548 (  6) LOADFP: LD      E,(HL)          ; Get LSB of number
17DE-23          I  3549 (  4)         INC     HL
17DF-56          I  3550 (  6)         LD      D,(HL)          ; Get NMSB of number
17E0-23          I  3551 (  4)         INC     HL
17E1-4E          I  3552 (  6)         LD      C,(HL)          ; Get MSB of number
17E2-23          I  3553 (  4)         INC     HL
17E3-46          I  3554 (  6)         LD      B,(HL)          ; Get exponent of number
17E4-23          I  3555 (  4) INCHL:  INC     HL              ; Used for conditional "INC HL"
17E5-C9          I  3556 (  9)         RET
17E6-            I  3557
17E6-11 29 23    I  3558 (  9) FPTHL:  LD      DE,FPREG        ; Point to FPREG
17E9-06 04       I  3559 (  6) DETHL4: LD      B,4             ; 4 bytes to move
17EB-1A          I  3560 (  6) DETHLB: LD      A,(DE)          ; Get source
17EC-77          I  3561 (  7)         LD      (HL),A          ; Save destination
17ED-13          I  3562 (  4)         INC     DE              ; Next source
17EE-23          I  3563 (  4)         INC     HL              ; Next destination
17EF-05          I  3564 (  4)         DEC     B               ; Count bytes
17F0-C2 EB 17    I  3565 ( 6+)         JP      NZ,DETHLB       ; Loop if more
17F3-C9          I  3566 (  9)         RET
17F4-            I  3567
17F4-21 2B 23    I  3568 (  9) SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
17F7-7E          I  3569 (  6)         LD      A,(HL)          ; Get MSB
17F8-07          I  3570 (  3)         RLCA                    ; Old sign to carry
17F9-37          I  3571 (  3)         SCF                     ; Set MSBit
17FA-1F          I  3572 (  3)         RRA                     ; Set MSBit of MSB
17FB-77          I  3573 (  7)         LD      (HL),A          ; Save new MSB
17FC-3F          I  3574 (  3)         CCF                     ; Complement sign
17FD-1F          I  3575 (  3)         RRA                     ; Old sign to carry
17FE-23          I  3576 (  4)         INC     HL
17FF-23          I  3577 (  4)         INC     HL
1800-77          I  3578 (  7)         LD      (HL),A          ; Set sign of result
1801-79          I  3579 (  4)         LD      A,C             ; Get MSB
1802-07          I  3580 (  3)         RLCA                    ; Old sign to carry
1803-37          I  3581 (  3)         SCF                     ; Set MSBit
1804-1F          I  3582 (  3)         RRA                     ; Set MSBit of MSB
1805-4F          I  3583 (  4)         LD      C,A             ; Save MSB
1806-1F          I  3584 (  3)         RRA
1807-AE          I  3585 (  6)         XOR     (HL)            ; New sign of result
1808-C9          I  3586 (  9)         RET
1809-            I  3587
1809-78          I  3588 (  4) CMPNUM: LD      A,B             ; Get exponent of number
180A-B7          I  3589 (  4)         OR      A
180B-CA 8E 17    I  3590 ( 6+)         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
180E-21 97 17    I  3591 (  9)         LD      HL,RETREL       ; Return relation routine
1811-E5          I  3592 ( 11)         PUSH    HL              ; Save for return
1812-CD 8E 17    I  3593 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
1815-79          I  3594 (  4)         LD      A,C             ; Get MSB of number
1816-C8          I  3595 ( 5+)         RET     Z               ; FPREG zero - Number's MSB
1817-21 2B 23    I  3596 (  9)         LD      HL,FPREG+2      ; MSB of FPREG
181A-AE          I  3597 (  6)         XOR     (HL)            ; Combine signs
181B-79          I  3598 (  4)         LD      A,C             ; Get MSB of number
181C-F8          I  3599 ( 5+)         RET     M               ; Exit if signs different
181D-CD 23 18    I  3600 ( 16)         CALL    CMPFP           ; Compare FP numbers
1820-1F          I  3601 (  3)         RRA                     ; Get carry to sign
1821-A9          I  3602 (  4)         XOR     C               ; Combine with MSB of number
1822-C9          I  3603 (  9)         RET
1823-            I  3604
1823-23          I  3605 (  4) CMPFP:  INC     HL              ; Point to exponent
1824-78          I  3606 (  4)         LD      A,B             ; Get exponent
1825-BE          I  3607 (  6)         CP      (HL)            ; Compare exponents
1826-C0          I  3608 ( 5+)         RET     NZ              ; Different
1827-2B          I  3609 (  4)         DEC     HL              ; Point to MBS
1828-79          I  3610 (  4)         LD      A,C             ; Get MSB
1829-BE          I  3611 (  6)         CP      (HL)            ; Compare MSBs
182A-C0          I  3612 ( 5+)         RET     NZ              ; Different
182B-2B          I  3613 (  4)         DEC     HL              ; Point to NMSB
182C-7A          I  3614 (  4)         LD      A,D             ; Get NMSB
182D-BE          I  3615 (  6)         CP      (HL)            ; Compare NMSBs
182E-C0          I  3616 ( 5+)         RET     NZ              ; Different
182F-2B          I  3617 (  4)         DEC     HL              ; Point to LSB
1830-7B          I  3618 (  4)         LD      A,E             ; Get LSB
1831-96          I  3619 (  6)         SUB     (HL)            ; Compare LSBs
1832-C0          I  3620 ( 5+)         RET     NZ              ; Different
1833-E1          I  3621 (  9)         POP     HL              ; Drop RETurn
1834-E1          I  3622 (  9)         POP     HL              ; Drop another RETurn
1835-C9          I  3623 (  9)         RET
1836-            I  3624
1836-47          I  3625 (  4) FPINT:  LD      B,A             ; <- Move
1837-4F          I  3626 (  4)         LD      C,A             ; <- exponent
1838-57          I  3627 (  4)         LD      D,A             ; <- to all
1839-5F          I  3628 (  4)         LD      E,A             ; <- bits
183A-B7          I  3629 (  4)         OR      A               ; Test exponent
183B-C8          I  3630 ( 5+)         RET     Z               ; Zero - Return zero
183C-E5          I  3631 ( 11)         PUSH    HL              ; Save pointer to number
183D-CD DA 17    I  3632 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1840-CD F4 17    I  3633 ( 16)         CALL    SIGNS           ; Set MSBs & sign of result
1843-AE          I  3634 (  6)         XOR     (HL)            ; Combine with sign of FPREG
1844-67          I  3635 (  4)         LD      H,A             ; Save combined signs
1845-FC 5A 18    I  3636 ( 6+)         CALL    M,DCBCDE        ; Negative - Decrement BCDE
1848-3E 98       I  3637 (  6)         LD      A,80H+24        ; 24 bits
184A-90          I  3638 (  4)         SUB     B               ; Bits to shift
184B-CD 0D 16    I  3639 ( 16)         CALL    SCALE           ; Shift BCDE
184E-7C          I  3640 (  4)         LD      A,H             ; Get combined sign
184F-17          I  3641 (  3)         RLA                     ; Sign to carry
1850-DC E0 15    I  3642 ( 6+)         CALL    C,FPROND        ; Negative - Round number up
1853-06 00       I  3643 (  6)         LD      B,0             ; Zero exponent
1855-DC F9 15    I  3644 ( 6+)         CALL    C,COMPL         ; If negative make positive
1858-E1          I  3645 (  9)         POP     HL              ; Restore pointer to number
1859-C9          I  3646 (  9)         RET
185A-            I  3647
185A-1B          I  3648 (  4) DCBCDE: DEC     DE              ; Decrement BCDE
185B-7A          I  3649 (  4)         LD      A,D             ; Test LSBs
185C-A3          I  3650 (  4)         AND     E
185D-3C          I  3651 (  4)         INC     A
185E-C0          I  3652 ( 5+)         RET     NZ              ; Exit if LSBs not FFFF
185F-0B          I  3653 (  4)         DEC     BC              ; Decrement MSBs
1860-C9          I  3654 (  9)         RET
1861-            I  3655
1861-21 2C 23    I  3656 (  9) INT:    LD      HL,FPEXP        ; Point to exponent
1864-7E          I  3657 (  6)         LD      A,(HL)          ; Get exponent
1865-FE 98       I  3658 (  6)         CP      80H+24          ; Integer accuracy only?
1867-3A 29 23    I  3659 ( 12)         LD      A,(FPREG)       ; Get LSB
186A-D0          I  3660 ( 5+)         RET     NC              ; Yes - Already integer
186B-7E          I  3661 (  6)         LD      A,(HL)          ; Get exponent
186C-CD 36 18    I  3662 ( 16)         CALL    FPINT           ; F.P to integer
186F-36 98       I  3663 (  9)         LD      (HL),80H+24     ; Save 24 bit integer
1871-7B          I  3664 (  4)         LD      A,E             ; Get LSB of number
1872-F5          I  3665 ( 11)         PUSH    AF              ; Save LSB
1873-79          I  3666 (  4)         LD      A,C             ; Get MSB of number
1874-17          I  3667 (  3)         RLA                     ; Sign to carry
1875-CD 96 15    I  3668 ( 16)         CALL    CONPOS          ; Set sign of result
1878-F1          I  3669 (  9)         POP     AF              ; Restore LSB of number
1879-C9          I  3670 (  9)         RET
187A-            I  3671
187A-21 00 00    I  3672 (  9) MLDEBC: LD      HL,0            ; Clear partial product
187D-78          I  3673 (  4)         LD      A,B             ; Test multiplier
187E-B1          I  3674 (  4)         OR      C
187F-C8          I  3675 ( 5+)         RET     Z               ; Return zero if zero
1880-3E 10       I  3676 (  6)         LD      A,16            ; 16 bits
1882-29          I  3677 (  7) MLDBLP: ADD     HL,HL           ; Shift P.P left
1883-DA BA 10    I  3678 ( 6+)         JP      C,BSERR         ; ?BS Error if overflow
1886-EB          I  3679 (  3)         EX      DE,HL
1887-29          I  3680 (  7)         ADD     HL,HL           ; Shift multiplier left
1888-EB          I  3681 (  3)         EX      DE,HL
1889-D2 90 18    I  3682 ( 6+)         JP      NC,NOMLAD       ; Bit was zero - No add
188C-09          I  3683 (  7)         ADD     HL,BC           ; Add multiplicand
188D-DA BA 10    I  3684 ( 6+)         JP      C,BSERR         ; ?BS Error if overflow
1890-3D          I  3685 (  4) NOMLAD: DEC     A               ; Count bits
1891-C2 82 18    I  3686 ( 6+)         JP      NZ,MLDBLP       ; More
1894-C9          I  3687 (  9)         RET
1895-            I  3688
1895-FE 2D       I  3689 (  6) ASCTFP: CP      '-'             ; Negative?
1897-F5          I  3690 ( 11)         PUSH    AF              ; Save it and flags
1898-CA A1 18    I  3691 ( 6+)         JP      Z,CNVNUM        ; Yes - Convert number
189B-FE 2B       I  3692 (  6)         CP      '+'             ; Positive?
189D-CA A1 18    I  3693 ( 6+)         JP      Z,CNVNUM        ; Yes - Convert number
18A0-2B          I  3694 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
18A1-CD AE 15    I  3695 ( 16) CNVNUM: CALL    RESZER          ; Set result to zero
18A4-47          I  3696 (  4)         LD      B,A             ; Digits after point counter
18A5-57          I  3697 (  4)         LD      D,A             ; Sign of exponent
18A6-5F          I  3698 (  4)         LD      E,A             ; Exponent of ten
18A7-2F          I  3699 (  3)         CPL
18A8-4F          I  3700 (  4)         LD      C,A             ; Before or after point flag
18A9-CD 3F 09    I  3701 ( 16) MANLP:  CALL    GETCHR          ; Get next character
18AC-DA F2 18    I  3702 ( 6+)         JP      C,ADDIG         ; Digit - Add to number
18AF-FE 2E       I  3703 (  6)         CP      '.'
18B1-CA CD 18    I  3704 ( 6+)         JP      Z,DPOINT        ; '.' - Flag point
18B4-FE 45       I  3705 (  6)         CP      'E'
18B6-C2 D1 18    I  3706 ( 6+)         JP      NZ,CONEXP       ; Not 'E' - Scale number
18B9-CD 3F 09    I  3707 ( 16)         CALL    GETCHR          ; Get next character
18BC-CD E5 0E    I  3708 ( 16)         CALL    SGNEXP          ; Get sign of exponent
18BF-CD 3F 09    I  3709 ( 16) EXPLP:  CALL    GETCHR          ; Get next character
18C2-DA 14 19    I  3710 ( 6+)         JP      C,EDIGIT        ; Digit - Add to exponent
18C5-14          I  3711 (  4)         INC     D               ; Is sign negative?
18C6-C2 D1 18    I  3712 ( 6+)         JP      NZ,CONEXP       ; No - Scale number
18C9-AF          I  3713 (  4)         XOR     A
18CA-93          I  3714 (  4)         SUB     E               ; Negate exponent
18CB-5F          I  3715 (  4)         LD      E,A             ; And re-save it
18CC-0C          I  3716 (  4)         INC     C               ; Flag end of number
18CD-0C          I  3717 (  4) DPOINT: INC     C               ; Flag point passed
18CE-CA A9 18    I  3718 ( 6+)         JP      Z,MANLP         ; Zero - Get another digit
18D1-E5          I  3719 ( 11) CONEXP: PUSH    HL              ; Save code string address
18D2-7B          I  3720 (  4)         LD      A,E             ; Get exponent
18D3-90          I  3721 (  4)         SUB     B               ; Subtract digits after point
18D4-F4 EA 18    I  3722 ( 6+) SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
18D7-F2 E0 18    I  3723 ( 6+)         JP      P,ENDCON        ; Positive - All done
18DA-F5          I  3724 ( 11)         PUSH    AF              ; Save number of times to /10
18DB-CD D6 16    I  3725 ( 16)         CALL    DIV10           ; Divide by 10
18DE-F1          I  3726 (  9)         POP     AF              ; Restore count
18DF-3C          I  3727 (  4)         INC     A               ; Count divides
18E0-            I  3728
18E0-C2 D4 18    I  3729 ( 6+) ENDCON: JP      NZ,SCALMI       ; More to do
18E3-D1          I  3730 (  9)         POP     DE              ; Restore code string address
18E4-F1          I  3731 (  9)         POP     AF              ; Restore sign of number
18E5-CC B7 17    I  3732 ( 6+)         CALL    Z,INVSGN        ; Negative - Negate number
18E8-EB          I  3733 (  3)         EX      DE,HL           ; Code string address to HL
18E9-C9          I  3734 (  9)         RET
18EA-            I  3735
18EA-C8          I  3736 ( 5+) SCALPL: RET     Z               ; Exit if no scaling needed
18EB-F5          I  3737 ( 11) MULTEN: PUSH    AF              ; Save count
18EC-CD 77 17    I  3738 ( 16)         CALL    MLSP10          ; Multiply number by 10
18EF-F1          I  3739 (  9)         POP     AF              ; Restore count
18F0-3D          I  3740 (  4)         DEC     A               ; Count multiplies
18F1-C9          I  3741 (  9)         RET
18F2-            I  3742
18F2-D5          I  3743 ( 11) ADDIG:  PUSH    DE              ; Save sign of exponent
18F3-57          I  3744 (  4)         LD      D,A             ; Save digit
18F4-78          I  3745 (  4)         LD      A,B             ; Get digits after point
18F5-89          I  3746 (  4)         ADC     A,C             ; Add one if after point
18F6-47          I  3747 (  4)         LD      B,A             ; Re-save counter
18F7-C5          I  3748 ( 11)         PUSH    BC              ; Save point flags
18F8-E5          I  3749 ( 11)         PUSH    HL              ; Save code string address
18F9-D5          I  3750 ( 11)         PUSH    DE              ; Save digit
18FA-CD 77 17    I  3751 ( 16)         CALL    MLSP10          ; Multiply number by 10
18FD-F1          I  3752 (  9)         POP     AF              ; Restore digit
18FE-D6 30       I  3753 (  6)         SUB     '0'             ; Make it absolute
1900-CD 09 19    I  3754 ( 16)         CALL    RSCALE          ; Re-scale number
1903-E1          I  3755 (  9)         POP     HL              ; Restore code string address
1904-C1          I  3756 (  9)         POP     BC              ; Restore point flags
1905-D1          I  3757 (  9)         POP     DE              ; Restore sign of exponent
1906-C3 A9 18    I  3758 (  9)         JP      MANLP           ; Get another digit
1909-            I  3759
1909-CD BF 17    I  3760 ( 16) RSCALE: CALL    STAKFP          ; Put number on stack
190C-CD A0 17    I  3761 ( 16)         CALL    FLGREL          ; Digit to add to FPREG
190F-C1          I  3762 (  9) PADD:   POP     BC              ; Restore number
1910-D1          I  3763 (  9)         POP     DE
1911-C3 48 15    I  3764 (  9)         JP      FPADD           ; Add BCDE to FPREG and return
1914-            I  3765
1914-7B          I  3766 (  4) EDIGIT: LD      A,E             ; Get digit
1915-07          I  3767 (  3)         RLCA                    ; Times 2
1916-07          I  3768 (  3)         RLCA                    ; Times 4
1917-83          I  3769 (  4)         ADD     A,E             ; Times 5
1918-07          I  3770 (  3)         RLCA                    ; Times 10
1919-86          I  3771 (  6)         ADD     A,(HL)          ; Add next digit
191A-D6 30       I  3772 (  6)         SUB     '0'             ; Make it absolute
191C-5F          I  3773 (  4)         LD      E,A             ; Save new digit
191D-C3 BF 18    I  3774 (  9)         JP      EXPLP           ; Look for another digit
1920-            I  3775
1920-E5          I  3776 ( 11) LINEIN: PUSH    HL              ; Save code string address
1921-21 6A 04    I  3777 (  9)         LD      HL,INMSG        ; Output " in "
1924-CD 85 12    I  3778 ( 16)         CALL    PRS             ; Output string at HL
1927-E1          I  3779 (  9)         POP     HL              ; Restore code string address
1928-EB          I  3780 (  3) PRNTHL: EX      DE,HL           ; Code string address to DE
1929-AF          I  3781 (  4)         XOR     A
192A-06 98       I  3782 (  6)         LD      B,80H+24        ; 24 bits
192C-CD A5 17    I  3783 ( 16)         CALL    RETINT          ; Return the integer
192F-21 84 12    I  3784 (  9)         LD      HL,PRNUMS       ; Print number string
1932-E5          I  3785 ( 11)         PUSH    HL              ; Save for return
1933-21 2E 23    I  3786 (  9) NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
1936-E5          I  3787 ( 11)         PUSH    HL              ; Save for return
1937-CD 8E 17    I  3788 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
193A-36 20       I  3789 (  9)         LD      (HL),' '        ; Space at start
193C-F2 41 19    I  3790 ( 6+)         JP      P,SPCFST        ; Positive - Space to start
193F-36 2D       I  3791 (  9)         LD      (HL),'-'        ; '-' sign at start
1941-23          I  3792 (  4) SPCFST: INC     HL              ; First byte of number
1942-36 30       I  3793 (  9)         LD      (HL),'0'        ; '0' if zero
1944-CA F7 19    I  3794 ( 6+)         JP      Z,JSTZER        ; Return '0' if zero
1947-E5          I  3795 ( 11)         PUSH    HL              ; Save buffer address
1948-FC B7 17    I  3796 ( 6+)         CALL    M,INVSGN        ; Negate FPREG if negative
194B-AF          I  3797 (  4)         XOR     A               ; Zero A
194C-F5          I  3798 ( 11)         PUSH    AF              ; Save it
194D-CD FD 19    I  3799 ( 16)         CALL    RNGTST          ; Test number is in range
1950-01 43 91    I  3800 (  9) SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
1953-11 F8 4F    I  3801 (  9)         LD      DE,4FF8H
1956-CD 09 18    I  3802 ( 16)         CALL    CMPNUM          ; Compare numbers
1959-B7          I  3803 (  4)         OR      A
195A-E2 6E 19    I  3804 ( 6+)         JP      PO,INRNG        ; > 99999.9 - Sort it out
195D-F1          I  3805 (  9)         POP     AF              ; Restore count
195E-CD EB 18    I  3806 ( 16)         CALL    MULTEN          ; Multiply by ten
1961-F5          I  3807 ( 11)         PUSH    AF              ; Re-save count
1962-C3 50 19    I  3808 (  9)         JP      SIXDIG          ; Test it again
1965-            I  3809
1965-CD D6 16    I  3810 ( 16) GTSIXD: CALL    DIV10           ; Divide by 10
1968-F1          I  3811 (  9)         POP     AF              ; Get count
1969-3C          I  3812 (  4)         INC     A               ; Count divides
196A-F5          I  3813 ( 11)         PUSH    AF              ; Re-save count
196B-CD FD 19    I  3814 ( 16)         CALL    RNGTST          ; Test number is in range
196E-CD 36 15    I  3815 ( 16) INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
1971-3C          I  3816 (  4)         INC     A
1972-CD 36 18    I  3817 ( 16)         CALL    FPINT           ; F.P to integer
1975-CD CF 17    I  3818 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
1978-01 06 03    I  3819 (  9)         LD      BC,0306H        ; 1E+06 to 1E-03 range
197B-F1          I  3820 (  9)         POP     AF              ; Restore count
197C-81          I  3821 (  4)         ADD     A,C             ; 6 digits before point
197D-3C          I  3822 (  4)         INC     A               ; Add one
197E-FA 8A 19    I  3823 ( 6+)         JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
1981-FE 08       I  3824 (  6)         CP      6+1+1           ; More than 999999 ?
1983-D2 8A 19    I  3825 ( 6+)         JP      NC,MAKNUM       ; Yes - Do it in 'E' form
1986-3C          I  3826 (  4)         INC     A               ; Adjust for exponent
1987-47          I  3827 (  4)         LD      B,A             ; Exponent of number
1988-3E 02       I  3828 (  6)         LD      A,2             ; Make it zero after
198A-            I  3829
198A-3D          I  3830 (  4) MAKNUM: DEC     A               ; Adjust for digits to do
198B-3D          I  3831 (  4)         DEC     A
198C-E1          I  3832 (  9)         POP     HL              ; Restore buffer address
198D-F5          I  3833 ( 11)         PUSH    AF              ; Save count
198E-11 10 1A    I  3834 (  9)         LD      DE,POWERS       ; Powers of ten
1991-05          I  3835 (  4)         DEC     B               ; Count digits before point
1992-C2 9B 19    I  3836 ( 6+)         JP      NZ,DIGTXT       ; Not zero - Do number
1995-36 2E       I  3837 (  9)         LD      (HL),'.'        ; Save point
1997-23          I  3838 (  4)         INC     HL              ; Move on
1998-36 30       I  3839 (  9)         LD      (HL),'0'        ; Save zero
199A-23          I  3840 (  4)         INC     HL              ; Move on
199B-05          I  3841 (  4) DIGTXT: DEC     B               ; Count digits before point
199C-36 2E       I  3842 (  9)         LD      (HL),'.'        ; Save point in case
199E-CC E4 17    I  3843 ( 6+)         CALL    Z,INCHL         ; Last digit - move on
19A1-C5          I  3844 ( 11)         PUSH    BC              ; Save digits before point
19A2-E5          I  3845 ( 11)         PUSH    HL              ; Save buffer address
19A3-D5          I  3846 ( 11)         PUSH    DE              ; Save powers of ten
19A4-CD DA 17    I  3847 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
19A7-E1          I  3848 (  9)         POP     HL              ; Powers of ten table
19A8-06 2F       I  3849 (  6)         LD      B, '0'-1        ; ASCII '0' - 1
19AA-04          I  3850 (  4) TRYAGN: INC     B               ; Count subtractions
19AB-7B          I  3851 (  4)         LD      A,E             ; Get LSB
19AC-96          I  3852 (  6)         SUB     (HL)            ; Subtract LSB
19AD-5F          I  3853 (  4)         LD      E,A             ; Save LSB
19AE-23          I  3854 (  4)         INC     HL
19AF-7A          I  3855 (  4)         LD      A,D             ; Get NMSB
19B0-9E          I  3856 (  6)         SBC     A,(HL)          ; Subtract NMSB
19B1-57          I  3857 (  4)         LD      D,A             ; Save NMSB
19B2-23          I  3858 (  4)         INC     HL
19B3-79          I  3859 (  4)         LD      A,C             ; Get MSB
19B4-9E          I  3860 (  6)         SBC     A,(HL)          ; Subtract MSB
19B5-4F          I  3861 (  4)         LD      C,A             ; Save MSB
19B6-2B          I  3862 (  4)         DEC     HL              ; Point back to start
19B7-2B          I  3863 (  4)         DEC     HL
19B8-D2 AA 19    I  3864 ( 6+)         JP      NC,TRYAGN       ; No overflow - Try again
19BB-CD ED 15    I  3865 ( 16)         CALL    PLUCDE          ; Restore number
19BE-23          I  3866 (  4)         INC     HL              ; Start of next number
19BF-CD CF 17    I  3867 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
19C2-EB          I  3868 (  3)         EX      DE,HL           ; Save point in table
19C3-E1          I  3869 (  9)         POP     HL              ; Restore buffer address
19C4-70          I  3870 (  7)         LD      (HL),B          ; Save digit in buffer
19C5-23          I  3871 (  4)         INC     HL              ; And move on
19C6-C1          I  3872 (  9)         POP     BC              ; Restore digit count
19C7-0D          I  3873 (  4)         DEC     C               ; Count digits
19C8-C2 9B 19    I  3874 ( 6+)         JP      NZ,DIGTXT       ; More - Do them
19CB-05          I  3875 (  4)         DEC     B               ; Any decimal part?
19CC-CA DB 19    I  3876 ( 6+)         JP      Z,DOEBIT        ; No - Do 'E' bit
19CF-2B          I  3877 (  4) SUPTLZ: DEC     HL              ; Move back through buffer
19D0-7E          I  3878 (  6)         LD      A,(HL)          ; Get character
19D1-FE 30       I  3879 (  6)         CP      '0'             ; '0' character?
19D3-CA CF 19    I  3880 ( 6+)         JP      Z,SUPTLZ        ; Yes - Look back for more
19D6-FE 2E       I  3881 (  6)         CP      '.'             ; A decimal point?
19D8-C4 E4 17    I  3882 ( 6+)         CALL    NZ,INCHL        ; Move back over digit
19DB-            I  3883
19DB-F1          I  3884 (  9) DOEBIT: POP     AF              ; Get 'E' flag
19DC-CA FA 19    I  3885 ( 6+)         JP      Z,NOENED        ; No 'E' needed - End buffer
19DF-36 45       I  3886 (  9)         LD      (HL),'E'        ; Put 'E' in buffer
19E1-23          I  3887 (  4)         INC     HL              ; And move on
19E2-36 2B       I  3888 (  9)         LD      (HL),'+'        ; Put '+' in buffer
19E4-F2 EB 19    I  3889 ( 6+)         JP      P,OUTEXP        ; Positive - Output exponent
19E7-36 2D       I  3890 (  9)         LD      (HL),'-'        ; Put '-' in buffer
19E9-2F          I  3891 (  3)         CPL                     ; Negate exponent
19EA-3C          I  3892 (  4)         INC     A
19EB-06 2F       I  3893 (  6) OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
19ED-04          I  3894 (  4) EXPTEN: INC     B               ; Count subtractions
19EE-D6 0A       I  3895 (  6)         SUB     10              ; Tens digit
19F0-D2 ED 19    I  3896 ( 6+)         JP      NC,EXPTEN       ; More to do
19F3-C6 3A       I  3897 (  6)         ADD     A,'0'+10        ; Restore and make ASCII
19F5-23          I  3898 (  4)         INC     HL              ; Move on
19F6-70          I  3899 (  7)         LD      (HL),B          ; Save MSB of exponent
19F7-23          I  3900 (  4) JSTZER: INC     HL              ;
19F8-77          I  3901 (  7)         LD      (HL),A          ; Save LSB of exponent
19F9-23          I  3902 (  4)         INC     HL
19FA-71          I  3903 (  7) NOENED: LD      (HL),C          ; Mark end of buffer
19FB-E1          I  3904 (  9)         POP     HL              ; Restore code string address
19FC-C9          I  3905 (  9)         RET
19FD-            I  3906
19FD-01 74 94    I  3907 (  9) RNGTST: LD      BC,9474H        ; BCDE = 999999.
1A00-11 F7 23    I  3908 (  9)         LD      DE,23F7H
1A03-CD 09 18    I  3909 ( 16)         CALL    CMPNUM          ; Compare numbers
1A06-B7          I  3910 (  4)         OR      A
1A07-E1          I  3911 (  9)         POP     HL              ; Return address to HL
1A08-E2 65 19    I  3912 ( 6+)         JP      PO,GTSIXD       ; Too big - Divide by ten
1A0B-E9          I  3913 (  3)         JP      (HL)            ; Otherwise return to caller
1A0C-            I  3914
1A0C-00 00 00 80 I  3915       HALF:   .DB      00H,00H,00H,80H ; 0.5
1A10-            I  3916
1A10-A0 86 01    I  3917       POWERS: .DB      0A0H,086H,001H  ; 100000
1A13-10 27 00    I  3918               .DB      010H,027H,000H  ;  10000
1A16-E8 03 00    I  3919               .DB      0E8H,003H,000H  ;   1000
1A19-64 00 00    I  3920               .DB      064H,000H,000H  ;    100
1A1C-0A 00 00    I  3921               .DB      00AH,000H,000H  ;     10
1A1F-01 00 00    I  3922               .DB      001H,000H,000H  ;      1
1A22-            I  3923
1A22-21 B7 17    I  3924 (  9) NEGAFT: LD  HL,INVSGN           ; Negate result
1A25-E3          I  3925 ( 16)         EX      (SP),HL         ; To be done after caller
1A26-E9          I  3926 (  3)         JP      (HL)            ; Return to caller
1A27-            I  3927
1A27-CD BF 17    I  3928 ( 16) SQR:    CALL    STAKFP          ; Put value on stack
1A2A-21 0C 1A    I  3929 (  9)         LD      HL,HALF         ; Set power to 1/2
1A2D-CD CC 17    I  3930 ( 16)         CALL    PHLTFP          ; Move 1/2 to FPREG
1A30-            I  3931
1A30-C1          I  3932 (  9) POWER:  POP     BC              ; Get base
1A31-D1          I  3933 (  9)         POP     DE
1A32-CD 8E 17    I  3934 ( 16)         CALL    TSTSGN          ; Test sign of power
1A35-78          I  3935 (  4)         LD      A,B             ; Get exponent of base
1A36-CA 75 1A    I  3936 ( 6+)         JP      Z,EXP           ; Make result 1 if zero
1A39-F2 40 1A    I  3937 ( 6+)         JP      P,POWER1        ; Positive base - Ok
1A3C-B7          I  3938 (  4)         OR      A               ; Zero to negative power?
1A3D-CA DB 04    I  3939 ( 6+)         JP      Z,DZERR         ; Yes - ?/0 Error
1A40-B7          I  3940 (  4) POWER1: OR      A               ; Base zero?
1A41-CA AF 15    I  3941 ( 6+)         JP      Z,SAVEXP        ; Yes - Return zero
1A44-D5          I  3942 ( 11)         PUSH    DE              ; Save base
1A45-C5          I  3943 ( 11)         PUSH    BC
1A46-79          I  3944 (  4)         LD      A,C             ; Get MSB of base
1A47-F6 7F       I  3945 (  6)         OR      01111111B       ; Get sign status
1A49-CD DA 17    I  3946 ( 16)         CALL    BCDEFP          ; Move power to BCDE
1A4C-F2 5D 1A    I  3947 ( 6+)         JP      P,POWER2        ; Positive base - Ok
1A4F-D5          I  3948 ( 11)         PUSH    DE              ; Save power
1A50-C5          I  3949 ( 11)         PUSH    BC
1A51-CD 61 18    I  3950 ( 16)         CALL    INT             ; Get integer of power
1A54-C1          I  3951 (  9)         POP     BC              ; Restore power
1A55-D1          I  3952 (  9)         POP     DE
1A56-F5          I  3953 ( 11)         PUSH    AF              ; MSB of base
1A57-CD 09 18    I  3954 ( 16)         CALL    CMPNUM          ; Power an integer?
1A5A-E1          I  3955 (  9)         POP     HL              ; Restore MSB of base
1A5B-7C          I  3956 (  4)         LD      A,H             ; but don't affect flags
1A5C-1F          I  3957 (  3)         RRA                     ; Exponent odd or even?
1A5D-E1          I  3958 (  9) POWER2: POP     HL              ; Restore MSB and exponent
1A5E-22 2B 23    I  3959 ( 20)         LD      (FPREG+2),HL    ; Save base in FPREG
1A61-E1          I  3960 (  9)         POP     HL              ; LSBs of base
1A62-22 29 23    I  3961 ( 20)         LD      (FPREG),HL      ; Save in FPREG
1A65-DC 22 1A    I  3962 ( 6+)         CALL    C,NEGAFT        ; Odd power - Negate result
1A68-CC B7 17    I  3963 ( 6+)         CALL    Z,INVSGN        ; Negative base - Negate it
1A6B-D5          I  3964 ( 11)         PUSH    DE              ; Save power
1A6C-C5          I  3965 ( 11)         PUSH    BC
1A6D-CD 42 16    I  3966 ( 16)         CALL    LOG             ; Get LOG of base
1A70-C1          I  3967 (  9)         POP     BC              ; Restore power
1A71-D1          I  3968 (  9)         POP     DE
1A72-CD 83 16    I  3969 ( 16)         CALL    FPMULT          ; Multiply LOG by power
1A75-            I  3970
1A75-CD BF 17    I  3971 ( 16) EXP:    CALL    STAKFP          ; Put value on stack
1A78-01 38 81    I  3972 (  9)         LD      BC,08138H       ; BCDE = 1/Ln(2)
1A7B-11 3B AA    I  3973 (  9)         LD      DE,0AA3BH
1A7E-CD 83 16    I  3974 ( 16)         CALL    FPMULT          ; Multiply value by 1/LN(2)
1A81-3A 2C 23    I  3975 ( 12)         LD      A,(FPEXP)       ; Get exponent
1A84-FE 88       I  3976 (  6)         CP      80H+8           ; Is it in range?
1A86-D2 6A 17    I  3977 ( 6+)         JP      NC,OVTST1       ; No - Test for overflow
1A89-CD 61 18    I  3978 ( 16)         CALL    INT             ; Get INT of FPREG
1A8C-C6 80       I  3979 (  6)         ADD     A,80H           ; For excess 128
1A8E-C6 02       I  3980 (  6)         ADD     A,2             ; Exponent > 126?
1A90-DA 6A 17    I  3981 ( 6+)         JP      C,OVTST1        ; Yes - Test for overflow
1A93-F5          I  3982 ( 11)         PUSH    AF              ; Save scaling factor
1A94-21 31 16    I  3983 (  9)         LD      HL,UNITY        ; Point to 1.
1A97-CD 39 15    I  3984 ( 16)         CALL    ADDPHL          ; Add 1 to FPREG
1A9A-CD 7A 16    I  3985 ( 16)         CALL    MULLN2          ; Multiply by LN(2)
1A9D-F1          I  3986 (  9)         POP     AF              ; Restore scaling factor
1A9E-C1          I  3987 (  9)         POP     BC              ; Restore exponent
1A9F-D1          I  3988 (  9)         POP     DE
1AA0-F5          I  3989 ( 11)         PUSH    AF              ; Save scaling factor
1AA1-CD 45 15    I  3990 ( 16)         CALL    SUBCDE          ; Subtract exponent from FPREG
1AA4-CD B7 17    I  3991 ( 16)         CALL    INVSGN          ; Negate result
1AA7-21 B5 1A    I  3992 (  9)         LD      HL,EXPTAB       ; Coefficient table
1AAA-CD E5 1A    I  3993 ( 16)         CALL    SMSER1          ; Sum the series
1AAD-11 00 00    I  3994 (  9)         LD      DE,0            ; Zero LSBs
1AB0-C1          I  3995 (  9)         POP     BC              ; Scaling factor
1AB1-4A          I  3996 (  4)         LD      C,D             ; Zero MSB
1AB2-C3 83 16    I  3997 (  9)         JP      FPMULT          ; Scale result to correct value
1AB5-            I  3998
1AB5-08          I  3999       EXPTAB: .DB      8                       ; Table used by EXP
1AB6-40 2E 94 74 I  4000               .DB      040H,02EH,094H,074H     ; -1/7! (-1/5040)
1ABA-70 4F 2E 77 I  4001               .DB      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
1ABE-6E 02 88 7A I  4002               .DB      06EH,002H,088H,07AH     ; -1/5! (-1/120)
1AC2-E6 A0 2A 7C I  4003               .DB      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
1AC6-50 AA AA 7E I  4004               .DB      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
1ACA-FF FF 7F 7F I  4005               .DB      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
1ACE-00 00 80 81 I  4006               .DB      000H,000H,080H,081H     ; -1/1! (-1/1)
1AD2-00 00 00 81 I  4007               .DB      000H,000H,000H,081H     ;  1/0! ( 1/1)
1AD6-            I  4008
1AD6-CD BF 17    I  4009 ( 16) SUMSER: CALL    STAKFP          ; Put FPREG on stack
1AD9-11 81 16    I  4010 (  9)         LD      DE,MULT         ; Multiply by "X"
1ADC-D5          I  4011 ( 11)         PUSH    DE              ; To be done after
1ADD-E5          I  4012 ( 11)         PUSH    HL              ; Save address of table
1ADE-CD DA 17    I  4013 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1AE1-CD 83 16    I  4014 ( 16)         CALL    FPMULT          ; Square the value
1AE4-E1          I  4015 (  9)         POP     HL              ; Restore address of table
1AE5-CD BF 17    I  4016 ( 16) SMSER1: CALL    STAKFP          ; Put value on stack
1AE8-7E          I  4017 (  6)         LD      A,(HL)          ; Get number of coefficients
1AE9-23          I  4018 (  4)         INC     HL              ; Point to start of table
1AEA-CD CC 17    I  4019 ( 16)         CALL    PHLTFP          ; Move coefficient to FPREG
1AED-06          I  4020               .DB      06H             ; Skip "POP AF"
1AEE-F1          I  4021 (  9) SUMLP:  POP     AF              ; Restore count
1AEF-C1          I  4022 (  9)         POP     BC              ; Restore number
1AF0-D1          I  4023 (  9)         POP     DE
1AF1-3D          I  4024 (  4)         DEC     A               ; Cont coefficients
1AF2-C8          I  4025 ( 5+)         RET     Z               ; All done
1AF3-D5          I  4026 ( 11)         PUSH    DE              ; Save number
1AF4-C5          I  4027 ( 11)         PUSH    BC
1AF5-F5          I  4028 ( 11)         PUSH    AF              ; Save count
1AF6-E5          I  4029 ( 11)         PUSH    HL              ; Save address in table
1AF7-CD 83 16    I  4030 ( 16)         CALL    FPMULT          ; Multiply FPREG by BCDE
1AFA-E1          I  4031 (  9)         POP     HL              ; Restore address in table
1AFB-CD DD 17    I  4032 ( 16)         CALL    LOADFP          ; Number at HL to BCDE
1AFE-E5          I  4033 ( 11)         PUSH    HL              ; Save address in table
1AFF-CD 48 15    I  4034 ( 16)         CALL    FPADD           ; Add coefficient to FPREG
1B02-E1          I  4035 (  9)         POP     HL              ; Restore address in table
1B03-C3 EE 1A    I  4036 (  9)         JP      SUMLP           ; More coefficients
1B06-            I  4037
1B06-CD 8E 17    I  4038 ( 16) RND:    CALL    TSTSGN          ; Test sign of FPREG
1B09-21 5E 22    I  4039 (  9)         LD      HL,SEED+2       ; Random number seed
1B0C-FA 67 1B    I  4040 ( 6+)         JP      M,RESEED        ; Negative - Re-seed
1B0F-21 7F 22    I  4041 (  9)         LD      HL,LSTRND       ; Last random number
1B12-CD CC 17    I  4042 ( 16)         CALL    PHLTFP          ; Move last RND to FPREG
1B15-21 5E 22    I  4043 (  9)         LD      HL,SEED+2       ; Random number seed
1B18-C8          I  4044 ( 5+)         RET     Z               ; Return if RND(0)
1B19-86          I  4045 (  6)         ADD     A,(HL)          ; Add (SEED)+2)
1B1A-E6 07       I  4046 (  6)         AND     00000111B       ; 0 to 7
1B1C-06 00       I  4047 (  6)         LD      B,0
1B1E-77          I  4048 (  7)         LD      (HL),A          ; Re-save seed
1B1F-23          I  4049 (  4)         INC     HL              ; Move to coefficient table
1B20-87          I  4050 (  4)         ADD     A,A             ; 4 bytes
1B21-87          I  4051 (  4)         ADD     A,A             ; per entry
1B22-4F          I  4052 (  4)         LD      C,A             ; BC = Offset into table
1B23-09          I  4053 (  7)         ADD     HL,BC           ; Point to coefficient
1B24-CD DD 17    I  4054 ( 16)         CALL    LOADFP          ; Coefficient to BCDE
1B27-CD 83 16    I  4055 ( 16)         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
1B2A-3A 5D 22    I  4056 ( 12)         LD      A,(SEED+1)      ; Get (SEED+1)
1B2D-3C          I  4057 (  4)         INC     A               ; Add 1
1B2E-E6 03       I  4058 (  6)         AND     00000011B       ; 0 to 3
1B30-06 00       I  4059 (  6)         LD      B,0
1B32-FE 01       I  4060 (  6)         CP      1               ; Is it zero?
1B34-88          I  4061 (  4)         ADC     A,B             ; Yes - Make it 1
1B35-32 5D 22    I  4062 ( 13)         LD      (SEED+1),A      ; Re-save seed
1B38-21 6B 1B    I  4063 (  9)         LD      HL,RNDTAB-4     ; Addition table
1B3B-87          I  4064 (  4)         ADD     A,A             ; 4 bytes
1B3C-87          I  4065 (  4)         ADD     A,A             ; per entry
1B3D-4F          I  4066 (  4)         LD      C,A             ; BC = Offset into table
1B3E-09          I  4067 (  7)         ADD     HL,BC           ; Point to value
1B3F-CD 39 15    I  4068 ( 16)         CALL    ADDPHL          ; Add value to FPREG
1B42-CD DA 17    I  4069 ( 16) RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
1B45-7B          I  4070 (  4)         LD      A,E             ; Get LSB
1B46-59          I  4071 (  4)         LD      E,C             ; LSB = MSB
1B47-EE 4F       I  4072 (  6)         XOR     01001111B       ; Fiddle around
1B49-4F          I  4073 (  4)         LD      C,A             ; New MSB
1B4A-36 80       I  4074 (  9)         LD      (HL),80H        ; Set exponent
1B4C-2B          I  4075 (  4)         DEC     HL              ; Point to MSB
1B4D-46          I  4076 (  6)         LD      B,(HL)          ; Get MSB
1B4E-36 80       I  4077 (  9)         LD      (HL),80H        ; Make value -0.5
1B50-21 5C 22    I  4078 (  9)         LD      HL,SEED         ; Random number seed
1B53-34          I  4079 ( 10)         INC     (HL)            ; Count seed
1B54-7E          I  4080 (  6)         LD      A,(HL)          ; Get seed
1B55-D6 AB       I  4081 (  6)         SUB     171             ; Do it modulo 171
1B57-C2 5E 1B    I  4082 ( 6+)         JP      NZ,RND2         ; Non-zero - Ok
1B5A-77          I  4083 (  7)         LD      (HL),A          ; Zero seed
1B5B-0C          I  4084 (  4)         INC     C               ; Fillde about
1B5C-15          I  4085 (  4)         DEC     D               ; with the
1B5D-1C          I  4086 (  4)         INC     E               ; number
1B5E-CD 99 15    I  4087 ( 16) RND2:   CALL    BNORM           ; Normalise number
1B61-21 7F 22    I  4088 (  9)         LD      HL,LSTRND       ; Save random number
1B64-C3 E6 17    I  4089 (  9)         JP      FPTHL           ; Move FPREG to last and return
1B67-            I  4090
1B67-77          I  4091 (  7) RESEED: LD      (HL),A          ; Re-seed random numbers
1B68-2B          I  4092 (  4)         DEC     HL
1B69-77          I  4093 (  7)         LD      (HL),A
1B6A-2B          I  4094 (  4)         DEC     HL
1B6B-77          I  4095 (  7)         LD      (HL),A
1B6C-C3 42 1B    I  4096 (  9)         JP      RND1            ; Return RND seed
1B6F-            I  4097
1B6F-68 B1 46 68 I  4098       RNDTAB: .DB   068H,0B1H,046H,068H     ; Table used by RND
1B73-99 E9 92 69 I  4099               .DB   099H,0E9H,092H,069H
1B77-10 D1 75 68 I  4100               .DB   010H,0D1H,075H,068H
1B7B-            I  4101
1B7B-21 C5 1B    I  4102 (  9) COS:    LD      HL,HALFPI       ; Point to PI/2
1B7E-CD 39 15    I  4103 ( 16)         CALL    ADDPHL          ; Add it to PPREG
1B81-CD BF 17    I  4104 ( 16) SIN:    CALL    STAKFP          ; Put angle on stack
1B84-01 49 83    I  4105 (  9)         LD      BC,8349H        ; BCDE = 2 PI
1B87-11 DB 0F    I  4106 (  9)         LD      DE,0FDBH
1B8A-CD CF 17    I  4107 ( 16)         CALL    FPBCDE          ; Move 2 PI to FPREG
1B8D-C1          I  4108 (  9)         POP     BC              ; Restore angle
1B8E-D1          I  4109 (  9)         POP     DE
1B8F-CD E4 16    I  4110 ( 16)         CALL    DVBCDE          ; Divide angle by 2 PI
1B92-CD BF 17    I  4111 ( 16)         CALL    STAKFP          ; Put it on stack
1B95-CD 61 18    I  4112 ( 16)         CALL    INT             ; Get INT of result
1B98-C1          I  4113 (  9)         POP     BC              ; Restore number
1B99-D1          I  4114 (  9)         POP     DE
1B9A-CD 45 15    I  4115 ( 16)         CALL    SUBCDE          ; Make it 0 <= value < 1
1B9D-21 C9 1B    I  4116 (  9)         LD      HL,QUARTR       ; Point to 0.25
1BA0-CD 3F 15    I  4117 ( 16)         CALL    SUBPHL          ; Subtract value from 0.25
1BA3-CD 8E 17    I  4118 ( 16)         CALL    TSTSGN          ; Test sign of value
1BA6-37          I  4119 (  3)         SCF                     ; Flag positive
1BA7-F2 B1 1B    I  4120 ( 6+)         JP      P,SIN1          ; Positive - Ok
1BAA-CD 36 15    I  4121 ( 16)         CALL    ROUND           ; Add 0.5 to value
1BAD-CD 8E 17    I  4122 ( 16)         CALL    TSTSGN          ; Test sign of value
1BB0-B7          I  4123 (  4)         OR      A               ; Flag negative
1BB1-F5          I  4124 ( 11) SIN1:   PUSH    AF              ; Save sign
1BB2-F4 B7 17    I  4125 ( 6+)         CALL    P,INVSGN        ; Negate value if positive
1BB5-21 C9 1B    I  4126 (  9)         LD      HL,QUARTR       ; Point to 0.25
1BB8-CD 39 15    I  4127 ( 16)         CALL    ADDPHL          ; Add 0.25 to value
1BBB-F1          I  4128 (  9)         POP     AF              ; Restore sign
1BBC-D4 B7 17    I  4129 ( 6+)         CALL    NC,INVSGN       ; Negative - Make positive
1BBF-21 CD 1B    I  4130 (  9)         LD      HL,SINTAB       ; Coefficient table
1BC2-C3 D6 1A    I  4131 (  9)         JP      SUMSER          ; Evaluate sum of series
1BC5-            I  4132
1BC5-DB 0F 49 81 I  4133       HALFPI: .DB   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
1BC9-            I  4134
1BC9-00 00 00 7F I  4135       QUARTR: .DB   000H,000H,000H,07FH     ; 0.25
1BCD-            I  4136
1BCD-05          I  4137       SINTAB: .DB   5                       ; Table used by SIN
1BCE-BA D7 1E 86 I  4138               .DB   0BAH,0D7H,01EH,086H     ; 39.711
1BD2-64 26 99 87 I  4139               .DB   064H,026H,099H,087H     ;-76.575
1BD6-58 34 23 87 I  4140               .DB   058H,034H,023H,087H     ; 81.602
1BDA-E0 5D A5 86 I  4141               .DB   0E0H,05DH,0A5H,086H     ;-41.342
1BDE-DA 0F 49 83 I  4142               .DB   0DAH,00FH,049H,083H     ;  6.2832
1BE2-            I  4143
1BE2-CD BF 17    I  4144 ( 16) TAN:    CALL    STAKFP          ; Put angle on stack
1BE5-CD 81 1B    I  4145 ( 16)         CALL    SIN             ; Get SIN of angle
1BE8-C1          I  4146 (  9)         POP     BC              ; Restore angle
1BE9-E1          I  4147 (  9)         POP     HL
1BEA-CD BF 17    I  4148 ( 16)         CALL    STAKFP          ; Save SIN of angle
1BED-EB          I  4149 (  3)         EX      DE,HL           ; BCDE = Angle
1BEE-CD CF 17    I  4150 ( 16)         CALL    FPBCDE          ; Angle to FPREG
1BF1-CD 7B 1B    I  4151 ( 16)         CALL    COS             ; Get COS of angle
1BF4-C3 E2 16    I  4152 (  9)         JP      DIV             ; TAN = SIN / COS
1BF7-            I  4153
1BF7-CD 8E 17    I  4154 ( 16) ATN:    CALL    TSTSGN          ; Test sign of value
1BFA-FC 22 1A    I  4155 ( 6+)         CALL    M,NEGAFT        ; Negate result after if -ve
1BFD-FC B7 17    I  4156 ( 6+)         CALL    M,INVSGN        ; Negate value if -ve
1C00-3A 2C 23    I  4157 ( 12)         LD      A,(FPEXP)       ; Get exponent
1C03-FE 81       I  4158 (  6)         CP      81H             ; Number less than 1?
1C05-DA 14 1C    I  4159 ( 6+)         JP      C,ATN1          ; Yes - Get arc tangnt
1C08-01 00 81    I  4160 (  9)         LD      BC,8100H        ; BCDE = 1
1C0B-51          I  4161 (  4)         LD      D,C
1C0C-59          I  4162 (  4)         LD      E,C
1C0D-CD E4 16    I  4163 ( 16)         CALL    DVBCDE          ; Get reciprocal of number
1C10-21 3F 15    I  4164 (  9)         LD      HL,SUBPHL       ; Sub angle from PI/2
1C13-E5          I  4165 ( 11)         PUSH    HL              ; Save for angle > 1
1C14-21 1E 1C    I  4166 (  9) ATN1:   LD      HL,ATNTAB       ; Coefficient table
1C17-CD D6 1A    I  4167 ( 16)         CALL    SUMSER          ; Evaluate sum of series
1C1A-21 C5 1B    I  4168 (  9)         LD      HL,HALFPI       ; PI/2 - angle in case > 1
1C1D-C9          I  4169 (  9)         RET                     ; Number > 1 - Sub from PI/2
1C1E-            I  4170
1C1E-09          I  4171       ATNTAB: .DB   9                       ; Table used by ATN
1C1F-4A D7 3B 78 I  4172               .DB   04AH,0D7H,03BH,078H     ; 1/17
1C23-02 6E 84 7B I  4173               .DB   002H,06EH,084H,07BH     ;-1/15
1C27-FE C1 2F 7C I  4174               .DB   0FEH,0C1H,02FH,07CH     ; 1/13
1C2B-74 31 9A 7D I  4175               .DB   074H,031H,09AH,07DH     ;-1/11
1C2F-84 3D 5A 7D I  4176               .DB   084H,03DH,05AH,07DH     ; 1/9
1C33-C8 7F 91 7E I  4177               .DB   0C8H,07FH,091H,07EH     ;-1/7
1C37-E4 BB 4C 7E I  4178               .DB   0E4H,0BBH,04CH,07EH     ; 1/5
1C3B-6C AA AA 7F I  4179               .DB   06CH,0AAH,0AAH,07FH     ;-1/3
1C3F-00 00 00 81 I  4180               .DB   000H,000H,000H,081H     ; 1/1
1C43-            I  4181
1C43-            I  4182
1C43-C9          I  4183 (  9) ARET:   RET                     ; A RETurn instruction
1C44-            I  4184
1C44-D7          I  4185 ( 11) GETINP: RST         10H             ;input a character
1C45-C9          I  4186 (  9)         RET
1C46-            I  4187
1C46-            I  4188       CLS:
1C46-3E 0C       I  4189 (  6)         LD      A,CS            ; ASCII Clear screen
1C48-C3 80 1D    I  4190 (  9)         JP      MONOUT          ; Output character
1C4B-            I  4191
1C4B-CD 0D 15    I  4192 ( 16) WIDTH:  CALL    GETINT          ; Get integer 0-255
1C4E-7B          I  4193 (  4)         LD      A,E             ; Width to A
1C4F-32 87 22    I  4194 ( 13)         LD      (LWIDTH),A      ; Set width
1C52-C9          I  4195 (  9)         RET
1C53-            I  4196
1C53-CD AC 0D    I  4197 ( 16) LINES:  CALL    GETNUM          ; Get a number
1C56-CD F1 09    I  4198 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C59-ED 53 8B 22 I  4199 ( 20)         LD      (LINESC),DE     ; Set lines counter
1C5D-ED 53 8D 22 I  4200 ( 20)         LD      (LINESN),DE     ; Set lines number
1C61-C9          I  4201 (  9)         RET
1C62-            I  4202
1C62-CD F1 09    I  4203 ( 16) DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
1C65-D5          I  4204 ( 11)         PUSH    DE              ; Save number
1C66-E1          I  4205 (  9)         POP     HL              ; Number to HL
1C67-46          I  4206 (  6)         LD      B,(HL)          ; Get LSB of contents
1C68-23          I  4207 (  4)         INC     HL
1C69-7E          I  4208 (  6)         LD      A,(HL)          ; Get MSB of contents
1C6A-C3 67 11    I  4209 (  9)         JP      ABPASS          ; Return integer AB
1C6D-            I  4210
1C6D-CD AC 0D    I  4211 ( 16) DOKE:   CALL    GETNUM          ; Get a number
1C70-CD F1 09    I  4212 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C73-D5          I  4213 ( 11)         PUSH    DE              ; Save address
1C74-CD B5 07    I  4214 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1C77-2C          I  4215               .DB      ','
1C78-CD AC 0D    I  4216 ( 16)         CALL    GETNUM          ; Get a number
1C7B-CD F1 09    I  4217 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C7E-E3          I  4218 ( 16)         EX      (SP),HL         ; Save value,get address
1C7F-73          I  4219 (  7)         LD      (HL),E          ; Save LSB of value
1C80-23          I  4220 (  4)         INC     HL
1C81-72          I  4221 (  7)         LD      (HL),D          ; Save MSB of value
1C82-E1          I  4222 (  9)         POP     HL              ; Restore code string address
1C83-C9          I  4223 (  9)         RET
1C84-            I  4224
1C84-            I  4225
1C84-            I  4226       ; HEX$(nn) Convert 16 bit number to Hexadecimal string
1C84-            I  4227
1C84-CD AF 0D    I  4228 ( 16) HEX:    CALL    TSTNUM          ; Verify it's a number
1C87-CD F1 09    I  4229 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C8A-C5          I  4230 ( 11)         PUSH    BC              ; Save contents of BC
1C8B-21 2E 23    I  4231 (  9)         LD          HL,PBUFF
1C8E-7A          I  4232 (  4)         LD          A,D             ; Get high order into A
1C8F-FE 00       I  4233 (  6)         CP      $0
1C91-28 0C       I  4234 ( 6+)                 JR      Z,HEX2          ; Skip output if both high digits are zero
1C93-CD BC 1C    I  4235 ( 16)         CALL    BYT2ASC         ; Convert D to ASCII
1C96-78          I  4236 (  4)                 LD      A,B
1C97-FE 30       I  4237 (  6)                 CP      '0'
1C99-28 02       I  4238 ( 6+)                 JR      Z,HEX1          ; Don't store high digit if zero
1C9B-70          I  4239 (  7)         LD          (HL),B          ; Store it to PBUFF
1C9C-23          I  4240 (  4)         INC         HL              ; Next location
1C9D-71          I  4241 (  7) HEX1:   LD          (HL),C          ; Store C to PBUFF+1
1C9E-23          I  4242 (  4)         INC     HL              ; Next location
1C9F-7B          I  4243 (  4) HEX2:   LD          A,E             ; Get lower byte
1CA0-CD BC 1C    I  4244 ( 16)         CALL    BYT2ASC         ; Convert E to ASCII
1CA3-7A          I  4245 (  4)                 LD      A,D
1CA4-FE 00       I  4246 (  6)         CP      $0
1CA6-20 05       I  4247 ( 6+)                 JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
1CA8-78          I  4248 (  4)                 LD      A,B
1CA9-FE 30       I  4249 (  6)                 CP      '0'             ; If high digit of lower byte is zero then don't print
1CAB-28 02       I  4250 ( 6+)                 JR      Z,HEX4
1CAD-70          I  4251 (  7) HEX3:   LD      (HL),B          ; to PBUFF+2
1CAE-23          I  4252 (  4)         INC     HL              ; Next location
1CAF-71          I  4253 (  7) HEX4:   LD      (HL),C          ; to PBUFF+3
1CB0-23          I  4254 (  4)         INC     HL              ; PBUFF+4 to zero
1CB1-AF          I  4255 (  4)         XOR     A               ; Terminating character
1CB2-77          I  4256 (  7)         LD      (HL),A          ; Store zero to terminate
1CB3-23          I  4257 (  4)         INC     HL              ; Make sure PBUFF is terminated
1CB4-77          I  4258 (  7)         LD      (HL),A          ; Store the double zero there
1CB5-C1          I  4259 (  9)         POP     BC              ; Get BC back
1CB6-21 2E 23    I  4260 (  9)         LD      HL,PBUFF        ; Reset to start of PBUFF
1CB9-C3 15 12    I  4261 (  9)         JP      STR1            ; Convert the PBUFF to a string and return it
1CBC-            I  4262
1CBC-47          I  4263 (  4) BYT2ASC LD      B,A             ; Save original value
1CBD-E6 0F       I  4264 (  6)         AND     $0F             ; Strip off upper nybble
1CBF-FE 0A       I  4265 (  6)         CP      $0A             ; 0-9?
1CC1-38 02       I  4266 ( 6+)         JR      C,ADD30         ; If A-F, add 7 more
1CC3-C6 07       I  4267 (  6)         ADD     A,$07           ; Bring value up to ASCII A-F
1CC5-C6 30       I  4268 (  6) ADD30   ADD     A,$30           ; And make ASCII
1CC7-4F          I  4269 (  4)         LD      C,A             ; Save converted char to C
1CC8-78          I  4270 (  4)         LD      A,B             ; Retrieve original value
1CC9-0F          I  4271 (  3)         RRCA                    ; and Rotate it right
1CCA-0F          I  4272 (  3)         RRCA
1CCB-0F          I  4273 (  3)         RRCA
1CCC-0F          I  4274 (  3)         RRCA
1CCD-E6 0F       I  4275 (  6)         AND     $0F             ; Mask off upper nybble
1CCF-FE 0A       I  4276 (  6)         CP      $0A             ; 0-9? < A hex?
1CD1-38 02       I  4277 ( 6+)         JR      C,ADD301        ; Skip Add 7
1CD3-C6 07       I  4278 (  6)         ADD     A,$07           ; Bring it up to ASCII A-F
1CD5-C6 30       I  4279 (  6) ADD301  ADD     A,$30           ; And make it full ASCII
1CD7-47          I  4280 (  4)         LD      B,A             ; Store high order byte
1CD8-C9          I  4281 (  9)         RET
1CD9-            I  4282
1CD9-            I  4283       ; Convert "&Hnnnn" to FPREG
1CD9-            I  4284       ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
1CD9-            I  4285       ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
1CD9-EB          I  4286 (  3) HEXTFP  EX      DE,HL           ; Move code string pointer to DE
1CDA-21 00 00    I  4287 (  9)         LD      HL,$0000        ; Zero out the value
1CDD-CD F2 1C    I  4288 ( 16)         CALL    GETHEX          ; Check the number for valid hex
1CE0-DA 12 1D    I  4289 ( 6+)         JP      C,HXERR         ; First value wasn't hex, HX error
1CE3-18 05       I  4290 (  8)         JR      HEXLP1          ; Convert first character
1CE5-CD F2 1C    I  4291 ( 16) HEXLP   CALL    GETHEX          ; Get second and addtional characters
1CE8-38 1F       I  4292 ( 6+)         JR      C,HEXIT         ; Exit if not a hex character
1CEA-29          I  4293 (  7) HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
1CEB-29          I  4294 (  7)         ADD     HL,HL
1CEC-29          I  4295 (  7)         ADD     HL,HL
1CED-29          I  4296 (  7)         ADD     HL,HL
1CEE-B5          I  4297 (  4)         OR      L               ; Add in D0-D3 into L
1CEF-6F          I  4298 (  4)         LD      L,A             ; Save new value
1CF0-18 F3       I  4299 (  8)         JR      HEXLP           ; And continue until all hex characters are in
1CF2-            I  4300
1CF2-13          I  4301 (  4) GETHEX  INC     DE              ; Next location
1CF3-1A          I  4302 (  6)         LD      A,(DE)          ; Load character at pointer
1CF4-FE 20       I  4303 (  6)         CP      ' '
1CF6-CA F2 1C    I  4304 ( 6+)         JP      Z,GETHEX        ; Skip spaces
1CF9-D6 30       I  4305 (  6)         SUB     $30             ; Get absolute value
1CFB-D8          I  4306 ( 5+)         RET     C               ; < "0", error
1CFC-FE 0A       I  4307 (  6)         CP      $0A
1CFE-38 05       I  4308 ( 6+)         JR      C,NOSUB7        ; Is already in the range 0-9
1D00-D6 07       I  4309 (  6)         SUB     $07             ; Reduce to A-F
1D02-FE 0A       I  4310 (  6)         CP      $0A             ; Value should be $0A-$0F at this point
1D04-D8          I  4311 ( 5+)         RET     C               ; CY set if was :            ; < = > ? @
1D05-FE 10       I  4312 (  6) NOSUB7  CP      $10             ; > Greater than "F"?
1D07-3F          I  4313 (  3)         CCF
1D08-C9          I  4314 (  9)         RET                     ; CY set if it wasn't valid hex
1D09-            I  4315
1D09-EB          I  4316 (  3) HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
1D0A-7A          I  4317 (  4)         LD      A,D             ; Load DE into AC
1D0B-4B          I  4318 (  4)         LD      C,E             ; For prep to
1D0C-E5          I  4319 ( 11)         PUSH    HL
1D0D-CD 66 11    I  4320 ( 16)         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1D10-E1          I  4321 (  9)         POP     HL
1D11-C9          I  4322 (  9)         RET
1D12-            I  4323
1D12-1E 26       I  4324 (  6) HXERR:  LD      E,HX            ; ?HEX Error
1D14-C3 EC 04    I  4325 (  9)         JP      ERROR
1D17-            I  4326
1D17-            I  4327       ; BIN$(NN) Convert integer to a 1-16 char binary string
1D17-CD AF 0D    I  4328 ( 16) BIN:    CALL    TSTNUM          ; Verify it's a number
1D1A-CD F1 09    I  4329 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1D1D-C5          I  4330 ( 11) BIN2:   PUSH    BC              ; Save contents of BC
1D1E-21 2E 23    I  4331 (  9)         LD      HL,PBUFF
1D21-06 11       I  4332 (  6)         LD      B,17            ; One higher than max char count
1D23-            I  4333       ZEROSUP:                        ; Suppress leading zeros
1D23-05          I  4334 (  4)         DEC     B               ; Max 16 chars
1D24-78          I  4335 (  4)         LD      A,B
1D25-FE 01       I  4336 (  6)         CP      $01
1D27-28 08       I  4337 ( 6+)         JR      Z,BITOUT        ; Always output at least one character
1D29-CB 13       I  4338 (  7)         RL      E
1D2B-CB 12       I  4339 (  7)         RL      D
1D2D-30 F4       I  4340 ( 6+)         JR      NC,ZEROSUP
1D2F-18 04       I  4341 (  8)         JR      BITOUT2
1D31-            I  4342       BITOUT:
1D31-CB 13       I  4343 (  7)         RL      E
1D33-CB 12       I  4344 (  7)         RL      D               ; Top bit now in carry
1D35-            I  4345       BITOUT2:
1D35-3E 30       I  4346 (  6)         LD      A,'0'           ; Char for '0'
1D37-CE 00       I  4347 (  6)         ADC     A,0             ; If carry set then '0' --> '1'
1D39-77          I  4348 (  7)         LD      (HL),A
1D3A-23          I  4349 (  4)         INC     HL
1D3B-05          I  4350 (  4)         DEC     B
1D3C-20 F3       I  4351 ( 6+)         JR      NZ,BITOUT
1D3E-AF          I  4352 (  4)         XOR     A               ; Terminating character
1D3F-77          I  4353 (  7)         LD      (HL),A          ; Store zero to terminate
1D40-23          I  4354 (  4)         INC     HL              ; Make sure PBUFF is terminated
1D41-77          I  4355 (  7)         LD      (HL),A          ; Store the double zero there
1D42-C1          I  4356 (  9)         POP     BC
1D43-21 2E 23    I  4357 (  9)         LD      HL,PBUFF
1D46-C3 15 12    I  4358 (  9)         JP      STR1
1D49-            I  4359
1D49-            I  4360       ; Convert "&Bnnnn" to FPREG
1D49-            I  4361       ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1D49-EB          I  4362 (  3) BINTFP: EX      DE,HL           ; Move code string pointer to DE
1D4A-21 00 00    I  4363 (  9)         LD      HL,$0000        ; Zero out the value
1D4D-CD 66 1D    I  4364 ( 16)         CALL    CHKBIN          ; Check the number for valid bin
1D50-DA 74 1D    I  4365 ( 6+)         JP      C,BINERR        ; First value wasn't bin, HX error
1D53-D6 30       I  4366 (  6) BINIT:  SUB     '0'
1D55-29          I  4367 (  7)         ADD     HL,HL           ; Rotate HL left
1D56-B5          I  4368 (  4)         OR      L
1D57-6F          I  4369 (  4)         LD      L,A
1D58-CD 66 1D    I  4370 ( 16)         CALL    CHKBIN          ; Get second and addtional characters
1D5B-30 F6       I  4371 ( 6+)         JR      NC,BINIT        ; Process if a bin character
1D5D-EB          I  4372 (  3)         EX      DE,HL           ; Value into DE, Code string into HL
1D5E-7A          I  4373 (  4)         LD      A,D             ; Load DE into AC
1D5F-4B          I  4374 (  4)         LD      C,E             ; For prep to
1D60-E5          I  4375 ( 11)         PUSH    HL
1D61-CD 66 11    I  4376 ( 16)         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1D64-E1          I  4377 (  9)         POP     HL
1D65-C9          I  4378 (  9)         RET
1D66-            I  4379
1D66-            I  4380       ; Char is in A, NC if char is 0 or 1
1D66-13          I  4381 (  4) CHKBIN: INC     DE
1D67-1A          I  4382 (  6)         LD      A,(DE)
1D68-FE 20       I  4383 (  6)         CP      ' '
1D6A-CA 66 1D    I  4384 ( 6+)         JP      Z,CHKBIN        ; Skip spaces
1D6D-FE 30       I  4385 (  6)         CP      '0'             ; Set C if < '0'
1D6F-D8          I  4386 ( 5+)         RET     C
1D70-FE 32       I  4387 (  6)         CP      '2'
1D72-3F          I  4388 (  3)         CCF                     ; Set C if > '1'
1D73-C9          I  4389 (  9)         RET
1D74-            I  4390
1D74-1E 28       I  4391 (  6) BINERR: LD      E,BN            ; ?BIN Error
1D76-C3 EC 04    I  4392 (  9)         JP      ERROR
1D79-            I  4393
1D79-            I  4394
1D79-            I  4395       JJUMP1:
1D79-DD 21 FF FF I  4396 ( 12)         LD      IX,-1           ; Flag cold start
1D7D-C3 61 01    I  4397 (  9)         JP      CSTART          ; Go and initialise
1D80-            I  4398
1D80-            I  4399       MONOUT:
1D80-C3 08 00    I  4400 (  9)         JP      $0008           ; output a char
1D83-            I  4401
1D83-            I  4402
1D83-            I  4403       MONITR:
1D83-C3 00 00    I  4404 (  9)         JP      $0000           ; Restart (Normally Monitor Start)
1D86-            I  4405
1D86-            I  4406
1D86-3E 00       I  4407 (  6) INITST: LD      A,0             ; Clear break flag
1D88-32 92 22    I  4408 ( 13)         LD      (BRKFLG),A
1D8B-C3 68 01    I  4409 (  9)         JP      INIT
1D8E-            I  4410
1D8E-ED 45       I  4411 ( 12) ARETN:  RETN                    ; Return from NMI
1D90-            I  4412
1D90-            I  4413
1D90-F5          I  4414 ( 11) TSTBIT: PUSH    AF              ; Save bit mask
1D91-A0          I  4415 (  4)         AND     B               ; Get common bits
1D92-C1          I  4416 (  9)         POP     BC              ; Restore bit mask
1D93-B8          I  4417 (  4)         CP      B               ; Same bit set?
1D94-3E 00       I  4418 (  6)         LD      A,0             ; Return 0 in A
1D96-C9          I  4419 (  9)         RET
1D97-            I  4420
1D97-CD C0 07    I  4421 ( 16) OUTNCR: CALL    OUTC            ; Output character in A
1D9A-C3 E7 0B    I  4422 (  9)         JP      PRNTCRLF        ; Output CRLF
1D9D-            I  4423
1D9D-            I  4424       .end
1D9D-            I  4425
