0000-                 18       ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0000-                 19       ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0000-                 20       ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0000-                 21       ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0000-                 22       ; the original ROM code (checksum A934H). PA
0000-                 23
0000-                 24       ; GENERAL EQUATES
0000-                 25
0003-                 26       CTRLC   .EQU    03H             ; Control "C"
0007-                 27       CTRLG   .EQU    07H             ; Control "G"
0008-                 28       BKSP    .EQU    08H             ; Back space
000A-                 29       LF      .EQU    0AH             ; Line feed
000C-                 30       CS      .EQU    0CH             ; Clear screen
000D-                 31       CR      .EQU    0DH             ; Carriage return
000F-                 32       CTRLO   .EQU    0FH             ; Control "O"
0011-                 33       CTRLQ   .EQU    11H                     ; Control "Q"
0012-                 34       CTRLR   .EQU    12H             ; Control "R"
0013-                 35       CTRLS   .EQU    13H             ; Control "S"
0015-                 36       CTRLU   .EQU    15H             ; Control "U"
001B-                 37       ESC     .EQU    1BH             ; Escape
007F-                 38       DEL     .EQU    7FH             ; Delete
0000-                 39
0000-                 40       ; BASIC WORK SPACE LOCATIONS
0000-                 41
2045-                 42       WRKSPC  .EQU    2045H             ; BASIC Work space
2048-                 43       USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
204B-                 44       OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
204C-                 45       OTPORT  .EQU    WRKSPC+7H           ; Port (p)
204E-                 46       DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
204F-                 47       DIV1    .EQU    WRKSPC+0AH           ; <- Values
2053-                 48       DIV2    .EQU    WRKSPC+0EH           ; <-   to
2057-                 49       DIV3    .EQU    WRKSPC+12H           ; <-   be
205A-                 50       DIV4    .EQU    WRKSPC+15H           ; <-inserted
205C-                 51       SEED    .EQU    WRKSPC+17H           ; Random number seed
207F-                 52       LSTRND  .EQU    WRKSPC+3AH           ; Last random number
2083-                 53       INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
2084-                 54       INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
2086-                 55       NULLS   .EQU    WRKSPC+41H           ; Number of nulls
2087-                 56       LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
2088-                 57       COMMAN  .EQU    WRKSPC+43H           ; Width for commas
2089-                 58       NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
208A-                 59       CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
208B-                 60       LINESC  .EQU    WRKSPC+46H           ; Lines counter
208D-                 61       LINESN  .EQU    WRKSPC+48H           ; Lines number
208F-                 62       CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
2091-                 63       NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
2092-                 64       BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
2093-                 65       RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
2096-                 66       POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
2099-                 67       PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
209C-                 68       RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
209F-                 69       STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
20A1-                 70       LINEAT  .EQU    WRKSPC+5CH           ; Current line number
20A3-                 71       BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
20A6-                 72       BUFFER  .EQU    WRKSPC+61H           ; Input buffer
20AB-                 73       STACK   .EQU    WRKSPC+66H           ; Initial stack
20F0-                 74       CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
20F1-                 75       LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
20F2-                 76       TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
20F3-                 77       DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
20F4-                 78       LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
20F6-                 79       TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
20F8-                 80       TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
2104-                 81       TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
2108-                 82       STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
210A-                 83       CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
210C-                 84       LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
210E-                 85       DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
2110-                 86       FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
2111-                 87       LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
2112-                 88       READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
2113-                 89       BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
2115-                 90       NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
2117-                 91       ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
2119-                 92       CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
211B-                 93       PROGND  .EQU    WRKSPC+0D6H          ; End of program
211D-                 94       VAREND  .EQU    WRKSPC+0D8H          ; End of variables
211F-                 95       ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
2121-                 96       NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
2123-                 97       FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
2125-                 98       FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
2129-                 99       FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
212C-                100       FPEXP   .EQU    FPREG+3         ; Floating point exponent
212D-                101       SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
212E-                102       PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
213B-                103       MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
213E-                104       PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
21A2-                105       STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0000-                106
0000-                107       ; BASIC ERROR CODE VALUES
0000-                108
0000-                109       NF      .EQU    00H             ; NEXT without FOR
0002-                110       SN      .EQU    02H             ; Syntax error
0004-                111       RG      .EQU    04H             ; RETURN without GOSUB
0006-                112       OD      .EQU    06H             ; Out of DATA
0008-                113       FC      .EQU    08H             ; Function call error
000A-                114       OV      .EQU    0AH             ; Overflow
000C-                115       OM      .EQU    0CH             ; Out of memory
000E-                116       UL      .EQU    0EH             ; Undefined line number
0010-                117       BS      .EQU    10H             ; Bad subscript
0012-                118       DD      .EQU    12H             ; Re-DIMensioned array
0014-                119       DZ      .EQU    14H             ; Division by zero (/0)
0016-                120       ID      .EQU    16H             ; Illegal direct
0018-                121       TM      .EQU    18H             ; Type miss-match
001A-                122       OS      .EQU    1AH             ; Out of string space
001C-                123       LS      .EQU    1CH             ; String too long
001E-                124       ST      .EQU    1EH             ; String formula too complex
0020-                125       CN      .EQU    20H             ; Can't CONTinue
0022-                126       UF      .EQU    22H             ; UnDEFined FN function
0024-                127       MO      .EQU    24H             ; Missing operand
0026-                128       HX      .EQU    26H             ; HEX error
0028-                129       BN      .EQU    28H             ; BIN error
0000-                130
0150-                131               .ORG    00150H
0150-                132
0150-C3 56 01        133 (  9) COLD:   JP      STARTB          ; Jump for cold start
0153-C3 F4 01        134 (  9) WARM:   JP      WARMST          ; Jump for warm start
0156-                135       STARTB:
0156-DD 21 00 00     136 ( 12)         LD      IX,0            ; Flag cold start
015A-C3 61 01        137 (  9)         JP      CSTART          ; Jump to initialise
015D-                138
015D-07 0A           139               .DW   DEINT           ; Get integer -32768 to 32767
015F-7D 11           140               .DW   ABPASS          ; Return integer in AB
0161-                141
0161-                142
0161-21 45 20        143 (  9) CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0164-F9              144 (  4)         LD      SP,HL           ; Set up a temporary stack
0165-C3 9C 1D        145 (  9)         JP      INITST          ; Go to initialise
0168-                146
0168-11 2E 04        147 (  9) INIT:   LD      DE,INITAB       ; Initialise workspace
016B-06 63           148 (  6)         LD      B,INITBE-INITAB+3 ; Bytes to copy
016D-21 45 20        149 (  9)         LD      HL,WRKSPC       ; Into workspace RAM
0170-1A              150 (  6) COPY:   LD      A,(DE)          ; Get source
0171-77              151 (  7)         LD      (HL),A          ; To destination
0172-23              152 (  4)         INC     HL              ; Next destination
0173-13              153 (  4)         INC     DE              ; Next source
0174-05              154 (  4)         DEC     B               ; Count bytes
0175-C2 70 01        155 ( 6+)         JP      NZ,COPY         ; More to move
0178-F9              156 (  4)         LD      SP,HL           ; Temporary stack
0179-CD 2F 06        157 ( 16)         CALL    CLREG           ; Clear registers and stack
017C-CD FD 0B        158 ( 16)         CALL    PRNTCRLF        ; Output CRLF
017F-32 EF 20        159 ( 13)         LD      (BUFFER+72+1),A ; Mark end of buffer
0182-32 3E 21        160 ( 13)         LD      (PROGST),A      ; Initialise program area
0185-21 43 02        161 (  9) MSIZE:  LD      HL,MEMMSG       ; Point to message
0188-CD 9B 12        162 ( 16)         CALL    PRS             ; Output "Memory size"
018B-CD 4C 06        163 ( 16)         CALL    PROMPT          ; Get input with '?'
018E-CD 55 09        164 ( 16)         CALL    GETCHR          ; Get next character
0191-B7              165 (  4)         OR      A               ; Set flags
0192-C2 AA 01        166 ( 6+)         JP      NZ,TSTMEM       ; If number - Test if RAM there
0195-21 A2 21        167 (  9)         LD      HL,STLOOK       ; Point to start of RAM
0198-23              168 (  4) MLOOP:  INC     HL              ; Next byte
0199-7C              169 (  4)         LD      A,H             ; Above address FFFF ?
019A-B5              170 (  4)         OR      L
019B-CA BC 01        171 ( 6+)         JP      Z,SETTOP        ; Yes - 64K RAM
019E-7E              172 (  6)         LD      A,(HL)          ; Get contents
019F-47              173 (  4)         LD      B,A             ; Save it
01A0-2F              174 (  3)         CPL                     ; Flip all bits
01A1-77              175 (  7)         LD      (HL),A          ; Put it back
01A2-BE              176 (  6)         CP      (HL)            ; RAM there if same
01A3-70              177 (  7)         LD      (HL),B          ; Restore old contents
01A4-CA 98 01        178 ( 6+)         JP      Z,MLOOP         ; If RAM - test next byte
01A7-C3 BC 01        179 (  9)         JP      SETTOP          ; Top of RAM found
01AA-                180
01AA-CD 21 0A        181 ( 16) TSTMEM: CALL    ATOH            ; Get high memory into DE
01AD-B7              182 (  4)         OR      A               ; Set flags on last byte
01AE-C2 FD 04        183 ( 6+)         JP      NZ,SNERR        ; ?SN Error if bad character
01B1-EB              184 (  3)         EX      DE,HL           ; Address into HL
01B2-2B              185 (  4)         DEC     HL              ; Back one byte
01B3-3E D9           186 (  6)         LD      A,11011001B     ; Test byte
01B5-46              187 (  6)         LD      B,(HL)          ; Get old contents
01B6-77              188 (  7)         LD      (HL),A          ; Load test byte
01B7-BE              189 (  6)         CP      (HL)            ; RAM there if same
01B8-70              190 (  7)         LD      (HL),B          ; Restore old contents
01B9-C2 85 01        191 ( 6+)         JP      NZ,MSIZE        ; Ask again if no RAM
01BC-                192
01BC-2B              193 (  4) SETTOP: DEC     HL              ; Back one byte
01BD-11 A1 21        194 (  9)         LD      DE,STLOOK-1     ; See if enough RAM
01C0-CD C5 07        195 ( 16)         CALL    CPDEHL          ; Compare DE with HL
01C3-DA 85 01        196 ( 6+)         JP      C,MSIZE         ; Ask again if not enough RAM
01C6-11 CE FF        197 (  9)         LD      DE,0-50         ; 50 Bytes string space
01C9-22 F4 20        198 ( 20)         LD      (LSTRAM),HL     ; Save last available RAM
01CC-19              199 (  7)         ADD     HL,DE           ; Allocate string space
01CD-22 9F 20        200 ( 20)         LD      (STRSPC),HL     ; Save string space
01D0-CD 0A 06        201 ( 16)         CALL    CLRPTR          ; Clear program area
01D3-2A 9F 20        202 ( 15)         LD      HL,(STRSPC)     ; Get end of memory
01D6-11 EF FF        203 (  9)         LD      DE,0-17         ; Offset for free bytes
01D9-19              204 (  7)         ADD     HL,DE           ; Adjust HL
01DA-11 3E 21        205 (  9)         LD      DE,PROGST       ; Start of program text
01DD-7D              206 (  4)         LD      A,L             ; Get LSB
01DE-93              207 (  4)         SUB     E               ; Adjust it
01DF-6F              208 (  4)         LD      L,A             ; Re-save
01E0-7C              209 (  4)         LD      A,H             ; Get MSB
01E1-9A              210 (  4)         SBC     A,D             ; Adjust it
01E2-67              211 (  4)         LD      H,A             ; Re-save
01E3-E5              212 ( 11)         PUSH    HL              ; Save bytes free
01E4-21 0C 02        213 (  9)         LD      HL,SIGNON       ; Sign-on message
01E7-CD 9B 12        214 ( 16)         CALL    PRS             ; Output string
01EA-E1              215 (  9)         POP     HL              ; Get bytes free back
01EB-CD 3E 19        216 ( 16)         CALL    PRNTHL          ; Output amount of free memory
01EE-21 FD 01        217 (  9)         LD      HL,BFREE        ; " Bytes free" message
01F1-CD 9B 12        218 ( 16)         CALL    PRS             ; Output string
01F4-                219
01F4-31 AB 20        220 (  9) WARMST: LD      SP,STACK        ; Temporary stack
01F7-CD 2F 06        221 ( 16) BRKRET: CALL    CLREG           ; Clear registers and stack
01FA-C3 48 05        222 (  9)         JP      PRNTOK          ; Go to get command line
01FD-                223
01FD-20 42 79 74 
     65 73 20 66 
     72 65 65 0D 
     0A 00 00        224       BFREE:  .DB   " Bytes free",CR,LF,0,0
020C-                225
020C-5A 38 30 20 
     42 41 53 49 
     43 20 56 65 
     72 20 34 2E 
     37 62 0D 0A     226       SIGNON: .DB   "Z80 BASIC Ver 4.7b",CR,LF
0220-43 6F 70 79 
     72 69 67 68 
     74 20 28 43 
     29              227               .DB   "Copyright ",40,"C",41
022D-20 31 39 37 
     38 20 62 79 
     20 4D 69 63 
     72 6F 73 6F 
     66 74 0D 0A 
     00 00           228               .DB   " 1978 by Microsoft",CR,LF,0,0
0243-                229
0243-4D 65 6D 6F 
     72 79 20 74 
     6F 70 00        230       MEMMSG: .DB   "Memory top",0
024E-                231
024E-                232       ; FUNCTION ADDRESS TABLE
024E-                233
024E-B3 17           234       FNCTAB: .DW   SGN
0250-77 18           235               .DW   INT
0252-C9 17           236               .DW   ABS
0254-48 20           237               .DW   USR
0256-5B 11           238               .DW   FRE
0258-E0 14           239               .DW   INP
025A-89 11           240               .DW   POS
025C-3D 1A           241               .DW   SQR
025E-1C 1B           242               .DW   RND
0260-58 16           243               .DW   LOG
0262-8B 1A           244               .DW   EXP
0264-91 1B           245               .DW   COS
0266-97 1B           246               .DW   SIN
0268-F8 1B           247               .DW   TAN
026A-0D 1C           248               .DW   ATN
026C-34 15           249               .DW   PEEK
026E-78 1C           250               .DW   DEEK
0270-96 20           251               .DW   POINT
0272-0D 14           252               .DW   LEN
0274-25 12           253               .DW   STR
0276-A7 14           254               .DW   VAL
0278-1C 14           255               .DW   ASC
027A-2D 14           256               .DW   CHR
027C-9A 1C           257               .DW   HEX
027E-2D 1D           258               .DW   BIN
0280-3D 14           259               .DW   LEFT
0282-6D 14           260               .DW   RIGHT
0284-77 14           261               .DW   MID
0286-                262
0286-                263       ; RESERVED WORD LIST
0286-                264
0286-C5              265       WORDS:  .AT   'E'
0287-4E 44           266               .DB "ND"
0289-C6              267               .AT   'F'
028A-4F 52           268               .DB "OR"
028C-CE              269               .AT   'N'
028D-45 58 54        270               .DB "EXT"
0290-C4              271               .AT   'D'
0291-41 54 41        272               .DB "ATA"
0294-C9              273               .AT   'I'
0295-4E 50 55 54     274               .DB "NPUT"
0299-C4              275               .AT   'D'
029A-49 4D           276               .DB "IM"
029C-D2              277               .AT   'R'
029D-45 41 44        278               .DB "EAD"
02A0-CC              279               .AT   'L'
02A1-45 54           280               .DB "ET"
02A3-C7              281               .AT   'G'
02A4-4F 54 4F        282               .DB "OTO"
02A7-D2              283               .AT   'R'
02A8-55 4E           284               .DB "UN"
02AA-C9              285               .AT   'I'
02AB-46              286               .DB "F"
02AC-D2              287               .AT   'R'
02AD-45 53 54 4F 
     52 45           288               .DB "ESTORE"
02B3-C7              289               .AT   'G'
02B4-4F 53 55 42     290               .DB "OSUB"
02B8-D2              291               .AT   'R'
02B9-45 54 55 52 
     4E              292               .DB "ETURN"
02BE-D2              293               .AT   'R'
02BF-45 4D           294               .DB "EM"
02C1-D3              295               .AT   'S'
02C2-54 4F 50        296               .DB "TOP"
02C5-CF              297               .AT   'O'
02C6-55 54           298               .DB "UT"
02C8-CF              299               .AT   'O'
02C9-4E              300               .DB "N"
02CA-CE              301               .AT   'N'
02CB-55 4C 4C        302               .DB "ULL"
02CE-D7              303               .AT   'W'
02CF-41 49 54        304               .DB "AIT"
02D2-C4              305               .AT   'D'
02D3-45 46           306               .DB "EF"
02D5-D0              307               .AT   'P'
02D6-4F 4B 45        308               .DB "OKE"
02D9-C4              309               .AT   'D'
02DA-4F 4B 45        310               .DB "OKE"
02DD-D3              311               .AT   'S'
02DE-43 52 45 45 
     4E              312               .DB "CREEN"
02E3-CC              313               .AT   'L'
02E4-49 4E 45 53     314               .DB "INES"
02E8-C3              315               .AT   'C'
02E9-4C 53           316               .DB "LS"
02EB-D7              317               .AT   'W'
02EC-49 44 54 48     318               .DB "IDTH"
02F0-CD              319               .AT   'M'
02F1-4F 4E 49 54 
     4F 52           320               .DB "ONITOR"
02F7-D3              321               .AT   'S'
02F8-45 54           322               .DB "ET"
02FA-D2              323               .AT   'R'
02FB-45 53 45 54     324               .DB "ESET"
02FF-D0              325               .AT   'P'
0300-52 49 4E 54     326               .DB "RINT"
0304-C3              327               .AT   'C'
0305-4F 4E 54        328               .DB "ONT"
0308-CC              329               .AT   'L'
0309-49 53 54        330               .DB "IST"
030C-C3              331               .AT   'C'
030D-4C 45 41 52     332               .DB "LEAR"
0311-C3              333               .AT   'C'
0312-4C 4F 41 44     334               .DB "LOAD"
0316-C3              335               .AT   'C'
0317-53 41 56 45     336               .DB "SAVE"
031B-CE              337               .AT   'N'
031C-45 57           338               .DB "EW"
031E-                339
031E-D4              340               .AT   'T'
031F-41 42 28        341               .DB "AB("
0322-D4              342               .AT   'T'
0323-4F              343               .DB "O"
0324-C6              344               .AT   'F'
0325-4E              345               .DB "N"
0326-D3              346               .AT   'S'
0327-50 43 28        347               .DB "PC("
032A-D4              348               .AT   'T'
032B-48 45 4E        349               .DB "HEN"
032E-CE              350               .AT   'N'
032F-4F 54           351               .DB "OT"
0331-D3              352               .AT   'S'
0332-54 45 50        353               .DB "TEP"
0335-                354
0335-AB              355               .AT   '+'
0336-AD              356               .AT   '-'
0337-AA              357               .AT   '*'
0338-AF              358               .AT   '/'
0339-DE              359               .AT   '^'
033A-C1              360               .AT   'A'
033B-4E 44           361               .DB "ND"
033D-CF              362               .AT   'O'
033E-52              363               .DB "R"
033F-BE              364               .AT   '>'
0340-BD              365               .AT   '='
0341-BC              366               .AT   '<'
0342-                367
0342-D3              368               .AT   'S'
0343-47 4E           369               .DB "GN"
0345-C9              370               .AT   'I'
0346-4E 54           371               .DB "NT"
0348-C1              372               .AT   'A'
0349-42 53           373               .DB "BS"
034B-D5              374               .AT   'U'
034C-53 52           375               .DB "SR"
034E-C6              376               .AT   'F'
034F-52 45           377               .DB "RE"
0351-C9              378               .AT   'I'
0352-4E 50           379               .DB "NP"
0354-D0              380               .AT   'P'
0355-4F 53           381               .DB "OS"
0357-D3              382               .AT   'S'
0358-51 52           383               .DB "QR"
035A-D2              384               .AT   'R'
035B-4E 44           385               .DB "ND"
035D-CC              386               .AT   'L'
035E-4F 47           387               .DB "OG"
0360-C5              388               .AT   'E'
0361-58 50           389               .DB "XP"
0363-C3              390               .AT   'C'
0364-4F 53           391               .DB "OS"
0366-D3              392               .AT   'S'
0367-49 4E           393               .DB "IN"
0369-D4              394               .AT   'T'
036A-41 4E           395               .DB "AN"
036C-C1              396               .AT   'A'
036D-54 4E           397               .DB "TN"
036F-D0              398               .AT   'P'
0370-45 45 4B        399               .DB "EEK"
0373-C4              400               .AT   'D'
0374-45 45 4B        401               .DB "EEK"
0377-D0              402               .AT   'P'
0378-4F 49 4E 54     403               .DB "OINT"
037C-CC              404               .AT   'L'
037D-45 4E           405               .DB "EN"
037F-D3              406               .AT   'S'
0380-54 52 24        407               .DB "TR$"
0383-D6              408               .AT   'V'
0384-41 4C           409               .DB "AL"
0386-C1              410               .AT   'A'
0387-53 43           411               .DB "SC"
0389-C3              412               .AT   'C'
038A-48 52 24        413               .DB "HR$"
038D-C8              414               .AT   'H'
038E-45 58 24        415               .DB "EX$"
0391-C2              416               .AT   'B'
0392-49 4E 24        417               .DB "IN$"
0395-CC              418               .AT   'L'
0396-45 46 54 24     419               .DB "EFT$"
039A-D2              420               .AT   'R'
039B-49 47 48 54 
     24              421               .DB "IGHT$"
03A0-CD              422               .AT   'M'
03A1-49 44 24        423               .DB "ID$"
03A4-80              424               .DB   80H             ; End of list marker
03A5-                425
03A5-                426       ; KEYWORD ADDRESS TABLE
03A5-                427
03A5-9F 09           428       WORDTB: .DW   PEND
03A7-9C 08           429               .DW   FOR
03A9-77 0D           430               .DW   NEXT
03AB-EC 0A           431               .DW   DATA
03AD-7E 0C           432               .DW   INPUT
03AF-B3 0F           433               .DW   DIM
03B1-AD 0C           434               .DW   READ
03B3-03 0B           435               .DW   LET
03B5-A9 0A           436               .DW   GOTO
03B7-8C 0A           437               .DW   RUN
03B9-7B 0B           438               .DW   IF
03BB-65 09           439               .DW   RESTOR
03BD-98 0A           440               .DW   GOSUB
03BF-C7 0A           441               .DW   RETURN
03C1-EE 0A           442               .DW   REM
03C3-9D 09           443               .DW   STOP
03C5-EC 14           444               .DW   POUT
03C7-5D 0B           445               .DW   ON
03C9-DE 09           446               .DW   NULL
03CB-F2 14           447               .DW   WAIT
03CD-91 11           448               .DW   DEF
03CF-3B 15           449               .DW   POKE
03D1-83 1C           450               .DW   DOKE
03D3-EE 0A           451               .DW   REM
03D5-69 1C           452               .DW   LINES
03D7-5C 1C           453               .DW   CLS
03D9-61 1C           454               .DW   WIDTH
03DB-99 1D           455               .DW   MONITR
03DD-99 20           456               .DW   PSET
03DF-9C 20           457               .DW   RESET
03E1-9F 0B           458               .DW   PRINT
03E3-CB 09           459               .DW   CONT
03E5-11 08           460               .DW   LIST
03E7-46 0A           461               .DW   CLEAR
03E9-EE 0A           462               .DW   REM
03EB-EE 0A           463               .DW   REM
03ED-09 06           464               .DW   NEW
03EF-                465
03EF-                466       ; RESERVED WORD TOKEN VALUES
03EF-                467
0080-                468       ZEND    .EQU    080H            ; END
0081-                469       ZFOR    .EQU    081H            ; FOR
0083-                470       ZDATA   .EQU    083H            ; DATA
0088-                471       ZGOTO   .EQU    088H            ; GOTO
008C-                472       ZGOSUB  .EQU    08CH            ; GOSUB
008E-                473       ZREM    .EQU    08EH            ; REM
009E-                474       ZPRINT  .EQU    09EH            ; PRINT
00A4-                475       ZNEW    .EQU    0A4H            ; NEW
03EF-                476
00A5-                477       ZTAB    .EQU    0A5H            ; TAB
00A6-                478       ZTO     .EQU    0A6H            ; TO
00A7-                479       ZFN     .EQU    0A7H            ; FN
00A8-                480       ZSPC    .EQU    0A8H            ; SPC
00A9-                481       ZTHEN   .EQU    0A9H            ; THEN
00AA-                482       ZNOT    .EQU    0AAH            ; NOT
00AB-                483       ZSTEP   .EQU    0ABH            ; STEP
03EF-                484
00AC-                485       ZPLUS   .EQU    0ACH            ; +
00AD-                486       ZMINUS  .EQU    0ADH            ; -
00AE-                487       ZTIMES  .EQU    0AEH            ; *
00AF-                488       ZDIV    .EQU    0AFH            ; /
00B2-                489       ZOR     .EQU    0B2H            ; OR
00B3-                490       ZGTR    .EQU    0B3H            ; >
00B4-                491       ZEQUAL  .EQU    0B4H            ; M
00B5-                492       ZLTH    .EQU    0B5H            ; <
00B6-                493       ZSGN    .EQU    0B6H            ; SGN
00C7-                494       ZPOINT  .EQU    0C7H            ; POINT
00CD-                495       ZLEFT   .EQU    0CDH +2         ; LEFT$
03EF-                496
03EF-                497       ; ARITHMETIC PRECEDENCE TABLE
03EF-                498
03EF-79              499       PRITAB: .DB   79H             ; Precedence value
03F0-25 19           500               .DW   PADD            ; FPREG = <last> + FPREG
03F2-                501
03F2-79              502               .DB   79H             ; Precedence value
03F3-59 15           503               .DW   PSUB            ; FPREG = <last> - FPREG
03F5-                504
03F5-7C              505               .DB   7CH             ; Precedence value
03F6-97 16           506               .DW   MULT            ; PPREG = <last> * FPREG
03F8-                507
03F8-7C              508               .DB   7CH             ; Precedence value
03F9-F8 16           509               .DW   DIV             ; FPREG = <last> / FPREG
03FB-                510
03FB-7F              511               .DB   7FH             ; Precedence value
03FC-46 1A           512               .DW   POWER           ; FPREG = <last> ^ FPREG
03FE-                513
03FE-50              514               .DB   50H             ; Precedence value
03FF-0C 0F           515               .DW   PAND            ; FPREG = <last> AND FPREG
0401-                516
0401-46              517               .DB   46H             ; Precedence value
0402-0B 0F           518               .DW   POR             ; FPREG = <last> OR FPREG
0404-                519
0404-                520       ; BASIC ERROR CODE LIST
0404-                521
0404-4E 46           522       ERRORS: .DB   "NF"            ; NEXT without FOR
0406-53 4E           523               .DB   "SN"            ; Syntax error
0408-52 47           524               .DB   "RG"            ; RETURN without GOSUB
040A-4F 44           525               .DB   "OD"            ; Out of DATA
040C-46 43           526               .DB   "FC"            ; Illegal function call
040E-4F 56           527               .DB   "OV"            ; Overflow error
0410-4F 4D           528               .DB   "OM"            ; Out of memory
0412-55 4C           529               .DB   "UL"            ; Undefined line
0414-42 53           530               .DB   "BS"            ; Bad subscript
0416-44 44           531               .DB   "DD"            ; Re-DIMensioned array
0418-2F 30           532               .DB   "/0"            ; Division by zero
041A-49 44           533               .DB   "ID"            ; Illegal direct
041C-54 4D           534               .DB   "TM"            ; Type mis-match
041E-4F 53           535               .DB   "OS"            ; Out of string space
0420-4C 53           536               .DB   "LS"            ; String too long
0422-53 54           537               .DB   "ST"            ; String formula too complex
0424-43 4E           538               .DB   "CN"            ; Can't CONTinue
0426-55 46           539               .DB   "UF"            ; Undefined FN function
0428-4D 4F           540               .DB   "MO"            ; Missing operand
042A-48 58           541               .DB   "HX"            ; HEX error
042C-42 4E           542               .DB   "BN"            ; BIN error
042E-                543
042E-                544       ; INITIALISATION TABLE -------------------------------------------------------
042E-                545
042E-C3 F4 01        546 (  9) INITAB: JP      WARMST          ; Warm start jump
0431-C3 1C 0A        547 (  9)         JP      FCERR           ; "USR (X)" jump (Set to Error)
0434-D3 00           548 ( 10)         OUT     (0),A           ; "OUT p,n" skeleton
0436-C9              549 (  9)         RET
0437-D6 00           550 (  6)         SUB     0               ; Division support routine
0439-6F              551 (  4)         LD      L,A
043A-7C              552 (  4)         LD      A,H
043B-DE 00           553 (  6)         SBC     A,0
043D-67              554 (  4)         LD      H,A
043E-78              555 (  4)         LD      A,B
043F-DE 00           556 (  6)         SBC     A,0
0441-47              557 (  4)         LD      B,A
0442-3E 00           558 (  6)         LD      A,0
0444-C9              559 (  9)         RET
0445-00 00 00        560               .DB   0,0,0                   ; Random number seed table used by RND
0448-35 4A CA 99     561               .DB   035H,04AH,0CAH,099H     ;-2.65145E+07
044C-39 1C 76 98     562               .DB   039H,01CH,076H,098H     ; 1.61291E+07
0450-22 95 B3 98     563               .DB   022H,095H,0B3H,098H     ;-1.17691E+07
0454-0A DD 47 98     564               .DB   00AH,0DDH,047H,098H     ; 1.30983E+07
0458-53 D1 99 99     565               .DB   053H,0D1H,099H,099H     ;-2-01612E+07
045C-0A 1A 9F 98     566               .DB   00AH,01AH,09FH,098H     ;-1.04269E+07
0460-65 BC CD 98     567               .DB   065H,0BCH,0CDH,098H     ;-1.34831E+07
0464-D6 77 3E 98     568               .DB   0D6H,077H,03EH,098H     ; 1.24825E+07
0468-52 C7 4F 80     569               .DB   052H,0C7H,04FH,080H     ; Last random number
046C-DB 00           570 (  9)         IN      A,(0)           ; INP (x) skeleton
046E-C9              571 (  9)         RET
046F-01              572               .DB   1               ; POS (x) number (1)
0470-FF              573               .DB   255             ; Terminal width (255 = no auto CRLF)
0471-1C              574               .DB   28              ; Width for commas (3 columns)
0472-00              575               .DB   0               ; No nulls after input bytes
0473-00              576               .DB   0               ; Output enabled (^O off)
0474-14 00           577               .DW   20              ; Initial lines counter
0476-14 00           578               .DW   20              ; Initial lines number
0478-00 00           579               .DW   0               ; Array load/save check sum
047A-00              580               .DB   0               ; Break not by NMI
047B-00              581               .DB   0               ; Break flag
047C-C3 42 07        582 (  9)         JP      TTYLIN          ; Input reflection (set to TTY)
047F-C3 00 00        583 (  9)         JP      $0000           ; POINT reflection unused
0482-C3 00 00        584 (  9)         JP      $0000           ; SET reflection
0485-C3 00 00        585 (  9)         JP      $0000           ; RESET reflection
0488-A2 21           586               .DW   STLOOK          ; Temp string space
048A-FE FF           587               .DW   -2              ; Current line number (cold)
048C-3F 21           588               .DW   PROGST+1        ; Start of program text
048E-                589       INITBE:
048E-                590
048E-                591       ; END OF INITIALISATION TABLE ---------------------------------------------------
048E-                592
048E-20 45 72 72 
     6F 72 00        593       ERRMSG: .DB   " Error",0
0495-20 69 6E 20 
     00              594       INMSG:  .DB   " in ",0
0499-                595       ZERBYT  .EQU    $-1             ; A zero byte
049A-4F 6B 0D 0A 
     00 00           596       OKMSG:  .DB   "Ok",CR,LF,0,0
04A0-42 72 65 61 
     6B 00           597       BRKMSG: .DB   "Break",0
04A6-                598
04A6-21 04 00        599 (  9) BAKSTK: LD      HL,4            ; Look for "FOR" block with
04A9-39              600 (  7)         ADD     HL,SP           ; same index as specified
04AA-7E              601 (  6) LOKFOR: LD      A,(HL)          ; Get block ID
04AB-23              602 (  4)         INC     HL              ; Point to index address
04AC-FE 81           603 (  6)         CP      ZFOR            ; Is it a "FOR" token
04AE-C0              604 ( 5+)         RET     NZ              ; No - exit
04AF-4E              605 (  6)         LD      C,(HL)          ; BC = Address of "FOR" index
04B0-23              606 (  4)         INC     HL
04B1-46              607 (  6)         LD      B,(HL)
04B2-23              608 (  4)         INC     HL              ; Point to sign of STEP
04B3-E5              609 ( 11)         PUSH    HL              ; Save pointer to sign
04B4-69              610 (  4)         LD      L,C             ; HL = address of "FOR" index
04B5-60              611 (  4)         LD      H,B
04B6-7A              612 (  4)         LD      A,D             ; See if an index was specified
04B7-B3              613 (  4)         OR      E               ; DE = 0 if no index specified
04B8-EB              614 (  3)         EX      DE,HL           ; Specified index into HL
04B9-CA C0 04        615 ( 6+)         JP      Z,INDFND        ; Skip if no index given
04BC-EB              616 (  3)         EX      DE,HL           ; Index back into DE
04BD-CD C5 07        617 ( 16)         CALL    CPDEHL          ; Compare index with one given
04C0-01 0D 00        618 (  9) INDFND: LD      BC,16-3         ; Offset to next block
04C3-E1              619 (  9)         POP     HL              ; Restore pointer to sign
04C4-C8              620 ( 5+)         RET     Z               ; Return if block found
04C5-09              621 (  7)         ADD     HL,BC           ; Point to next block
04C6-C3 AA 04        622 (  9)         JP      LOKFOR          ; Keep on looking
04C9-                623
04C9-CD E3 04        624 ( 16) MOVUP:  CALL    ENFMEM          ; See if enough memory
04CC-C5              625 ( 11) MOVSTR: PUSH    BC              ; Save end of source
04CD-E3              626 ( 16)         EX      (SP),HL         ; Swap source and dest" end
04CE-C1              627 (  9)         POP     BC              ; Get end of destination
04CF-CD C5 07        628 ( 16) MOVLP:  CALL    CPDEHL          ; See if list moved
04D2-7E              629 (  6)         LD      A,(HL)          ; Get byte
04D3-02              630 (  7)         LD      (BC),A          ; Move it
04D4-C8              631 ( 5+)         RET     Z               ; Exit if all done
04D5-0B              632 (  4)         DEC     BC              ; Next byte to move to
04D6-2B              633 (  4)         DEC     HL              ; Next byte to move
04D7-C3 CF 04        634 (  9)         JP      MOVLP           ; Loop until all bytes moved
04DA-                635
04DA-E5              636 ( 11) CHKSTK: PUSH    HL              ; Save code string address
04DB-2A 1F 21        637 ( 15)         LD      HL,(ARREND)     ; Lowest free memory
04DE-06 00           638 (  6)         LD      B,0             ; BC = Number of levels to test
04E0-09              639 (  7)         ADD     HL,BC           ; 2 Bytes for each level
04E1-09              640 (  7)         ADD     HL,BC
04E2-3E              641               .DB   3EH             ; Skip "PUSH HL"
04E3-E5              642 ( 11) ENFMEM: PUSH    HL              ; Save code string address
04E4-3E D0           643 (  6)         LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
04E6-95              644 (  4)         SUB     L
04E7-6F              645 (  4)         LD      L,A
04E8-3E FF           646 (  6)         LD      A,0FFH ;HIGH (-48) ; 48 Bytes minimum RAM
04EA-9C              647 (  4)         SBC     A,H
04EB-DA F2 04        648 ( 6+)         JP      C,OMERR         ; Not enough - ?OM Error
04EE-67              649 (  4)         LD      H,A
04EF-39              650 (  7)         ADD     HL,SP           ; Test if stack is overflowed
04F0-E1              651 (  9)         POP     HL              ; Restore code string address
04F1-D8              652 ( 5+)         RET     C               ; Return if enough mmory
04F2-1E 0C           653 (  6) OMERR:  LD      E,OM            ; ?OM Error
04F4-C3 11 05        654 (  9)         JP      ERROR
04F7-                655
04F7-2A 0E 21        656 ( 15) DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
04FA-22 A1 20        657 ( 20)         LD      (LINEAT),HL     ; Save as current line
04FD-1E 02           658 (  6) SNERR:  LD      E,SN            ; ?SN Error
04FF-01              659               .DB   01H             ; Skip "LD E,DZ"
0500-1E 14           660 (  6) DZERR:  LD      E,DZ            ; ?/0 Error
0502-01              661               .DB   01H             ; Skip "LD E,NF"
0503-1E 00           662 (  6) NFERR:  LD      E,NF            ; ?NF Error
0505-01              663               .DB   01H             ; Skip "LD E,DD"
0506-1E 12           664 (  6) DDERR:  LD      E,DD            ; ?DD Error
0508-01              665               .DB   01H             ; Skip "LD E,UF"
0509-1E 22           666 (  6) UFERR:  LD      E,UF            ; ?UF Error
050B-01              667               .DB   01H             ; Skip "LD E,OV
050C-1E 0A           668 (  6) OVERR:  LD      E,OV            ; ?OV Error
050E-01              669               .DB   01H             ; Skip "LD E,TM"
050F-1E 18           670 (  6) TMERR:  LD      E,TM            ; ?TM Error
0511-                671
0511-CD 2F 06        672 ( 16) ERROR:  CALL    CLREG           ; Clear registers and stack
0514-32 8A 20        673 ( 13)         LD      (CTLOFG),A      ; Enable output (A is 0)
0517-CD F0 0B        674 ( 16)         CALL    STTLIN          ; Start new line
051A-21 04 04        675 (  9)         LD      HL,ERRORS       ; Point to error codes
051D-57              676 (  4)         LD      D,A             ; D = 0 (A is 0)
051E-3E 3F           677 (  6)         LD      A,'?'
0520-CD D6 07        678 ( 16)         CALL    OUTC            ; Output '?'
0523-19              679 (  7)         ADD     HL,DE           ; Offset to correct error code
0524-7E              680 (  6)         LD      A,(HL)          ; First character
0525-CD D6 07        681 ( 16)         CALL    OUTC            ; Output it
0528-CD 55 09        682 ( 16)         CALL    GETCHR          ; Get next character
052B-CD D6 07        683 ( 16)         CALL    OUTC            ; Output it
052E-21 8E 04        684 (  9)         LD      HL,ERRMSG       ; "Error" message
0531-CD 9B 12        685 ( 16) ERRIN:  CALL    PRS             ; Output message
0534-2A A1 20        686 ( 15)         LD      HL,(LINEAT)     ; Get line of error
0537-11 FE FF        687 (  9)         LD      DE,-2           ; Cold start error if -2
053A-CD C5 07        688 ( 16)         CALL    CPDEHL          ; See if cold start error
053D-CA 61 01        689 ( 6+)         JP      Z,CSTART        ; Cold start error - Restart
0540-7C              690 (  4)         LD      A,H             ; Was it a direct error?
0541-A5              691 (  4)         AND     L               ; Line = -1 if direct error
0542-3C              692 (  4)         INC     A
0543-C4 36 19        693 ( 6+)         CALL    NZ,LINEIN       ; No - output line of error
0546-3E              694               .DB   3EH             ; Skip "POP BC"
0547-C1              695 (  9) POPNOK: POP     BC              ; Drop address in input buffer
0548-                696
0548-AF              697 (  4) PRNTOK: XOR     A               ; Output "Ok" and get command
0549-32 8A 20        698 ( 13)         LD      (CTLOFG),A      ; Enable output
054C-CD F0 0B        699 ( 16)         CALL    STTLIN          ; Start new line
054F-21 9A 04        700 (  9)         LD      HL,OKMSG        ; "Ok" message
0552-CD 9B 12        701 ( 16)         CALL    PRS             ; Output "Ok"
0555-21 FF FF        702 (  9) GETCMD: LD      HL,-1           ; Flag direct mode
0558-22 A1 20        703 ( 20)         LD      (LINEAT),HL     ; Save as current line
055B-CD 42 07        704 ( 16)         CALL    GETLIN          ; Get an input line
055E-DA 55 05        705 ( 6+)         JP      C,GETCMD        ; Get line again if break
0561-CD 55 09        706 ( 16)         CALL    GETCHR          ; Get first character
0564-3C              707 (  4)         INC     A               ; Test if end of line
0565-3D              708 (  4)         DEC     A               ; Without affecting Carry
0566-CA 55 05        709 ( 6+)         JP      Z,GETCMD        ; Nothing entered - Get another
0569-F5              710 ( 11)         PUSH    AF              ; Save Carry status
056A-CD 21 0A        711 ( 16)         CALL    ATOH            ; Get line number into DE
056D-D5              712 ( 11)         PUSH    DE              ; Save line number
056E-CD 59 06        713 ( 16)         CALL    CRUNCH          ; Tokenise rest of line
0571-47              714 (  4)         LD      B,A             ; Length of tokenised line
0572-D1              715 (  9)         POP     DE              ; Restore line number
0573-F1              716 (  9)         POP     AF              ; Restore Carry
0574-D2 35 09        717 ( 6+)         JP      NC,EXCUTE       ; No line number - Direct mode
0577-D5              718 ( 11)         PUSH    DE              ; Save line number
0578-C5              719 ( 11)         PUSH    BC              ; Save length of tokenised line
0579-AF              720 (  4)         XOR     A
057A-32 11 21        721 ( 13)         LD      (LSTBIN),A      ; Clear last byte input
057D-CD 55 09        722 ( 16)         CALL    GETCHR          ; Get next character
0580-B7              723 (  4)         OR      A               ; Set flags
0581-F5              724 ( 11)         PUSH    AF              ; And save them
0582-CD E9 05        725 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0585-DA 8E 05        726 ( 6+)         JP      C,LINFND        ; Jump if line found
0588-F1              727 (  9)         POP     AF              ; Get status
0589-F5              728 ( 11)         PUSH    AF              ; And re-save
058A-CA C2 0A        729 ( 6+)         JP      Z,ULERR         ; Nothing after number - Error
058D-B7              730 (  4)         OR      A               ; Clear Carry
058E-C5              731 ( 11) LINFND: PUSH    BC              ; Save address of line in prog
058F-D2 A5 05        732 ( 6+)         JP      NC,INEWLN       ; Line not found - Insert new
0592-EB              733 (  3)         EX      DE,HL           ; Next line address in DE
0593-2A 1B 21        734 ( 15)         LD      HL,(PROGND)     ; End of program
0596-1A              735 (  6) SFTPRG: LD      A,(DE)          ; Shift rest of program down
0597-02              736 (  7)         LD      (BC),A
0598-03              737 (  4)         INC     BC              ; Next destination
0599-13              738 (  4)         INC     DE              ; Next source
059A-CD C5 07        739 ( 16)         CALL    CPDEHL          ; All done?
059D-C2 96 05        740 ( 6+)         JP      NZ,SFTPRG       ; More to do
05A0-60              741 (  4)         LD      H,B             ; HL - New end of program
05A1-69              742 (  4)         LD      L,C
05A2-22 1B 21        743 ( 20)         LD      (PROGND),HL     ; Update end of program
05A5-                744
05A5-D1              745 (  9) INEWLN: POP     DE              ; Get address of line,
05A6-F1              746 (  9)         POP     AF              ; Get status
05A7-CA CC 05        747 ( 6+)         JP      Z,SETPTR        ; No text - Set up pointers
05AA-2A 1B 21        748 ( 15)         LD      HL,(PROGND)     ; Get end of program
05AD-E3              749 ( 16)         EX      (SP),HL         ; Get length of input line
05AE-C1              750 (  9)         POP     BC              ; End of program to BC
05AF-09              751 (  7)         ADD     HL,BC           ; Find new end
05B0-E5              752 ( 11)         PUSH    HL              ; Save new end
05B1-CD C9 04        753 ( 16)         CALL    MOVUP           ; Make space for line
05B4-E1              754 (  9)         POP     HL              ; Restore new end
05B5-22 1B 21        755 ( 20)         LD      (PROGND),HL     ; Update end of program pointer
05B8-EB              756 (  3)         EX      DE,HL           ; Get line to move up in HL
05B9-74              757 (  7)         LD      (HL),H          ; Save MSB
05BA-D1              758 (  9)         POP     DE              ; Get new line number
05BB-23              759 (  4)         INC     HL              ; Skip pointer
05BC-23              760 (  4)         INC     HL
05BD-73              761 (  7)         LD      (HL),E          ; Save LSB of line number
05BE-23              762 (  4)         INC     HL
05BF-72              763 (  7)         LD      (HL),D          ; Save MSB of line number
05C0-23              764 (  4)         INC     HL              ; To first byte in line
05C1-11 A6 20        765 (  9)         LD      DE,BUFFER       ; Copy buffer to program
05C4-1A              766 (  6) MOVBUF: LD      A,(DE)          ; Get source
05C5-77              767 (  7)         LD      (HL),A          ; Save destinations
05C6-23              768 (  4)         INC     HL              ; Next source
05C7-13              769 (  4)         INC     DE              ; Next destination
05C8-B7              770 (  4)         OR      A               ; Done?
05C9-C2 C4 05        771 ( 6+)         JP      NZ,MOVBUF       ; No - Repeat
05CC-CD 15 06        772 ( 16) SETPTR: CALL    RUNFST          ; Set line pointers
05CF-23              773 (  4)         INC     HL              ; To LSB of pointer
05D0-EB              774 (  3)         EX      DE,HL           ; Address to DE
05D1-62              775 (  4) PTRLP:  LD      H,D             ; Address to HL
05D2-6B              776 (  4)         LD      L,E
05D3-7E              777 (  6)         LD      A,(HL)          ; Get LSB of pointer
05D4-23              778 (  4)         INC     HL              ; To MSB of pointer
05D5-B6              779 (  6)         OR      (HL)            ; Compare with MSB pointer
05D6-CA 55 05        780 ( 6+)         JP      Z,GETCMD        ; Get command line if end
05D9-23              781 (  4)         INC     HL              ; To LSB of line number
05DA-23              782 (  4)         INC     HL              ; Skip line number
05DB-23              783 (  4)         INC     HL              ; Point to first byte in line
05DC-AF              784 (  4)         XOR     A               ; Looking for 00 byte
05DD-BE              785 (  6) FNDEND: CP      (HL)            ; Found end of line?
05DE-23              786 (  4)         INC     HL              ; Move to next byte
05DF-C2 DD 05        787 ( 6+)         JP      NZ,FNDEND       ; No - Keep looking
05E2-EB              788 (  3)         EX      DE,HL           ; Next line address to HL
05E3-73              789 (  7)         LD      (HL),E          ; Save LSB of pointer
05E4-23              790 (  4)         INC     HL
05E5-72              791 (  7)         LD      (HL),D          ; Save MSB of pointer
05E6-C3 D1 05        792 (  9)         JP      PTRLP           ; Do next line
05E9-                793
05E9-2A A3 20        794 ( 15) SRCHLN: LD      HL,(BASTXT)     ; Start of program text
05EC-44              795 (  4) SRCHLP: LD      B,H             ; BC = Address to look at
05ED-4D              796 (  4)         LD      C,L
05EE-7E              797 (  6)         LD      A,(HL)          ; Get address of next line
05EF-23              798 (  4)         INC     HL
05F0-B6              799 (  6)         OR      (HL)            ; End of program found?
05F1-2B              800 (  4)         DEC     HL
05F2-C8              801 ( 5+)         RET     Z               ; Yes - Line not found
05F3-23              802 (  4)         INC     HL
05F4-23              803 (  4)         INC     HL
05F5-7E              804 (  6)         LD      A,(HL)          ; Get LSB of line number
05F6-23              805 (  4)         INC     HL
05F7-66              806 (  6)         LD      H,(HL)          ; Get MSB of line number
05F8-6F              807 (  4)         LD      L,A
05F9-CD C5 07        808 ( 16)         CALL    CPDEHL          ; Compare with line in DE
05FC-60              809 (  4)         LD      H,B             ; HL = Start of this line
05FD-69              810 (  4)         LD      L,C
05FE-7E              811 (  6)         LD      A,(HL)          ; Get LSB of next line address
05FF-23              812 (  4)         INC     HL
0600-66              813 (  6)         LD      H,(HL)          ; Get MSB of next line address
0601-6F              814 (  4)         LD      L,A             ; Next line to HL
0602-3F              815 (  3)         CCF
0603-C8              816 ( 5+)         RET     Z               ; Lines found - Exit
0604-3F              817 (  3)         CCF
0605-D0              818 ( 5+)         RET     NC              ; Line not found,at line after
0606-C3 EC 05        819 (  9)         JP      SRCHLP          ; Keep looking
0609-                820
0609-C0              821 ( 5+) NEW:    RET     NZ              ; Return if any more on line
060A-2A A3 20        822 ( 15) CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
060D-AF              823 (  4)         XOR     A               ; Set program area to empty
060E-77              824 (  7)         LD      (HL),A          ; Save LSB = 00
060F-23              825 (  4)         INC     HL
0610-77              826 (  7)         LD      (HL),A          ; Save MSB = 00
0611-23              827 (  4)         INC     HL
0612-22 1B 21        828 ( 20)         LD      (PROGND),HL     ; Set program end
0615-                829
0615-2A A3 20        830 ( 15) RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0618-2B              831 (  4)         DEC     HL
0619-                832
0619-22 13 21        833 ( 20) INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
061C-2A F4 20        834 ( 15)         LD      HL,(LSTRAM)     ; Get end of RAM
061F-22 08 21        835 ( 20)         LD      (STRBOT),HL     ; Clear string space
0622-AF              836 (  4)         XOR     A
0623-CD 65 09        837 ( 16)         CALL    RESTOR          ; Reset DATA pointers
0626-2A 1B 21        838 ( 15)         LD      HL,(PROGND)     ; Get end of program
0629-22 1D 21        839 ( 20)         LD      (VAREND),HL     ; Clear variables
062C-22 1F 21        840 ( 20)         LD      (ARREND),HL     ; Clear arrays
062F-                841
062F-C1              842 (  9) CLREG:  POP     BC              ; Save return address
0630-2A 9F 20        843 ( 15)         LD      HL,(STRSPC)     ; Get end of working RAN
0633-F9              844 (  4)         LD      SP,HL           ; Set stack
0634-21 F8 20        845 (  9)         LD      HL,TMSTPL       ; Temporary string pool
0637-22 F6 20        846 ( 20)         LD      (TMSTPT),HL     ; Reset temporary string ptr
063A-AF              847 (  4)         XOR     A               ; A = 00
063B-6F              848 (  4)         LD      L,A             ; HL = 0000
063C-67              849 (  4)         LD      H,A
063D-22 19 21        850 ( 20)         LD      (CONTAD),HL     ; No CONTinue
0640-32 10 21        851 ( 13)         LD      (FORFLG),A      ; Clear FOR flag
0643-22 23 21        852 ( 20)         LD      (FNRGNM),HL     ; Clear FN argument
0646-E5              853 ( 11)         PUSH    HL              ; HL = 0000
0647-C5              854 ( 11)         PUSH    BC              ; Put back return
0648-2A 13 21        855 ( 15) DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
064B-C9              856 (  9)         RET                     ; Return to execution driver
064C-                857
064C-3E 3F           858 (  6) PROMPT: LD      A,'?'           ; '?'
064E-CD D6 07        859 ( 16)         CALL    OUTC            ; Output character
0651-3E 20           860 (  6)         LD      A,' '           ; Space
0653-CD D6 07        861 ( 16)         CALL    OUTC            ; Output character
0656-C3 93 20        862 (  9)         JP      RINPUT          ; Get input line
0659-                863
0659-AF              864 (  4) CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
065A-32 F3 20        865 ( 13)         LD      (DATFLG),A      ; Reset literal flag
065D-0E 05           866 (  6)         LD      C,2+3           ; 2 byte number and 3 nulls
065F-11 A6 20        867 (  9)         LD      DE,BUFFER       ; Start of input buffer
0662-7E              868 (  6) CRNCLP: LD      A,(HL)          ; Get byte
0663-FE 20           869 (  6)         CP      ' '             ; Is it a space?
0665-CA E1 06        870 ( 6+)         JP      Z,MOVDIR        ; Yes - Copy direct
0668-47              871 (  4)         LD      B,A             ; Save character
0669-FE 22           872 (  6)         CP      '"'             ; Is it a quote?
066B-CA 01 07        873 ( 6+)         JP      Z,CPYLIT        ; Yes - Copy literal string
066E-B7              874 (  4)         OR      A               ; Is it end of buffer?
066F-CA 08 07        875 ( 6+)         JP      Z,ENDBUF        ; Yes - End buffer
0672-3A F3 20        876 ( 12)         LD      A,(DATFLG)      ; Get data type
0675-B7              877 (  4)         OR      A               ; Literal?
0676-7E              878 (  6)         LD      A,(HL)          ; Get byte to copy
0677-C2 E1 06        879 ( 6+)         JP      NZ,MOVDIR       ; Literal - Copy direct
067A-FE 3F           880 (  6)         CP      '?'             ; Is it '?' short for PRINT
067C-3E 9E           881 (  6)         LD      A,ZPRINT        ; "PRINT" token
067E-CA E1 06        882 ( 6+)         JP      Z,MOVDIR        ; Yes - replace it
0681-7E              883 (  6)         LD      A,(HL)          ; Get byte again
0682-FE 30           884 (  6)         CP      '0'             ; Is it less than '0'
0684-DA 8C 06        885 ( 6+)         JP      C,FNDWRD        ; Yes - Look for reserved words
0687-FE 3C           886 (  6)         CP      60 ; ";"+1           ; Is it "0123456789:;" ?
0689-DA E1 06        887 ( 6+)         JP      C,MOVDIR        ; Yes - copy it direct
068C-D5              888 ( 11) FNDWRD: PUSH    DE              ; Look for reserved words
068D-11 85 02        889 (  9)         LD      DE,WORDS-1      ; Point to table
0690-C5              890 ( 11)         PUSH    BC              ; Save count
0691-01 DD 06        891 (  9)         LD      BC,RETNAD       ; Where to return to
0694-C5              892 ( 11)         PUSH    BC              ; Save return address
0695-06 7F           893 (  6)         LD      B,ZEND-1        ; First token value -1
0697-7E              894 (  6)         LD      A,(HL)          ; Get byte
0698-FE 61           895 (  6)         CP      'a'             ; Less than 'a' ?
069A-DA A5 06        896 ( 6+)         JP      C,SEARCH        ; Yes - search for words
069D-FE 7B           897 (  6)         CP      'z'+1           ; Greater than 'z' ?
069F-D2 A5 06        898 ( 6+)         JP      NC,SEARCH       ; Yes - search for words
06A2-E6 5F           899 (  6)         AND     01011111B       ; Force upper case
06A4-77              900 (  7)         LD      (HL),A          ; Replace byte
06A5-4E              901 (  6) SEARCH: LD      C,(HL)          ; Search for a word
06A6-EB              902 (  3)         EX      DE,HL
06A7-23              903 (  4) GETNXT: INC     HL              ; Get next reserved word
06A8-B6              904 (  6)         OR      (HL)            ; Start of word?
06A9-F2 A7 06        905 ( 6+)         JP      P,GETNXT        ; No - move on
06AC-04              906 (  4)         INC     B               ; Increment token value
06AD-7E              907 (  6)         LD      A, (HL)         ; Get byte from table
06AE-E6 7F           908 (  6)         AND     01111111B       ; Strip bit 7
06B0-C8              909 ( 5+)         RET     Z               ; Return if end of list
06B1-B9              910 (  4)         CP      C               ; Same character as in buffer?
06B2-C2 A7 06        911 ( 6+)         JP      NZ,GETNXT       ; No - get next word
06B5-EB              912 (  3)         EX      DE,HL
06B6-E5              913 ( 11)         PUSH    HL              ; Save start of word
06B7-                914
06B7-13              915 (  4) NXTBYT: INC     DE              ; Look through rest of word
06B8-1A              916 (  6)         LD      A,(DE)          ; Get byte from table
06B9-B7              917 (  4)         OR      A               ; End of word ?
06BA-FA D9 06        918 ( 6+)         JP      M,MATCH         ; Yes - Match found
06BD-4F              919 (  4)         LD      C,A             ; Save it
06BE-78              920 (  4)         LD      A,B             ; Get token value
06BF-FE 88           921 (  6)         CP      ZGOTO           ; Is it "GOTO" token ?
06C1-C2 C8 06        922 ( 6+)         JP      NZ,NOSPC        ; No - Don't allow spaces
06C4-CD 55 09        923 ( 16)         CALL    GETCHR          ; Get next character
06C7-2B              924 (  4)         DEC     HL              ; Cancel increment from GETCHR
06C8-23              925 (  4) NOSPC:  INC     HL              ; Next byte
06C9-7E              926 (  6)         LD      A,(HL)          ; Get byte
06CA-FE 61           927 (  6)         CP      'a'             ; Less than 'a' ?
06CC-DA D1 06        928 ( 6+)         JP      C,NOCHNG        ; Yes - don't change
06CF-E6 5F           929 (  6)         AND     01011111B       ; Make upper case
06D1-B9              930 (  4) NOCHNG: CP      C               ; Same as in buffer ?
06D2-CA B7 06        931 ( 6+)         JP      Z,NXTBYT        ; Yes - keep testing
06D5-E1              932 (  9)         POP     HL              ; Get back start of word
06D6-C3 A5 06        933 (  9)         JP      SEARCH          ; Look at next word
06D9-                934
06D9-48              935 (  4) MATCH:  LD      C,B             ; Word found - Save token value
06DA-F1              936 (  9)         POP     AF              ; Throw away return
06DB-EB              937 (  3)         EX      DE,HL
06DC-C9              938 (  9)         RET                     ; Return to "RETNAD"
06DD-EB              939 (  3) RETNAD: EX      DE,HL           ; Get address in string
06DE-79              940 (  4)         LD      A,C             ; Get token value
06DF-C1              941 (  9)         POP     BC              ; Restore buffer length
06E0-D1              942 (  9)         POP     DE              ; Get destination address
06E1-23              943 (  4) MOVDIR: INC     HL              ; Next source in buffer
06E2-12              944 (  7)         LD      (DE),A          ; Put byte in buffer
06E3-13              945 (  4)         INC     DE              ; Move up buffer
06E4-0C              946 (  4)         INC     C               ; Increment length of buffer
06E5-D6 3A           947 (  6)         SUB     ':'             ; End of statement?
06E7-CA EF 06        948 ( 6+)         JP      Z,SETLIT        ; Jump if multi-statement line
06EA-FE 49           949 (  6)         CP      ZDATA-3AH       ; Is it DATA statement ?
06EC-C2 F2 06        950 ( 6+)         JP      NZ,TSTREM       ; No - see if REM
06EF-32 F3 20        951 ( 13) SETLIT: LD      (DATFLG),A      ; Set literal flag
06F2-D6 54           952 (  6) TSTREM: SUB     ZREM-3AH        ; Is it REM?
06F4-C2 62 06        953 ( 6+)         JP      NZ,CRNCLP       ; No - Leave flag
06F7-47              954 (  4)         LD      B,A             ; Copy rest of buffer
06F8-7E              955 (  6) NXTCHR: LD      A,(HL)          ; Get byte
06F9-B7              956 (  4)         OR      A               ; End of line ?
06FA-CA 08 07        957 ( 6+)         JP      Z,ENDBUF        ; Yes - Terminate buffer
06FD-B8              958 (  4)         CP      B               ; End of statement ?
06FE-CA E1 06        959 ( 6+)         JP      Z,MOVDIR        ; Yes - Get next one
0701-23              960 (  4) CPYLIT: INC     HL              ; Move up source string
0702-12              961 (  7)         LD      (DE),A          ; Save in destination
0703-0C              962 (  4)         INC     C               ; Increment length
0704-13              963 (  4)         INC     DE              ; Move up destination
0705-C3 F8 06        964 (  9)         JP      NXTCHR          ; Repeat
0708-                965
0708-21 A5 20        966 (  9) ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
070B-12              967 (  7)         LD      (DE),A          ; Mark end of buffer (A = 00)
070C-13              968 (  4)         INC     DE
070D-12              969 (  7)         LD      (DE),A          ; A = 00
070E-13              970 (  4)         INC     DE
070F-12              971 (  7)         LD      (DE),A          ; A = 00
0710-C9              972 (  9)         RET
0711-                973
0711-3A 89 20        974 ( 12) DODEL:  LD      A,(NULFLG)      ; Get null flag status
0714-B7              975 (  4)         OR      A               ; Is it zero?
0715-3E 00           976 (  6)         LD      A,0             ; Zero A - Leave flags
0717-32 89 20        977 ( 13)         LD      (NULFLG),A      ; Zero null flag
071A-C2 25 07        978 ( 6+)         JP      NZ,ECHDEL       ; Set - Echo it
071D-05              979 (  4)         DEC     B               ; Decrement length
071E-CA 42 07        980 ( 6+)         JP      Z,GETLIN        ; Get line again if empty
0721-CD D6 07        981 ( 16)         CALL    OUTC            ; Output null character
0724-3E              982               .DB   3EH             ; Skip "DEC B"
0725-05              983 (  4) ECHDEL: DEC     B               ; Count bytes in buffer
0726-2B              984 (  4)         DEC     HL              ; Back space buffer
0727-CA 39 07        985 ( 6+)         JP      Z,OTKLN         ; No buffer - Try again
072A-7E              986 (  6)         LD      A,(HL)          ; Get deleted byte
072B-CD D6 07        987 ( 16)         CALL    OUTC            ; Echo it
072E-C3 4B 07        988 (  9)         JP      MORINP          ; Get more input
0731-                989
0731-05              990 (  4) DELCHR: DEC     B               ; Count bytes in buffer
0732-2B              991 (  4)         DEC     HL              ; Back space buffer
0733-CD D6 07        992 ( 16)         CALL    OUTC            ; Output character in A
0736-C2 4B 07        993 ( 6+)         JP      NZ,MORINP       ; Not end - Get more
0739-CD D6 07        994 ( 16) OTKLN:  CALL    OUTC            ; Output character in A
073C-CD FD 0B        995 ( 16) KILIN:  CALL    PRNTCRLF        ; Output CRLF
073F-C3 42 07        996 (  9)         JP      TTYLIN          ; Get line again
0742-                997
0742-                998       GETLIN:
0742-21 A6 20        999 (  9) TTYLIN: LD      HL,BUFFER       ; Get a line by character
0745-06 01          1000 (  6)         LD      B,1             ; Set buffer as empty
0747-AF             1001 (  4)         XOR     A
0748-32 89 20       1002 ( 13)         LD      (NULFLG),A      ; Clear null flag
074B-CD 00 08       1003 ( 16) MORINP: CALL    CLOTST          ; Get character and test ^O
074E-4F             1004 (  4)         LD      C,A             ; Save character in C
074F-FE 7F          1005 (  6)         CP      DEL             ; Delete character?
0751-CA 11 07       1006 ( 6+)         JP      Z,DODEL         ; Yes - Process it
0754-3A 89 20       1007 ( 12)         LD      A,(NULFLG)      ; Get null flag
0757-B7             1008 (  4)         OR      A               ; Test null flag status
0758-CA 64 07       1009 ( 6+)         JP      Z,PROCES        ; Reset - Process character
075B-3E 00          1010 (  6)         LD      A,0             ; Set a null
075D-CD D6 07       1011 ( 16)         CALL    OUTC            ; Output null
0760-AF             1012 (  4)         XOR     A               ; Clear A
0761-32 89 20       1013 ( 13)         LD      (NULFLG),A      ; Reset null flag
0764-79             1014 (  4) PROCES: LD      A,C             ; Get character
0765-FE 07          1015 (  6)         CP      CTRLG           ; Bell?
0767-CA A8 07       1016 ( 6+)         JP      Z,PUTCTL        ; Yes - Save it
076A-FE 03          1017 (  6)         CP      CTRLC           ; Is it control "C"?
076C-CC FD 0B       1018 ( 6+)         CALL    Z,PRNTCRLF      ; Yes - Output CRLF
076F-37             1019 (  3)         SCF                     ; Flag break
0770-C8             1020 ( 5+)         RET     Z               ; Return if control "C"
0771-FE 0D          1021 (  6)         CP      CR              ; Is it enter?
0773-CA F8 0B       1022 ( 6+)         JP      Z,ENDINP        ; Yes - Terminate input
0776-FE 15          1023 (  6)         CP      CTRLU           ; Is it control "U"?
0778-CA 3C 07       1024 ( 6+)         JP      Z,KILIN         ; Yes - Get another line
077B-FE 40          1025 (  6)         CP      '@'             ; Is it "kill line"?
077D-CA 39 07       1026 ( 6+)         JP      Z,OTKLN         ; Yes - Kill line
0780-FE 5F          1027 (  6)         CP      '_'             ; Is it delete?
0782-CA 31 07       1028 ( 6+)         JP      Z,DELCHR        ; Yes - Delete character
0785-FE 08          1029 (  6)         CP      BKSP            ; Is it backspace?
0787-CA 31 07       1030 ( 6+)         JP      Z,DELCHR        ; Yes - Delete character
078A-FE 12          1031 (  6)         CP      CTRLR           ; Is it control "R"?
078C-C2 A3 07       1032 ( 6+)         JP      NZ,PUTBUF       ; No - Put in buffer
078F-C5             1033 ( 11)         PUSH    BC              ; Save buffer length
0790-D5             1034 ( 11)         PUSH    DE              ; Save DE
0791-E5             1035 ( 11)         PUSH    HL              ; Save buffer address
0792-36 00          1036 (  9)         LD      (HL),0          ; Mark end of buffer
0794-CD AD 1D       1037 ( 16)         CALL    OUTNCR          ; Output and do CRLF
0797-21 A6 20       1038 (  9)         LD      HL,BUFFER       ; Point to buffer start
079A-CD 9B 12       1039 ( 16)         CALL    PRS             ; Output buffer
079D-E1             1040 (  9)         POP     HL              ; Restore buffer address
079E-D1             1041 (  9)         POP     DE              ; Restore DE
079F-C1             1042 (  9)         POP     BC              ; Restore buffer length
07A0-C3 4B 07       1043 (  9)         JP      MORINP          ; Get another character
07A3-               1044
07A3-FE 20          1045 (  6) PUTBUF: CP      ' '             ; Is it a control code?
07A5-DA 4B 07       1046 ( 6+)         JP      C,MORINP        ; Yes - Ignore
07A8-78             1047 (  4) PUTCTL: LD      A,B             ; Get number of bytes in buffer
07A9-FE 49          1048 (  6)         CP      72+1            ; Test for line overflow
07AB-3E 07          1049 (  6)         LD      A,CTRLG         ; Set a bell
07AD-D2 BD 07       1050 ( 6+)         JP      NC,OUTNBS       ; Ring bell if buffer full
07B0-79             1051 (  4)         LD      A,C             ; Get character
07B1-71             1052 (  7)         LD      (HL),C          ; Save in buffer
07B2-32 11 21       1053 ( 13)         LD      (LSTBIN),A      ; Save last input byte
07B5-23             1054 (  4)         INC     HL              ; Move up buffer
07B6-04             1055 (  4)         INC     B               ; Increment length
07B7-CD D6 07       1056 ( 16) OUTIT:  CALL    OUTC            ; Output the character entered
07BA-C3 4B 07       1057 (  9)         JP      MORINP          ; Get another character
07BD-               1058
07BD-CD D6 07       1059 ( 16) OUTNBS: CALL    OUTC            ; Output bell and back over it
07C0-3E 08          1060 (  6)         LD      A,BKSP          ; Set back space
07C2-C3 B7 07       1061 (  9)         JP      OUTIT           ; Output it and get more
07C5-               1062
07C5-7C             1063 (  4) CPDEHL: LD      A,H             ; Get H
07C6-92             1064 (  4)         SUB     D               ; Compare with D
07C7-C0             1065 ( 5+)         RET     NZ              ; Different - Exit
07C8-7D             1066 (  4)         LD      A,L             ; Get L
07C9-93             1067 (  4)         SUB     E               ; Compare with E
07CA-C9             1068 (  9)         RET                     ; Return status
07CB-               1069
07CB-7E             1070 (  6) CHKSYN: LD      A,(HL)          ; Check syntax of character
07CC-E3             1071 ( 16)         EX      (SP),HL         ; Address of test byte
07CD-BE             1072 (  6)         CP      (HL)            ; Same as in code string?
07CE-23             1073 (  4)         INC     HL              ; Return address
07CF-E3             1074 ( 16)         EX      (SP),HL         ; Put it back
07D0-CA 55 09       1075 ( 6+)         JP      Z,GETCHR        ; Yes - Get next character
07D3-C3 FD 04       1076 (  9)         JP      SNERR           ; Different - ?SN Error
07D6-               1077
07D6-F5             1078 ( 11) OUTC:   PUSH    AF              ; Save character
07D7-3A 8A 20       1079 ( 12)         LD      A,(CTLOFG)      ; Get control "O" flag
07DA-B7             1080 (  4)         OR      A               ; Is it set?
07DB-C2 D0 12       1081 ( 6+)         JP      NZ,POPAF        ; Yes - don't output
07DE-F1             1082 (  9)         POP     AF              ; Restore character
07DF-C5             1083 ( 11)         PUSH    BC              ; Save buffer length
07E0-F5             1084 ( 11)         PUSH    AF              ; Save character
07E1-FE 20          1085 (  6)         CP      ' '             ; Is it a control code?
07E3-DA FA 07       1086 ( 6+)         JP      C,DINPOS        ; Yes - Don't INC POS(X)
07E6-3A 87 20       1087 ( 12)         LD      A,(LWIDTH)      ; Get line width
07E9-47             1088 (  4)         LD      B,A             ; To B
07EA-3A F0 20       1089 ( 12)         LD      A,(CURPOS)      ; Get cursor position
07ED-04             1090 (  4)         INC     B               ; Width 255?
07EE-CA F6 07       1091 ( 6+)         JP      Z,INCLEN        ; Yes - No width limit
07F1-05             1092 (  4)         DEC     B               ; Restore width
07F2-B8             1093 (  4)         CP      B               ; At end of line?
07F3-CC FD 0B       1094 ( 6+)         CALL    Z,PRNTCRLF      ; Yes - output CRLF
07F6-3C             1095 (  4) INCLEN: INC     A               ; Move on one character
07F7-32 F0 20       1096 ( 13)         LD      (CURPOS),A      ; Save new position
07FA-F1             1097 (  9) DINPOS: POP     AF              ; Restore character
07FB-C1             1098 (  9)         POP     BC              ; Restore buffer length
07FC-CD 96 1D       1099 ( 16)         CALL    MONOUT          ; Send it
07FF-C9             1100 (  9)         RET
0800-               1101
0800-CD 5A 1C       1102 ( 16) CLOTST: CALL    GETINP          ; Get input character
0803-E6 7F          1103 (  6)         AND     01111111B       ; Strip bit 7
0805-FE 0F          1104 (  6)         CP      CTRLO           ; Is it control "O"?
0807-C0             1105 ( 5+)         RET     NZ              ; No don't flip flag
0808-3A 8A 20       1106 ( 12)         LD      A,(CTLOFG)      ; Get flag
080B-2F             1107 (  3)         CPL                     ; Flip it
080C-32 8A 20       1108 ( 13)         LD      (CTLOFG),A      ; Put it back
080F-AF             1109 (  4)         XOR     A               ; Null character
0810-C9             1110 (  9)         RET
0811-               1111
0811-CD 21 0A       1112 ( 16) LIST:   CALL    ATOH            ; ASCII number to DE
0814-C0             1113 ( 5+)         RET     NZ              ; Return if anything extra
0815-C1             1114 (  9)         POP     BC              ; Rubbish - Not needed
0816-CD E9 05       1115 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0819-C5             1116 ( 11)         PUSH    BC              ; Save address of line
081A-CD 67 08       1117 ( 16)         CALL    SETLIN          ; Set up lines counter
081D-E1             1118 (  9) LISTLP: POP     HL              ; Restore address of line
081E-4E             1119 (  6)         LD      C,(HL)          ; Get LSB of next line
081F-23             1120 (  4)         INC     HL
0820-46             1121 (  6)         LD      B,(HL)          ; Get MSB of next line
0821-23             1122 (  4)         INC     HL
0822-78             1123 (  4)         LD      A,B             ; BC = 0 (End of program)?
0823-B1             1124 (  4)         OR      C
0824-CA 48 05       1125 ( 6+)         JP      Z,PRNTOK        ; Yes - Go to command mode
0827-CD 70 08       1126 ( 16)         CALL    COUNT           ; Count lines
082A-CD 80 09       1127 ( 16)         CALL    TSTBRK          ; Test for break key
082D-C5             1128 ( 11)         PUSH    BC              ; Save address of next line
082E-CD FD 0B       1129 ( 16)         CALL    PRNTCRLF        ; Output CRLF
0831-5E             1130 (  6)         LD      E,(HL)          ; Get LSB of line number
0832-23             1131 (  4)         INC     HL
0833-56             1132 (  6)         LD      D,(HL)          ; Get MSB of line number
0834-23             1133 (  4)         INC     HL
0835-E5             1134 ( 11)         PUSH    HL              ; Save address of line start
0836-EB             1135 (  3)         EX      DE,HL           ; Line number to HL
0837-CD 3E 19       1136 ( 16)         CALL    PRNTHL          ; Output line number in decimal
083A-3E 20          1137 (  6)         LD      A,' '           ; Space after line number
083C-E1             1138 (  9)         POP     HL              ; Restore start of line address
083D-CD D6 07       1139 ( 16) LSTLP2: CALL    OUTC            ; Output character in A
0840-7E             1140 (  6) LSTLP3: LD      A,(HL)          ; Get next byte in line
0841-B7             1141 (  4)         OR      A               ; End of line?
0842-23             1142 (  4)         INC     HL              ; To next byte in line
0843-CA 1D 08       1143 ( 6+)         JP      Z,LISTLP        ; Yes - get next line
0846-F2 3D 08       1144 ( 6+)         JP      P,LSTLP2        ; No token - output it
0849-D6 7F          1145 (  6)         SUB     ZEND-1          ; Find and output word
084B-4F             1146 (  4)         LD      C,A             ; Token offset+1 to C
084C-11 86 02       1147 (  9)         LD      DE,WORDS        ; Reserved word list
084F-1A             1148 (  6) FNDTOK: LD      A,(DE)          ; Get character in list
0850-13             1149 (  4)         INC     DE              ; Move on to next
0851-B7             1150 (  4)         OR      A               ; Is it start of word?
0852-F2 4F 08       1151 ( 6+)         JP      P,FNDTOK        ; No - Keep looking for word
0855-0D             1152 (  4)         DEC     C               ; Count words
0856-C2 4F 08       1153 ( 6+)         JP      NZ,FNDTOK       ; Not there - keep looking
0859-E6 7F          1154 (  6) OUTWRD: AND     01111111B       ; Strip bit 7
085B-CD D6 07       1155 ( 16)         CALL    OUTC            ; Output first character
085E-1A             1156 (  6)         LD      A,(DE)          ; Get next character
085F-13             1157 (  4)         INC     DE              ; Move on to next
0860-B7             1158 (  4)         OR      A               ; Is it end of word?
0861-F2 59 08       1159 ( 6+)         JP      P,OUTWRD        ; No - output the rest
0864-C3 40 08       1160 (  9)         JP      LSTLP3          ; Next byte in line
0867-               1161
0867-E5             1162 ( 11) SETLIN: PUSH    HL              ; Set up LINES counter
0868-2A 8D 20       1163 ( 15)         LD      HL,(LINESN)     ; Get LINES number
086B-22 8B 20       1164 ( 20)         LD      (LINESC),HL     ; Save in LINES counter
086E-E1             1165 (  9)         POP     HL
086F-C9             1166 (  9)         RET
0870-               1167
0870-E5             1168 ( 11) COUNT:  PUSH    HL              ; Save code string address
0871-D5             1169 ( 11)         PUSH    DE
0872-2A 8B 20       1170 ( 15)         LD      HL,(LINESC)     ; Get LINES counter
0875-11 FF FF       1171 (  9)         LD      DE,-1
0878-ED 5A          1172 ( 10)         ADC     HL,DE           ; Decrement
087A-22 8B 20       1173 ( 20)         LD      (LINESC),HL     ; Put it back
087D-D1             1174 (  9)         POP     DE
087E-E1             1175 (  9)         POP     HL              ; Restore code string address
087F-F0             1176 ( 5+)         RET     P               ; Return if more lines to go
0880-E5             1177 ( 11)         PUSH    HL              ; Save code string address
0881-2A 8D 20       1178 ( 15)         LD      HL,(LINESN)     ; Get LINES number
0884-22 8B 20       1179 ( 20)         LD      (LINESC),HL     ; Reset LINES counter
0887-CD 5A 1C       1180 ( 16)         CALL    GETINP          ; Get input character
088A-FE 03          1181 (  6)         CP      CTRLC           ; Is it control "C"?
088C-CA 93 08       1182 ( 6+)         JP      Z,RSLNBK        ; Yes - Reset LINES and break
088F-E1             1183 (  9)         POP     HL              ; Restore code string address
0890-C3 70 08       1184 (  9)         JP      COUNT           ; Keep on counting
0893-               1185
0893-2A 8D 20       1186 ( 15) RSLNBK: LD      HL,(LINESN)     ; Get LINES number
0896-22 8B 20       1187 ( 20)         LD      (LINESC),HL     ; Reset LINES counter
0899-C3 F7 01       1188 (  9)         JP      BRKRET          ; Go and output "Break"
089C-               1189
089C-3E 64          1190 (  6) FOR:    LD      A,64H           ; Flag "FOR" assignment
089E-32 10 21       1191 ( 13)         LD      (FORFLG),A      ; Save "FOR" flag
08A1-CD 03 0B       1192 ( 16)         CALL    LET             ; Set up initial index
08A4-C1             1193 (  9)         POP     BC              ; Drop RETurn address
08A5-E5             1194 ( 11)         PUSH    HL              ; Save code string address
08A6-CD EC 0A       1195 ( 16)         CALL    DATA            ; Get next statement address
08A9-22 0C 21       1196 ( 20)         LD      (LOOPST),HL     ; Save it for start of loop
08AC-21 02 00       1197 (  9)         LD      HL,2            ; Offset for "FOR" block
08AF-39             1198 (  7)         ADD     HL,SP           ; Point to it
08B0-CD AA 04       1199 ( 16) FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
08B3-D1             1200 (  9)         POP     DE              ; Get code string address
08B4-C2 CC 08       1201 ( 6+)         JP      NZ,FORFND       ; No nesting found
08B7-09             1202 (  7)         ADD     HL,BC           ; Move into "FOR" block
08B8-D5             1203 ( 11)         PUSH    DE              ; Save code string address
08B9-2B             1204 (  4)         DEC     HL
08BA-56             1205 (  6)         LD      D,(HL)          ; Get MSB of loop statement
08BB-2B             1206 (  4)         DEC     HL
08BC-5E             1207 (  6)         LD      E,(HL)          ; Get LSB of loop statement
08BD-23             1208 (  4)         INC     HL
08BE-23             1209 (  4)         INC     HL
08BF-E5             1210 ( 11)         PUSH    HL              ; Save block address
08C0-2A 0C 21       1211 ( 15)         LD      HL,(LOOPST)     ; Get address of loop statement
08C3-CD C5 07       1212 ( 16)         CALL    CPDEHL          ; Compare the FOR loops
08C6-E1             1213 (  9)         POP     HL              ; Restore block address
08C7-C2 B0 08       1214 ( 6+)         JP      NZ,FORSLP       ; Different FORs - Find another
08CA-D1             1215 (  9)         POP     DE              ; Restore code string address
08CB-F9             1216 (  4)         LD      SP,HL           ; Remove all nested loops
08CC-               1217
08CC-EB             1218 (  3) FORFND: EX      DE,HL           ; Code string address to HL
08CD-0E 08          1219 (  6)         LD      C,8
08CF-CD DA 04       1220 ( 16)         CALL    CHKSTK          ; Check for 8 levels of stack
08D2-E5             1221 ( 11)         PUSH    HL              ; Save code string address
08D3-2A 0C 21       1222 ( 15)         LD      HL,(LOOPST)     ; Get first statement of loop
08D6-E3             1223 ( 16)         EX      (SP),HL         ; Save and restore code string
08D7-E5             1224 ( 11)         PUSH    HL              ; Re-save code string address
08D8-2A A1 20       1225 ( 15)         LD      HL,(LINEAT)     ; Get current line number
08DB-E3             1226 ( 16)         EX      (SP),HL         ; Save and restore code string
08DC-CD C5 0D       1227 ( 16)         CALL    TSTNUM          ; Make sure it's a number
08DF-CD CB 07       1228 ( 16)         CALL    CHKSYN          ; Make sure "TO" is next
08E2-A6             1229               .DB   ZTO          ; "TO" token
08E3-CD C2 0D       1230 ( 16)         CALL    GETNUM          ; Get "TO" expression value
08E6-E5             1231 ( 11)         PUSH    HL              ; Save code string address
08E7-CD F0 17       1232 ( 16)         CALL    BCDEFP          ; Move "TO" value to BCDE
08EA-E1             1233 (  9)         POP     HL              ; Restore code string address
08EB-C5             1234 ( 11)         PUSH    BC              ; Save "TO" value in block
08EC-D5             1235 ( 11)         PUSH    DE
08ED-01 00 81       1236 (  9)         LD      BC,8100H        ; BCDE - 1 (default STEP)
08F0-51             1237 (  4)         LD      D,C             ; C=0
08F1-5A             1238 (  4)         LD      E,D             ; D=0
08F2-7E             1239 (  6)         LD      A,(HL)          ; Get next byte in code string
08F3-FE AB          1240 (  6)         CP      ZSTEP           ; See if "STEP" is stated
08F5-3E 01          1241 (  6)         LD      A,1             ; Sign of step = 1
08F7-C2 08 09       1242 ( 6+)         JP      NZ,SAVSTP       ; No STEP given - Default to 1
08FA-CD 55 09       1243 ( 16)         CALL    GETCHR          ; Jump over "STEP" token
08FD-CD C2 0D       1244 ( 16)         CALL    GETNUM          ; Get step value
0900-E5             1245 ( 11)         PUSH    HL              ; Save code string address
0901-CD F0 17       1246 ( 16)         CALL    BCDEFP          ; Move STEP to BCDE
0904-CD A4 17       1247 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
0907-E1             1248 (  9)         POP     HL              ; Restore code string address
0908-C5             1249 ( 11) SAVSTP: PUSH    BC              ; Save the STEP value in block
0909-D5             1250 ( 11)         PUSH    DE
090A-F5             1251 ( 11)         PUSH    AF              ; Save sign of STEP
090B-33             1252 (  4)         INC     SP              ; Don't save flags
090C-E5             1253 ( 11)         PUSH    HL              ; Save code string address
090D-2A 13 21       1254 ( 15)         LD      HL,(BRKLIN)     ; Get address of index variable
0910-E3             1255 ( 16)         EX      (SP),HL         ; Save and restore code string
0911-06 81          1256 (  6) PUTFID: LD      B,ZFOR          ; "FOR" block marker
0913-C5             1257 ( 11)         PUSH    BC              ; Save it
0914-33             1258 (  4)         INC     SP              ; Don't save C
0915-               1259
0915-CD 80 09       1260 ( 16) RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
0918-22 13 21       1261 ( 20)         LD      (BRKLIN),HL     ; Save code address for break
091B-7E             1262 (  6)         LD      A,(HL)          ; Get next byte in code string
091C-FE 3A          1263 (  6)         CP      ':'             ; Multi statement line?
091E-CA 35 09       1264 ( 6+)         JP      Z,EXCUTE        ; Yes - Execute it
0921-B7             1265 (  4)         OR      A               ; End of line?
0922-C2 FD 04       1266 ( 6+)         JP      NZ,SNERR        ; No - Syntax error
0925-23             1267 (  4)         INC     HL              ; Point to address of next line
0926-7E             1268 (  6)         LD      A,(HL)          ; Get LSB of line pointer
0927-23             1269 (  4)         INC     HL
0928-B6             1270 (  6)         OR      (HL)            ; Is it zero (End of prog)?
0929-CA A7 09       1271 ( 6+)         JP      Z,ENDPRG        ; Yes - Terminate execution
092C-23             1272 (  4)         INC     HL              ; Point to line number
092D-5E             1273 (  6)         LD      E,(HL)          ; Get LSB of line number
092E-23             1274 (  4)         INC     HL
092F-56             1275 (  6)         LD      D,(HL)          ; Get MSB of line number
0930-EB             1276 (  3)         EX      DE,HL           ; Line number to HL
0931-22 A1 20       1277 ( 20)         LD      (LINEAT),HL     ; Save as current line number
0934-EB             1278 (  3)         EX      DE,HL           ; Line number back to DE
0935-CD 55 09       1279 ( 16) EXCUTE: CALL    GETCHR          ; Get key word
0938-11 15 09       1280 (  9)         LD      DE,RUNCNT       ; Where to RETurn to
093B-D5             1281 ( 11)         PUSH    DE              ; Save for RETurn
093C-C8             1282 ( 5+) IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
093D-D6 80          1283 (  6) ONJMP:  SUB     ZEND            ; Is it a token?
093F-DA 03 0B       1284 ( 6+)         JP      C,LET           ; No - try to assign it
0942-FE 25          1285 (  6)         CP      ZNEW+1-ZEND     ; END to NEW ?
0944-D2 FD 04       1286 ( 6+)         JP      NC,SNERR        ; Not a key word - ?SN Error
0947-07             1287 (  3)         RLCA                    ; Double it
0948-4F             1288 (  4)         LD      C,A             ; BC = Offset into table
0949-06 00          1289 (  6)         LD      B,0
094B-EB             1290 (  3)         EX      DE,HL           ; Save code string address
094C-21 A5 03       1291 (  9)         LD      HL,WORDTB       ; Keyword address table
094F-09             1292 (  7)         ADD     HL,BC           ; Point to routine address
0950-4E             1293 (  6)         LD      C,(HL)          ; Get LSB of routine address
0951-23             1294 (  4)         INC     HL
0952-46             1295 (  6)         LD      B,(HL)          ; Get MSB of routine address
0953-C5             1296 ( 11)         PUSH    BC              ; Save routine address
0954-EB             1297 (  3)         EX      DE,HL           ; Restore code string address
0955-               1298
0955-23             1299 (  4) GETCHR: INC     HL              ; Point to next character
0956-7E             1300 (  6)         LD      A,(HL)          ; Get next code string byte
0957-FE 3A          1301 (  6)         CP      ':'             ; Z if ':'
0959-D0             1302 ( 5+)         RET     NC              ; NC if > "9"
095A-FE 20          1303 (  6)         CP      ' '
095C-CA 55 09       1304 ( 6+)         JP      Z,GETCHR        ; Skip over spaces
095F-FE 30          1305 (  6)         CP      '0'
0961-3F             1306 (  3)         CCF                     ; NC if < '0'
0962-3C             1307 (  4)         INC     A               ; Test for zero - Leave carry
0963-3D             1308 (  4)         DEC     A               ; Z if Null
0964-C9             1309 (  9)         RET
0965-               1310
0965-EB             1311 (  3) RESTOR: EX      DE,HL           ; Save code string address
0966-2A A3 20       1312 ( 15)         LD      HL,(BASTXT)     ; Point to start of program
0969-CA 7A 09       1313 ( 6+)         JP      Z,RESTNL        ; Just RESTORE - reset pointer
096C-EB             1314 (  3)         EX      DE,HL           ; Restore code string address
096D-CD 21 0A       1315 ( 16)         CALL    ATOH            ; Get line number to DE
0970-E5             1316 ( 11)         PUSH    HL              ; Save code string address
0971-CD E9 05       1317 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0974-60             1318 (  4)         LD      H,B             ; HL = Address of line
0975-69             1319 (  4)         LD      L,C
0976-D1             1320 (  9)         POP     DE              ; Restore code string address
0977-D2 C2 0A       1321 ( 6+)         JP      NC,ULERR        ; ?UL Error if not found
097A-2B             1322 (  4) RESTNL: DEC     HL              ; Byte before DATA statement
097B-22 21 21       1323 ( 20) UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
097E-EB             1324 (  3)         EX      DE,HL           ; Restore code string address
097F-C9             1325 (  9)         RET
0980-               1326
0980-               1327
0980-DF             1328 ( 11) TSTBRK: RST     18H             ; Check input status
0981-C8             1329 ( 5+)         RET     Z               ; No key, go back
0982-D7             1330 ( 11)         RST     10H             ; Get the key into A
0983-FE 1B          1331 (  6)         CP      ESC             ; Escape key?
0985-28 11          1332 ( 6+)         JR      Z,BRK           ; Yes, break
0987-FE 03          1333 (  6)         CP      CTRLC           ; <Ctrl-C>
0989-28 0D          1334 ( 6+)         JR      Z,BRK           ; Yes, break
098B-FE 13          1335 (  6)         CP      CTRLS           ; Stop scrolling?
098D-C0             1336 ( 5+)         RET     NZ              ; Other key, ignore
098E-               1337
098E-               1338
098E-D7             1339 ( 11) STALL:  RST     10H             ; Wait for key
098F-FE 11          1340 (  6)         CP      CTRLQ           ; Resume scrolling?
0991-C8             1341 ( 5+)         RET      Z              ; Release the chokehold
0992-FE 03          1342 (  6)         CP      CTRLC           ; Second break?
0994-28 07          1343 ( 6+)         JR      Z,STOP          ; Break during hold exits prog
0996-18 F6          1344 (  8)         JR      STALL           ; Loop until <Ctrl-Q> or <brk>
0998-               1345
0998-3E FF          1346 (  6) BRK     LD      A,$FF           ; Set BRKFLG
099A-32 92 20       1347 ( 13)         LD      (BRKFLG),A      ; Store it
099D-               1348
099D-               1349
099D-C0             1350 ( 5+) STOP:   RET     NZ              ; Exit if anything else
099E-F6             1351               .DB   0F6H            ; Flag "STOP"
099F-C0             1352 ( 5+) PEND:   RET     NZ              ; Exit if anything else
09A0-22 13 21       1353 ( 20)         LD      (BRKLIN),HL     ; Save point of break
09A3-21             1354               .DB   21H             ; Skip "OR 11111111B"
09A4-F6 FF          1355 (  6) INPBRK: OR      11111111B       ; Flag "Break" wanted
09A6-C1             1356 (  9)         POP     BC              ; Return not needed and more
09A7-2A A1 20       1357 ( 15) ENDPRG: LD      HL,(LINEAT)     ; Get current line number
09AA-F5             1358 ( 11)         PUSH    AF              ; Save STOP / END status
09AB-7D             1359 (  4)         LD      A,L             ; Is it direct break?
09AC-A4             1360 (  4)         AND     H
09AD-3C             1361 (  4)         INC     A               ; Line is -1 if direct break
09AE-CA BA 09       1362 ( 6+)         JP      Z,NOLIN         ; Yes - No line number
09B1-22 17 21       1363 ( 20)         LD      (ERRLIN),HL     ; Save line of break
09B4-2A 13 21       1364 ( 15)         LD      HL,(BRKLIN)     ; Get point of break
09B7-22 19 21       1365 ( 20)         LD      (CONTAD),HL     ; Save point to CONTinue
09BA-AF             1366 (  4) NOLIN:  XOR     A
09BB-32 8A 20       1367 ( 13)         LD      (CTLOFG),A      ; Enable output
09BE-CD F0 0B       1368 ( 16)         CALL    STTLIN          ; Start a new line
09C1-F1             1369 (  9)         POP     AF              ; Restore STOP / END status
09C2-21 A0 04       1370 (  9)         LD      HL,BRKMSG       ; "Break" message
09C5-C2 31 05       1371 ( 6+)         JP      NZ,ERRIN        ; "in line" wanted?
09C8-C3 48 05       1372 (  9)         JP      PRNTOK          ; Go to command mode
09CB-               1373
09CB-2A 19 21       1374 ( 15) CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
09CE-7C             1375 (  4)         LD      A,H             ; Is it zero?
09CF-B5             1376 (  4)         OR      L
09D0-1E 20          1377 (  6)         LD      E,CN            ; ?CN Error
09D2-CA 11 05       1378 ( 6+)         JP      Z,ERROR         ; Yes - output "?CN Error"
09D5-EB             1379 (  3)         EX      DE,HL           ; Save code string address
09D6-2A 17 21       1380 ( 15)         LD      HL,(ERRLIN)     ; Get line of last break
09D9-22 A1 20       1381 ( 20)         LD      (LINEAT),HL     ; Set up current line number
09DC-EB             1382 (  3)         EX      DE,HL           ; Restore code string address
09DD-C9             1383 (  9)         RET                     ; CONTinue where left off
09DE-               1384
09DE-CD 23 15       1385 ( 16) NULL:   CALL    GETINT          ; Get integer 0-255
09E1-C0             1386 ( 5+)         RET     NZ              ; Return if bad value
09E2-32 86 20       1387 ( 13)         LD      (NULLS),A       ; Set nulls number
09E5-C9             1388 (  9)         RET
09E6-               1389
09E6-               1390
09E6-E5             1391 ( 11) ACCSUM: PUSH    HL              ; Save address in array
09E7-2A 8F 20       1392 ( 15)         LD      HL,(CHKSUM)     ; Get check sum
09EA-06 00          1393 (  6)         LD      B,0             ; BC - Value of byte
09EC-4F             1394 (  4)         LD      C,A
09ED-09             1395 (  7)         ADD     HL,BC           ; Add byte to check sum
09EE-22 8F 20       1396 ( 20)         LD      (CHKSUM),HL     ; Re-save check sum
09F1-E1             1397 (  9)         POP     HL              ; Restore address in array
09F2-C9             1398 (  9)         RET
09F3-               1399
09F3-7E             1400 (  6) CHKLTR: LD      A,(HL)          ; Get byte
09F4-FE 41          1401 (  6)         CP      'A'             ; < 'a' ?
09F6-D8             1402 ( 5+)         RET     C               ; Carry set if not letter
09F7-FE 5B          1403 (  6)         CP      'Z'+1           ; > 'z' ?
09F9-3F             1404 (  3)         CCF
09FA-C9             1405 (  9)         RET                     ; Carry set if not letter
09FB-               1406
09FB-CD 55 09       1407 ( 16) FPSINT: CALL    GETCHR          ; Get next character
09FE-CD C2 0D       1408 ( 16) POSINT: CALL    GETNUM          ; Get integer 0 to 32767
0A01-CD A4 17       1409 ( 16) DEPINT: CALL    TSTSGN          ; Test sign of FPREG
0A04-FA 1C 0A       1410 ( 6+)         JP      M,FCERR         ; Negative - ?FC Error
0A07-3A 2C 21       1411 ( 12) DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
0A0A-FE 90          1412 (  6)         CP      80H+16          ; Exponent in range (16 bits)?
0A0C-DA 4C 18       1413 ( 6+)         JP      C,FPINT         ; Yes - convert it
0A0F-01 80 90       1414 (  9)         LD      BC,9080H        ; BCDE = -32768
0A12-11 00 00       1415 (  9)         LD      DE,0000
0A15-E5             1416 ( 11)         PUSH    HL              ; Save code string address
0A16-CD 1F 18       1417 ( 16)         CALL    CMPNUM          ; Compare FPREG with BCDE
0A19-E1             1418 (  9)         POP     HL              ; Restore code string address
0A1A-51             1419 (  4)         LD      D,C             ; MSB to D
0A1B-C8             1420 ( 5+)         RET     Z               ; Return if in range
0A1C-1E 08          1421 (  6) FCERR:  LD      E,FC            ; ?FC Error
0A1E-C3 11 05       1422 (  9)         JP      ERROR           ; Output error-
0A21-               1423
0A21-2B             1424 (  4) ATOH:   DEC     HL              ; ASCII number to DE binary
0A22-11 00 00       1425 (  9) GETLN:  LD      DE,0            ; Get number to DE
0A25-CD 55 09       1426 ( 16) GTLNLP: CALL    GETCHR          ; Get next character
0A28-D0             1427 ( 5+)         RET     NC              ; Exit if not a digit
0A29-E5             1428 ( 11)         PUSH    HL              ; Save code string address
0A2A-F5             1429 ( 11)         PUSH    AF              ; Save digit
0A2B-21 98 19       1430 (  9)         LD      HL,65529/10     ; Largest number 65529
0A2E-CD C5 07       1431 ( 16)         CALL    CPDEHL          ; Number in range?
0A31-DA FD 04       1432 ( 6+)         JP      C,SNERR         ; No - ?SN Error
0A34-62             1433 (  4)         LD      H,D             ; HL = Number
0A35-6B             1434 (  4)         LD      L,E
0A36-19             1435 (  7)         ADD     HL,DE           ; Times 2
0A37-29             1436 (  7)         ADD     HL,HL           ; Times 4
0A38-19             1437 (  7)         ADD     HL,DE           ; Times 5
0A39-29             1438 (  7)         ADD     HL,HL           ; Times 10
0A3A-F1             1439 (  9)         POP     AF              ; Restore digit
0A3B-D6 30          1440 (  6)         SUB     '0'             ; Make it 0 to 9
0A3D-5F             1441 (  4)         LD      E,A             ; DE = Value of digit
0A3E-16 00          1442 (  6)         LD      D,0
0A40-19             1443 (  7)         ADD     HL,DE           ; Add to number
0A41-EB             1444 (  3)         EX      DE,HL           ; Number to DE
0A42-E1             1445 (  9)         POP     HL              ; Restore code string address
0A43-C3 25 0A       1446 (  9)         JP      GTLNLP          ; Go to next character
0A46-               1447
0A46-CA 19 06       1448 ( 6+) CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
0A49-CD FE 09       1449 ( 16)         CALL    POSINT          ; Get integer 0 to 32767 to DE
0A4C-2B             1450 (  4)         DEC     HL              ; Cancel increment
0A4D-CD 55 09       1451 ( 16)         CALL    GETCHR          ; Get next character
0A50-E5             1452 ( 11)         PUSH    HL              ; Save code string address
0A51-2A F4 20       1453 ( 15)         LD      HL,(LSTRAM)     ; Get end of RAM
0A54-CA 69 0A       1454 ( 6+)         JP      Z,STORED        ; No value given - Use stored
0A57-E1             1455 (  9)         POP     HL              ; Restore code string address
0A58-CD CB 07       1456 ( 16)         CALL    CHKSYN          ; Check for comma
0A5B-2C             1457               .DB      ','
0A5C-D5             1458 ( 11)         PUSH    DE              ; Save number
0A5D-CD FE 09       1459 ( 16)         CALL    POSINT          ; Get integer 0 to 32767
0A60-2B             1460 (  4)         DEC     HL              ; Cancel increment
0A61-CD 55 09       1461 ( 16)         CALL    GETCHR          ; Get next character
0A64-C2 FD 04       1462 ( 6+)         JP      NZ,SNERR        ; ?SN Error if more on line
0A67-E3             1463 ( 16)         EX      (SP),HL         ; Save code string address
0A68-EB             1464 (  3)         EX      DE,HL           ; Number to DE
0A69-7D             1465 (  4) STORED: LD      A,L             ; Get LSB of new RAM top
0A6A-93             1466 (  4)         SUB     E               ; Subtract LSB of string space
0A6B-5F             1467 (  4)         LD      E,A             ; Save LSB
0A6C-7C             1468 (  4)         LD      A,H             ; Get MSB of new RAM top
0A6D-9A             1469 (  4)         SBC     A,D             ; Subtract MSB of string space
0A6E-57             1470 (  4)         LD      D,A             ; Save MSB
0A6F-DA F2 04       1471 ( 6+)         JP      C,OMERR         ; ?OM Error if not enough mem
0A72-E5             1472 ( 11)         PUSH    HL              ; Save RAM top
0A73-2A 1B 21       1473 ( 15)         LD      HL,(PROGND)     ; Get program end
0A76-01 28 00       1474 (  9)         LD      BC,40           ; 40 Bytes minimum working RAM
0A79-09             1475 (  7)         ADD     HL,BC           ; Get lowest address
0A7A-CD C5 07       1476 ( 16)         CALL    CPDEHL          ; Enough memory?
0A7D-D2 F2 04       1477 ( 6+)         JP      NC,OMERR        ; No - ?OM Error
0A80-EB             1478 (  3)         EX      DE,HL           ; RAM top to HL
0A81-22 9F 20       1479 ( 20)         LD      (STRSPC),HL     ; Set new string space
0A84-E1             1480 (  9)         POP     HL              ; End of memory to use
0A85-22 F4 20       1481 ( 20)         LD      (LSTRAM),HL     ; Set new top of RAM
0A88-E1             1482 (  9)         POP     HL              ; Restore code string address
0A89-C3 19 06       1483 (  9)         JP      INTVAR          ; Initialise variables
0A8C-               1484
0A8C-CA 15 06       1485 ( 6+) RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
0A8F-CD 19 06       1486 ( 16)         CALL    INTVAR          ; Initialise variables
0A92-01 15 09       1487 (  9)         LD      BC,RUNCNT       ; Execution driver loop
0A95-C3 A8 0A       1488 (  9)         JP      RUNLIN          ; RUN from line number
0A98-               1489
0A98-0E 03          1490 (  6) GOSUB:  LD      C,3             ; 3 Levels of stack needed
0A9A-CD DA 04       1491 ( 16)         CALL    CHKSTK          ; Check for 3 levels of stack
0A9D-C1             1492 (  9)         POP     BC              ; Get return address
0A9E-E5             1493 ( 11)         PUSH    HL              ; Save code string for RETURN
0A9F-E5             1494 ( 11)         PUSH    HL              ; And for GOSUB routine
0AA0-2A A1 20       1495 ( 15)         LD      HL,(LINEAT)     ; Get current line
0AA3-E3             1496 ( 16)         EX      (SP),HL         ; Into stack - Code string out
0AA4-3E 8C          1497 (  6)         LD      A,ZGOSUB        ; "GOSUB" token
0AA6-F5             1498 ( 11)         PUSH    AF              ; Save token
0AA7-33             1499 (  4)         INC     SP              ; Don't save flags
0AA8-               1500
0AA8-C5             1501 ( 11) RUNLIN: PUSH    BC              ; Save return address
0AA9-CD 21 0A       1502 ( 16) GOTO:   CALL    ATOH            ; ASCII number to DE binary
0AAC-CD EE 0A       1503 ( 16)         CALL    REM             ; Get end of line
0AAF-E5             1504 ( 11)         PUSH    HL              ; Save end of line
0AB0-2A A1 20       1505 ( 15)         LD      HL,(LINEAT)     ; Get current line
0AB3-CD C5 07       1506 ( 16)         CALL    CPDEHL          ; Line after current?
0AB6-E1             1507 (  9)         POP     HL              ; Restore end of line
0AB7-23             1508 (  4)         INC     HL              ; Start of next line
0AB8-DC EC 05       1509 ( 6+)         CALL    C,SRCHLP        ; Line is after current line
0ABB-D4 E9 05       1510 ( 6+)         CALL    NC,SRCHLN       ; Line is before current line
0ABE-60             1511 (  4)         LD      H,B             ; Set up code string address
0ABF-69             1512 (  4)         LD      L,C
0AC0-2B             1513 (  4)         DEC     HL              ; Incremented after
0AC1-D8             1514 ( 5+)         RET     C               ; Line found
0AC2-1E 0E          1515 (  6) ULERR:  LD      E,UL            ; ?UL Error
0AC4-C3 11 05       1516 (  9)         JP      ERROR           ; Output error message
0AC7-               1517
0AC7-C0             1518 ( 5+) RETURN: RET     NZ              ; Return if not just RETURN
0AC8-16 FF          1519 (  6)         LD      D,-1            ; Flag "GOSUB" search
0ACA-CD A6 04       1520 ( 16)         CALL    BAKSTK          ; Look "GOSUB" block
0ACD-F9             1521 (  4)         LD      SP,HL           ; Kill all FORs in subroutine
0ACE-FE 8C          1522 (  6)         CP      ZGOSUB          ; Test for "GOSUB" token
0AD0-1E 04          1523 (  6)         LD      E,RG            ; ?RG Error
0AD2-C2 11 05       1524 ( 6+)         JP      NZ,ERROR        ; Error if no "GOSUB" found
0AD5-E1             1525 (  9)         POP     HL              ; Get RETURN line number
0AD6-22 A1 20       1526 ( 20)         LD      (LINEAT),HL     ; Save as current
0AD9-23             1527 (  4)         INC     HL              ; Was it from direct statement?
0ADA-7C             1528 (  4)         LD      A,H
0ADB-B5             1529 (  4)         OR      L               ; Return to line
0ADC-C2 E6 0A       1530 ( 6+)         JP      NZ,RETLIN       ; No - Return to line
0ADF-3A 11 21       1531 ( 12)         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
0AE2-B7             1532 (  4)         OR      A               ; If so buffer is corrupted
0AE3-C2 47 05       1533 ( 6+)         JP      NZ,POPNOK       ; Yes - Go to command mode
0AE6-21 15 09       1534 (  9) RETLIN: LD      HL,RUNCNT       ; Execution driver loop
0AE9-E3             1535 ( 16)         EX      (SP),HL         ; Into stack - Code string out
0AEA-3E             1536               .DB      3EH             ; Skip "POP HL"
0AEB-E1             1537 (  9) NXTDTA: POP     HL              ; Restore code string address
0AEC-               1538
0AEC-01 3A          1539       DATA:   .DB      01H,3AH         ; ':' End of statement
0AEE-0E 00          1540 (  6) REM:    LD      C,0             ; 00  End of statement
0AF0-06 00          1541 (  6)         LD      B,0
0AF2-79             1542 (  4) NXTSTL: LD      A,C             ; Statement and byte
0AF3-48             1543 (  4)         LD      C,B
0AF4-47             1544 (  4)         LD      B,A             ; Statement end byte
0AF5-7E             1545 (  6) NXTSTT: LD      A,(HL)          ; Get byte
0AF6-B7             1546 (  4)         OR      A               ; End of line?
0AF7-C8             1547 ( 5+)         RET     Z               ; Yes - Exit
0AF8-B8             1548 (  4)         CP      B               ; End of statement?
0AF9-C8             1549 ( 5+)         RET     Z               ; Yes - Exit
0AFA-23             1550 (  4)         INC     HL              ; Next byte
0AFB-FE 22          1551 (  6)         CP      '"'             ; Literal string?
0AFD-CA F2 0A       1552 ( 6+)         JP      Z,NXTSTL        ; Yes - Look for another '"'
0B00-C3 F5 0A       1553 (  9)         JP      NXTSTT          ; Keep looking
0B03-               1554
0B03-CD B8 0F       1555 ( 16) LET:    CALL    GETVAR          ; Get variable name
0B06-CD CB 07       1556 ( 16)         CALL    CHKSYN          ; Make sure "=" follows
0B09-B4             1557               .DB      ZEQUAL          ; "=" token
0B0A-D5             1558 ( 11)         PUSH    DE              ; Save address of variable
0B0B-3A F2 20       1559 ( 12)         LD      A,(TYPE)        ; Get data type
0B0E-F5             1560 ( 11)         PUSH    AF              ; Save type
0B0F-CD D4 0D       1561 ( 16)         CALL    EVAL            ; Evaluate expression
0B12-F1             1562 (  9)         POP     AF              ; Restore type
0B13-E3             1563 ( 16)         EX      (SP),HL         ; Save code - Get var addr
0B14-22 13 21       1564 ( 20)         LD      (BRKLIN),HL     ; Save address of variable
0B17-1F             1565 (  3)         RRA                     ; Adjust type
0B18-CD C7 0D       1566 ( 16)         CALL    CHKTYP          ; Check types are the same
0B1B-CA 56 0B       1567 ( 6+)         JP      Z,LETNUM        ; Numeric - Move value
0B1E-E5             1568 ( 11) LETSTR: PUSH    HL              ; Save address of string var
0B1F-2A 29 21       1569 ( 15)         LD      HL,(FPREG)      ; Pointer to string entry
0B22-E5             1570 ( 11)         PUSH    HL              ; Save it on stack
0B23-23             1571 (  4)         INC     HL              ; Skip over length
0B24-23             1572 (  4)         INC     HL
0B25-5E             1573 (  6)         LD      E,(HL)          ; LSB of string address
0B26-23             1574 (  4)         INC     HL
0B27-56             1575 (  6)         LD      D,(HL)          ; MSB of string address
0B28-2A A3 20       1576 ( 15)         LD      HL,(BASTXT)     ; Point to start of program
0B2B-CD C5 07       1577 ( 16)         CALL    CPDEHL          ; Is string before program?
0B2E-D2 45 0B       1578 ( 6+)         JP      NC,CRESTR       ; Yes - Create string entry
0B31-2A 9F 20       1579 ( 15)         LD      HL,(STRSPC)     ; Point to string space
0B34-CD C5 07       1580 ( 16)         CALL    CPDEHL          ; Is string literal in program?
0B37-D1             1581 (  9)         POP     DE              ; Restore address of string
0B38-D2 4D 0B       1582 ( 6+)         JP      NC,MVSTPT       ; Yes - Set up pointer
0B3B-21 04 21       1583 (  9)         LD      HL,TMPSTR       ; Temporary string pool
0B3E-CD C5 07       1584 ( 16)         CALL    CPDEHL          ; Is string in temporary pool?
0B41-D2 4D 0B       1585 ( 6+)         JP      NC,MVSTPT       ; No - Set up pointer
0B44-3E             1586               .DB   3EH             ; Skip "POP DE"
0B45-D1             1587 (  9) CRESTR: POP     DE              ; Restore address of string
0B46-CD FC 13       1588 ( 16)         CALL    BAKTMP          ; Back to last tmp-str entry
0B49-EB             1589 (  3)         EX      DE,HL           ; Address of string entry
0B4A-CD 35 12       1590 ( 16)         CALL    SAVSTR          ; Save string in string area
0B4D-CD FC 13       1591 ( 16) MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
0B50-E1             1592 (  9)         POP     HL              ; Get string pointer
0B51-CD FF 17       1593 ( 16)         CALL    DETHL4          ; Move string pointer to var
0B54-E1             1594 (  9)         POP     HL              ; Restore code string address
0B55-C9             1595 (  9)         RET
0B56-               1596
0B56-E5             1597 ( 11) LETNUM: PUSH    HL              ; Save address of variable
0B57-CD FC 17       1598 ( 16)         CALL    FPTHL           ; Move value to variable
0B5A-D1             1599 (  9)         POP     DE              ; Restore address of variable
0B5B-E1             1600 (  9)         POP     HL              ; Restore code string address
0B5C-C9             1601 (  9)         RET
0B5D-               1602
0B5D-CD 23 15       1603 ( 16) ON:     CALL    GETINT          ; Get integer 0-255
0B60-7E             1604 (  6)         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
0B61-47             1605 (  4)         LD      B,A             ; Save in B
0B62-FE 8C          1606 (  6)         CP      ZGOSUB          ; "GOSUB" token?
0B64-CA 6C 0B       1607 ( 6+)         JP      Z,ONGO          ; Yes - Find line number
0B67-CD CB 07       1608 ( 16)         CALL    CHKSYN          ; Make sure it's "GOTO"
0B6A-88             1609               .DB   ZGOTO           ; "GOTO" token
0B6B-2B             1610 (  4)         DEC     HL              ; Cancel increment
0B6C-4B             1611 (  4) ONGO:   LD      C,E             ; Integer of branch value
0B6D-0D             1612 (  4) ONGOLP: DEC     C               ; Count branches
0B6E-78             1613 (  4)         LD      A,B             ; Get "GOTO" or "GOSUB" token
0B6F-CA 3D 09       1614 ( 6+)         JP      Z,ONJMP         ; Go to that line if right one
0B72-CD 22 0A       1615 ( 16)         CALL    GETLN           ; Get line number to DE
0B75-FE 2C          1616 (  6)         CP      ','             ; Another line number?
0B77-C0             1617 ( 5+)         RET     NZ              ; No - Drop through
0B78-C3 6D 0B       1618 (  9)         JP      ONGOLP          ; Yes - loop
0B7B-               1619
0B7B-CD D4 0D       1620 ( 16) IF:     CALL    EVAL            ; Evaluate expression
0B7E-7E             1621 (  6)         LD      A,(HL)          ; Get token
0B7F-FE 88          1622 (  6)         CP      ZGOTO           ; "GOTO" token?
0B81-CA 89 0B       1623 ( 6+)         JP      Z,IFGO          ; Yes - Get line
0B84-CD CB 07       1624 ( 16)         CALL    CHKSYN          ; Make sure it's "THEN"
0B87-A9             1625               .DB      ZTHEN           ; "THEN" token
0B88-2B             1626 (  4)         DEC     HL              ; Cancel increment
0B89-CD C5 0D       1627 ( 16) IFGO:   CALL    TSTNUM          ; Make sure it's numeric
0B8C-CD A4 17       1628 ( 16)         CALL    TSTSGN          ; Test state of expression
0B8F-CA EE 0A       1629 ( 6+)         JP      Z,REM           ; False - Drop through
0B92-CD 55 09       1630 ( 16)         CALL    GETCHR          ; Get next character
0B95-DA A9 0A       1631 ( 6+)         JP      C,GOTO          ; Number - GOTO that line
0B98-C3 3C 09       1632 (  9)         JP      IFJMP           ; Otherwise do statement
0B9B-               1633
0B9B-2B             1634 (  4) MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
0B9C-CD 55 09       1635 ( 16)         CALL    GETCHR          ; Get next character
0B9F-CA FD 0B       1636 ( 6+) PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
0BA2-C8             1637 ( 5+) PRNTLP: RET     Z               ; End of list - Exit
0BA3-FE A5          1638 (  6)         CP      ZTAB            ; "TAB(" token?
0BA5-CA 30 0C       1639 ( 6+)         JP      Z,DOTAB         ; Yes - Do TAB routine
0BA8-FE A8          1640 (  6)         CP      ZSPC            ; "SPC(" token?
0BAA-CA 30 0C       1641 ( 6+)         JP      Z,DOTAB         ; Yes - Do SPC routine
0BAD-E5             1642 ( 11)         PUSH    HL              ; Save code string address
0BAE-FE 2C          1643 (  6)         CP      ','             ; Comma?
0BB0-CA 19 0C       1644 ( 6+)         JP      Z,DOCOM         ; Yes - Move to next zone
0BB3-FE 3B          1645 (  6)         CP      59 ;";"         ; Semi-colon?
0BB5-CA 53 0C       1646 ( 6+)         JP      Z,NEXITM        ; Do semi-colon routine
0BB8-C1             1647 (  9)         POP     BC              ; Code string address to BC
0BB9-CD D4 0D       1648 ( 16)         CALL    EVAL            ; Evaluate expression
0BBC-E5             1649 ( 11)         PUSH    HL              ; Save code string address
0BBD-3A F2 20       1650 ( 12)         LD      A,(TYPE)        ; Get variable type
0BC0-B7             1651 (  4)         OR      A               ; Is it a string variable?
0BC1-C2 E9 0B       1652 ( 6+)         JP      NZ,PRNTST       ; Yes - Output string contents
0BC4-CD 49 19       1653 ( 16)         CALL    NUMASC          ; Convert number to text
0BC7-CD 59 12       1654 ( 16)         CALL    CRTST           ; Create temporary string
0BCA-36 20          1655 (  9)         LD      (HL),' '        ; Followed by a space
0BCC-2A 29 21       1656 ( 15)         LD      HL,(FPREG)      ; Get length of output
0BCF-34             1657 ( 10)         INC     (HL)            ; Plus 1 for the space
0BD0-2A 29 21       1658 ( 15)         LD      HL,(FPREG)      ; < Not needed >
0BD3-3A 87 20       1659 ( 12)         LD      A,(LWIDTH)      ; Get width of line
0BD6-47             1660 (  4)         LD      B,A             ; To B
0BD7-04             1661 (  4)         INC     B               ; Width 255 (No limit)?
0BD8-CA E5 0B       1662 ( 6+)         JP      Z,PRNTNB        ; Yes - Output number string
0BDB-04             1663 (  4)         INC     B               ; Adjust it
0BDC-3A F0 20       1664 ( 12)         LD      A,(CURPOS)      ; Get cursor position
0BDF-86             1665 (  6)         ADD     A,(HL)          ; Add length of string
0BE0-3D             1666 (  4)         DEC     A               ; Adjust it
0BE1-B8             1667 (  4)         CP      B               ; Will output fit on this line?
0BE2-D4 FD 0B       1668 ( 6+)         CALL    NC,PRNTCRLF     ; No - CRLF first
0BE5-CD 9E 12       1669 ( 16) PRNTNB: CALL    PRS1            ; Output string at (HL)
0BE8-AF             1670 (  4)         XOR     A               ; Skip CALL by setting 'z' flag
0BE9-C4 9E 12       1671 ( 6+) PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
0BEC-E1             1672 (  9)         POP     HL              ; Restore code string address
0BED-C3 9B 0B       1673 (  9)         JP      MRPRNT          ; See if more to PRINT
0BF0-               1674
0BF0-3A F0 20       1675 ( 12) STTLIN: LD      A,(CURPOS)      ; Make sure on new line
0BF3-B7             1676 (  4)         OR      A               ; Already at start?
0BF4-C8             1677 ( 5+)         RET     Z               ; Yes - Do nothing
0BF5-C3 FD 0B       1678 (  9)         JP      PRNTCRLF        ; Start a new line
0BF8-               1679
0BF8-36 00          1680 (  9) ENDINP: LD      (HL),0          ; Mark end of buffer
0BFA-21 A5 20       1681 (  9)         LD      HL,BUFFER-1     ; Point to buffer
0BFD-3E 0D          1682 (  6) PRNTCRLF: LD    A,CR            ; Load a CR
0BFF-CD D6 07       1683 ( 16)         CALL    OUTC            ; Output character
0C02-3E 0A          1684 (  6)         LD      A,LF            ; Load a LF
0C04-CD D6 07       1685 ( 16)         CALL    OUTC            ; Output character
0C07-AF             1686 (  4) DONULL: XOR     A               ; Set to position 0
0C08-32 F0 20       1687 ( 13)         LD      (CURPOS),A      ; Store it
0C0B-3A 86 20       1688 ( 12)         LD      A,(NULLS)       ; Get number of nulls
0C0E-3D             1689 (  4) NULLP:  DEC     A               ; Count them
0C0F-C8             1690 ( 5+)         RET     Z               ; Return if done
0C10-F5             1691 ( 11)         PUSH    AF              ; Save count
0C11-AF             1692 (  4)         XOR     A               ; Load a null
0C12-CD D6 07       1693 ( 16)         CALL    OUTC            ; Output it
0C15-F1             1694 (  9)         POP     AF              ; Restore count
0C16-C3 0E 0C       1695 (  9)         JP      NULLP           ; Keep counting
0C19-               1696
0C19-3A 88 20       1697 ( 12) DOCOM:  LD      A,(COMMAN)      ; Get comma width
0C1C-47             1698 (  4)         LD      B,A             ; Save in B
0C1D-3A F0 20       1699 ( 12)         LD      A,(CURPOS)      ; Get current position
0C20-B8             1700 (  4)         CP      B               ; Within the limit?
0C21-D4 FD 0B       1701 ( 6+)         CALL    NC,PRNTCRLF     ; No - output CRLF
0C24-D2 53 0C       1702 ( 6+)         JP      NC,NEXITM       ; Get next item
0C27-D6 0E          1703 (  6) ZONELP: SUB     14              ; Next zone of 14 characters
0C29-D2 27 0C       1704 ( 6+)         JP      NC,ZONELP       ; Repeat if more zones
0C2C-2F             1705 (  3)         CPL                     ; Number of spaces to output
0C2D-C3 48 0C       1706 (  9)         JP      ASPCS           ; Output them
0C30-               1707
0C30-F5             1708 ( 11) DOTAB:  PUSH    AF              ; Save token
0C31-CD 20 15       1709 ( 16)         CALL    FNDNUM          ; Evaluate expression
0C34-CD CB 07       1710 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
0C37-29             1711               .DB   ")"
0C38-2B             1712 (  4)         DEC     HL              ; Back space on to ")"
0C39-F1             1713 (  9)         POP     AF              ; Restore token
0C3A-D6 A8          1714 (  6)         SUB     ZSPC            ; Was it "SPC(" ?
0C3C-E5             1715 ( 11)         PUSH    HL              ; Save code string address
0C3D-CA 43 0C       1716 ( 6+)         JP      Z,DOSPC         ; Yes - Do 'E' spaces
0C40-3A F0 20       1717 ( 12)         LD      A,(CURPOS)      ; Get current position
0C43-2F             1718 (  3) DOSPC:  CPL                     ; Number of spaces to print to
0C44-83             1719 (  4)         ADD     A,E             ; Total number to print
0C45-D2 53 0C       1720 ( 6+)         JP      NC,NEXITM       ; TAB < Current POS(X)
0C48-3C             1721 (  4) ASPCS:  INC     A               ; Output A spaces
0C49-47             1722 (  4)         LD      B,A             ; Save number to print
0C4A-3E 20          1723 (  6)         LD      A,' '           ; Space
0C4C-CD D6 07       1724 ( 16) SPCLP:  CALL    OUTC            ; Output character in A
0C4F-05             1725 (  4)         DEC     B               ; Count them
0C50-C2 4C 0C       1726 ( 6+)         JP      NZ,SPCLP        ; Repeat if more
0C53-E1             1727 (  9) NEXITM: POP     HL              ; Restore code string address
0C54-CD 55 09       1728 ( 16)         CALL    GETCHR          ; Get next character
0C57-C3 A2 0B       1729 (  9)         JP      PRNTLP          ; More to print
0C5A-               1730
0C5A-3F 52 65 64 
     6F 20 66 72 
     6F 6D 20 73 
     74 61 72 74 
     0D 0A 00       1731       REDO:   .DB   "?Redo from start",CR,LF,0
0C6D-               1732
0C6D-3A 12 21       1733 ( 12) BADINP: LD      A,(READFG)      ; READ or INPUT?
0C70-B7             1734 (  4)         OR      A
0C71-C2 F7 04       1735 ( 6+)         JP      NZ,DATSNR       ; READ - ?SN Error
0C74-C1             1736 (  9)         POP     BC              ; Throw away code string addr
0C75-21 5A 0C       1737 (  9)         LD      HL,REDO         ; "Redo from start" message
0C78-CD 9B 12       1738 ( 16)         CALL    PRS             ; Output string
0C7B-C3 48 06       1739 (  9)         JP      DOAGN           ; Do last INPUT again
0C7E-               1740
0C7E-CD 06 12       1741 ( 16) INPUT:  CALL    IDTEST          ; Test for illegal direct
0C81-7E             1742 (  6)         LD      A,(HL)          ; Get character after "INPUT"
0C82-FE 22          1743 (  6)         CP      '"'             ; Is there a prompt string?
0C84-3E 00          1744 (  6)         LD      A,0             ; Clear A and leave flags
0C86-32 8A 20       1745 ( 13)         LD      (CTLOFG),A      ; Enable output
0C89-C2 98 0C       1746 ( 6+)         JP      NZ,NOPMPT       ; No prompt - get input
0C8C-CD 5A 12       1747 ( 16)         CALL    QTSTR           ; Get string terminated by '"'
0C8F-CD CB 07       1748 ( 16)         CALL    CHKSYN          ; Check for ';' after prompt
0C92-3B             1749               .DB   ';'
0C93-E5             1750 ( 11)         PUSH    HL              ; Save code string address
0C94-CD 9E 12       1751 ( 16)         CALL    PRS1            ; Output prompt string
0C97-3E             1752               .DB   3EH             ; Skip "PUSH HL"
0C98-E5             1753 ( 11) NOPMPT: PUSH    HL              ; Save code string address
0C99-CD 4C 06       1754 ( 16)         CALL    PROMPT          ; Get input with "? " prompt
0C9C-C1             1755 (  9)         POP     BC              ; Restore code string address
0C9D-DA A4 09       1756 ( 6+)         JP      C,INPBRK        ; Break pressed - Exit
0CA0-23             1757 (  4)         INC     HL              ; Next byte
0CA1-7E             1758 (  6)         LD      A,(HL)          ; Get it
0CA2-B7             1759 (  4)         OR      A               ; End of line?
0CA3-2B             1760 (  4)         DEC     HL              ; Back again
0CA4-C5             1761 ( 11)         PUSH    BC              ; Re-save code string address
0CA5-CA EB 0A       1762 ( 6+)         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
0CA8-36 2C          1763 (  9)         LD      (HL),','        ; Store comma as separator
0CAA-C3 B2 0C       1764 (  9)         JP      NXTITM          ; Get next item
0CAD-               1765
0CAD-E5             1766 ( 11) READ:   PUSH    HL              ; Save code string address
0CAE-2A 21 21       1767 ( 15)         LD      HL,(NXTDAT)     ; Next DATA statement
0CB1-F6             1768               .DB   0F6H            ; Flag "READ"
0CB2-AF             1769 (  4) NXTITM: XOR     A               ; Flag "INPUT"
0CB3-32 12 21       1770 ( 13)         LD      (READFG),A      ; Save "READ"/"INPUT" flag
0CB6-E3             1771 ( 16)         EX      (SP),HL         ; Get code str' , Save pointer
0CB7-C3 BE 0C       1772 (  9)         JP      GTVLUS          ; Get values
0CBA-               1773
0CBA-CD CB 07       1774 ( 16) NEDMOR: CALL    CHKSYN          ; Check for comma between items
0CBD-2C             1775               .DB      ','
0CBE-CD B8 0F       1776 ( 16) GTVLUS: CALL    GETVAR          ; Get variable name
0CC1-E3             1777 ( 16)         EX      (SP),HL         ; Save code str" , Get pointer
0CC2-D5             1778 ( 11)         PUSH    DE              ; Save variable address
0CC3-7E             1779 (  6)         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
0CC4-FE 2C          1780 (  6)         CP      ','             ; Comma?
0CC6-CA E6 0C       1781 ( 6+)         JP      Z,ANTVLU        ; Yes - Get another value
0CC9-3A 12 21       1782 ( 12)         LD      A,(READFG)      ; Is it READ?
0CCC-B7             1783 (  4)         OR      A
0CCD-C2 53 0D       1784 ( 6+)         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
0CD0-3E 3F          1785 (  6)         LD      A,'?'           ; More INPUT needed
0CD2-CD D6 07       1786 ( 16)         CALL    OUTC            ; Output character
0CD5-CD 4C 06       1787 ( 16)         CALL    PROMPT          ; Get INPUT with prompt
0CD8-D1             1788 (  9)         POP     DE              ; Variable address
0CD9-C1             1789 (  9)         POP     BC              ; Code string address
0CDA-DA A4 09       1790 ( 6+)         JP      C,INPBRK        ; Break pressed
0CDD-23             1791 (  4)         INC     HL              ; Point to next DATA byte
0CDE-7E             1792 (  6)         LD      A,(HL)          ; Get byte
0CDF-B7             1793 (  4)         OR      A               ; Is it zero (No input) ?
0CE0-2B             1794 (  4)         DEC     HL              ; Back space INPUT pointer
0CE1-C5             1795 ( 11)         PUSH    BC              ; Save code string address
0CE2-CA EB 0A       1796 ( 6+)         JP      Z,NXTDTA        ; Find end of buffer
0CE5-D5             1797 ( 11)         PUSH    DE              ; Save variable address
0CE6-3A F2 20       1798 ( 12) ANTVLU: LD      A,(TYPE)        ; Check data type
0CE9-B7             1799 (  4)         OR      A               ; Is it numeric?
0CEA-CA 10 0D       1800 ( 6+)         JP      Z,INPBIN        ; Yes - Convert to binary
0CED-CD 55 09       1801 ( 16)         CALL    GETCHR          ; Get next character
0CF0-57             1802 (  4)         LD      D,A             ; Save input character
0CF1-47             1803 (  4)         LD      B,A             ; Again
0CF2-FE 22          1804 (  6)         CP      '"'             ; Start of literal sting?"
0CF4-CA 04 0D       1805 ( 6+)         JP      Z,STRENT        ; Yes - Create string entry
0CF7-3A 12 21       1806 ( 12)         LD      A,(READFG)      ; "READ" or "INPUT" ?
0CFA-B7             1807 (  4)         OR      A
0CFB-57             1808 (  4)         LD      D,A             ; Save 00 if "INPUT"
0CFC-CA 01 0D       1809 ( 6+)         JP      Z,ITMSEP        ; "INPUT" - End with 00
0CFF-16 3A          1810 (  6)         LD      D,':'           ; "DATA" - End with 00 or ':'
0D01-06 2C          1811 (  6) ITMSEP: LD      B,','           ; Item separator
0D03-2B             1812 (  4)         DEC     HL              ; Back space for DTSTR
0D04-CD 5D 12       1813 ( 16) STRENT: CALL    DTSTR           ; Get string terminated by D
0D07-EB             1814 (  3)         EX      DE,HL           ; String address to DE
0D08-21 1B 0D       1815 (  9)         LD      HL,LTSTND       ; Where to go after LETSTR
0D0B-E3             1816 ( 16)         EX      (SP),HL         ; Save HL , get input pointer
0D0C-D5             1817 ( 11)         PUSH    DE              ; Save address of string
0D0D-C3 1E 0B       1818 (  9)         JP      LETSTR          ; Assign string to variable
0D10-               1819
0D10-CD 55 09       1820 ( 16) INPBIN: CALL    GETCHR          ; Get next character
0D13-CD AB 18       1821 ( 16)         CALL    ASCTFP          ; Convert ASCII to FP number
0D16-E3             1822 ( 16)         EX      (SP),HL         ; Save input ptr, Get var addr
0D17-CD FC 17       1823 ( 16)         CALL    FPTHL           ; Move FPREG to variable
0D1A-E1             1824 (  9)         POP     HL              ; Restore input pointer
0D1B-2B             1825 (  4) LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
0D1C-CD 55 09       1826 ( 16)         CALL    GETCHR          ; Get next character
0D1F-CA 27 0D       1827 ( 6+)         JP      Z,MORDT         ; End of line - More needed?
0D22-FE 2C          1828 (  6)         CP      ','             ; Another value?
0D24-C2 6D 0C       1829 ( 6+)         JP      NZ,BADINP       ; No - Bad input
0D27-E3             1830 ( 16) MORDT:  EX      (SP),HL         ; Get code string address
0D28-2B             1831 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
0D29-CD 55 09       1832 ( 16)         CALL    GETCHR          ; Get next character
0D2C-C2 BA 0C       1833 ( 6+)         JP      NZ,NEDMOR       ; More needed - Get it
0D2F-D1             1834 (  9)         POP     DE              ; Restore DATA pointer
0D30-3A 12 21       1835 ( 12)         LD      A,(READFG)      ; "READ" or "INPUT" ?
0D33-B7             1836 (  4)         OR      A
0D34-EB             1837 (  3)         EX      DE,HL           ; DATA pointer to HL
0D35-C2 7B 09       1838 ( 6+)         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
0D38-D5             1839 ( 11)         PUSH    DE              ; Save code string address
0D39-B6             1840 (  6)         OR      (HL)            ; More input given?
0D3A-21 42 0D       1841 (  9)         LD      HL,EXTIG        ; "?Extra ignored" message
0D3D-C4 9B 12       1842 ( 6+)         CALL    NZ,PRS          ; Output string if extra given
0D40-E1             1843 (  9)         POP     HL              ; Restore code string address
0D41-C9             1844 (  9)         RET
0D42-               1845
0D42-3F 45 78 74 
     72 61 20 69 
     67 6E 6F 72 
     65 64 0D 0A 
     00             1846       EXTIG:  .DB   "?Extra ignored",CR,LF,0
0D53-               1847
0D53-CD EC 0A       1848 ( 16) FDTLP:  CALL    DATA            ; Get next statement
0D56-B7             1849 (  4)         OR      A               ; End of line?
0D57-C2 6C 0D       1850 ( 6+)         JP      NZ,FANDT        ; No - See if DATA statement
0D5A-23             1851 (  4)         INC     HL
0D5B-7E             1852 (  6)         LD      A,(HL)          ; End of program?
0D5C-23             1853 (  4)         INC     HL
0D5D-B6             1854 (  6)         OR      (HL)            ; 00 00 Ends program
0D5E-1E 06          1855 (  6)         LD      E,OD            ; ?OD Error
0D60-CA 11 05       1856 ( 6+)         JP      Z,ERROR         ; Yes - Out of DATA
0D63-23             1857 (  4)         INC     HL
0D64-5E             1858 (  6)         LD      E,(HL)          ; LSB of line number
0D65-23             1859 (  4)         INC     HL
0D66-56             1860 (  6)         LD      D,(HL)          ; MSB of line number
0D67-EB             1861 (  3)         EX      DE,HL
0D68-22 0E 21       1862 ( 20)         LD      (DATLIN),HL     ; Set line of current DATA item
0D6B-EB             1863 (  3)         EX      DE,HL
0D6C-CD 55 09       1864 ( 16) FANDT:  CALL    GETCHR          ; Get next character
0D6F-FE 83          1865 (  6)         CP      ZDATA           ; "DATA" token
0D71-C2 53 0D       1866 ( 6+)         JP      NZ,FDTLP        ; No "DATA" - Keep looking
0D74-C3 E6 0C       1867 (  9)         JP      ANTVLU          ; Found - Convert input
0D77-               1868
0D77-11 00 00       1869 (  9) NEXT:   LD      DE,0            ; In case no index given
0D7A-C4 B8 0F       1870 ( 6+) NEXT1:  CALL    NZ,GETVAR       ; Get index address
0D7D-22 13 21       1871 ( 20)         LD      (BRKLIN),HL     ; Save code string address
0D80-CD A6 04       1872 ( 16)         CALL    BAKSTK          ; Look for "FOR" block
0D83-C2 03 05       1873 ( 6+)         JP      NZ,NFERR        ; No "FOR" - ?NF Error
0D86-F9             1874 (  4)         LD      SP,HL           ; Clear nested loops
0D87-D5             1875 ( 11)         PUSH    DE              ; Save index address
0D88-7E             1876 (  6)         LD      A,(HL)          ; Get sign of STEP
0D89-23             1877 (  4)         INC     HL
0D8A-F5             1878 ( 11)         PUSH    AF              ; Save sign of STEP
0D8B-D5             1879 ( 11)         PUSH    DE              ; Save index address
0D8C-CD E2 17       1880 ( 16)         CALL    PHLTFP          ; Move index value to FPREG
0D8F-E3             1881 ( 16)         EX      (SP),HL         ; Save address of TO value
0D90-E5             1882 ( 11)         PUSH    HL              ; Save address of index
0D91-CD 4F 15       1883 ( 16)         CALL    ADDPHL          ; Add STEP to index value
0D94-E1             1884 (  9)         POP     HL              ; Restore address of index
0D95-CD FC 17       1885 ( 16)         CALL    FPTHL           ; Move value to index variable
0D98-E1             1886 (  9)         POP     HL              ; Restore address of TO value
0D99-CD F3 17       1887 ( 16)         CALL    LOADFP          ; Move TO value to BCDE
0D9C-E5             1888 ( 11)         PUSH    HL              ; Save address of line of FOR
0D9D-CD 1F 18       1889 ( 16)         CALL    CMPNUM          ; Compare index with TO value
0DA0-E1             1890 (  9)         POP     HL              ; Restore address of line num
0DA1-C1             1891 (  9)         POP     BC              ; Address of sign of STEP
0DA2-90             1892 (  4)         SUB     B               ; Compare with expected sign
0DA3-CD F3 17       1893 ( 16)         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
0DA6-CA B2 0D       1894 ( 6+)         JP      Z,KILFOR        ; Loop finished - Terminate it
0DA9-EB             1895 (  3)         EX      DE,HL           ; Loop statement line number
0DAA-22 A1 20       1896 ( 20)         LD      (LINEAT),HL     ; Set loop line number
0DAD-69             1897 (  4)         LD      L,C             ; Set code string to loop
0DAE-60             1898 (  4)         LD      H,B
0DAF-C3 11 09       1899 (  9)         JP      PUTFID          ; Put back "FOR" and continue
0DB2-               1900
0DB2-F9             1901 (  4) KILFOR: LD      SP,HL           ; Remove "FOR" block
0DB3-2A 13 21       1902 ( 15)         LD      HL,(BRKLIN)     ; Code string after "NEXT"
0DB6-7E             1903 (  6)         LD      A,(HL)          ; Get next byte in code string
0DB7-FE 2C          1904 (  6)         CP      ','             ; More NEXTs ?
0DB9-C2 15 09       1905 ( 6+)         JP      NZ,RUNCNT       ; No - Do next statement
0DBC-CD 55 09       1906 ( 16)         CALL    GETCHR          ; Position to index name
0DBF-CD 7A 0D       1907 ( 16)         CALL    NEXT1           ; Re-enter NEXT routine
0DC2-               1908       ; < will not RETurn to here , Exit to RUNCNT or Loop >
0DC2-               1909
0DC2-CD D4 0D       1910 ( 16) GETNUM: CALL    EVAL            ; Get a numeric expression
0DC5-F6             1911       TSTNUM: .DB      0F6H            ; Clear carry (numeric)
0DC6-37             1912 (  3) TSTSTR: SCF                     ; Set carry (string)
0DC7-3A F2 20       1913 ( 12) CHKTYP: LD      A,(TYPE)        ; Check types match
0DCA-8F             1914 (  4)         ADC     A,A             ; Expected + actual
0DCB-B7             1915 (  4)         OR      A               ; Clear carry , set parity
0DCC-E8             1916 ( 5+)         RET     PE              ; Even parity - Types match
0DCD-C3 0F 05       1917 (  9)         JP      TMERR           ; Different types - Error
0DD0-               1918
0DD0-CD CB 07       1919 ( 16) OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
0DD3-28             1920               .DB   "("
0DD4-2B             1921 (  4) EVAL:   DEC     HL              ; Evaluate expression & save
0DD5-16 00          1922 (  6)         LD      D,0             ; Precedence value
0DD7-D5             1923 ( 11) EVAL1:  PUSH    DE              ; Save precedence
0DD8-0E 01          1924 (  6)         LD      C,1
0DDA-CD DA 04       1925 ( 16)         CALL    CHKSTK          ; Check for 1 level of stack
0DDD-CD 4B 0E       1926 ( 16)         CALL    OPRND           ; Get next expression value
0DE0-22 15 21       1927 ( 20) EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
0DE3-2A 15 21       1928 ( 15) EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
0DE6-C1             1929 (  9)         POP     BC              ; Precedence value and operator
0DE7-78             1930 (  4)         LD      A,B             ; Get precedence value
0DE8-FE 78          1931 (  6)         CP      78H             ; "AND" or "OR" ?
0DEA-D4 C5 0D       1932 ( 6+)         CALL    NC,TSTNUM       ; No - Make sure it's a number
0DED-7E             1933 (  6)         LD      A,(HL)          ; Get next operator / function
0DEE-16 00          1934 (  6)         LD      D,0             ; Clear Last relation
0DF0-D6 B3          1935 (  6) RLTLP:  SUB     ZGTR            ; ">" Token
0DF2-DA 0C 0E       1936 ( 6+)         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
0DF5-FE 03          1937 (  6)         CP      ZLTH+1-ZGTR     ; < = >
0DF7-D2 0C 0E       1938 ( 6+)         JP      NC,FOPRND       ; Function - Call it
0DFA-FE 01          1939 (  6)         CP      ZEQUAL-ZGTR     ; "="
0DFC-17             1940 (  3)         RLA                     ; <- Test for legal
0DFD-AA             1941 (  4)         XOR     D               ; <- combinations of < = >
0DFE-BA             1942 (  4)         CP      D               ; <- by combining last token
0DFF-57             1943 (  4)         LD      D,A             ; <- with current one
0E00-DA FD 04       1944 ( 6+)         JP      C,SNERR         ; Error if "<<' '==" or ">>"
0E03-22 0A 21       1945 ( 20)         LD      (CUROPR),HL     ; Save address of current token
0E06-CD 55 09       1946 ( 16)         CALL    GETCHR          ; Get next character
0E09-C3 F0 0D       1947 (  9)         JP      RLTLP           ; Treat the two as one
0E0C-               1948
0E0C-7A             1949 (  4) FOPRND: LD      A,D             ; < = > found ?
0E0D-B7             1950 (  4)         OR      A
0E0E-C2 33 0F       1951 ( 6+)         JP      NZ,TSTRED       ; Yes - Test for reduction
0E11-7E             1952 (  6)         LD      A,(HL)          ; Get operator token
0E12-22 0A 21       1953 ( 20)         LD      (CUROPR),HL     ; Save operator address
0E15-D6 AC          1954 (  6)         SUB     ZPLUS           ; Operator or function?
0E17-D8             1955 ( 5+)         RET     C               ; Neither - Exit
0E18-FE 07          1956 (  6)         CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
0E1A-D0             1957 ( 5+)         RET     NC              ; No - Exit
0E1B-5F             1958 (  4)         LD      E,A             ; Coded operator
0E1C-3A F2 20       1959 ( 12)         LD      A,(TYPE)        ; Get data type
0E1F-3D             1960 (  4)         DEC     A               ; FF = numeric , 00 = string
0E20-B3             1961 (  4)         OR      E               ; Combine with coded operator
0E21-7B             1962 (  4)         LD      A,E             ; Get coded operator
0E22-CA 91 13       1963 ( 6+)         JP      Z,CONCAT        ; String concatenation
0E25-07             1964 (  3)         RLCA                    ; Times 2
0E26-83             1965 (  4)         ADD     A,E             ; Times 3
0E27-5F             1966 (  4)         LD      E,A             ; To DE (D is 0)
0E28-21 EF 03       1967 (  9)         LD      HL,PRITAB       ; Precedence table
0E2B-19             1968 (  7)         ADD     HL,DE           ; To the operator concerned
0E2C-78             1969 (  4)         LD      A,B             ; Last operator precedence
0E2D-56             1970 (  6)         LD      D,(HL)          ; Get evaluation precedence
0E2E-BA             1971 (  4)         CP      D               ; Compare with eval precedence
0E2F-D0             1972 ( 5+)         RET     NC              ; Exit if higher precedence
0E30-23             1973 (  4)         INC     HL              ; Point to routine address
0E31-CD C5 0D       1974 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0E34-               1975
0E34-C5             1976 ( 11) STKTHS: PUSH    BC              ; Save last precedence & token
0E35-01 E3 0D       1977 (  9)         LD      BC,EVAL3        ; Where to go on prec' break
0E38-C5             1978 ( 11)         PUSH    BC              ; Save on stack for return
0E39-43             1979 (  4)         LD      B,E             ; Save operator
0E3A-4A             1980 (  4)         LD      C,D             ; Save precedence
0E3B-CD D5 17       1981 ( 16)         CALL    STAKFP          ; Move value to stack
0E3E-58             1982 (  4)         LD      E,B             ; Restore operator
0E3F-51             1983 (  4)         LD      D,C             ; Restore precedence
0E40-4E             1984 (  6)         LD      C,(HL)          ; Get LSB of routine address
0E41-23             1985 (  4)         INC     HL
0E42-46             1986 (  6)         LD      B,(HL)          ; Get MSB of routine address
0E43-23             1987 (  4)         INC     HL
0E44-C5             1988 ( 11)         PUSH    BC              ; Save routine address
0E45-2A 0A 21       1989 ( 15)         LD      HL,(CUROPR)     ; Address of current operator
0E48-C3 D7 0D       1990 (  9)         JP      EVAL1           ; Loop until prec' break
0E4B-               1991
0E4B-AF             1992 (  4) OPRND:  XOR     A               ; Get operand routine
0E4C-32 F2 20       1993 ( 13)         LD      (TYPE),A        ; Set numeric expected
0E4F-CD 55 09       1994 ( 16)         CALL    GETCHR          ; Get next character
0E52-1E 24          1995 (  6)         LD      E,MO            ; ?MO Error
0E54-CA 11 05       1996 ( 6+)         JP      Z,ERROR         ; No operand - Error
0E57-DA AB 18       1997 ( 6+)         JP      C,ASCTFP        ; Number - Get value
0E5A-CD F3 09       1998 ( 16)         CALL    CHKLTR          ; See if a letter
0E5D-D2 B2 0E       1999 ( 6+)         JP      NC,CONVAR       ; Letter - Find variable
0E60-FE 26          2000 (  6)         CP      '&'                             ; &H = HEX, &B = BINARY
0E62-20 12          2001 ( 6+)         JR      NZ,NOTAMP
0E64-CD 55 09       2002 ( 16)         CALL    GETCHR          ; Get next character
0E67-FE 48          2003 (  6)         CP      'H'             ; Hex number indicated? [function added]
0E69-CA EF 1C       2004 ( 6+)         JP      Z,HEXTFP        ; Convert Hex to FPREG
0E6C-FE 42          2005 (  6)         CP      'B'             ; Binary number indicated? [function added]
0E6E-CA 5F 1D       2006 ( 6+)         JP      Z,BINTFP        ; Convert Bin to FPREG
0E71-1E 02          2007 (  6)         LD      E,SN            ; If neither then a ?SN Error
0E73-CA 11 05       2008 ( 6+)         JP      Z,ERROR         ;
0E76-FE AC          2009 (  6) NOTAMP: CP      ZPLUS           ; '+' Token ?
0E78-CA 4B 0E       2010 ( 6+)         JP      Z,OPRND         ; Yes - Look for operand
0E7B-FE 2E          2011 (  6)         CP      '.'             ; '.' ?
0E7D-CA AB 18       2012 ( 6+)         JP      Z,ASCTFP        ; Yes - Create FP number
0E80-FE AD          2013 (  6)         CP      ZMINUS          ; '-' Token ?
0E82-CA A1 0E       2014 ( 6+)         JP      Z,MINUS         ; Yes - Do minus
0E85-FE 22          2015 (  6)         CP      '"'             ; Literal string ?
0E87-CA 5A 12       2016 ( 6+)         JP      Z,QTSTR         ; Get string terminated by '"'
0E8A-FE AA          2017 (  6)         CP      ZNOT            ; "NOT" Token ?
0E8C-CA 93 0F       2018 ( 6+)         JP      Z,EVNOT         ; Yes - Eval NOT expression
0E8F-FE A7          2019 (  6)         CP      ZFN             ; "FN" Token ?
0E91-CA BE 11       2020 ( 6+)         JP      Z,DOFN          ; Yes - Do FN routine
0E94-D6 B6          2021 (  6)         SUB     ZSGN            ; Is it a function?
0E96-D2 C3 0E       2022 ( 6+)         JP      NC,FNOFST       ; Yes - Evaluate function
0E99-CD D0 0D       2023 ( 16) EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
0E9C-CD CB 07       2024 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
0E9F-29             2025               .DB   ")"
0EA0-C9             2026 (  9)         RET
0EA1-               2027
0EA1-16 7D          2028 (  6) MINUS:  LD      D,7DH           ; '-' precedence
0EA3-CD D7 0D       2029 ( 16)         CALL    EVAL1           ; Evaluate until prec' break
0EA6-2A 15 21       2030 ( 15)         LD      HL,(NXTOPR)     ; Get next operator address
0EA9-E5             2031 ( 11)         PUSH    HL              ; Save next operator address
0EAA-CD CD 17       2032 ( 16)         CALL    INVSGN          ; Negate value
0EAD-CD C5 0D       2033 ( 16) RETNUM: CALL    TSTNUM          ; Make sure it's a number
0EB0-E1             2034 (  9)         POP     HL              ; Restore next operator address
0EB1-C9             2035 (  9)         RET
0EB2-               2036
0EB2-CD B8 0F       2037 ( 16) CONVAR: CALL    GETVAR          ; Get variable address to DE
0EB5-E5             2038 ( 11) FRMEVL: PUSH    HL              ; Save code string address
0EB6-EB             2039 (  3)         EX      DE,HL           ; Variable address to HL
0EB7-22 29 21       2040 ( 20)         LD      (FPREG),HL      ; Save address of variable
0EBA-3A F2 20       2041 ( 12)         LD      A,(TYPE)        ; Get type
0EBD-B7             2042 (  4)         OR      A               ; Numeric?
0EBE-CC E2 17       2043 ( 6+)         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
0EC1-E1             2044 (  9)         POP     HL              ; Restore code string address
0EC2-C9             2045 (  9)         RET
0EC3-               2046
0EC3-06 00          2047 (  6) FNOFST: LD      B,0             ; Get address of function
0EC5-07             2048 (  3)         RLCA                    ; Double function offset
0EC6-4F             2049 (  4)         LD      C,A             ; BC = Offset in function table
0EC7-C5             2050 ( 11)         PUSH    BC              ; Save adjusted token value
0EC8-CD 55 09       2051 ( 16)         CALL    GETCHR          ; Get next character
0ECB-79             2052 (  4)         LD      A,C             ; Get adjusted token value
0ECC-FE 31          2053 (  6)         CP      031H ; 2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT$ or MID$ ?
0ECE-DA EA 0E       2054 ( 6+)         JP      C,FNVAL         ; No - Do function
0ED1-CD D0 0D       2055 ( 16)         CALL    OPNPAR          ; Evaluate expression  (X,...
0ED4-CD CB 07       2056 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
0ED7-2C             2057               .DB      ','
0ED8-CD C6 0D       2058 ( 16)         CALL    TSTSTR          ; Make sure it's a string
0EDB-EB             2059 (  3)         EX      DE,HL           ; Save code string address
0EDC-2A 29 21       2060 ( 15)         LD      HL,(FPREG)      ; Get address of string
0EDF-E3             2061 ( 16)         EX      (SP),HL         ; Save address of string
0EE0-E5             2062 ( 11)         PUSH    HL              ; Save adjusted token value
0EE1-EB             2063 (  3)         EX      DE,HL           ; Restore code string address
0EE2-CD 23 15       2064 ( 16)         CALL    GETINT          ; Get integer 0-255
0EE5-EB             2065 (  3)         EX      DE,HL           ; Save code string address
0EE6-E3             2066 ( 16)         EX      (SP),HL         ; Save integer,HL = adj' token
0EE7-C3 F2 0E       2067 (  9)         JP      GOFUNC          ; Jump to string function
0EEA-               2068
0EEA-CD 99 0E       2069 ( 16) FNVAL:  CALL    EVLPAR          ; Evaluate expression
0EED-E3             2070 ( 16)         EX      (SP),HL         ; HL = Adjusted token value
0EEE-11 AD 0E       2071 (  9)         LD      DE,RETNUM       ; Return number from function
0EF1-D5             2072 ( 11)         PUSH    DE              ; Save on stack
0EF2-01 4E 02       2073 (  9) GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
0EF5-09             2074 (  7)         ADD     HL,BC           ; Point to right address
0EF6-4E             2075 (  6)         LD      C,(HL)          ; Get LSB of address
0EF7-23             2076 (  4)         INC     HL              ;
0EF8-66             2077 (  6)         LD      H,(HL)          ; Get MSB of address
0EF9-69             2078 (  4)         LD      L,C             ; Address to HL
0EFA-E9             2079 (  3)         JP      (HL)            ; Jump to function
0EFB-               2080
0EFB-15             2081 (  4) SGNEXP: DEC     D               ; Dee to flag negative exponent
0EFC-FE AD          2082 (  6)         CP      ZMINUS          ; '-' token ?
0EFE-C8             2083 ( 5+)         RET     Z               ; Yes - Return
0EFF-FE 2D          2084 (  6)         CP      '-'             ; '-' ASCII ?
0F01-C8             2085 ( 5+)         RET     Z               ; Yes - Return
0F02-14             2086 (  4)         INC     D               ; Inc to flag positive exponent
0F03-FE 2B          2087 (  6)         CP      '+'             ; '+' ASCII ?
0F05-C8             2088 ( 5+)         RET     Z               ; Yes - Return
0F06-FE AC          2089 (  6)         CP      ZPLUS           ; '+' token ?
0F08-C8             2090 ( 5+)         RET     Z               ; Yes - Return
0F09-2B             2091 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
0F0A-C9             2092 (  9)         RET                     ; Return "NZ"
0F0B-               2093
0F0B-F6             2094       POR:    .DB      0F6H            ; Flag "OR"
0F0C-AF             2095 (  4) PAND:   XOR     A               ; Flag "AND"
0F0D-F5             2096 ( 11)         PUSH    AF              ; Save "AND" / "OR" flag
0F0E-CD C5 0D       2097 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0F11-CD 07 0A       2098 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
0F14-F1             2099 (  9)         POP     AF              ; Restore "AND" / "OR" flag
0F15-EB             2100 (  3)         EX      DE,HL           ; <- Get last
0F16-C1             2101 (  9)         POP     BC              ; <-  value
0F17-E3             2102 ( 16)         EX      (SP),HL         ; <-  from
0F18-EB             2103 (  3)         EX      DE,HL           ; <-  stack
0F19-CD E5 17       2104 ( 16)         CALL    FPBCDE          ; Move last value to FPREG
0F1C-F5             2105 ( 11)         PUSH    AF              ; Save "AND" / "OR" flag
0F1D-CD 07 0A       2106 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
0F20-F1             2107 (  9)         POP     AF              ; Restore "AND" / "OR" flag
0F21-C1             2108 (  9)         POP     BC              ; Get value
0F22-79             2109 (  4)         LD      A,C             ; Get LSB
0F23-21 7C 11       2110 (  9)         LD      HL,ACPASS       ; Address of save AC as current
0F26-C2 2E 0F       2111 ( 6+)         JP      NZ,POR1         ; Jump if OR
0F29-A3             2112 (  4)         AND     E               ; "AND" LSBs
0F2A-4F             2113 (  4)         LD      C,A             ; Save LSB
0F2B-78             2114 (  4)         LD      A,B             ; Get MBS
0F2C-A2             2115 (  4)         AND     D               ; "AND" MSBs
0F2D-E9             2116 (  3)         JP      (HL)            ; Save AC as current (ACPASS)
0F2E-               2117
0F2E-B3             2118 (  4) POR1:   OR      E               ; "OR" LSBs
0F2F-4F             2119 (  4)         LD      C,A             ; Save LSB
0F30-78             2120 (  4)         LD      A,B             ; Get MSB
0F31-B2             2121 (  4)         OR      D               ; "OR" MSBs
0F32-E9             2122 (  3)         JP      (HL)            ; Save AC as current (ACPASS)
0F33-               2123
0F33-21 45 0F       2124 (  9) TSTRED: LD      HL,CMPLOG       ; Logical compare routine
0F36-3A F2 20       2125 ( 12)         LD      A,(TYPE)        ; Get data type
0F39-1F             2126 (  3)         RRA                     ; Carry set = string
0F3A-7A             2127 (  4)         LD      A,D             ; Get last precedence value
0F3B-17             2128 (  3)         RLA                     ; Times 2 plus carry
0F3C-5F             2129 (  4)         LD      E,A             ; To E
0F3D-16 64          2130 (  6)         LD      D,64H           ; Relational precedence
0F3F-78             2131 (  4)         LD      A,B             ; Get current precedence
0F40-BA             2132 (  4)         CP      D               ; Compare with last
0F41-D0             2133 ( 5+)         RET     NC              ; Eval if last was rel' or log'
0F42-C3 34 0E       2134 (  9)         JP      STKTHS          ; Stack this one and get next
0F45-               2135
0F45-47 0F          2136       CMPLOG: .DW   CMPLG1          ; Compare two values / strings
0F47-79             2137 (  4) CMPLG1: LD      A,C             ; Get data type
0F48-B7             2138 (  4)         OR      A
0F49-1F             2139 (  3)         RRA
0F4A-C1             2140 (  9)         POP     BC              ; Get last expression to BCDE
0F4B-D1             2141 (  9)         POP     DE
0F4C-F5             2142 ( 11)         PUSH    AF              ; Save status
0F4D-CD C7 0D       2143 ( 16)         CALL    CHKTYP          ; Check that types match
0F50-21 89 0F       2144 (  9)         LD      HL,CMPRES       ; Result to comparison
0F53-E5             2145 ( 11)         PUSH    HL              ; Save for RETurn
0F54-CA 1F 18       2146 ( 6+)         JP      Z,CMPNUM        ; Compare values if numeric
0F57-AF             2147 (  4)         XOR     A               ; Compare two strings
0F58-32 F2 20       2148 ( 13)         LD      (TYPE),A        ; Set type to numeric
0F5B-D5             2149 ( 11)         PUSH    DE              ; Save string name
0F5C-CD DE 13       2150 ( 16)         CALL    GSTRCU          ; Get current string
0F5F-7E             2151 (  6)         LD      A,(HL)          ; Get length of string
0F60-23             2152 (  4)         INC     HL
0F61-23             2153 (  4)         INC     HL
0F62-4E             2154 (  6)         LD      C,(HL)          ; Get LSB of address
0F63-23             2155 (  4)         INC     HL
0F64-46             2156 (  6)         LD      B,(HL)          ; Get MSB of address
0F65-D1             2157 (  9)         POP     DE              ; Restore string name
0F66-C5             2158 ( 11)         PUSH    BC              ; Save address of string
0F67-F5             2159 ( 11)         PUSH    AF              ; Save length of string
0F68-CD E2 13       2160 ( 16)         CALL    GSTRDE          ; Get second string
0F6B-CD F3 17       2161 ( 16)         CALL    LOADFP          ; Get address of second string
0F6E-F1             2162 (  9)         POP     AF              ; Restore length of string 1
0F6F-57             2163 (  4)         LD      D,A             ; Length to D
0F70-E1             2164 (  9)         POP     HL              ; Restore address of string 1
0F71-7B             2165 (  4) CMPSTR: LD      A,E             ; Bytes of string 2 to do
0F72-B2             2166 (  4)         OR      D               ; Bytes of string 1 to do
0F73-C8             2167 ( 5+)         RET     Z               ; Exit if all bytes compared
0F74-7A             2168 (  4)         LD      A,D             ; Get bytes of string 1 to do
0F75-D6 01          2169 (  6)         SUB     1
0F77-D8             2170 ( 5+)         RET     C               ; Exit if end of string 1
0F78-AF             2171 (  4)         XOR     A
0F79-BB             2172 (  4)         CP      E               ; Bytes of string 2 to do
0F7A-3C             2173 (  4)         INC     A
0F7B-D0             2174 ( 5+)         RET     NC              ; Exit if end of string 2
0F7C-15             2175 (  4)         DEC     D               ; Count bytes in string 1
0F7D-1D             2176 (  4)         DEC     E               ; Count bytes in string 2
0F7E-0A             2177 (  6)         LD      A,(BC)          ; Byte in string 2
0F7F-BE             2178 (  6)         CP      (HL)            ; Compare to byte in string 1
0F80-23             2179 (  4)         INC     HL              ; Move up string 1
0F81-03             2180 (  4)         INC     BC              ; Move up string 2
0F82-CA 71 0F       2181 ( 6+)         JP      Z,CMPSTR        ; Same - Try next bytes
0F85-3F             2182 (  3)         CCF                     ; Flag difference (">" or "<")
0F86-C3 AF 17       2183 (  9)         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
0F89-               2184
0F89-3C             2185 (  4) CMPRES: INC     A               ; Increment current value
0F8A-8F             2186 (  4)         ADC     A,A             ; Double plus carry
0F8B-C1             2187 (  9)         POP     BC              ; Get other value
0F8C-A0             2188 (  4)         AND     B               ; Combine them
0F8D-C6 FF          2189 (  6)         ADD     A,-1            ; Carry set if different
0F8F-9F             2190 (  4)         SBC     A,A             ; 00 - Equal , FF - Different
0F90-C3 B6 17       2191 (  9)         JP      FLGREL          ; Set current value & continue
0F93-               2192
0F93-16 5A          2193 (  6) EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
0F95-CD D7 0D       2194 ( 16)         CALL    EVAL1           ; Eval until precedence break
0F98-CD C5 0D       2195 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0F9B-CD 07 0A       2196 ( 16)         CALL    DEINT           ; Get integer -32768 - 32767
0F9E-7B             2197 (  4)         LD      A,E             ; Get LSB
0F9F-2F             2198 (  3)         CPL                     ; Invert LSB
0FA0-4F             2199 (  4)         LD      C,A             ; Save "NOT" of LSB
0FA1-7A             2200 (  4)         LD      A,D             ; Get MSB
0FA2-2F             2201 (  3)         CPL                     ; Invert MSB
0FA3-CD 7C 11       2202 ( 16)         CALL    ACPASS          ; Save AC as current
0FA6-C1             2203 (  9)         POP     BC              ; Clean up stack
0FA7-C3 E3 0D       2204 (  9)         JP      EVAL3           ; Continue evaluation
0FAA-               2205
0FAA-2B             2206 (  4) DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
0FAB-CD 55 09       2207 ( 16)         CALL    GETCHR          ; Get next character
0FAE-C8             2208 ( 5+)         RET     Z               ; End of DIM statement
0FAF-CD CB 07       2209 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
0FB2-2C             2210               .DB      ','
0FB3-01 AA 0F       2211 (  9) DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
0FB6-C5             2212 ( 11)         PUSH    BC              ; Save on stack
0FB7-F6             2213               .DB      0F6H            ; Flag "Create" variable
0FB8-AF             2214 (  4) GETVAR: XOR     A               ; Find variable address,to DE
0FB9-32 F1 20       2215 ( 13)         LD      (LCRFLG),A      ; Set locate / create flag
0FBC-46             2216 (  6)         LD      B,(HL)          ; Get First byte of name
0FBD-CD F3 09       2217 ( 16) GTFNAM: CALL    CHKLTR          ; See if a letter
0FC0-DA FD 04       2218 ( 6+)         JP      C,SNERR         ; ?SN Error if not a letter
0FC3-AF             2219 (  4)         XOR     A
0FC4-4F             2220 (  4)         LD      C,A             ; Clear second byte of name
0FC5-32 F2 20       2221 ( 13)         LD      (TYPE),A        ; Set type to numeric
0FC8-CD 55 09       2222 ( 16)         CALL    GETCHR          ; Get next character
0FCB-DA D4 0F       2223 ( 6+)         JP      C,SVNAM2        ; Numeric - Save in name
0FCE-CD F3 09       2224 ( 16)         CALL    CHKLTR          ; See if a letter
0FD1-DA E1 0F       2225 ( 6+)         JP      C,CHARTY        ; Not a letter - Check type
0FD4-4F             2226 (  4) SVNAM2: LD      C,A             ; Save second byte of name
0FD5-CD 55 09       2227 ( 16) ENDNAM: CALL    GETCHR          ; Get next character
0FD8-DA D5 0F       2228 ( 6+)         JP      C,ENDNAM        ; Numeric - Get another
0FDB-CD F3 09       2229 ( 16)         CALL    CHKLTR          ; See if a letter
0FDE-D2 D5 0F       2230 ( 6+)         JP      NC,ENDNAM       ; Letter - Get another
0FE1-D6 24          2231 (  6) CHARTY: SUB     '$'             ; String variable?
0FE3-C2 F0 0F       2232 ( 6+)         JP      NZ,NOTSTR       ; No - Numeric variable
0FE6-3C             2233 (  4)         INC     A               ; A = 1 (string type)
0FE7-32 F2 20       2234 ( 13)         LD      (TYPE),A        ; Set type to string
0FEA-0F             2235 (  3)         RRCA                    ; A = 80H , Flag for string
0FEB-81             2236 (  4)         ADD     A,C             ; 2nd byte of name has bit 7 on
0FEC-4F             2237 (  4)         LD      C,A             ; Resave second byte on name
0FED-CD 55 09       2238 ( 16)         CALL    GETCHR          ; Get next character
0FF0-3A 10 21       2239 ( 12) NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
0FF3-3D             2240 (  4)         DEC     A
0FF4-CA 9D 10       2241 ( 6+)         JP      Z,ARLDSV        ; Yes - Get array name
0FF7-F2 00 10       2242 ( 6+)         JP      P,NSCFOR        ; No array with "FOR" or "FN"
0FFA-7E             2243 (  6)         LD      A,(HL)          ; Get byte again
0FFB-D6 28          2244 (  6)         SUB     '('             ; Subscripted variable?
0FFD-CA 75 10       2245 ( 6+)         JP      Z,SBSCPT        ; Yes - Sort out subscript
1000-               2246
1000-AF             2247 (  4) NSCFOR: XOR     A               ; Simple variable
1001-32 10 21       2248 ( 13)         LD      (FORFLG),A      ; Clear "FOR" flag
1004-E5             2249 ( 11)         PUSH    HL              ; Save code string address
1005-50             2250 (  4)         LD      D,B             ; DE = Variable name to find
1006-59             2251 (  4)         LD      E,C
1007-2A 23 21       2252 ( 15)         LD      HL,(FNRGNM)     ; FN argument name
100A-CD C5 07       2253 ( 16)         CALL    CPDEHL          ; Is it the FN argument?
100D-11 25 21       2254 (  9)         LD      DE,FNARG        ; Point to argument value
1010-CA E5 16       2255 ( 6+)         JP      Z,POPHRT        ; Yes - Return FN argument value
1013-2A 1D 21       2256 ( 15)         LD      HL,(VAREND)     ; End of variables
1016-EB             2257 (  3)         EX      DE,HL           ; Address of end of search
1017-2A 1B 21       2258 ( 15)         LD      HL,(PROGND)     ; Start of variables address
101A-CD C5 07       2259 ( 16) FNDVAR: CALL    CPDEHL          ; End of variable list table?
101D-CA 33 10       2260 ( 6+)         JP      Z,CFEVAL        ; Yes - Called from EVAL?
1020-79             2261 (  4)         LD      A,C             ; Get second byte of name
1021-96             2262 (  6)         SUB     (HL)            ; Compare with name in list
1022-23             2263 (  4)         INC     HL              ; Move on to first byte
1023-C2 28 10       2264 ( 6+)         JP      NZ,FNTHR        ; Different - Find another
1026-78             2265 (  4)         LD      A,B             ; Get first byte of name
1027-96             2266 (  6)         SUB     (HL)            ; Compare with name in list
1028-23             2267 (  4) FNTHR:  INC     HL              ; Move on to LSB of value
1029-CA 67 10       2268 ( 6+)         JP      Z,RETADR        ; Found - Return address
102C-23             2269 (  4)         INC     HL              ; <- Skip
102D-23             2270 (  4)         INC     HL              ; <- over
102E-23             2271 (  4)         INC     HL              ; <- F.P.
102F-23             2272 (  4)         INC     HL              ; <- value
1030-C3 1A 10       2273 (  9)         JP      FNDVAR          ; Keep looking
1033-               2274
1033-E1             2275 (  9) CFEVAL: POP     HL              ; Restore code string address
1034-E3             2276 ( 16)         EX      (SP),HL         ; Get return address
1035-D5             2277 ( 11)         PUSH    DE              ; Save address of variable
1036-11 B5 0E       2278 (  9)         LD      DE,FRMEVL       ; Return address in EVAL
1039-CD C5 07       2279 ( 16)         CALL    CPDEHL          ; Called from EVAL ?
103C-D1             2280 (  9)         POP     DE              ; Restore address of variable
103D-CA 6A 10       2281 ( 6+)         JP      Z,RETNUL        ; Yes - Return null variable
1040-E3             2282 ( 16)         EX      (SP),HL         ; Put back return
1041-E5             2283 ( 11)         PUSH    HL              ; Save code string address
1042-C5             2284 ( 11)         PUSH    BC              ; Save variable name
1043-01 06 00       2285 (  9)         LD      BC,6            ; 2 byte name plus 4 byte data
1046-2A 1F 21       2286 ( 15)         LD      HL,(ARREND)     ; End of arrays
1049-E5             2287 ( 11)         PUSH    HL              ; Save end of arrays
104A-09             2288 (  7)         ADD     HL,BC           ; Move up 6 bytes
104B-C1             2289 (  9)         POP     BC              ; Source address in BC
104C-E5             2290 ( 11)         PUSH    HL              ; Save new end address
104D-CD C9 04       2291 ( 16)         CALL    MOVUP           ; Move arrays up
1050-E1             2292 (  9)         POP     HL              ; Restore new end address
1051-22 1F 21       2293 ( 20)         LD      (ARREND),HL     ; Set new end address
1054-60             2294 (  4)         LD      H,B             ; End of variables to HL
1055-69             2295 (  4)         LD      L,C
1056-22 1D 21       2296 ( 20)         LD      (VAREND),HL     ; Set new end address
1059-               2297
1059-2B             2298 (  4) ZEROLP: DEC     HL              ; Back through to zero variable
105A-36 00          2299 (  9)         LD      (HL),0          ; Zero byte in variable
105C-CD C5 07       2300 ( 16)         CALL    CPDEHL          ; Done them all?
105F-C2 59 10       2301 ( 6+)         JP      NZ,ZEROLP       ; No - Keep on going
1062-D1             2302 (  9)         POP     DE              ; Get variable name
1063-73             2303 (  7)         LD      (HL),E          ; Store second character
1064-23             2304 (  4)         INC     HL
1065-72             2305 (  7)         LD      (HL),D          ; Store first character
1066-23             2306 (  4)         INC     HL
1067-EB             2307 (  3) RETADR: EX      DE,HL           ; Address of variable in DE
1068-E1             2308 (  9)         POP     HL              ; Restore code string address
1069-C9             2309 (  9)         RET
106A-               2310
106A-32 2C 21       2311 ( 13) RETNUL: LD      (FPEXP),A       ; Set result to zero
106D-21 99 04       2312 (  9)         LD      HL,ZERBYT       ; Also set a null string
1070-22 29 21       2313 ( 20)         LD      (FPREG),HL      ; Save for EVAL
1073-E1             2314 (  9)         POP     HL              ; Restore code string address
1074-C9             2315 (  9)         RET
1075-               2316
1075-E5             2317 ( 11) SBSCPT: PUSH    HL              ; Save code string address
1076-2A F1 20       2318 ( 15)         LD      HL,(LCRFLG)     ; Locate/Create and Type
1079-E3             2319 ( 16)         EX      (SP),HL         ; Save and get code string
107A-57             2320 (  4)         LD      D,A             ; Zero number of dimensions
107B-D5             2321 ( 11) SCPTLP: PUSH    DE              ; Save number of dimensions
107C-C5             2322 ( 11)         PUSH    BC              ; Save array name
107D-CD FB 09       2323 ( 16)         CALL    FPSINT          ; Get subscript (0-32767)
1080-C1             2324 (  9)         POP     BC              ; Restore array name
1081-F1             2325 (  9)         POP     AF              ; Get number of dimensions
1082-EB             2326 (  3)         EX      DE,HL
1083-E3             2327 ( 16)         EX      (SP),HL         ; Save subscript value
1084-E5             2328 ( 11)         PUSH    HL              ; Save LCRFLG and TYPE
1085-EB             2329 (  3)         EX      DE,HL
1086-3C             2330 (  4)         INC     A               ; Count dimensions
1087-57             2331 (  4)         LD      D,A             ; Save in D
1088-7E             2332 (  6)         LD      A,(HL)          ; Get next byte in code string
1089-FE 2C          2333 (  6)         CP      ','             ; Comma (more to come)?
108B-CA 7B 10       2334 ( 6+)         JP      Z,SCPTLP        ; Yes - More subscripts
108E-CD CB 07       2335 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
1091-29             2336               .DB      ")"
1092-22 15 21       2337 ( 20)         LD      (NXTOPR),HL     ; Save code string address
1095-E1             2338 (  9)         POP     HL              ; Get LCRFLG and TYPE
1096-22 F1 20       2339 ( 20)         LD      (LCRFLG),HL     ; Restore Locate/create & type
1099-1E 00          2340 (  6)         LD      E,0             ; Flag not CSAVE* or CLOAD*
109B-D5             2341 ( 11)         PUSH    DE              ; Save number of dimensions (D)
109C-11             2342               .DB      11H             ; Skip "PUSH HL" and "PUSH AF'
109D-               2343
109D-E5             2344 ( 11) ARLDSV: PUSH    HL              ; Save code string address
109E-F5             2345 ( 11)         PUSH    AF              ; A = 00 , Flags set = Z,N
109F-2A 1D 21       2346 ( 15)         LD      HL,(VAREND)     ; Start of arrays
10A2-3E             2347               .DB      3EH             ; Skip "ADD HL,DE"
10A3-19             2348 (  7) FNDARY: ADD     HL,DE           ; Move to next array start
10A4-EB             2349 (  3)         EX      DE,HL
10A5-2A 1F 21       2350 ( 15)         LD      HL,(ARREND)     ; End of arrays
10A8-EB             2351 (  3)         EX      DE,HL           ; Current array pointer
10A9-CD C5 07       2352 ( 16)         CALL    CPDEHL          ; End of arrays found?
10AC-CA D5 10       2353 ( 6+)         JP      Z,CREARY        ; Yes - Create array
10AF-7E             2354 (  6)         LD      A,(HL)          ; Get second byte of name
10B0-B9             2355 (  4)         CP      C               ; Compare with name given
10B1-23             2356 (  4)         INC     HL              ; Move on
10B2-C2 B7 10       2357 ( 6+)         JP      NZ,NXTARY       ; Different - Find next array
10B5-7E             2358 (  6)         LD      A,(HL)          ; Get first byte of name
10B6-B8             2359 (  4)         CP      B               ; Compare with name given
10B7-23             2360 (  4) NXTARY: INC     HL              ; Move on
10B8-5E             2361 (  6)         LD      E,(HL)          ; Get LSB of next array address
10B9-23             2362 (  4)         INC     HL
10BA-56             2363 (  6)         LD      D,(HL)          ; Get MSB of next array address
10BB-23             2364 (  4)         INC     HL
10BC-C2 A3 10       2365 ( 6+)         JP      NZ,FNDARY       ; Not found - Keep looking
10BF-3A F1 20       2366 ( 12)         LD      A,(LCRFLG)      ; Found Locate or Create it?
10C2-B7             2367 (  4)         OR      A
10C3-C2 06 05       2368 ( 6+)         JP      NZ,DDERR        ; Create - ?DD Error
10C6-F1             2369 (  9)         POP     AF              ; Locate - Get number of dim'ns
10C7-44             2370 (  4)         LD      B,H             ; BC Points to array dim'ns
10C8-4D             2371 (  4)         LD      C,L
10C9-CA E5 16       2372 ( 6+)         JP      Z,POPHRT        ; Jump if array load/save
10CC-96             2373 (  6)         SUB     (HL)            ; Same number of dimensions?
10CD-CA 33 11       2374 ( 6+)         JP      Z,FINDEL        ; Yes - Find element
10D0-1E 10          2375 (  6) BSERR:  LD      E,BS            ; ?BS Error
10D2-C3 11 05       2376 (  9)         JP      ERROR           ; Output error
10D5-               2377
10D5-11 04 00       2378 (  9) CREARY: LD      DE,4            ; 4 Bytes per entry
10D8-F1             2379 (  9)         POP     AF              ; Array to save or 0 dim'ns?
10D9-CA 1C 0A       2380 ( 6+)         JP      Z,FCERR         ; Yes - ?FC Error
10DC-71             2381 (  7)         LD      (HL),C          ; Save second byte of name
10DD-23             2382 (  4)         INC     HL
10DE-70             2383 (  7)         LD      (HL),B          ; Save first byte of name
10DF-23             2384 (  4)         INC     HL
10E0-4F             2385 (  4)         LD      C,A             ; Number of dimensions to C
10E1-CD DA 04       2386 ( 16)         CALL    CHKSTK          ; Check if enough memory
10E4-23             2387 (  4)         INC     HL              ; Point to number of dimensions
10E5-23             2388 (  4)         INC     HL
10E6-22 0A 21       2389 ( 20)         LD      (CUROPR),HL     ; Save address of pointer
10E9-71             2390 (  7)         LD      (HL),C          ; Set number of dimensions
10EA-23             2391 (  4)         INC     HL
10EB-3A F1 20       2392 ( 12)         LD      A,(LCRFLG)      ; Locate of Create?
10EE-17             2393 (  3)         RLA                     ; Carry set = Create
10EF-79             2394 (  4)         LD      A,C             ; Get number of dimensions
10F0-01 0B 00       2395 (  9) CRARLP: LD      BC,10+1         ; Default dimension size 10
10F3-D2 F8 10       2396 ( 6+)         JP      NC,DEFSIZ       ; Locate - Set default size
10F6-C1             2397 (  9)         POP     BC              ; Get specified dimension size
10F7-03             2398 (  4)         INC     BC              ; Include zero element
10F8-71             2399 (  7) DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
10F9-23             2400 (  4)         INC     HL
10FA-70             2401 (  7)         LD      (HL),B          ; Save MSB of dimension size
10FB-23             2402 (  4)         INC     HL
10FC-F5             2403 ( 11)         PUSH    AF              ; Save num' of dim'ns an status
10FD-E5             2404 ( 11)         PUSH    HL              ; Save address of dim'n size
10FE-CD 90 18       2405 ( 16)         CALL    MLDEBC          ; Multiply DE by BC to find
1101-EB             2406 (  3)         EX      DE,HL           ; amount of mem needed (to DE)
1102-E1             2407 (  9)         POP     HL              ; Restore address of dimension
1103-F1             2408 (  9)         POP     AF              ; Restore number of dimensions
1104-3D             2409 (  4)         DEC     A               ; Count them
1105-C2 F0 10       2410 ( 6+)         JP      NZ,CRARLP       ; Do next dimension if more
1108-F5             2411 ( 11)         PUSH    AF              ; Save locate/create flag
1109-42             2412 (  4)         LD      B,D             ; MSB of memory needed
110A-4B             2413 (  4)         LD      C,E             ; LSB of memory needed
110B-EB             2414 (  3)         EX      DE,HL
110C-19             2415 (  7)         ADD     HL,DE           ; Add bytes to array start
110D-DA F2 04       2416 ( 6+)         JP      C,OMERR         ; Too big - Error
1110-CD E3 04       2417 ( 16)         CALL    ENFMEM          ; See if enough memory
1113-22 1F 21       2418 ( 20)         LD      (ARREND),HL     ; Save new end of array
1116-               2419
1116-2B             2420 (  4) ZERARY: DEC     HL              ; Back through array data
1117-36 00          2421 (  9)         LD      (HL),0          ; Set array element to zero
1119-CD C5 07       2422 ( 16)         CALL    CPDEHL          ; All elements zeroed?
111C-C2 16 11       2423 ( 6+)         JP      NZ,ZERARY       ; No - Keep on going
111F-03             2424 (  4)         INC     BC              ; Number of bytes + 1
1120-57             2425 (  4)         LD      D,A             ; A=0
1121-2A 0A 21       2426 ( 15)         LD      HL,(CUROPR)     ; Get address of array
1124-5E             2427 (  6)         LD      E,(HL)          ; Number of dimensions
1125-EB             2428 (  3)         EX      DE,HL           ; To HL
1126-29             2429 (  7)         ADD     HL,HL           ; Two bytes per dimension size
1127-09             2430 (  7)         ADD     HL,BC           ; Add number of bytes
1128-EB             2431 (  3)         EX      DE,HL           ; Bytes needed to DE
1129-2B             2432 (  4)         DEC     HL
112A-2B             2433 (  4)         DEC     HL
112B-73             2434 (  7)         LD      (HL),E          ; Save LSB of bytes needed
112C-23             2435 (  4)         INC     HL
112D-72             2436 (  7)         LD      (HL),D          ; Save MSB of bytes needed
112E-23             2437 (  4)         INC     HL
112F-F1             2438 (  9)         POP     AF              ; Locate / Create?
1130-DA 57 11       2439 ( 6+)         JP      C,ENDDIM        ; A is 0 , End if create
1133-47             2440 (  4) FINDEL: LD      B,A             ; Find array element
1134-4F             2441 (  4)         LD      C,A
1135-7E             2442 (  6)         LD      A,(HL)          ; Number of dimensions
1136-23             2443 (  4)         INC     HL
1137-16             2444               .DB      16H             ; Skip "POP HL"
1138-E1             2445 (  9) FNDELP: POP     HL              ; Address of next dim' size
1139-5E             2446 (  6)         LD      E,(HL)          ; Get LSB of dim'n size
113A-23             2447 (  4)         INC     HL
113B-56             2448 (  6)         LD      D,(HL)          ; Get MSB of dim'n size
113C-23             2449 (  4)         INC     HL
113D-E3             2450 ( 16)         EX      (SP),HL         ; Save address - Get index
113E-F5             2451 ( 11)         PUSH    AF              ; Save number of dim'ns
113F-CD C5 07       2452 ( 16)         CALL    CPDEHL          ; Dimension too large?
1142-D2 D0 10       2453 ( 6+)         JP      NC,BSERR        ; Yes - ?BS Error
1145-E5             2454 ( 11)         PUSH    HL              ; Save index
1146-CD 90 18       2455 ( 16)         CALL    MLDEBC          ; Multiply previous by size
1149-D1             2456 (  9)         POP     DE              ; Index supplied to DE
114A-19             2457 (  7)         ADD     HL,DE           ; Add index to pointer
114B-F1             2458 (  9)         POP     AF              ; Number of dimensions
114C-3D             2459 (  4)         DEC     A               ; Count them
114D-44             2460 (  4)         LD      B,H             ; MSB of pointer
114E-4D             2461 (  4)         LD      C,L             ; LSB of pointer
114F-C2 38 11       2462 ( 6+)         JP      NZ,FNDELP       ; More - Keep going
1152-29             2463 (  7)         ADD     HL,HL           ; 4 Bytes per element
1153-29             2464 (  7)         ADD     HL,HL
1154-C1             2465 (  9)         POP     BC              ; Start of array
1155-09             2466 (  7)         ADD     HL,BC           ; Point to element
1156-EB             2467 (  3)         EX      DE,HL           ; Address of element to DE
1157-2A 15 21       2468 ( 15) ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
115A-C9             2469 (  9)         RET
115B-               2470
115B-2A 1F 21       2471 ( 15) FRE:    LD      HL,(ARREND)     ; Start of free memory
115E-EB             2472 (  3)         EX      DE,HL           ; To DE
115F-21 00 00       2473 (  9)         LD      HL,0            ; End of free memory
1162-39             2474 (  7)         ADD     HL,SP           ; Current stack value
1163-3A F2 20       2475 ( 12)         LD      A,(TYPE)        ; Dummy argument type
1166-B7             2476 (  4)         OR      A
1167-CA 77 11       2477 ( 6+)         JP      Z,FRENUM        ; Numeric - Free variable space
116A-CD DE 13       2478 ( 16)         CALL    GSTRCU          ; Current string to pool
116D-CD DE 12       2479 ( 16)         CALL    GARBGE          ; Garbage collection
1170-2A 9F 20       2480 ( 15)         LD      HL,(STRSPC)     ; Bottom of string space in use
1173-EB             2481 (  3)         EX      DE,HL           ; To DE
1174-2A 08 21       2482 ( 15)         LD      HL,(STRBOT)     ; Bottom of string space
1177-7D             2483 (  4) FRENUM: LD      A,L             ; Get LSB of end
1178-93             2484 (  4)         SUB     E               ; Subtract LSB of beginning
1179-4F             2485 (  4)         LD      C,A             ; Save difference if C
117A-7C             2486 (  4)         LD      A,H             ; Get MSB of end
117B-9A             2487 (  4)         SBC     A,D             ; Subtract MSB of beginning
117C-41             2488 (  4) ACPASS: LD      B,C             ; Return integer AC
117D-50             2489 (  4) ABPASS: LD      D,B             ; Return integer AB
117E-1E 00          2490 (  6)         LD      E,0
1180-21 F2 20       2491 (  9)         LD      HL,TYPE         ; Point to type
1183-73             2492 (  7)         LD      (HL),E          ; Set type to numeric
1184-06 90          2493 (  6)         LD      B,80H+16        ; 16 bit integer
1186-C3 BB 17       2494 (  9)         JP      RETINT          ; Return the integr
1189-               2495
1189-3A F0 20       2496 ( 12) POS:    LD      A,(CURPOS)      ; Get cursor position
118C-47             2497 (  4) PASSA:  LD      B,A             ; Put A into AB
118D-AF             2498 (  4)         XOR     A               ; Zero A
118E-C3 7D 11       2499 (  9)         JP      ABPASS          ; Return integer AB
1191-               2500
1191-CD 14 12       2501 ( 16) DEF:    CALL    CHEKFN          ; Get "FN" and name
1194-CD 06 12       2502 ( 16)         CALL    IDTEST          ; Test for illegal direct
1197-01 EC 0A       2503 (  9)         LD      BC,DATA         ; To get next statement
119A-C5             2504 ( 11)         PUSH    BC              ; Save address for RETurn
119B-D5             2505 ( 11)         PUSH    DE              ; Save address of function ptr
119C-CD CB 07       2506 ( 16)         CALL    CHKSYN          ; Make sure "(" follows
119F-28             2507               .DB      "("
11A0-CD B8 0F       2508 ( 16)         CALL    GETVAR          ; Get argument variable name
11A3-E5             2509 ( 11)         PUSH    HL              ; Save code string address
11A4-EB             2510 (  3)         EX      DE,HL           ; Argument address to HL
11A5-2B             2511 (  4)         DEC     HL
11A6-56             2512 (  6)         LD      D,(HL)          ; Get first byte of arg name
11A7-2B             2513 (  4)         DEC     HL
11A8-5E             2514 (  6)         LD      E,(HL)          ; Get second byte of arg name
11A9-E1             2515 (  9)         POP     HL              ; Restore code string address
11AA-CD C5 0D       2516 ( 16)         CALL    TSTNUM          ; Make sure numeric argument
11AD-CD CB 07       2517 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
11B0-29             2518               .DB      ")"
11B1-CD CB 07       2519 ( 16)         CALL    CHKSYN          ; Make sure "=" follows
11B4-B4             2520               .DB      ZEQUAL          ; "=" token
11B5-44             2521 (  4)         LD      B,H             ; Code string address to BC
11B6-4D             2522 (  4)         LD      C,L
11B7-E3             2523 ( 16)         EX      (SP),HL         ; Save code str , Get FN ptr
11B8-71             2524 (  7)         LD      (HL),C          ; Save LSB of FN code string
11B9-23             2525 (  4)         INC     HL
11BA-70             2526 (  7)         LD      (HL),B          ; Save MSB of FN code string
11BB-C3 53 12       2527 (  9)         JP      SVSTAD          ; Save address and do function
11BE-               2528
11BE-CD 14 12       2529 ( 16) DOFN:   CALL    CHEKFN          ; Make sure FN follows
11C1-D5             2530 ( 11)         PUSH    DE              ; Save function pointer address
11C2-CD 99 0E       2531 ( 16)         CALL    EVLPAR          ; Evaluate expression in "()"
11C5-CD C5 0D       2532 ( 16)         CALL    TSTNUM          ; Make sure numeric result
11C8-E3             2533 ( 16)         EX      (SP),HL         ; Save code str , Get FN ptr
11C9-5E             2534 (  6)         LD      E,(HL)          ; Get LSB of FN code string
11CA-23             2535 (  4)         INC     HL
11CB-56             2536 (  6)         LD      D,(HL)          ; Get MSB of FN code string
11CC-23             2537 (  4)         INC     HL
11CD-7A             2538 (  4)         LD      A,D             ; And function DEFined?
11CE-B3             2539 (  4)         OR      E
11CF-CA 09 05       2540 ( 6+)         JP      Z,UFERR         ; No - ?UF Error
11D2-7E             2541 (  6)         LD      A,(HL)          ; Get LSB of argument address
11D3-23             2542 (  4)         INC     HL
11D4-66             2543 (  6)         LD      H,(HL)          ; Get MSB of argument address
11D5-6F             2544 (  4)         LD      L,A             ; HL = Arg variable address
11D6-E5             2545 ( 11)         PUSH    HL              ; Save it
11D7-2A 23 21       2546 ( 15)         LD      HL,(FNRGNM)     ; Get old argument name
11DA-E3             2547 ( 16)         EX      (SP),HL ;       ; Save old , Get new
11DB-22 23 21       2548 ( 20)         LD      (FNRGNM),HL     ; Set new argument name
11DE-2A 27 21       2549 ( 15)         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
11E1-E5             2550 ( 11)         PUSH    HL              ; Save it
11E2-2A 25 21       2551 ( 15)         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
11E5-E5             2552 ( 11)         PUSH    HL              ; Save it
11E6-21 25 21       2553 (  9)         LD      HL,FNARG        ; HL = Value of argument
11E9-D5             2554 ( 11)         PUSH    DE              ; Save FN code string address
11EA-CD FC 17       2555 ( 16)         CALL    FPTHL           ; Move FPREG to argument
11ED-E1             2556 (  9)         POP     HL              ; Get FN code string address
11EE-CD C2 0D       2557 ( 16)         CALL    GETNUM          ; Get value from function
11F1-2B             2558 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
11F2-CD 55 09       2559 ( 16)         CALL    GETCHR          ; Get next character
11F5-C2 FD 04       2560 ( 6+)         JP      NZ,SNERR        ; Bad character in FN - Error
11F8-E1             2561 (  9)         POP     HL              ; Get MSB,EXP of old arg
11F9-22 25 21       2562 ( 20)         LD      (FNARG),HL      ; Restore it
11FC-E1             2563 (  9)         POP     HL              ; Get LSB,NLSB of old arg
11FD-22 27 21       2564 ( 20)         LD      (FNARG+2),HL    ; Restore it
1200-E1             2565 (  9)         POP     HL              ; Get name of old arg
1201-22 23 21       2566 ( 20)         LD      (FNRGNM),HL     ; Restore it
1204-E1             2567 (  9)         POP     HL              ; Restore code string address
1205-C9             2568 (  9)         RET
1206-               2569
1206-E5             2570 ( 11) IDTEST: PUSH    HL              ; Save code string address
1207-2A A1 20       2571 ( 15)         LD      HL,(LINEAT)     ; Get current line number
120A-23             2572 (  4)         INC     HL              ; -1 means direct statement
120B-7C             2573 (  4)         LD      A,H
120C-B5             2574 (  4)         OR      L
120D-E1             2575 (  9)         POP     HL              ; Restore code string address
120E-C0             2576 ( 5+)         RET     NZ              ; Return if in program
120F-1E 16          2577 (  6)         LD      E,ID            ; ?ID Error
1211-C3 11 05       2578 (  9)         JP      ERROR
1214-               2579
1214-CD CB 07       2580 ( 16) CHEKFN: CALL    CHKSYN          ; Make sure FN follows
1217-A7             2581               .DB      ZFN             ; "FN" token
1218-3E 80          2582 (  6)         LD      A,80H
121A-32 10 21       2583 ( 13)         LD      (FORFLG),A      ; Flag FN name to find
121D-B6             2584 (  6)         OR      (HL)            ; FN name has bit 7 set
121E-47             2585 (  4)         LD      B,A             ; in first byte of name
121F-CD BD 0F       2586 ( 16)         CALL    GTFNAM          ; Get FN name
1222-C3 C5 0D       2587 (  9)         JP      TSTNUM          ; Make sure numeric function
1225-               2588
1225-CD C5 0D       2589 ( 16) STR:    CALL    TSTNUM          ; Make sure it's a number
1228-CD 49 19       2590 ( 16)         CALL    NUMASC          ; Turn number into text
122B-CD 59 12       2591 ( 16) STR1:   CALL    CRTST           ; Create string entry for it
122E-CD DE 13       2592 ( 16)         CALL    GSTRCU          ; Current string to pool
1231-01 39 14       2593 (  9)         LD      BC,TOPOOL       ; Save in string pool
1234-C5             2594 ( 11)         PUSH    BC              ; Save address on stack
1235-               2595
1235-7E             2596 (  6) SAVSTR: LD      A,(HL)          ; Get string length
1236-23             2597 (  4)         INC     HL
1237-23             2598 (  4)         INC     HL
1238-E5             2599 ( 11)         PUSH    HL              ; Save pointer to string
1239-CD B4 12       2600 ( 16)         CALL    TESTR           ; See if enough string space
123C-E1             2601 (  9)         POP     HL              ; Restore pointer to string
123D-4E             2602 (  6)         LD      C,(HL)          ; Get LSB of address
123E-23             2603 (  4)         INC     HL
123F-46             2604 (  6)         LD      B,(HL)          ; Get MSB of address
1240-CD 4D 12       2605 ( 16)         CALL    CRTMST          ; Create string entry
1243-E5             2606 ( 11)         PUSH    HL              ; Save pointer to MSB of addr
1244-6F             2607 (  4)         LD      L,A             ; Length of string
1245-CD D1 13       2608 ( 16)         CALL    TOSTRA          ; Move to string area
1248-D1             2609 (  9)         POP     DE              ; Restore pointer to MSB
1249-C9             2610 (  9)         RET
124A-               2611
124A-CD B4 12       2612 ( 16) MKTMST: CALL    TESTR           ; See if enough string space
124D-21 04 21       2613 (  9) CRTMST: LD      HL,TMPSTR       ; Temporary string
1250-E5             2614 ( 11)         PUSH    HL              ; Save it
1251-77             2615 (  7)         LD      (HL),A          ; Save length of string
1252-23             2616 (  4)         INC     HL
1253-23             2617 (  4) SVSTAD: INC     HL
1254-73             2618 (  7)         LD      (HL),E          ; Save LSB of address
1255-23             2619 (  4)         INC     HL
1256-72             2620 (  7)         LD      (HL),D          ; Save MSB of address
1257-E1             2621 (  9)         POP     HL              ; Restore pointer
1258-C9             2622 (  9)         RET
1259-               2623
1259-2B             2624 (  4) CRTST:  DEC     HL              ; DEC - INCed after
125A-06 22          2625 (  6) QTSTR:  LD      B,'"'           ; Terminating quote
125C-50             2626 (  4)         LD      D,B             ; Quote to D
125D-E5             2627 ( 11) DTSTR:  PUSH    HL              ; Save start
125E-0E FF          2628 (  6)         LD      C,-1            ; Set counter to -1
1260-23             2629 (  4) QTSTLP: INC     HL              ; Move on
1261-7E             2630 (  6)         LD      A,(HL)          ; Get byte
1262-0C             2631 (  4)         INC     C               ; Count bytes
1263-B7             2632 (  4)         OR      A               ; End of line?
1264-CA 6F 12       2633 ( 6+)         JP      Z,CRTSTE        ; Yes - Create string entry
1267-BA             2634 (  4)         CP      D               ; Terminator D found?
1268-CA 6F 12       2635 ( 6+)         JP      Z,CRTSTE        ; Yes - Create string entry
126B-B8             2636 (  4)         CP      B               ; Terminator B found?
126C-C2 60 12       2637 ( 6+)         JP      NZ,QTSTLP       ; No - Keep looking
126F-FE 22          2638 (  6) CRTSTE: CP      '"'             ; End with '"'?
1271-CC 55 09       2639 ( 6+)         CALL    Z,GETCHR        ; Yes - Get next character
1274-E3             2640 ( 16)         EX      (SP),HL         ; Starting quote
1275-23             2641 (  4)         INC     HL              ; First byte of string
1276-EB             2642 (  3)         EX      DE,HL           ; To DE
1277-79             2643 (  4)         LD      A,C             ; Get length
1278-CD 4D 12       2644 ( 16)         CALL    CRTMST          ; Create string entry
127B-11 04 21       2645 (  9) TSTOPL: LD      DE,TMPSTR       ; Temporary string
127E-2A F6 20       2646 ( 15)         LD      HL,(TMSTPT)     ; Temporary string pool pointer
1281-22 29 21       2647 ( 20)         LD      (FPREG),HL      ; Save address of string ptr
1284-3E 01          2648 (  6)         LD      A,1
1286-32 F2 20       2649 ( 13)         LD      (TYPE),A        ; Set type to string
1289-CD FF 17       2650 ( 16)         CALL    DETHL4          ; Move string to pool
128C-CD C5 07       2651 ( 16)         CALL    CPDEHL          ; Out of string pool?
128F-22 F6 20       2652 ( 20)         LD      (TMSTPT),HL     ; Save new pointer
1292-E1             2653 (  9)         POP     HL              ; Restore code string address
1293-7E             2654 (  6)         LD      A,(HL)          ; Get next code byte
1294-C0             2655 ( 5+)         RET     NZ              ; Return if pool OK
1295-1E 1E          2656 (  6)         LD      E,ST            ; ?ST Error
1297-C3 11 05       2657 (  9)         JP      ERROR           ; String pool overflow
129A-               2658
129A-23             2659 (  4) PRNUMS: INC     HL              ; Skip leading space
129B-CD 59 12       2660 ( 16) PRS:    CALL    CRTST           ; Create string entry for it
129E-CD DE 13       2661 ( 16) PRS1:   CALL    GSTRCU          ; Current string to pool
12A1-CD F3 17       2662 ( 16)         CALL    LOADFP          ; Move string block to BCDE
12A4-1C             2663 (  4)         INC     E               ; Length + 1
12A5-1D             2664 (  4) PRSLP:  DEC     E               ; Count characters
12A6-C8             2665 ( 5+)         RET     Z               ; End of string
12A7-0A             2666 (  6)         LD      A,(BC)          ; Get byte to output
12A8-CD D6 07       2667 ( 16)         CALL    OUTC            ; Output character in A
12AB-FE 0D          2668 (  6)         CP      CR              ; Return?
12AD-CC 07 0C       2669 ( 6+)         CALL    Z,DONULL        ; Yes - Do nulls
12B0-03             2670 (  4)         INC     BC              ; Next byte in string
12B1-C3 A5 12       2671 (  9)         JP      PRSLP           ; More characters to output
12B4-               2672
12B4-B7             2673 (  4) TESTR:  OR      A               ; Test if enough room
12B5-0E             2674               .DB      0EH             ; No garbage collection done
12B6-F1             2675 (  9) GRBDON: POP     AF              ; Garbage collection done
12B7-F5             2676 ( 11)         PUSH    AF              ; Save status
12B8-2A 9F 20       2677 ( 15)         LD      HL,(STRSPC)     ; Bottom of string space in use
12BB-EB             2678 (  3)         EX      DE,HL           ; To DE
12BC-2A 08 21       2679 ( 15)         LD      HL,(STRBOT)     ; Bottom of string area
12BF-2F             2680 (  3)         CPL                     ; Negate length (Top down)
12C0-4F             2681 (  4)         LD      C,A             ; -Length to BC
12C1-06 FF          2682 (  6)         LD      B,-1            ; BC = -ve length of string
12C3-09             2683 (  7)         ADD     HL,BC           ; Add to bottom of space in use
12C4-23             2684 (  4)         INC     HL              ; Plus one for 2's complement
12C5-CD C5 07       2685 ( 16)         CALL    CPDEHL          ; Below string RAM area?
12C8-DA D2 12       2686 ( 6+)         JP      C,TESTOS        ; Tidy up if not done else err
12CB-22 08 21       2687 ( 20)         LD      (STRBOT),HL     ; Save new bottom of area
12CE-23             2688 (  4)         INC     HL              ; Point to first byte of string
12CF-EB             2689 (  3)         EX      DE,HL           ; Address to DE
12D0-F1             2690 (  9) POPAF:  POP     AF              ; Throw away status push
12D1-C9             2691 (  9)         RET
12D2-               2692
12D2-F1             2693 (  9) TESTOS: POP     AF              ; Garbage collect been done?
12D3-1E 1A          2694 (  6)         LD      E,OS            ; ?OS Error
12D5-CA 11 05       2695 ( 6+)         JP      Z,ERROR         ; Yes - Not enough string apace
12D8-BF             2696 (  4)         CP      A               ; Flag garbage collect done
12D9-F5             2697 ( 11)         PUSH    AF              ; Save status
12DA-01 B6 12       2698 (  9)         LD      BC,GRBDON       ; Garbage collection done
12DD-C5             2699 ( 11)         PUSH    BC              ; Save for RETurn
12DE-2A F4 20       2700 ( 15) GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
12E1-22 08 21       2701 ( 20) GARBLP: LD      (STRBOT),HL     ; Reset string pointer
12E4-21 00 00       2702 (  9)         LD      HL,0
12E7-E5             2703 ( 11)         PUSH    HL              ; Flag no string found
12E8-2A 9F 20       2704 ( 15)         LD      HL,(STRSPC)     ; Get bottom of string space
12EB-E5             2705 ( 11)         PUSH    HL              ; Save bottom of string space
12EC-21 F8 20       2706 (  9)         LD      HL,TMSTPL       ; Temporary string pool
12EF-EB             2707 (  3) GRBLP:  EX      DE,HL
12F0-2A F6 20       2708 ( 15)         LD      HL,(TMSTPT)     ; Temporary string pool pointer
12F3-EB             2709 (  3)         EX      DE,HL
12F4-CD C5 07       2710 ( 16)         CALL    CPDEHL          ; Temporary string pool done?
12F7-01 EF 12       2711 (  9)         LD      BC,GRBLP        ; Loop until string pool done
12FA-C2 43 13       2712 ( 6+)         JP      NZ,STPOOL       ; No - See if in string area
12FD-2A 1B 21       2713 ( 15)         LD      HL,(PROGND)     ; Start of simple variables
1300-EB             2714 (  3) SMPVAR: EX      DE,HL
1301-2A 1D 21       2715 ( 15)         LD      HL,(VAREND)     ; End of simple variables
1304-EB             2716 (  3)         EX      DE,HL
1305-CD C5 07       2717 ( 16)         CALL    CPDEHL          ; All simple strings done?
1308-CA 16 13       2718 ( 6+)         JP      Z,ARRLP         ; Yes - Do string arrays
130B-7E             2719 (  6)         LD      A,(HL)          ; Get type of variable
130C-23             2720 (  4)         INC     HL
130D-23             2721 (  4)         INC     HL
130E-B7             2722 (  4)         OR      A               ; "S" flag set if string
130F-CD 46 13       2723 ( 16)         CALL    STRADD          ; See if string in string area
1312-C3 00 13       2724 (  9)         JP      SMPVAR          ; Loop until simple ones done
1315-               2725
1315-C1             2726 (  9) GNXARY: POP     BC              ; Scrap address of this array
1316-EB             2727 (  3) ARRLP:  EX      DE,HL
1317-2A 1F 21       2728 ( 15)         LD      HL,(ARREND)     ; End of string arrays
131A-EB             2729 (  3)         EX      DE,HL
131B-CD C5 07       2730 ( 16)         CALL    CPDEHL          ; All string arrays done?
131E-CA 6C 13       2731 ( 6+)         JP      Z,SCNEND        ; Yes - Move string if found
1321-CD F3 17       2732 ( 16)         CALL    LOADFP          ; Get array name to BCDE
1324-7B             2733 (  4)         LD      A,E             ; Get type of array
1325-E5             2734 ( 11)         PUSH    HL              ; Save address of num of dim'ns
1326-09             2735 (  7)         ADD     HL,BC           ; Start of next array
1327-B7             2736 (  4)         OR      A               ; Test type of array
1328-F2 15 13       2737 ( 6+)         JP      P,GNXARY        ; Numeric array - Ignore it
132B-22 0A 21       2738 ( 20)         LD      (CUROPR),HL     ; Save address of next array
132E-E1             2739 (  9)         POP     HL              ; Get address of num of dim'ns
132F-4E             2740 (  6)         LD      C,(HL)          ; BC = Number of dimensions
1330-06 00          2741 (  6)         LD      B,0
1332-09             2742 (  7)         ADD     HL,BC           ; Two bytes per dimension size
1333-09             2743 (  7)         ADD     HL,BC
1334-23             2744 (  4)         INC     HL              ; Plus one for number of dim'ns
1335-EB             2745 (  3) GRBARY: EX      DE,HL
1336-2A 0A 21       2746 ( 15)         LD      HL,(CUROPR)     ; Get address of next array
1339-EB             2747 (  3)         EX      DE,HL
133A-CD C5 07       2748 ( 16)         CALL    CPDEHL          ; Is this array finished?
133D-CA 16 13       2749 ( 6+)         JP      Z,ARRLP         ; Yes - Get next one
1340-01 35 13       2750 (  9)         LD      BC,GRBARY       ; Loop until array all done
1343-C5             2751 ( 11) STPOOL: PUSH    BC              ; Save return address
1344-F6 80          2752 (  6)         OR      80H             ; Flag string type
1346-7E             2753 (  6) STRADD: LD      A,(HL)          ; Get string length
1347-23             2754 (  4)         INC     HL
1348-23             2755 (  4)         INC     HL
1349-5E             2756 (  6)         LD      E,(HL)          ; Get LSB of string address
134A-23             2757 (  4)         INC     HL
134B-56             2758 (  6)         LD      D,(HL)          ; Get MSB of string address
134C-23             2759 (  4)         INC     HL
134D-F0             2760 ( 5+)         RET     P               ; Not a string - Return
134E-B7             2761 (  4)         OR      A               ; Set flags on string length
134F-C8             2762 ( 5+)         RET     Z               ; Null string - Return
1350-44             2763 (  4)         LD      B,H             ; Save variable pointer
1351-4D             2764 (  4)         LD      C,L
1352-2A 08 21       2765 ( 15)         LD      HL,(STRBOT)     ; Bottom of new area
1355-CD C5 07       2766 ( 16)         CALL    CPDEHL          ; String been done?
1358-60             2767 (  4)         LD      H,B             ; Restore variable pointer
1359-69             2768 (  4)         LD      L,C
135A-D8             2769 ( 5+)         RET     C               ; String done - Ignore
135B-E1             2770 (  9)         POP     HL              ; Return address
135C-E3             2771 ( 16)         EX      (SP),HL         ; Lowest available string area
135D-CD C5 07       2772 ( 16)         CALL    CPDEHL          ; String within string area?
1360-E3             2773 ( 16)         EX      (SP),HL         ; Lowest available string area
1361-E5             2774 ( 11)         PUSH    HL              ; Re-save return address
1362-60             2775 (  4)         LD      H,B             ; Restore variable pointer
1363-69             2776 (  4)         LD      L,C
1364-D0             2777 ( 5+)         RET     NC              ; Outside string area - Ignore
1365-C1             2778 (  9)         POP     BC              ; Get return , Throw 2 away
1366-F1             2779 (  9)         POP     AF              ;
1367-F1             2780 (  9)         POP     AF              ;
1368-E5             2781 ( 11)         PUSH    HL              ; Save variable pointer
1369-D5             2782 ( 11)         PUSH    DE              ; Save address of current
136A-C5             2783 ( 11)         PUSH    BC              ; Put back return address
136B-C9             2784 (  9)         RET                     ; Go to it
136C-               2785
136C-D1             2786 (  9) SCNEND: POP     DE              ; Addresses of strings
136D-E1             2787 (  9)         POP     HL              ;
136E-7D             2788 (  4)         LD      A,L             ; HL = 0 if no more to do
136F-B4             2789 (  4)         OR      H
1370-C8             2790 ( 5+)         RET     Z               ; No more to do - Return
1371-2B             2791 (  4)         DEC     HL
1372-46             2792 (  6)         LD      B,(HL)          ; MSB of address of string
1373-2B             2793 (  4)         DEC     HL
1374-4E             2794 (  6)         LD      C,(HL)          ; LSB of address of string
1375-E5             2795 ( 11)         PUSH    HL              ; Save variable address
1376-2B             2796 (  4)         DEC     HL
1377-2B             2797 (  4)         DEC     HL
1378-6E             2798 (  6)         LD      L,(HL)          ; HL = Length of string
1379-26 00          2799 (  6)         LD      H,0
137B-09             2800 (  7)         ADD     HL,BC           ; Address of end of string+1
137C-50             2801 (  4)         LD      D,B             ; String address to DE
137D-59             2802 (  4)         LD      E,C
137E-2B             2803 (  4)         DEC     HL              ; Last byte in string
137F-44             2804 (  4)         LD      B,H             ; Address to BC
1380-4D             2805 (  4)         LD      C,L
1381-2A 08 21       2806 ( 15)         LD      HL,(STRBOT)     ; Current bottom of string area
1384-CD CC 04       2807 ( 16)         CALL    MOVSTR          ; Move string to new address
1387-E1             2808 (  9)         POP     HL              ; Restore variable address
1388-71             2809 (  7)         LD      (HL),C          ; Save new LSB of address
1389-23             2810 (  4)         INC     HL
138A-70             2811 (  7)         LD      (HL),B          ; Save new MSB of address
138B-69             2812 (  4)         LD      L,C             ; Next string area+1 to HL
138C-60             2813 (  4)         LD      H,B
138D-2B             2814 (  4)         DEC     HL              ; Next string area address
138E-C3 E1 12       2815 (  9)         JP      GARBLP          ; Look for more strings
1391-               2816
1391-C5             2817 ( 11) CONCAT: PUSH    BC              ; Save prec' opr & code string
1392-E5             2818 ( 11)         PUSH    HL              ;
1393-2A 29 21       2819 ( 15)         LD      HL,(FPREG)      ; Get first string
1396-E3             2820 ( 16)         EX      (SP),HL         ; Save first string
1397-CD 4B 0E       2821 ( 16)         CALL    OPRND           ; Get second string
139A-E3             2822 ( 16)         EX      (SP),HL         ; Restore first string
139B-CD C6 0D       2823 ( 16)         CALL    TSTSTR          ; Make sure it's a string
139E-7E             2824 (  6)         LD      A,(HL)          ; Get length of second string
139F-E5             2825 ( 11)         PUSH    HL              ; Save first string
13A0-2A 29 21       2826 ( 15)         LD      HL,(FPREG)      ; Get second string
13A3-E5             2827 ( 11)         PUSH    HL              ; Save second string
13A4-86             2828 (  6)         ADD     A,(HL)          ; Add length of second string
13A5-1E 1C          2829 (  6)         LD      E,LS            ; ?LS Error
13A7-DA 11 05       2830 ( 6+)         JP      C,ERROR         ; String too long - Error
13AA-CD 4A 12       2831 ( 16)         CALL    MKTMST          ; Make temporary string
13AD-D1             2832 (  9)         POP     DE              ; Get second string to DE
13AE-CD E2 13       2833 ( 16)         CALL    GSTRDE          ; Move to string pool if needed
13B1-E3             2834 ( 16)         EX      (SP),HL         ; Get first string
13B2-CD E1 13       2835 ( 16)         CALL    GSTRHL          ; Move to string pool if needed
13B5-E5             2836 ( 11)         PUSH    HL              ; Save first string
13B6-2A 06 21       2837 ( 15)         LD      HL,(TMPSTR+2)   ; Temporary string address
13B9-EB             2838 (  3)         EX      DE,HL           ; To DE
13BA-CD C8 13       2839 ( 16)         CALL    SSTSA           ; First string to string area
13BD-CD C8 13       2840 ( 16)         CALL    SSTSA           ; Second string to string area
13C0-21 E0 0D       2841 (  9)         LD      HL,EVAL2        ; Return to evaluation loop
13C3-E3             2842 ( 16)         EX      (SP),HL         ; Save return,get code string
13C4-E5             2843 ( 11)         PUSH    HL              ; Save code string address
13C5-C3 7B 12       2844 (  9)         JP      TSTOPL          ; To temporary string to pool
13C8-               2845
13C8-E1             2846 (  9) SSTSA:  POP     HL              ; Return address
13C9-E3             2847 ( 16)         EX      (SP),HL         ; Get string block,save return
13CA-7E             2848 (  6)         LD      A,(HL)          ; Get length of string
13CB-23             2849 (  4)         INC     HL
13CC-23             2850 (  4)         INC     HL
13CD-4E             2851 (  6)         LD      C,(HL)          ; Get LSB of string address
13CE-23             2852 (  4)         INC     HL
13CF-46             2853 (  6)         LD      B,(HL)          ; Get MSB of string address
13D0-6F             2854 (  4)         LD      L,A             ; Length to L
13D1-2C             2855 (  4) TOSTRA: INC     L               ; INC - DECed after
13D2-2D             2856 (  4) TSALP:  DEC     L               ; Count bytes moved
13D3-C8             2857 ( 5+)         RET     Z               ; End of string - Return
13D4-0A             2858 (  6)         LD      A,(BC)          ; Get source
13D5-12             2859 (  7)         LD      (DE),A          ; Save destination
13D6-03             2860 (  4)         INC     BC              ; Next source
13D7-13             2861 (  4)         INC     DE              ; Next destination
13D8-C3 D2 13       2862 (  9)         JP      TSALP           ; Loop until string moved
13DB-               2863
13DB-CD C6 0D       2864 ( 16) GETSTR: CALL    TSTSTR          ; Make sure it's a string
13DE-2A 29 21       2865 ( 15) GSTRCU: LD      HL,(FPREG)      ; Get current string
13E1-EB             2866 (  3) GSTRHL: EX      DE,HL           ; Save DE
13E2-CD FC 13       2867 ( 16) GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
13E5-EB             2868 (  3)         EX      DE,HL           ; Restore DE
13E6-C0             2869 ( 5+)         RET     NZ              ; No - Return
13E7-D5             2870 ( 11)         PUSH    DE              ; Save string
13E8-50             2871 (  4)         LD      D,B             ; String block address to DE
13E9-59             2872 (  4)         LD      E,C
13EA-1B             2873 (  4)         DEC     DE              ; Point to length
13EB-4E             2874 (  6)         LD      C,(HL)          ; Get string length
13EC-2A 08 21       2875 ( 15)         LD      HL,(STRBOT)     ; Current bottom of string area
13EF-CD C5 07       2876 ( 16)         CALL    CPDEHL          ; Last one in string area?
13F2-C2 FA 13       2877 ( 6+)         JP      NZ,POPHL        ; No - Return
13F5-47             2878 (  4)         LD      B,A             ; Clear B (A=0)
13F6-09             2879 (  7)         ADD     HL,BC           ; Remove string from str' area
13F7-22 08 21       2880 ( 20)         LD      (STRBOT),HL     ; Save new bottom of str' area
13FA-E1             2881 (  9) POPHL:  POP     HL              ; Restore string
13FB-C9             2882 (  9)         RET
13FC-               2883
13FC-2A F6 20       2884 ( 15) BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
13FF-2B             2885 (  4)         DEC     HL              ; Back
1400-46             2886 (  6)         LD      B,(HL)          ; Get MSB of address
1401-2B             2887 (  4)         DEC     HL              ; Back
1402-4E             2888 (  6)         LD      C,(HL)          ; Get LSB of address
1403-2B             2889 (  4)         DEC     HL              ; Back
1404-2B             2890 (  4)         DEC     HL              ; Back
1405-CD C5 07       2891 ( 16)         CALL    CPDEHL          ; String last in string pool?
1408-C0             2892 ( 5+)         RET     NZ              ; Yes - Leave it
1409-22 F6 20       2893 ( 20)         LD      (TMSTPT),HL     ; Save new string pool top
140C-C9             2894 (  9)         RET
140D-               2895
140D-01 8C 11       2896 (  9) LEN:    LD      BC,PASSA        ; To return integer A
1410-C5             2897 ( 11)         PUSH    BC              ; Save address
1411-CD DB 13       2898 ( 16) GETLEN: CALL    GETSTR          ; Get string and its length
1414-AF             2899 (  4)         XOR     A
1415-57             2900 (  4)         LD      D,A             ; Clear D
1416-32 F2 20       2901 ( 13)         LD      (TYPE),A        ; Set type to numeric
1419-7E             2902 (  6)         LD      A,(HL)          ; Get length of string
141A-B7             2903 (  4)         OR      A               ; Set status flags
141B-C9             2904 (  9)         RET
141C-               2905
141C-01 8C 11       2906 (  9) ASC:    LD      BC,PASSA        ; To return integer A
141F-C5             2907 ( 11)         PUSH    BC              ; Save address
1420-CD 11 14       2908 ( 16) GTFLNM: CALL    GETLEN          ; Get length of string
1423-CA 1C 0A       2909 ( 6+)         JP      Z,FCERR         ; Null string - Error
1426-23             2910 (  4)         INC     HL
1427-23             2911 (  4)         INC     HL
1428-5E             2912 (  6)         LD      E,(HL)          ; Get LSB of address
1429-23             2913 (  4)         INC     HL
142A-56             2914 (  6)         LD      D,(HL)          ; Get MSB of address
142B-1A             2915 (  6)         LD      A,(DE)          ; Get first byte of string
142C-C9             2916 (  9)         RET
142D-               2917
142D-3E 01          2918 (  6) CHR:    LD      A,1             ; One character string
142F-CD 4A 12       2919 ( 16)         CALL    MKTMST          ; Make a temporary string
1432-CD 26 15       2920 ( 16)         CALL    MAKINT          ; Make it integer A
1435-2A 06 21       2921 ( 15)         LD      HL,(TMPSTR+2)   ; Get address of string
1438-73             2922 (  7)         LD      (HL),E          ; Save character
1439-C1             2923 (  9) TOPOOL: POP     BC              ; Clean up stack
143A-C3 7B 12       2924 (  9)         JP      TSTOPL          ; Temporary string to pool
143D-               2925
143D-CD D6 14       2926 ( 16) LEFT:   CALL    LFRGNM          ; Get number and ending ")"
1440-AF             2927 (  4)         XOR     A               ; Start at first byte in string
1441-E3             2928 ( 16) RIGHT1: EX      (SP),HL         ; Save code string,Get string
1442-4F             2929 (  4)         LD      C,A             ; Starting position in string
1443-E5             2930 ( 11) MID1:   PUSH    HL              ; Save string block address
1444-7E             2931 (  6)         LD      A,(HL)          ; Get length of string
1445-B8             2932 (  4)         CP      B               ; Compare with number given
1446-DA 4B 14       2933 ( 6+)         JP      C,ALLFOL        ; All following bytes required
1449-78             2934 (  4)         LD      A,B             ; Get new length
144A-11             2935               .DB      11H             ; Skip "LD C,0"
144B-0E 00          2936 (  6) ALLFOL: LD      C,0             ; First byte of string
144D-C5             2937 ( 11)         PUSH    BC              ; Save position in string
144E-CD B4 12       2938 ( 16)         CALL    TESTR           ; See if enough string space
1451-C1             2939 (  9)         POP     BC              ; Get position in string
1452-E1             2940 (  9)         POP     HL              ; Restore string block address
1453-E5             2941 ( 11)         PUSH    HL              ; And re-save it
1454-23             2942 (  4)         INC     HL
1455-23             2943 (  4)         INC     HL
1456-46             2944 (  6)         LD      B,(HL)          ; Get LSB of address
1457-23             2945 (  4)         INC     HL
1458-66             2946 (  6)         LD      H,(HL)          ; Get MSB of address
1459-68             2947 (  4)         LD      L,B             ; HL = address of string
145A-06 00          2948 (  6)         LD      B,0             ; BC = starting address
145C-09             2949 (  7)         ADD     HL,BC           ; Point to that byte
145D-44             2950 (  4)         LD      B,H             ; BC = source string
145E-4D             2951 (  4)         LD      C,L
145F-CD 4D 12       2952 ( 16)         CALL    CRTMST          ; Create a string entry
1462-6F             2953 (  4)         LD      L,A             ; Length of new string
1463-CD D1 13       2954 ( 16)         CALL    TOSTRA          ; Move string to string area
1466-D1             2955 (  9)         POP     DE              ; Clear stack
1467-CD E2 13       2956 ( 16)         CALL    GSTRDE          ; Move to string pool if needed
146A-C3 7B 12       2957 (  9)         JP      TSTOPL          ; Temporary string to pool
146D-               2958
146D-CD D6 14       2959 ( 16) RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
1470-D1             2960 (  9)         POP     DE              ; Get string length
1471-D5             2961 ( 11)         PUSH    DE              ; And re-save
1472-1A             2962 (  6)         LD      A,(DE)          ; Get length
1473-90             2963 (  4)         SUB     B               ; Move back N bytes
1474-C3 41 14       2964 (  9)         JP      RIGHT1          ; Go and get sub-string
1477-               2965
1477-EB             2966 (  3) MID:    EX      DE,HL           ; Get code string address
1478-7E             2967 (  6)         LD      A,(HL)          ; Get next byte ',' or ")"
1479-CD DB 14       2968 ( 16)         CALL    MIDNUM          ; Get number supplied
147C-04             2969 (  4)         INC     B               ; Is it character zero?
147D-05             2970 (  4)         DEC     B
147E-CA 1C 0A       2971 ( 6+)         JP      Z,FCERR         ; Yes - Error
1481-C5             2972 ( 11)         PUSH    BC              ; Save starting position
1482-1E FF          2973 (  6)         LD      E,255           ; All of string
1484-FE 29          2974 (  6)         CP      ')'             ; Any length given?
1486-CA 90 14       2975 ( 6+)         JP      Z,RSTSTR        ; No - Rest of string
1489-CD CB 07       2976 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
148C-2C             2977               .DB      ','
148D-CD 23 15       2978 ( 16)         CALL    GETINT          ; Get integer 0-255
1490-CD CB 07       2979 ( 16) RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
1493-29             2980               .DB      ")"
1494-F1             2981 (  9)         POP     AF              ; Restore starting position
1495-E3             2982 ( 16)         EX      (SP),HL         ; Get string,8ave code string
1496-01 43 14       2983 (  9)         LD      BC,MID1         ; Continuation of MID$ routine
1499-C5             2984 ( 11)         PUSH    BC              ; Save for return
149A-3D             2985 (  4)         DEC     A               ; Starting position-1
149B-BE             2986 (  6)         CP      (HL)            ; Compare with length
149C-06 00          2987 (  6)         LD      B,0             ; Zero bytes length
149E-D0             2988 ( 5+)         RET     NC              ; Null string if start past end
149F-4F             2989 (  4)         LD      C,A             ; Save starting position-1
14A0-7E             2990 (  6)         LD      A,(HL)          ; Get length of string
14A1-91             2991 (  4)         SUB     C               ; Subtract start
14A2-BB             2992 (  4)         CP      E               ; Enough string for it?
14A3-47             2993 (  4)         LD      B,A             ; Save maximum length available
14A4-D8             2994 ( 5+)         RET     C               ; Truncate string if needed
14A5-43             2995 (  4)         LD      B,E             ; Set specified length
14A6-C9             2996 (  9)         RET                     ; Go and create string
14A7-               2997
14A7-CD 11 14       2998 ( 16) VAL:    CALL    GETLEN          ; Get length of string
14AA-CA C4 15       2999 ( 6+)         JP      Z,RESZER        ; Result zero
14AD-5F             3000 (  4)         LD      E,A             ; Save length
14AE-23             3001 (  4)         INC     HL
14AF-23             3002 (  4)         INC     HL
14B0-7E             3003 (  6)         LD      A,(HL)          ; Get LSB of address
14B1-23             3004 (  4)         INC     HL
14B2-66             3005 (  6)         LD      H,(HL)          ; Get MSB of address
14B3-6F             3006 (  4)         LD      L,A             ; HL = String address
14B4-E5             3007 ( 11)         PUSH    HL              ; Save string address
14B5-19             3008 (  7)         ADD     HL,DE
14B6-46             3009 (  6)         LD      B,(HL)          ; Get end of string+1 byte
14B7-72             3010 (  7)         LD      (HL),D          ; Zero it to terminate
14B8-E3             3011 ( 16)         EX      (SP),HL         ; Save string end,get start
14B9-C5             3012 ( 11)         PUSH    BC              ; Save end+1 byte
14BA-7E             3013 (  6)         LD      A,(HL)          ; Get starting byte
14BB-FE 24          3014 (  6)     CP  '$'             ; Hex number indicated? [function added]
14BD-C2 C5 14       3015 ( 6+)     JP  NZ,VAL1
14C0-CD EF 1C       3016 ( 16)     CALL        HEXTFP          ; Convert Hex to FPREG
14C3-18 0D          3017 (  8)     JR  VAL3
14C5-FE 25          3018 (  6) VAL1:   CP      '%'             ; Binary number indicated? [function added]
14C7-C2 CF 14       3019 ( 6+)     JP  NZ,VAL2
14CA-CD 5F 1D       3020 ( 16)     CALL        BINTFP          ; Convert Bin to FPREG
14CD-18 03          3021 (  8)     JR  VAL3
14CF-CD AB 18       3022 ( 16) VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
14D2-C1             3023 (  9) VAL3:   POP     BC              ; Restore end+1 byte
14D3-E1             3024 (  9)         POP     HL              ; Restore end+1 address
14D4-70             3025 (  7)         LD      (HL),B          ; Put back original byte
14D5-C9             3026 (  9)         RET
14D6-               3027
14D6-EB             3028 (  3) LFRGNM: EX      DE,HL           ; Code string address to HL
14D7-CD CB 07       3029 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
14DA-29             3030               .DB      ")"
14DB-C1             3031 (  9) MIDNUM: POP     BC              ; Get return address
14DC-D1             3032 (  9)         POP     DE              ; Get number supplied
14DD-C5             3033 ( 11)         PUSH    BC              ; Re-save return address
14DE-43             3034 (  4)         LD      B,E             ; Number to B
14DF-C9             3035 (  9)         RET
14E0-               3036
14E0-CD 26 15       3037 ( 16) INP:    CALL    MAKINT          ; Make it integer A
14E3-32 84 20       3038 ( 13)         LD      (INPORT),A      ; Set input port
14E6-CD 83 20       3039 ( 16)         CALL    INPSUB          ; Get input from port
14E9-C3 8C 11       3040 (  9)         JP      PASSA           ; Return integer A
14EC-               3041
14EC-CD 10 15       3042 ( 16) POUT:   CALL    SETIO           ; Set up port number
14EF-C3 4B 20       3043 (  9)         JP      OUTSUB          ; Output data and return
14F2-               3044
14F2-CD 10 15       3045 ( 16) WAIT:   CALL    SETIO           ; Set up port number
14F5-F5             3046 ( 11)         PUSH    AF              ; Save AND mask
14F6-1E 00          3047 (  6)         LD      E,0             ; Assume zero if none given
14F8-2B             3048 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
14F9-CD 55 09       3049 ( 16)         CALL    GETCHR          ; Get next character
14FC-CA 06 15       3050 ( 6+)         JP      Z,NOXOR         ; No XOR byte given
14FF-CD CB 07       3051 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1502-2C             3052               .DB      ','
1503-CD 23 15       3053 ( 16)         CALL    GETINT          ; Get integer 0-255 to XOR with
1506-C1             3054 (  9) NOXOR:  POP     BC              ; Restore AND mask
1507-CD 83 20       3055 ( 16) WAITLP: CALL    INPSUB          ; Get input
150A-AB             3056 (  4)         XOR     E               ; Flip selected bits
150B-A0             3057 (  4)         AND     B               ; Result non-zero?
150C-CA 07 15       3058 ( 6+)         JP      Z,WAITLP        ; No = keep waiting
150F-C9             3059 (  9)         RET
1510-               3060
1510-CD 23 15       3061 ( 16) SETIO:  CALL    GETINT          ; Get integer 0-255
1513-32 84 20       3062 ( 13)         LD      (INPORT),A      ; Set input port
1516-32 4C 20       3063 ( 13)         LD      (OTPORT),A      ; Set output port
1519-CD CB 07       3064 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
151C-2C             3065               .DB      ','
151D-C3 23 15       3066 (  9)         JP      GETINT          ; Get integer 0-255 and return
1520-               3067
1520-CD 55 09       3068 ( 16) FNDNUM: CALL    GETCHR          ; Get next character
1523-CD C2 0D       3069 ( 16) GETINT: CALL    GETNUM          ; Get a number from 0 to 255
1526-CD 01 0A       3070 ( 16) MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
1529-7A             3071 (  4)         LD      A,D             ; Get MSB of number
152A-B7             3072 (  4)         OR      A               ; Zero?
152B-C2 1C 0A       3073 ( 6+)         JP      NZ,FCERR        ; No - Error
152E-2B             3074 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
152F-CD 55 09       3075 ( 16)         CALL    GETCHR          ; Get next character
1532-7B             3076 (  4)         LD      A,E             ; Get number to A
1533-C9             3077 (  9)         RET
1534-               3078
1534-CD 07 0A       3079 ( 16) PEEK:   CALL    DEINT           ; Get memory address
1537-1A             3080 (  6)         LD      A,(DE)          ; Get byte in memory
1538-C3 8C 11       3081 (  9)         JP      PASSA           ; Return integer A
153B-               3082
153B-CD C2 0D       3083 ( 16) POKE:   CALL    GETNUM          ; Get memory address
153E-CD 07 0A       3084 ( 16)         CALL    DEINT           ; Get integer -32768 to 3276
1541-D5             3085 ( 11)         PUSH    DE              ; Save memory address
1542-CD CB 07       3086 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1545-2C             3087               .DB      ','
1546-CD 23 15       3088 ( 16)         CALL    GETINT          ; Get integer 0-255
1549-D1             3089 (  9)         POP     DE              ; Restore memory address
154A-12             3090 (  7)         LD      (DE),A          ; Load it into memory
154B-C9             3091 (  9)         RET
154C-               3092
154C-21 22 1A       3093 (  9) ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
154F-CD F3 17       3094 ( 16) ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
1552-C3 5E 15       3095 (  9)         JP      FPADD           ; Add BCDE to FPREG
1555-               3096
1555-CD F3 17       3097 ( 16) SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
1558-21             3098               .DB      21H             ; Skip "POP BC" and "POP DE"
1559-C1             3099 (  9) PSUB:   POP     BC              ; Get FP number from stack
155A-D1             3100 (  9)         POP     DE
155B-CD CD 17       3101 ( 16) SUBCDE: CALL    INVSGN          ; Negate FPREG
155E-78             3102 (  4) FPADD:  LD      A,B             ; Get FP exponent
155F-B7             3103 (  4)         OR      A               ; Is number zero?
1560-C8             3104 ( 5+)         RET     Z               ; Yes - Nothing to add
1561-3A 2C 21       3105 ( 12)         LD      A,(FPEXP)       ; Get FPREG exponent
1564-B7             3106 (  4)         OR      A               ; Is this number zero?
1565-CA E5 17       3107 ( 6+)         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
1568-90             3108 (  4)         SUB     B               ; BCDE number larger?
1569-D2 78 15       3109 ( 6+)         JP      NC,NOSWAP       ; No - Don't swap them
156C-2F             3110 (  3)         CPL                     ; Two's complement
156D-3C             3111 (  4)         INC     A               ;  FP exponent
156E-EB             3112 (  3)         EX      DE,HL
156F-CD D5 17       3113 ( 16)         CALL    STAKFP          ; Put FPREG on stack
1572-EB             3114 (  3)         EX      DE,HL
1573-CD E5 17       3115 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
1576-C1             3116 (  9)         POP     BC              ; Restore number from stack
1577-D1             3117 (  9)         POP     DE
1578-FE 19          3118 (  6) NOSWAP: CP      24+1            ; Second number insignificant?
157A-D0             3119 ( 5+)         RET     NC              ; Yes - First number is result
157B-F5             3120 ( 11)         PUSH    AF              ; Save number of bits to scale
157C-CD 0A 18       3121 ( 16)         CALL    SIGNS           ; Set MSBs & sign of result
157F-67             3122 (  4)         LD      H,A             ; Save sign of result
1580-F1             3123 (  9)         POP     AF              ; Restore scaling factor
1581-CD 23 16       3124 ( 16)         CALL    SCALE           ; Scale BCDE to same exponent
1584-B4             3125 (  4)         OR      H               ; Result to be positive?
1585-21 29 21       3126 (  9)         LD      HL,FPREG        ; Point to FPREG
1588-F2 9E 15       3127 ( 6+)         JP      P,MINCDE        ; No - Subtract FPREG from CDE
158B-CD 03 16       3128 ( 16)         CALL    PLUCDE          ; Add FPREG to CDE
158E-D2 E4 15       3129 ( 6+)         JP      NC,RONDUP       ; No overflow - Round it up
1591-23             3130 (  4)         INC     HL              ; Point to exponent
1592-34             3131 ( 10)         INC     (HL)            ; Increment it
1593-CA 0C 05       3132 ( 6+)         JP      Z,OVERR         ; Number overflowed - Error
1596-2E 01          3133 (  6)         LD      L,1             ; 1 bit to shift right
1598-CD 39 16       3134 ( 16)         CALL    SHRT1           ; Shift result right
159B-C3 E4 15       3135 (  9)         JP      RONDUP          ; Round it up
159E-               3136
159E-AF             3137 (  4) MINCDE: XOR     A               ; Clear A and carry
159F-90             3138 (  4)         SUB     B               ; Negate exponent
15A0-47             3139 (  4)         LD      B,A             ; Re-save exponent
15A1-7E             3140 (  6)         LD      A,(HL)          ; Get LSB of FPREG
15A2-9B             3141 (  4)         SBC     A, E            ; Subtract LSB of BCDE
15A3-5F             3142 (  4)         LD      E,A             ; Save LSB of BCDE
15A4-23             3143 (  4)         INC     HL
15A5-7E             3144 (  6)         LD      A,(HL)          ; Get NMSB of FPREG
15A6-9A             3145 (  4)         SBC     A,D             ; Subtract NMSB of BCDE
15A7-57             3146 (  4)         LD      D,A             ; Save NMSB of BCDE
15A8-23             3147 (  4)         INC     HL
15A9-7E             3148 (  6)         LD      A,(HL)          ; Get MSB of FPREG
15AA-99             3149 (  4)         SBC     A,C             ; Subtract MSB of BCDE
15AB-4F             3150 (  4)         LD      C,A             ; Save MSB of BCDE
15AC-DC 0F 16       3151 ( 6+) CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
15AF-               3152
15AF-68             3153 (  4) BNORM:  LD      L,B             ; L = Exponent
15B0-63             3154 (  4)         LD      H,E             ; H = LSB
15B1-AF             3155 (  4)         XOR     A
15B2-47             3156 (  4) BNRMLP: LD      B,A             ; Save bit count
15B3-79             3157 (  4)         LD      A,C             ; Get MSB
15B4-B7             3158 (  4)         OR      A               ; Is it zero?
15B5-C2 D1 15       3159 ( 6+)         JP      NZ,PNORM        ; No - Do it bit at a time
15B8-4A             3160 (  4)         LD      C,D             ; MSB = NMSB
15B9-54             3161 (  4)         LD      D,H             ; NMSB= LSB
15BA-65             3162 (  4)         LD      H,L             ; LSB = VLSB
15BB-6F             3163 (  4)         LD      L,A             ; VLSB= 0
15BC-78             3164 (  4)         LD      A,B             ; Get exponent
15BD-D6 08          3165 (  6)         SUB     8               ; Count 8 bits
15BF-FE E0          3166 (  6)         CP      -24-8           ; Was number zero?
15C1-C2 B2 15       3167 ( 6+)         JP      NZ,BNRMLP       ; No - Keep normalising
15C4-AF             3168 (  4) RESZER: XOR     A               ; Result is zero
15C5-32 2C 21       3169 ( 13) SAVEXP: LD      (FPEXP),A       ; Save result as zero
15C8-C9             3170 (  9)         RET
15C9-               3171
15C9-05             3172 (  4) NORMAL: DEC     B               ; Count bits
15CA-29             3173 (  7)         ADD     HL,HL           ; Shift HL left
15CB-7A             3174 (  4)         LD      A,D             ; Get NMSB
15CC-17             3175 (  3)         RLA                     ; Shift left with last bit
15CD-57             3176 (  4)         LD      D,A             ; Save NMSB
15CE-79             3177 (  4)         LD      A,C             ; Get MSB
15CF-8F             3178 (  4)         ADC     A,A             ; Shift left with last bit
15D0-4F             3179 (  4)         LD      C,A             ; Save MSB
15D1-F2 C9 15       3180 ( 6+) PNORM:  JP      P,NORMAL        ; Not done - Keep going
15D4-78             3181 (  4)         LD      A,B             ; Number of bits shifted
15D5-5C             3182 (  4)         LD      E,H             ; Save HL in EB
15D6-45             3183 (  4)         LD      B,L
15D7-B7             3184 (  4)         OR      A               ; Any shifting done?
15D8-CA E4 15       3185 ( 6+)         JP      Z,RONDUP        ; No - Round it up
15DB-21 2C 21       3186 (  9)         LD      HL,FPEXP        ; Point to exponent
15DE-86             3187 (  6)         ADD     A,(HL)          ; Add shifted bits
15DF-77             3188 (  7)         LD      (HL),A          ; Re-save exponent
15E0-D2 C4 15       3189 ( 6+)         JP      NC,RESZER       ; Underflow - Result is zero
15E3-C8             3190 ( 5+)         RET     Z               ; Result is zero
15E4-78             3191 (  4) RONDUP: LD      A,B             ; Get VLSB of number
15E5-21 2C 21       3192 (  9) RONDB:  LD      HL,FPEXP        ; Point to exponent
15E8-B7             3193 (  4)         OR      A               ; Any rounding?
15E9-FC F6 15       3194 ( 6+)         CALL    M,FPROND        ; Yes - Round number up
15EC-46             3195 (  6)         LD      B,(HL)          ; B = Exponent
15ED-23             3196 (  4)         INC     HL
15EE-7E             3197 (  6)         LD      A,(HL)          ; Get sign of result
15EF-E6 80          3198 (  6)         AND     10000000B       ; Only bit 7 needed
15F1-A9             3199 (  4)         XOR     C               ; Set correct sign
15F2-4F             3200 (  4)         LD      C,A             ; Save correct sign in number
15F3-C3 E5 17       3201 (  9)         JP      FPBCDE          ; Move BCDE to FPREG
15F6-               3202
15F6-1C             3203 (  4) FPROND: INC     E               ; Round LSB
15F7-C0             3204 ( 5+)         RET     NZ              ; Return if ok
15F8-14             3205 (  4)         INC     D               ; Round NMSB
15F9-C0             3206 ( 5+)         RET     NZ              ; Return if ok
15FA-0C             3207 (  4)         INC     C               ; Round MSB
15FB-C0             3208 ( 5+)         RET     NZ              ; Return if ok
15FC-0E 80          3209 (  6)         LD      C,80H           ; Set normal value
15FE-34             3210 ( 10)         INC     (HL)            ; Increment exponent
15FF-C0             3211 ( 5+)         RET     NZ              ; Return if ok
1600-C3 0C 05       3212 (  9)         JP      OVERR           ; Overflow error
1603-               3213
1603-7E             3214 (  6) PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
1604-83             3215 (  4)         ADD     A,E             ; Add LSB of BCDE
1605-5F             3216 (  4)         LD      E,A             ; Save LSB of BCDE
1606-23             3217 (  4)         INC     HL
1607-7E             3218 (  6)         LD      A,(HL)          ; Get NMSB of FPREG
1608-8A             3219 (  4)         ADC     A,D             ; Add NMSB of BCDE
1609-57             3220 (  4)         LD      D,A             ; Save NMSB of BCDE
160A-23             3221 (  4)         INC     HL
160B-7E             3222 (  6)         LD      A,(HL)          ; Get MSB of FPREG
160C-89             3223 (  4)         ADC     A,C             ; Add MSB of BCDE
160D-4F             3224 (  4)         LD      C,A             ; Save MSB of BCDE
160E-C9             3225 (  9)         RET
160F-               3226
160F-21 2D 21       3227 (  9) COMPL:  LD      HL,SGNRES       ; Sign of result
1612-7E             3228 (  6)         LD      A,(HL)          ; Get sign of result
1613-2F             3229 (  3)         CPL                     ; Negate it
1614-77             3230 (  7)         LD      (HL),A          ; Put it back
1615-AF             3231 (  4)         XOR     A
1616-6F             3232 (  4)         LD      L,A             ; Set L to zero
1617-90             3233 (  4)         SUB     B               ; Negate exponent,set carry
1618-47             3234 (  4)         LD      B,A             ; Re-save exponent
1619-7D             3235 (  4)         LD      A,L             ; Load zero
161A-9B             3236 (  4)         SBC     A,E             ; Negate LSB
161B-5F             3237 (  4)         LD      E,A             ; Re-save LSB
161C-7D             3238 (  4)         LD      A,L             ; Load zero
161D-9A             3239 (  4)         SBC     A,D             ; Negate NMSB
161E-57             3240 (  4)         LD      D,A             ; Re-save NMSB
161F-7D             3241 (  4)         LD      A,L             ; Load zero
1620-99             3242 (  4)         SBC     A,C             ; Negate MSB
1621-4F             3243 (  4)         LD      C,A             ; Re-save MSB
1622-C9             3244 (  9)         RET
1623-               3245
1623-06 00          3246 (  6) SCALE:  LD      B,0             ; Clear underflow
1625-D6 08          3247 (  6) SCALLP: SUB     8               ; 8 bits (a whole byte)?
1627-DA 32 16       3248 ( 6+)         JP      C,SHRITE        ; No - Shift right A bits
162A-43             3249 (  4)         LD      B,E             ; <- Shift
162B-5A             3250 (  4)         LD      E,D             ; <- right
162C-51             3251 (  4)         LD      D,C             ; <- eight
162D-0E 00          3252 (  6)         LD      C,0             ; <- bits
162F-C3 25 16       3253 (  9)         JP      SCALLP          ; More bits to shift
1632-               3254
1632-C6 09          3255 (  6) SHRITE: ADD     A,8+1           ; Adjust count
1634-6F             3256 (  4)         LD      L,A             ; Save bits to shift
1635-AF             3257 (  4) SHRLP:  XOR     A               ; Flag for all done
1636-2D             3258 (  4)         DEC     L               ; All shifting done?
1637-C8             3259 ( 5+)         RET     Z               ; Yes - Return
1638-79             3260 (  4)         LD      A,C             ; Get MSB
1639-1F             3261 (  3) SHRT1:  RRA                     ; Shift it right
163A-4F             3262 (  4)         LD      C,A             ; Re-save
163B-7A             3263 (  4)         LD      A,D             ; Get NMSB
163C-1F             3264 (  3)         RRA                     ; Shift right with last bit
163D-57             3265 (  4)         LD      D,A             ; Re-save it
163E-7B             3266 (  4)         LD      A,E             ; Get LSB
163F-1F             3267 (  3)         RRA                     ; Shift right with last bit
1640-5F             3268 (  4)         LD      E,A             ; Re-save it
1641-78             3269 (  4)         LD      A,B             ; Get underflow
1642-1F             3270 (  3)         RRA                     ; Shift right with last bit
1643-47             3271 (  4)         LD      B,A             ; Re-save underflow
1644-C3 35 16       3272 (  9)         JP      SHRLP           ; More bits to do
1647-               3273
1647-00 00 00 81    3274       UNITY:  .DB       000H,000H,000H,081H    ; 1.00000
164B-               3275
164B-03             3276       LOGTAB: .DB      3                       ; Table used by LOG
164C-AA 56 19 80    3277               .DB      0AAH,056H,019H,080H     ; 0.59898
1650-F1 22 76 80    3278               .DB      0F1H,022H,076H,080H     ; 0.96147
1654-45 AA 38 82    3279               .DB      045H,0AAH,038H,082H     ; 2.88539
1658-               3280
1658-CD A4 17       3281 ( 16) LOG:    CALL    TSTSGN          ; Test sign of value
165B-B7             3282 (  4)         OR      A
165C-EA 1C 0A       3283 ( 6+)         JP      PE,FCERR        ; ?FC Error if <= zero
165F-21 2C 21       3284 (  9)         LD      HL,FPEXP        ; Point to exponent
1662-7E             3285 (  6)         LD      A,(HL)          ; Get exponent
1663-01 35 80       3286 (  9)         LD      BC,8035H        ; BCDE = SQR(1/2)
1666-11 F3 04       3287 (  9)         LD      DE,04F3H
1669-90             3288 (  4)         SUB     B               ; Scale value to be < 1
166A-F5             3289 ( 11)         PUSH    AF              ; Save scale factor
166B-70             3290 (  7)         LD      (HL),B          ; Save new exponent
166C-D5             3291 ( 11)         PUSH    DE              ; Save SQR(1/2)
166D-C5             3292 ( 11)         PUSH    BC
166E-CD 5E 15       3293 ( 16)         CALL    FPADD           ; Add SQR(1/2) to value
1671-C1             3294 (  9)         POP     BC              ; Restore SQR(1/2)
1672-D1             3295 (  9)         POP     DE
1673-04             3296 (  4)         INC     B               ; Make it SQR(2)
1674-CD FA 16       3297 ( 16)         CALL    DVBCDE          ; Divide by SQR(2)
1677-21 47 16       3298 (  9)         LD      HL,UNITY        ; Point to 1.
167A-CD 55 15       3299 ( 16)         CALL    SUBPHL          ; Subtract FPREG from 1
167D-21 4B 16       3300 (  9)         LD      HL,LOGTAB       ; Coefficient table
1680-CD EC 1A       3301 ( 16)         CALL    SUMSER          ; Evaluate sum of series
1683-01 80 80       3302 (  9)         LD      BC,8080H        ; BCDE = -0.5
1686-11 00 00       3303 (  9)         LD      DE,0000H
1689-CD 5E 15       3304 ( 16)         CALL    FPADD           ; Subtract 0.5 from FPREG
168C-F1             3305 (  9)         POP     AF              ; Restore scale factor
168D-CD 1F 19       3306 ( 16)         CALL    RSCALE          ; Re-scale number
1690-01 31 80       3307 (  9) MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
1693-11 18 72       3308 (  9)         LD      DE,7218H
1696-21             3309               .DB      21H             ; Skip "POP BC" and "POP DE"
1697-               3310
1697-C1             3311 (  9) MULT:   POP     BC              ; Get number from stack
1698-D1             3312 (  9)         POP     DE
1699-CD A4 17       3313 ( 16) FPMULT: CALL    TSTSGN          ; Test sign of FPREG
169C-C8             3314 ( 5+)         RET     Z               ; Return zero if zero
169D-2E 00          3315 (  6)         LD      L,0             ; Flag add exponents
169F-CD 62 17       3316 ( 16)         CALL    ADDEXP          ; Add exponents
16A2-79             3317 (  4)         LD      A,C             ; Get MSB of multiplier
16A3-32 3B 21       3318 ( 13)         LD      (MULVAL),A      ; Save MSB of multiplier
16A6-EB             3319 (  3)         EX      DE,HL
16A7-22 3C 21       3320 ( 20)         LD      (MULVAL+1),HL   ; Save rest of multiplier
16AA-01 00 00       3321 (  9)         LD      BC,0            ; Partial product (BCDE) = zero
16AD-50             3322 (  4)         LD      D,B
16AE-58             3323 (  4)         LD      E,B
16AF-21 AF 15       3324 (  9)         LD      HL,BNORM        ; Address of normalise
16B2-E5             3325 ( 11)         PUSH    HL              ; Save for return
16B3-21 BB 16       3326 (  9)         LD      HL,MULT8        ; Address of 8 bit multiply
16B6-E5             3327 ( 11)         PUSH    HL              ; Save for NMSB,MSB
16B7-E5             3328 ( 11)         PUSH    HL              ;
16B8-21 29 21       3329 (  9)         LD      HL,FPREG        ; Point to number
16BB-7E             3330 (  6) MULT8:  LD      A,(HL)          ; Get LSB of number
16BC-23             3331 (  4)         INC     HL              ; Point to NMSB
16BD-B7             3332 (  4)         OR      A               ; Test LSB
16BE-CA E7 16       3333 ( 6+)         JP      Z,BYTSFT        ; Zero - shift to next byte
16C1-E5             3334 ( 11)         PUSH    HL              ; Save address of number
16C2-2E 08          3335 (  6)         LD      L,8             ; 8 bits to multiply by
16C4-1F             3336 (  3) MUL8LP: RRA                     ; Shift LSB right
16C5-67             3337 (  4)         LD      H,A             ; Save LSB
16C6-79             3338 (  4)         LD      A,C             ; Get MSB
16C7-D2 D5 16       3339 ( 6+)         JP      NC,NOMADD       ; Bit was zero - Don't add
16CA-E5             3340 ( 11)         PUSH    HL              ; Save LSB and count
16CB-2A 3C 21       3341 ( 15)         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
16CE-19             3342 (  7)         ADD     HL,DE           ; Add NMSB and LSB
16CF-EB             3343 (  3)         EX      DE,HL           ; Leave sum in DE
16D0-E1             3344 (  9)         POP     HL              ; Restore MSB and count
16D1-3A 3B 21       3345 ( 12)         LD      A,(MULVAL)      ; Get MSB of multiplier
16D4-89             3346 (  4)         ADC     A,C             ; Add MSB
16D5-1F             3347 (  3) NOMADD: RRA                     ; Shift MSB right
16D6-4F             3348 (  4)         LD      C,A             ; Re-save MSB
16D7-7A             3349 (  4)         LD      A,D             ; Get NMSB
16D8-1F             3350 (  3)         RRA                     ; Shift NMSB right
16D9-57             3351 (  4)         LD      D,A             ; Re-save NMSB
16DA-7B             3352 (  4)         LD      A,E             ; Get LSB
16DB-1F             3353 (  3)         RRA                     ; Shift LSB right
16DC-5F             3354 (  4)         LD      E,A             ; Re-save LSB
16DD-78             3355 (  4)         LD      A,B             ; Get VLSB
16DE-1F             3356 (  3)         RRA                     ; Shift VLSB right
16DF-47             3357 (  4)         LD      B,A             ; Re-save VLSB
16E0-2D             3358 (  4)         DEC     L               ; Count bits multiplied
16E1-7C             3359 (  4)         LD      A,H             ; Get LSB of multiplier
16E2-C2 C4 16       3360 ( 6+)         JP      NZ,MUL8LP       ; More - Do it
16E5-E1             3361 (  9) POPHRT: POP     HL              ; Restore address of number
16E6-C9             3362 (  9)         RET
16E7-               3363
16E7-43             3364 (  4) BYTSFT: LD      B,E             ; Shift partial product left
16E8-5A             3365 (  4)         LD      E,D
16E9-51             3366 (  4)         LD      D,C
16EA-4F             3367 (  4)         LD      C,A
16EB-C9             3368 (  9)         RET
16EC-               3369
16EC-CD D5 17       3370 ( 16) DIV10:  CALL    STAKFP          ; Save FPREG on stack
16EF-01 20 84       3371 (  9)         LD      BC,8420H        ; BCDE = 10.
16F2-11 00 00       3372 (  9)         LD      DE,0000H
16F5-CD E5 17       3373 ( 16)         CALL    FPBCDE          ; Move 10 to FPREG
16F8-               3374
16F8-C1             3375 (  9) DIV:    POP     BC              ; Get number from stack
16F9-D1             3376 (  9)         POP     DE
16FA-CD A4 17       3377 ( 16) DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
16FD-CA 00 05       3378 ( 6+)         JP      Z,DZERR         ; Error if division by zero
1700-2E FF          3379 (  6)         LD      L,-1            ; Flag subtract exponents
1702-CD 62 17       3380 ( 16)         CALL    ADDEXP          ; Subtract exponents
1705-34             3381 ( 10)         INC     (HL)            ; Add 2 to exponent to adjust
1706-34             3382 ( 10)         INC     (HL)
1707-2B             3383 (  4)         DEC     HL              ; Point to MSB
1708-7E             3384 (  6)         LD      A,(HL)          ; Get MSB of dividend
1709-32 57 20       3385 ( 13)         LD      (DIV3),A        ; Save for subtraction
170C-2B             3386 (  4)         DEC     HL
170D-7E             3387 (  6)         LD      A,(HL)          ; Get NMSB of dividend
170E-32 53 20       3388 ( 13)         LD      (DIV2),A        ; Save for subtraction
1711-2B             3389 (  4)         DEC     HL
1712-7E             3390 (  6)         LD      A,(HL)          ; Get MSB of dividend
1713-32 4F 20       3391 ( 13)         LD      (DIV1),A        ; Save for subtraction
1716-41             3392 (  4)         LD      B,C             ; Get MSB
1717-EB             3393 (  3)         EX      DE,HL           ; NMSB,LSB to HL
1718-AF             3394 (  4)         XOR     A
1719-4F             3395 (  4)         LD      C,A             ; Clear MSB of quotient
171A-57             3396 (  4)         LD      D,A             ; Clear NMSB of quotient
171B-5F             3397 (  4)         LD      E,A             ; Clear LSB of quotient
171C-32 5A 20       3398 ( 13)         LD      (DIV4),A        ; Clear overflow count
171F-E5             3399 ( 11) DIVLP:  PUSH    HL              ; Save divisor
1720-C5             3400 ( 11)         PUSH    BC
1721-7D             3401 (  4)         LD      A,L             ; Get LSB of number
1722-CD 4E 20       3402 ( 16)         CALL    DIVSUP          ; Subt' divisor from dividend
1725-DE 00          3403 (  6)         SBC     A,0             ; Count for overflows
1727-3F             3404 (  3)         CCF
1728-D2 32 17       3405 ( 6+)         JP      NC,RESDIV       ; Restore divisor if borrow
172B-32 5A 20       3406 ( 13)         LD      (DIV4),A        ; Re-save overflow count
172E-F1             3407 (  9)         POP     AF              ; Scrap divisor
172F-F1             3408 (  9)         POP     AF
1730-37             3409 (  3)         SCF                     ; Set carry to
1731-D2             3410               .DB      0D2H            ; Skip "POP BC" and "POP HL"
1732-               3411
1732-C1             3412 (  9) RESDIV: POP     BC              ; Restore divisor
1733-E1             3413 (  9)         POP     HL
1734-79             3414 (  4)         LD      A,C             ; Get MSB of quotient
1735-3C             3415 (  4)         INC     A
1736-3D             3416 (  4)         DEC     A
1737-1F             3417 (  3)         RRA                     ; Bit 0 to bit 7
1738-FA E5 15       3418 ( 6+)         JP      M,RONDB         ; Done - Normalise result
173B-17             3419 (  3)         RLA                     ; Restore carry
173C-7B             3420 (  4)         LD      A,E             ; Get LSB of quotient
173D-17             3421 (  3)         RLA                     ; Double it
173E-5F             3422 (  4)         LD      E,A             ; Put it back
173F-7A             3423 (  4)         LD      A,D             ; Get NMSB of quotient
1740-17             3424 (  3)         RLA                     ; Double it
1741-57             3425 (  4)         LD      D,A             ; Put it back
1742-79             3426 (  4)         LD      A,C             ; Get MSB of quotient
1743-17             3427 (  3)         RLA                     ; Double it
1744-4F             3428 (  4)         LD      C,A             ; Put it back
1745-29             3429 (  7)         ADD     HL,HL           ; Double NMSB,LSB of divisor
1746-78             3430 (  4)         LD      A,B             ; Get MSB of divisor
1747-17             3431 (  3)         RLA                     ; Double it
1748-47             3432 (  4)         LD      B,A             ; Put it back
1749-3A 5A 20       3433 ( 12)         LD      A,(DIV4)        ; Get VLSB of quotient
174C-17             3434 (  3)         RLA                     ; Double it
174D-32 5A 20       3435 ( 13)         LD      (DIV4),A        ; Put it back
1750-79             3436 (  4)         LD      A,C             ; Get MSB of quotient
1751-B2             3437 (  4)         OR      D               ; Merge NMSB
1752-B3             3438 (  4)         OR      E               ; Merge LSB
1753-C2 1F 17       3439 ( 6+)         JP      NZ,DIVLP        ; Not done - Keep dividing
1756-E5             3440 ( 11)         PUSH    HL              ; Save divisor
1757-21 2C 21       3441 (  9)         LD      HL,FPEXP        ; Point to exponent
175A-35             3442 ( 10)         DEC     (HL)            ; Divide by 2
175B-E1             3443 (  9)         POP     HL              ; Restore divisor
175C-C2 1F 17       3444 ( 6+)         JP      NZ,DIVLP        ; Ok - Keep going
175F-C3 0C 05       3445 (  9)         JP      OVERR           ; Overflow error
1762-               3446
1762-78             3447 (  4) ADDEXP: LD      A,B             ; Get exponent of dividend
1763-B7             3448 (  4)         OR      A               ; Test it
1764-CA 86 17       3449 ( 6+)         JP      Z,OVTST3        ; Zero - Result zero
1767-7D             3450 (  4)         LD      A,L             ; Get add/subtract flag
1768-21 2C 21       3451 (  9)         LD      HL,FPEXP        ; Point to exponent
176B-AE             3452 (  6)         XOR     (HL)            ; Add or subtract it
176C-80             3453 (  4)         ADD     A,B             ; Add the other exponent
176D-47             3454 (  4)         LD      B,A             ; Save new exponent
176E-1F             3455 (  3)         RRA                     ; Test exponent for overflow
176F-A8             3456 (  4)         XOR     B
1770-78             3457 (  4)         LD      A,B             ; Get exponent
1771-F2 85 17       3458 ( 6+)         JP      P,OVTST2        ; Positive - Test for overflow
1774-C6 80          3459 (  6)         ADD     A,80H           ; Add excess 128
1776-77             3460 (  7)         LD      (HL),A          ; Save new exponent
1777-CA E5 16       3461 ( 6+)         JP      Z,POPHRT        ; Zero - Result zero
177A-CD 0A 18       3462 ( 16)         CALL    SIGNS           ; Set MSBs and sign of result
177D-77             3463 (  7)         LD      (HL),A          ; Save new exponent
177E-2B             3464 (  4)         DEC     HL              ; Point to MSB
177F-C9             3465 (  9)         RET
1780-               3466
1780-CD A4 17       3467 ( 16) OVTST1: CALL    TSTSGN          ; Test sign of FPREG
1783-2F             3468 (  3)         CPL                     ; Invert sign
1784-E1             3469 (  9)         POP     HL              ; Clean up stack
1785-B7             3470 (  4) OVTST2: OR      A               ; Test if new exponent zero
1786-E1             3471 (  9) OVTST3: POP     HL              ; Clear off return address
1787-F2 C4 15       3472 ( 6+)         JP      P,RESZER        ; Result zero
178A-C3 0C 05       3473 (  9)         JP      OVERR           ; Overflow error
178D-               3474
178D-CD F0 17       3475 ( 16) MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
1790-78             3476 (  4)         LD      A,B             ; Get exponent
1791-B7             3477 (  4)         OR      A               ; Is it zero?
1792-C8             3478 ( 5+)         RET     Z               ; Yes - Result is zero
1793-C6 02          3479 (  6)         ADD     A,2             ; Multiply by 4
1795-DA 0C 05       3480 ( 6+)         JP      C,OVERR         ; Overflow - ?OV Error
1798-47             3481 (  4)         LD      B,A             ; Re-save exponent
1799-CD 5E 15       3482 ( 16)         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
179C-21 2C 21       3483 (  9)         LD      HL,FPEXP        ; Point to exponent
179F-34             3484 ( 10)         INC     (HL)            ; Double number (Times 10)
17A0-C0             3485 ( 5+)         RET     NZ              ; Ok - Return
17A1-C3 0C 05       3486 (  9)         JP      OVERR           ; Overflow error
17A4-               3487
17A4-3A 2C 21       3488 ( 12) TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
17A7-B7             3489 (  4)         OR      A
17A8-C8             3490 ( 5+)         RET     Z               ; RETurn if number is zero
17A9-3A 2B 21       3491 ( 12)         LD      A,(FPREG+2)     ; Get MSB of FPREG
17AC-FE             3492               .DB      0FEH            ; Test sign
17AD-2F             3493 (  3) RETREL: CPL                     ; Invert sign
17AE-17             3494 (  3)         RLA                     ; Sign bit to carry
17AF-9F             3495 (  4) FLGDIF: SBC     A,A             ; Carry to all bits of A
17B0-C0             3496 ( 5+)         RET     NZ              ; Return -1 if negative
17B1-3C             3497 (  4)         INC     A               ; Bump to +1
17B2-C9             3498 (  9)         RET                     ; Positive - Return +1
17B3-               3499
17B3-CD A4 17       3500 ( 16) SGN:    CALL    TSTSGN          ; Test sign of FPREG
17B6-06 88          3501 (  6) FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
17B8-11 00 00       3502 (  9)         LD      DE,0            ; Zero NMSB and LSB
17BB-21 2C 21       3503 (  9) RETINT: LD      HL,FPEXP        ; Point to exponent
17BE-4F             3504 (  4)         LD      C,A             ; CDE = MSB,NMSB and LSB
17BF-70             3505 (  7)         LD      (HL),B          ; Save exponent
17C0-06 00          3506 (  6)         LD      B,0             ; CDE = integer to normalise
17C2-23             3507 (  4)         INC     HL              ; Point to sign of result
17C3-36 80          3508 (  9)         LD      (HL),80H        ; Set sign of result
17C5-17             3509 (  3)         RLA                     ; Carry = sign of integer
17C6-C3 AC 15       3510 (  9)         JP      CONPOS          ; Set sign of result
17C9-               3511
17C9-CD A4 17       3512 ( 16) ABS:    CALL    TSTSGN          ; Test sign of FPREG
17CC-F0             3513 ( 5+)         RET     P               ; Return if positive
17CD-21 2B 21       3514 (  9) INVSGN: LD      HL,FPREG+2      ; Point to MSB
17D0-7E             3515 (  6)         LD      A,(HL)          ; Get sign of mantissa
17D1-EE 80          3516 (  6)         XOR     80H             ; Invert sign of mantissa
17D3-77             3517 (  7)         LD      (HL),A          ; Re-save sign of mantissa
17D4-C9             3518 (  9)         RET
17D5-               3519
17D5-EB             3520 (  3) STAKFP: EX      DE,HL           ; Save code string address
17D6-2A 29 21       3521 ( 15)         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
17D9-E3             3522 ( 16)         EX      (SP),HL         ; Stack them,get return
17DA-E5             3523 ( 11)         PUSH    HL              ; Re-save return
17DB-2A 2B 21       3524 ( 15)         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
17DE-E3             3525 ( 16)         EX      (SP),HL         ; Stack them,get return
17DF-E5             3526 ( 11)         PUSH    HL              ; Re-save return
17E0-EB             3527 (  3)         EX      DE,HL           ; Restore code string address
17E1-C9             3528 (  9)         RET
17E2-               3529
17E2-CD F3 17       3530 ( 16) PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
17E5-EB             3531 (  3) FPBCDE: EX      DE,HL           ; Save code string address
17E6-22 29 21       3532 ( 20)         LD      (FPREG),HL      ; Save LSB,NLSB of number
17E9-60             3533 (  4)         LD      H,B             ; Exponent of number
17EA-69             3534 (  4)         LD      L,C             ; MSB of number
17EB-22 2B 21       3535 ( 20)         LD      (FPREG+2),HL    ; Save MSB and exponent
17EE-EB             3536 (  3)         EX      DE,HL           ; Restore code string address
17EF-C9             3537 (  9)         RET
17F0-               3538
17F0-21 29 21       3539 (  9) BCDEFP: LD      HL,FPREG        ; Point to FPREG
17F3-5E             3540 (  6) LOADFP: LD      E,(HL)          ; Get LSB of number
17F4-23             3541 (  4)         INC     HL
17F5-56             3542 (  6)         LD      D,(HL)          ; Get NMSB of number
17F6-23             3543 (  4)         INC     HL
17F7-4E             3544 (  6)         LD      C,(HL)          ; Get MSB of number
17F8-23             3545 (  4)         INC     HL
17F9-46             3546 (  6)         LD      B,(HL)          ; Get exponent of number
17FA-23             3547 (  4) INCHL:  INC     HL              ; Used for conditional "INC HL"
17FB-C9             3548 (  9)         RET
17FC-               3549
17FC-11 29 21       3550 (  9) FPTHL:  LD      DE,FPREG        ; Point to FPREG
17FF-06 04          3551 (  6) DETHL4: LD      B,4             ; 4 bytes to move
1801-1A             3552 (  6) DETHLB: LD      A,(DE)          ; Get source
1802-77             3553 (  7)         LD      (HL),A          ; Save destination
1803-13             3554 (  4)         INC     DE              ; Next source
1804-23             3555 (  4)         INC     HL              ; Next destination
1805-05             3556 (  4)         DEC     B               ; Count bytes
1806-C2 01 18       3557 ( 6+)         JP      NZ,DETHLB       ; Loop if more
1809-C9             3558 (  9)         RET
180A-               3559
180A-21 2B 21       3560 (  9) SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
180D-7E             3561 (  6)         LD      A,(HL)          ; Get MSB
180E-07             3562 (  3)         RLCA                    ; Old sign to carry
180F-37             3563 (  3)         SCF                     ; Set MSBit
1810-1F             3564 (  3)         RRA                     ; Set MSBit of MSB
1811-77             3565 (  7)         LD      (HL),A          ; Save new MSB
1812-3F             3566 (  3)         CCF                     ; Complement sign
1813-1F             3567 (  3)         RRA                     ; Old sign to carry
1814-23             3568 (  4)         INC     HL
1815-23             3569 (  4)         INC     HL
1816-77             3570 (  7)         LD      (HL),A          ; Set sign of result
1817-79             3571 (  4)         LD      A,C             ; Get MSB
1818-07             3572 (  3)         RLCA                    ; Old sign to carry
1819-37             3573 (  3)         SCF                     ; Set MSBit
181A-1F             3574 (  3)         RRA                     ; Set MSBit of MSB
181B-4F             3575 (  4)         LD      C,A             ; Save MSB
181C-1F             3576 (  3)         RRA
181D-AE             3577 (  6)         XOR     (HL)            ; New sign of result
181E-C9             3578 (  9)         RET
181F-               3579
181F-78             3580 (  4) CMPNUM: LD      A,B             ; Get exponent of number
1820-B7             3581 (  4)         OR      A
1821-CA A4 17       3582 ( 6+)         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
1824-21 AD 17       3583 (  9)         LD      HL,RETREL       ; Return relation routine
1827-E5             3584 ( 11)         PUSH    HL              ; Save for return
1828-CD A4 17       3585 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
182B-79             3586 (  4)         LD      A,C             ; Get MSB of number
182C-C8             3587 ( 5+)         RET     Z               ; FPREG zero - Number's MSB
182D-21 2B 21       3588 (  9)         LD      HL,FPREG+2      ; MSB of FPREG
1830-AE             3589 (  6)         XOR     (HL)            ; Combine signs
1831-79             3590 (  4)         LD      A,C             ; Get MSB of number
1832-F8             3591 ( 5+)         RET     M               ; Exit if signs different
1833-CD 39 18       3592 ( 16)         CALL    CMPFP           ; Compare FP numbers
1836-1F             3593 (  3)         RRA                     ; Get carry to sign
1837-A9             3594 (  4)         XOR     C               ; Combine with MSB of number
1838-C9             3595 (  9)         RET
1839-               3596
1839-23             3597 (  4) CMPFP:  INC     HL              ; Point to exponent
183A-78             3598 (  4)         LD      A,B             ; Get exponent
183B-BE             3599 (  6)         CP      (HL)            ; Compare exponents
183C-C0             3600 ( 5+)         RET     NZ              ; Different
183D-2B             3601 (  4)         DEC     HL              ; Point to MBS
183E-79             3602 (  4)         LD      A,C             ; Get MSB
183F-BE             3603 (  6)         CP      (HL)            ; Compare MSBs
1840-C0             3604 ( 5+)         RET     NZ              ; Different
1841-2B             3605 (  4)         DEC     HL              ; Point to NMSB
1842-7A             3606 (  4)         LD      A,D             ; Get NMSB
1843-BE             3607 (  6)         CP      (HL)            ; Compare NMSBs
1844-C0             3608 ( 5+)         RET     NZ              ; Different
1845-2B             3609 (  4)         DEC     HL              ; Point to LSB
1846-7B             3610 (  4)         LD      A,E             ; Get LSB
1847-96             3611 (  6)         SUB     (HL)            ; Compare LSBs
1848-C0             3612 ( 5+)         RET     NZ              ; Different
1849-E1             3613 (  9)         POP     HL              ; Drop RETurn
184A-E1             3614 (  9)         POP     HL              ; Drop another RETurn
184B-C9             3615 (  9)         RET
184C-               3616
184C-47             3617 (  4) FPINT:  LD      B,A             ; <- Move
184D-4F             3618 (  4)         LD      C,A             ; <- exponent
184E-57             3619 (  4)         LD      D,A             ; <- to all
184F-5F             3620 (  4)         LD      E,A             ; <- bits
1850-B7             3621 (  4)         OR      A               ; Test exponent
1851-C8             3622 ( 5+)         RET     Z               ; Zero - Return zero
1852-E5             3623 ( 11)         PUSH    HL              ; Save pointer to number
1853-CD F0 17       3624 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1856-CD 0A 18       3625 ( 16)         CALL    SIGNS           ; Set MSBs & sign of result
1859-AE             3626 (  6)         XOR     (HL)            ; Combine with sign of FPREG
185A-67             3627 (  4)         LD      H,A             ; Save combined signs
185B-FC 70 18       3628 ( 6+)         CALL    M,DCBCDE        ; Negative - Decrement BCDE
185E-3E 98          3629 (  6)         LD      A,80H+24        ; 24 bits
1860-90             3630 (  4)         SUB     B               ; Bits to shift
1861-CD 23 16       3631 ( 16)         CALL    SCALE           ; Shift BCDE
1864-7C             3632 (  4)         LD      A,H             ; Get combined sign
1865-17             3633 (  3)         RLA                     ; Sign to carry
1866-DC F6 15       3634 ( 6+)         CALL    C,FPROND        ; Negative - Round number up
1869-06 00          3635 (  6)         LD      B,0             ; Zero exponent
186B-DC 0F 16       3636 ( 6+)         CALL    C,COMPL         ; If negative make positive
186E-E1             3637 (  9)         POP     HL              ; Restore pointer to number
186F-C9             3638 (  9)         RET
1870-               3639
1870-1B             3640 (  4) DCBCDE: DEC     DE              ; Decrement BCDE
1871-7A             3641 (  4)         LD      A,D             ; Test LSBs
1872-A3             3642 (  4)         AND     E
1873-3C             3643 (  4)         INC     A
1874-C0             3644 ( 5+)         RET     NZ              ; Exit if LSBs not FFFF
1875-0B             3645 (  4)         DEC     BC              ; Decrement MSBs
1876-C9             3646 (  9)         RET
1877-               3647
1877-21 2C 21       3648 (  9) INT:    LD      HL,FPEXP        ; Point to exponent
187A-7E             3649 (  6)         LD      A,(HL)          ; Get exponent
187B-FE 98          3650 (  6)         CP      80H+24          ; Integer accuracy only?
187D-3A 29 21       3651 ( 12)         LD      A,(FPREG)       ; Get LSB
1880-D0             3652 ( 5+)         RET     NC              ; Yes - Already integer
1881-7E             3653 (  6)         LD      A,(HL)          ; Get exponent
1882-CD 4C 18       3654 ( 16)         CALL    FPINT           ; F.P to integer
1885-36 98          3655 (  9)         LD      (HL),80H+24     ; Save 24 bit integer
1887-7B             3656 (  4)         LD      A,E             ; Get LSB of number
1888-F5             3657 ( 11)         PUSH    AF              ; Save LSB
1889-79             3658 (  4)         LD      A,C             ; Get MSB of number
188A-17             3659 (  3)         RLA                     ; Sign to carry
188B-CD AC 15       3660 ( 16)         CALL    CONPOS          ; Set sign of result
188E-F1             3661 (  9)         POP     AF              ; Restore LSB of number
188F-C9             3662 (  9)         RET
1890-               3663
1890-21 00 00       3664 (  9) MLDEBC: LD      HL,0            ; Clear partial product
1893-78             3665 (  4)         LD      A,B             ; Test multiplier
1894-B1             3666 (  4)         OR      C
1895-C8             3667 ( 5+)         RET     Z               ; Return zero if zero
1896-3E 10          3668 (  6)         LD      A,16            ; 16 bits
1898-29             3669 (  7) MLDBLP: ADD     HL,HL           ; Shift P.P left
1899-DA D0 10       3670 ( 6+)         JP      C,BSERR         ; ?BS Error if overflow
189C-EB             3671 (  3)         EX      DE,HL
189D-29             3672 (  7)         ADD     HL,HL           ; Shift multiplier left
189E-EB             3673 (  3)         EX      DE,HL
189F-D2 A6 18       3674 ( 6+)         JP      NC,NOMLAD       ; Bit was zero - No add
18A2-09             3675 (  7)         ADD     HL,BC           ; Add multiplicand
18A3-DA D0 10       3676 ( 6+)         JP      C,BSERR         ; ?BS Error if overflow
18A6-3D             3677 (  4) NOMLAD: DEC     A               ; Count bits
18A7-C2 98 18       3678 ( 6+)         JP      NZ,MLDBLP       ; More
18AA-C9             3679 (  9)         RET
18AB-               3680
18AB-FE 2D          3681 (  6) ASCTFP: CP      '-'             ; Negative?
18AD-F5             3682 ( 11)         PUSH    AF              ; Save it and flags
18AE-CA B7 18       3683 ( 6+)         JP      Z,CNVNUM        ; Yes - Convert number
18B1-FE 2B          3684 (  6)         CP      '+'             ; Positive?
18B3-CA B7 18       3685 ( 6+)         JP      Z,CNVNUM        ; Yes - Convert number
18B6-2B             3686 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
18B7-CD C4 15       3687 ( 16) CNVNUM: CALL    RESZER          ; Set result to zero
18BA-47             3688 (  4)         LD      B,A             ; Digits after point counter
18BB-57             3689 (  4)         LD      D,A             ; Sign of exponent
18BC-5F             3690 (  4)         LD      E,A             ; Exponent of ten
18BD-2F             3691 (  3)         CPL
18BE-4F             3692 (  4)         LD      C,A             ; Before or after point flag
18BF-CD 55 09       3693 ( 16) MANLP:  CALL    GETCHR          ; Get next character
18C2-DA 08 19       3694 ( 6+)         JP      C,ADDIG         ; Digit - Add to number
18C5-FE 2E          3695 (  6)         CP      '.'
18C7-CA E3 18       3696 ( 6+)         JP      Z,DPOINT        ; '.' - Flag point
18CA-FE 45          3697 (  6)         CP      'E'
18CC-C2 E7 18       3698 ( 6+)         JP      NZ,CONEXP       ; Not 'E' - Scale number
18CF-CD 55 09       3699 ( 16)         CALL    GETCHR          ; Get next character
18D2-CD FB 0E       3700 ( 16)         CALL    SGNEXP          ; Get sign of exponent
18D5-CD 55 09       3701 ( 16) EXPLP:  CALL    GETCHR          ; Get next character
18D8-DA 2A 19       3702 ( 6+)         JP      C,EDIGIT        ; Digit - Add to exponent
18DB-14             3703 (  4)         INC     D               ; Is sign negative?
18DC-C2 E7 18       3704 ( 6+)         JP      NZ,CONEXP       ; No - Scale number
18DF-AF             3705 (  4)         XOR     A
18E0-93             3706 (  4)         SUB     E               ; Negate exponent
18E1-5F             3707 (  4)         LD      E,A             ; And re-save it
18E2-0C             3708 (  4)         INC     C               ; Flag end of number
18E3-0C             3709 (  4) DPOINT: INC     C               ; Flag point passed
18E4-CA BF 18       3710 ( 6+)         JP      Z,MANLP         ; Zero - Get another digit
18E7-E5             3711 ( 11) CONEXP: PUSH    HL              ; Save code string address
18E8-7B             3712 (  4)         LD      A,E             ; Get exponent
18E9-90             3713 (  4)         SUB     B               ; Subtract digits after point
18EA-F4 00 19       3714 ( 6+) SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
18ED-F2 F6 18       3715 ( 6+)         JP      P,ENDCON        ; Positive - All done
18F0-F5             3716 ( 11)         PUSH    AF              ; Save number of times to /10
18F1-CD EC 16       3717 ( 16)         CALL    DIV10           ; Divide by 10
18F4-F1             3718 (  9)         POP     AF              ; Restore count
18F5-3C             3719 (  4)         INC     A               ; Count divides
18F6-               3720
18F6-C2 EA 18       3721 ( 6+) ENDCON: JP      NZ,SCALMI       ; More to do
18F9-D1             3722 (  9)         POP     DE              ; Restore code string address
18FA-F1             3723 (  9)         POP     AF              ; Restore sign of number
18FB-CC CD 17       3724 ( 6+)         CALL    Z,INVSGN        ; Negative - Negate number
18FE-EB             3725 (  3)         EX      DE,HL           ; Code string address to HL
18FF-C9             3726 (  9)         RET
1900-               3727
1900-C8             3728 ( 5+) SCALPL: RET     Z               ; Exit if no scaling needed
1901-F5             3729 ( 11) MULTEN: PUSH    AF              ; Save count
1902-CD 8D 17       3730 ( 16)         CALL    MLSP10          ; Multiply number by 10
1905-F1             3731 (  9)         POP     AF              ; Restore count
1906-3D             3732 (  4)         DEC     A               ; Count multiplies
1907-C9             3733 (  9)         RET
1908-               3734
1908-D5             3735 ( 11) ADDIG:  PUSH    DE              ; Save sign of exponent
1909-57             3736 (  4)         LD      D,A             ; Save digit
190A-78             3737 (  4)         LD      A,B             ; Get digits after point
190B-89             3738 (  4)         ADC     A,C             ; Add one if after point
190C-47             3739 (  4)         LD      B,A             ; Re-save counter
190D-C5             3740 ( 11)         PUSH    BC              ; Save point flags
190E-E5             3741 ( 11)         PUSH    HL              ; Save code string address
190F-D5             3742 ( 11)         PUSH    DE              ; Save digit
1910-CD 8D 17       3743 ( 16)         CALL    MLSP10          ; Multiply number by 10
1913-F1             3744 (  9)         POP     AF              ; Restore digit
1914-D6 30          3745 (  6)         SUB     '0'             ; Make it absolute
1916-CD 1F 19       3746 ( 16)         CALL    RSCALE          ; Re-scale number
1919-E1             3747 (  9)         POP     HL              ; Restore code string address
191A-C1             3748 (  9)         POP     BC              ; Restore point flags
191B-D1             3749 (  9)         POP     DE              ; Restore sign of exponent
191C-C3 BF 18       3750 (  9)         JP      MANLP           ; Get another digit
191F-               3751
191F-CD D5 17       3752 ( 16) RSCALE: CALL    STAKFP          ; Put number on stack
1922-CD B6 17       3753 ( 16)         CALL    FLGREL          ; Digit to add to FPREG
1925-C1             3754 (  9) PADD:   POP     BC              ; Restore number
1926-D1             3755 (  9)         POP     DE
1927-C3 5E 15       3756 (  9)         JP      FPADD           ; Add BCDE to FPREG and return
192A-               3757
192A-7B             3758 (  4) EDIGIT: LD      A,E             ; Get digit
192B-07             3759 (  3)         RLCA                    ; Times 2
192C-07             3760 (  3)         RLCA                    ; Times 4
192D-83             3761 (  4)         ADD     A,E             ; Times 5
192E-07             3762 (  3)         RLCA                    ; Times 10
192F-86             3763 (  6)         ADD     A,(HL)          ; Add next digit
1930-D6 30          3764 (  6)         SUB     '0'             ; Make it absolute
1932-5F             3765 (  4)         LD      E,A             ; Save new digit
1933-C3 D5 18       3766 (  9)         JP      EXPLP           ; Look for another digit
1936-               3767
1936-E5             3768 ( 11) LINEIN: PUSH    HL              ; Save code string address
1937-21 95 04       3769 (  9)         LD      HL,INMSG        ; Output " in "
193A-CD 9B 12       3770 ( 16)         CALL    PRS             ; Output string at HL
193D-E1             3771 (  9)         POP     HL              ; Restore code string address
193E-EB             3772 (  3) PRNTHL: EX      DE,HL           ; Code string address to DE
193F-AF             3773 (  4)         XOR     A
1940-06 98          3774 (  6)         LD      B,80H+24        ; 24 bits
1942-CD BB 17       3775 ( 16)         CALL    RETINT          ; Return the integer
1945-21 9A 12       3776 (  9)         LD      HL,PRNUMS       ; Print number string
1948-E5             3777 ( 11)         PUSH    HL              ; Save for return
1949-21 2E 21       3778 (  9) NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
194C-E5             3779 ( 11)         PUSH    HL              ; Save for return
194D-CD A4 17       3780 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
1950-36 20          3781 (  9)         LD      (HL),' '        ; Space at start
1952-F2 57 19       3782 ( 6+)         JP      P,SPCFST        ; Positive - Space to start
1955-36 2D          3783 (  9)         LD      (HL),'-'        ; '-' sign at start
1957-23             3784 (  4) SPCFST: INC     HL              ; First byte of number
1958-36 30          3785 (  9)         LD      (HL),'0'        ; '0' if zero
195A-CA 0D 1A       3786 ( 6+)         JP      Z,JSTZER        ; Return '0' if zero
195D-E5             3787 ( 11)         PUSH    HL              ; Save buffer address
195E-FC CD 17       3788 ( 6+)         CALL    M,INVSGN        ; Negate FPREG if negative
1961-AF             3789 (  4)         XOR     A               ; Zero A
1962-F5             3790 ( 11)         PUSH    AF              ; Save it
1963-CD 13 1A       3791 ( 16)         CALL    RNGTST          ; Test number is in range
1966-01 43 91       3792 (  9) SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
1969-11 F8 4F       3793 (  9)         LD      DE,4FF8H
196C-CD 1F 18       3794 ( 16)         CALL    CMPNUM          ; Compare numbers
196F-B7             3795 (  4)         OR      A
1970-E2 84 19       3796 ( 6+)         JP      PO,INRNG        ; > 99999.9 - Sort it out
1973-F1             3797 (  9)         POP     AF              ; Restore count
1974-CD 01 19       3798 ( 16)         CALL    MULTEN          ; Multiply by ten
1977-F5             3799 ( 11)         PUSH    AF              ; Re-save count
1978-C3 66 19       3800 (  9)         JP      SIXDIG          ; Test it again
197B-               3801
197B-CD EC 16       3802 ( 16) GTSIXD: CALL    DIV10           ; Divide by 10
197E-F1             3803 (  9)         POP     AF              ; Get count
197F-3C             3804 (  4)         INC     A               ; Count divides
1980-F5             3805 ( 11)         PUSH    AF              ; Re-save count
1981-CD 13 1A       3806 ( 16)         CALL    RNGTST          ; Test number is in range
1984-CD 4C 15       3807 ( 16) INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
1987-3C             3808 (  4)         INC     A
1988-CD 4C 18       3809 ( 16)         CALL    FPINT           ; F.P to integer
198B-CD E5 17       3810 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
198E-01 06 03       3811 (  9)         LD      BC,0306H        ; 1E+06 to 1E-03 range
1991-F1             3812 (  9)         POP     AF              ; Restore count
1992-81             3813 (  4)         ADD     A,C             ; 6 digits before point
1993-3C             3814 (  4)         INC     A               ; Add one
1994-FA A0 19       3815 ( 6+)         JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
1997-FE 08          3816 (  6)         CP      6+1+1           ; More than 999999 ?
1999-D2 A0 19       3817 ( 6+)         JP      NC,MAKNUM       ; Yes - Do it in 'E' form
199C-3C             3818 (  4)         INC     A               ; Adjust for exponent
199D-47             3819 (  4)         LD      B,A             ; Exponent of number
199E-3E 02          3820 (  6)         LD      A,2             ; Make it zero after
19A0-               3821
19A0-3D             3822 (  4) MAKNUM: DEC     A               ; Adjust for digits to do
19A1-3D             3823 (  4)         DEC     A
19A2-E1             3824 (  9)         POP     HL              ; Restore buffer address
19A3-F5             3825 ( 11)         PUSH    AF              ; Save count
19A4-11 26 1A       3826 (  9)         LD      DE,POWERS       ; Powers of ten
19A7-05             3827 (  4)         DEC     B               ; Count digits before point
19A8-C2 B1 19       3828 ( 6+)         JP      NZ,DIGTXT       ; Not zero - Do number
19AB-36 2E          3829 (  9)         LD      (HL),'.'        ; Save point
19AD-23             3830 (  4)         INC     HL              ; Move on
19AE-36 30          3831 (  9)         LD      (HL),'0'        ; Save zero
19B0-23             3832 (  4)         INC     HL              ; Move on
19B1-05             3833 (  4) DIGTXT: DEC     B               ; Count digits before point
19B2-36 2E          3834 (  9)         LD      (HL),'.'        ; Save point in case
19B4-CC FA 17       3835 ( 6+)         CALL    Z,INCHL         ; Last digit - move on
19B7-C5             3836 ( 11)         PUSH    BC              ; Save digits before point
19B8-E5             3837 ( 11)         PUSH    HL              ; Save buffer address
19B9-D5             3838 ( 11)         PUSH    DE              ; Save powers of ten
19BA-CD F0 17       3839 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
19BD-E1             3840 (  9)         POP     HL              ; Powers of ten table
19BE-06 2F          3841 (  6)         LD      B, '0'-1        ; ASCII '0' - 1
19C0-04             3842 (  4) TRYAGN: INC     B               ; Count subtractions
19C1-7B             3843 (  4)         LD      A,E             ; Get LSB
19C2-96             3844 (  6)         SUB     (HL)            ; Subtract LSB
19C3-5F             3845 (  4)         LD      E,A             ; Save LSB
19C4-23             3846 (  4)         INC     HL
19C5-7A             3847 (  4)         LD      A,D             ; Get NMSB
19C6-9E             3848 (  6)         SBC     A,(HL)          ; Subtract NMSB
19C7-57             3849 (  4)         LD      D,A             ; Save NMSB
19C8-23             3850 (  4)         INC     HL
19C9-79             3851 (  4)         LD      A,C             ; Get MSB
19CA-9E             3852 (  6)         SBC     A,(HL)          ; Subtract MSB
19CB-4F             3853 (  4)         LD      C,A             ; Save MSB
19CC-2B             3854 (  4)         DEC     HL              ; Point back to start
19CD-2B             3855 (  4)         DEC     HL
19CE-D2 C0 19       3856 ( 6+)         JP      NC,TRYAGN       ; No overflow - Try again
19D1-CD 03 16       3857 ( 16)         CALL    PLUCDE          ; Restore number
19D4-23             3858 (  4)         INC     HL              ; Start of next number
19D5-CD E5 17       3859 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
19D8-EB             3860 (  3)         EX      DE,HL           ; Save point in table
19D9-E1             3861 (  9)         POP     HL              ; Restore buffer address
19DA-70             3862 (  7)         LD      (HL),B          ; Save digit in buffer
19DB-23             3863 (  4)         INC     HL              ; And move on
19DC-C1             3864 (  9)         POP     BC              ; Restore digit count
19DD-0D             3865 (  4)         DEC     C               ; Count digits
19DE-C2 B1 19       3866 ( 6+)         JP      NZ,DIGTXT       ; More - Do them
19E1-05             3867 (  4)         DEC     B               ; Any decimal part?
19E2-CA F1 19       3868 ( 6+)         JP      Z,DOEBIT        ; No - Do 'E' bit
19E5-2B             3869 (  4) SUPTLZ: DEC     HL              ; Move back through buffer
19E6-7E             3870 (  6)         LD      A,(HL)          ; Get character
19E7-FE 30          3871 (  6)         CP      '0'             ; '0' character?
19E9-CA E5 19       3872 ( 6+)         JP      Z,SUPTLZ        ; Yes - Look back for more
19EC-FE 2E          3873 (  6)         CP      '.'             ; A decimal point?
19EE-C4 FA 17       3874 ( 6+)         CALL    NZ,INCHL        ; Move back over digit
19F1-               3875
19F1-F1             3876 (  9) DOEBIT: POP     AF              ; Get 'E' flag
19F2-CA 10 1A       3877 ( 6+)         JP      Z,NOENED        ; No 'E' needed - End buffer
19F5-36 45          3878 (  9)         LD      (HL),'E'        ; Put 'E' in buffer
19F7-23             3879 (  4)         INC     HL              ; And move on
19F8-36 2B          3880 (  9)         LD      (HL),'+'        ; Put '+' in buffer
19FA-F2 01 1A       3881 ( 6+)         JP      P,OUTEXP        ; Positive - Output exponent
19FD-36 2D          3882 (  9)         LD      (HL),'-'        ; Put '-' in buffer
19FF-2F             3883 (  3)         CPL                     ; Negate exponent
1A00-3C             3884 (  4)         INC     A
1A01-06 2F          3885 (  6) OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
1A03-04             3886 (  4) EXPTEN: INC     B               ; Count subtractions
1A04-D6 0A          3887 (  6)         SUB     10              ; Tens digit
1A06-D2 03 1A       3888 ( 6+)         JP      NC,EXPTEN       ; More to do
1A09-C6 3A          3889 (  6)         ADD     A,'0'+10        ; Restore and make ASCII
1A0B-23             3890 (  4)         INC     HL              ; Move on
1A0C-70             3891 (  7)         LD      (HL),B          ; Save MSB of exponent
1A0D-23             3892 (  4) JSTZER: INC     HL              ;
1A0E-77             3893 (  7)         LD      (HL),A          ; Save LSB of exponent
1A0F-23             3894 (  4)         INC     HL
1A10-71             3895 (  7) NOENED: LD      (HL),C          ; Mark end of buffer
1A11-E1             3896 (  9)         POP     HL              ; Restore code string address
1A12-C9             3897 (  9)         RET
1A13-               3898
1A13-01 74 94       3899 (  9) RNGTST: LD      BC,9474H        ; BCDE = 999999.
1A16-11 F7 23       3900 (  9)         LD      DE,23F7H
1A19-CD 1F 18       3901 ( 16)         CALL    CMPNUM          ; Compare numbers
1A1C-B7             3902 (  4)         OR      A
1A1D-E1             3903 (  9)         POP     HL              ; Return address to HL
1A1E-E2 7B 19       3904 ( 6+)         JP      PO,GTSIXD       ; Too big - Divide by ten
1A21-E9             3905 (  3)         JP      (HL)            ; Otherwise return to caller
1A22-               3906
1A22-00 00 00 80    3907       HALF:   .DB      00H,00H,00H,80H ; 0.5
1A26-               3908
1A26-A0 86 01       3909       POWERS: .DB      0A0H,086H,001H  ; 100000
1A29-10 27 00       3910               .DB      010H,027H,000H  ;  10000
1A2C-E8 03 00       3911               .DB      0E8H,003H,000H  ;   1000
1A2F-64 00 00       3912               .DB      064H,000H,000H  ;    100
1A32-0A 00 00       3913               .DB      00AH,000H,000H  ;     10
1A35-01 00 00       3914               .DB      001H,000H,000H  ;      1
1A38-               3915
1A38-21 CD 17       3916 (  9) NEGAFT: LD  HL,INVSGN           ; Negate result
1A3B-E3             3917 ( 16)         EX      (SP),HL         ; To be done after caller
1A3C-E9             3918 (  3)         JP      (HL)            ; Return to caller
1A3D-               3919
1A3D-CD D5 17       3920 ( 16) SQR:    CALL    STAKFP          ; Put value on stack
1A40-21 22 1A       3921 (  9)         LD      HL,HALF         ; Set power to 1/2
1A43-CD E2 17       3922 ( 16)         CALL    PHLTFP          ; Move 1/2 to FPREG
1A46-               3923
1A46-C1             3924 (  9) POWER:  POP     BC              ; Get base
1A47-D1             3925 (  9)         POP     DE
1A48-CD A4 17       3926 ( 16)         CALL    TSTSGN          ; Test sign of power
1A4B-78             3927 (  4)         LD      A,B             ; Get exponent of base
1A4C-CA 8B 1A       3928 ( 6+)         JP      Z,EXP           ; Make result 1 if zero
1A4F-F2 56 1A       3929 ( 6+)         JP      P,POWER1        ; Positive base - Ok
1A52-B7             3930 (  4)         OR      A               ; Zero to negative power?
1A53-CA 00 05       3931 ( 6+)         JP      Z,DZERR         ; Yes - ?/0 Error
1A56-B7             3932 (  4) POWER1: OR      A               ; Base zero?
1A57-CA C5 15       3933 ( 6+)         JP      Z,SAVEXP        ; Yes - Return zero
1A5A-D5             3934 ( 11)         PUSH    DE              ; Save base
1A5B-C5             3935 ( 11)         PUSH    BC
1A5C-79             3936 (  4)         LD      A,C             ; Get MSB of base
1A5D-F6 7F          3937 (  6)         OR      01111111B       ; Get sign status
1A5F-CD F0 17       3938 ( 16)         CALL    BCDEFP          ; Move power to BCDE
1A62-F2 73 1A       3939 ( 6+)         JP      P,POWER2        ; Positive base - Ok
1A65-D5             3940 ( 11)         PUSH    DE              ; Save power
1A66-C5             3941 ( 11)         PUSH    BC
1A67-CD 77 18       3942 ( 16)         CALL    INT             ; Get integer of power
1A6A-C1             3943 (  9)         POP     BC              ; Restore power
1A6B-D1             3944 (  9)         POP     DE
1A6C-F5             3945 ( 11)         PUSH    AF              ; MSB of base
1A6D-CD 1F 18       3946 ( 16)         CALL    CMPNUM          ; Power an integer?
1A70-E1             3947 (  9)         POP     HL              ; Restore MSB of base
1A71-7C             3948 (  4)         LD      A,H             ; but don't affect flags
1A72-1F             3949 (  3)         RRA                     ; Exponent odd or even?
1A73-E1             3950 (  9) POWER2: POP     HL              ; Restore MSB and exponent
1A74-22 2B 21       3951 ( 20)         LD      (FPREG+2),HL    ; Save base in FPREG
1A77-E1             3952 (  9)         POP     HL              ; LSBs of base
1A78-22 29 21       3953 ( 20)         LD      (FPREG),HL      ; Save in FPREG
1A7B-DC 38 1A       3954 ( 6+)         CALL    C,NEGAFT        ; Odd power - Negate result
1A7E-CC CD 17       3955 ( 6+)         CALL    Z,INVSGN        ; Negative base - Negate it
1A81-D5             3956 ( 11)         PUSH    DE              ; Save power
1A82-C5             3957 ( 11)         PUSH    BC
1A83-CD 58 16       3958 ( 16)         CALL    LOG             ; Get LOG of base
1A86-C1             3959 (  9)         POP     BC              ; Restore power
1A87-D1             3960 (  9)         POP     DE
1A88-CD 99 16       3961 ( 16)         CALL    FPMULT          ; Multiply LOG by power
1A8B-               3962
1A8B-CD D5 17       3963 ( 16) EXP:    CALL    STAKFP          ; Put value on stack
1A8E-01 38 81       3964 (  9)         LD      BC,08138H       ; BCDE = 1/Ln(2)
1A91-11 3B AA       3965 (  9)         LD      DE,0AA3BH
1A94-CD 99 16       3966 ( 16)         CALL    FPMULT          ; Multiply value by 1/LN(2)
1A97-3A 2C 21       3967 ( 12)         LD      A,(FPEXP)       ; Get exponent
1A9A-FE 88          3968 (  6)         CP      80H+8           ; Is it in range?
1A9C-D2 80 17       3969 ( 6+)         JP      NC,OVTST1       ; No - Test for overflow
1A9F-CD 77 18       3970 ( 16)         CALL    INT             ; Get INT of FPREG
1AA2-C6 80          3971 (  6)         ADD     A,80H           ; For excess 128
1AA4-C6 02          3972 (  6)         ADD     A,2             ; Exponent > 126?
1AA6-DA 80 17       3973 ( 6+)         JP      C,OVTST1        ; Yes - Test for overflow
1AA9-F5             3974 ( 11)         PUSH    AF              ; Save scaling factor
1AAA-21 47 16       3975 (  9)         LD      HL,UNITY        ; Point to 1.
1AAD-CD 4F 15       3976 ( 16)         CALL    ADDPHL          ; Add 1 to FPREG
1AB0-CD 90 16       3977 ( 16)         CALL    MULLN2          ; Multiply by LN(2)
1AB3-F1             3978 (  9)         POP     AF              ; Restore scaling factor
1AB4-C1             3979 (  9)         POP     BC              ; Restore exponent
1AB5-D1             3980 (  9)         POP     DE
1AB6-F5             3981 ( 11)         PUSH    AF              ; Save scaling factor
1AB7-CD 5B 15       3982 ( 16)         CALL    SUBCDE          ; Subtract exponent from FPREG
1ABA-CD CD 17       3983 ( 16)         CALL    INVSGN          ; Negate result
1ABD-21 CB 1A       3984 (  9)         LD      HL,EXPTAB       ; Coefficient table
1AC0-CD FB 1A       3985 ( 16)         CALL    SMSER1          ; Sum the series
1AC3-11 00 00       3986 (  9)         LD      DE,0            ; Zero LSBs
1AC6-C1             3987 (  9)         POP     BC              ; Scaling factor
1AC7-4A             3988 (  4)         LD      C,D             ; Zero MSB
1AC8-C3 99 16       3989 (  9)         JP      FPMULT          ; Scale result to correct value
1ACB-               3990
1ACB-08             3991       EXPTAB: .DB      8                       ; Table used by EXP
1ACC-40 2E 94 74    3992               .DB      040H,02EH,094H,074H     ; -1/7! (-1/5040)
1AD0-70 4F 2E 77    3993               .DB      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
1AD4-6E 02 88 7A    3994               .DB      06EH,002H,088H,07AH     ; -1/5! (-1/120)
1AD8-E6 A0 2A 7C    3995               .DB      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
1ADC-50 AA AA 7E    3996               .DB      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
1AE0-FF FF 7F 7F    3997               .DB      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
1AE4-00 00 80 81    3998               .DB      000H,000H,080H,081H     ; -1/1! (-1/1)
1AE8-00 00 00 81    3999               .DB      000H,000H,000H,081H     ;  1/0! ( 1/1)
1AEC-               4000
1AEC-CD D5 17       4001 ( 16) SUMSER: CALL    STAKFP          ; Put FPREG on stack
1AEF-11 97 16       4002 (  9)         LD      DE,MULT         ; Multiply by "X"
1AF2-D5             4003 ( 11)         PUSH    DE              ; To be done after
1AF3-E5             4004 ( 11)         PUSH    HL              ; Save address of table
1AF4-CD F0 17       4005 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1AF7-CD 99 16       4006 ( 16)         CALL    FPMULT          ; Square the value
1AFA-E1             4007 (  9)         POP     HL              ; Restore address of table
1AFB-CD D5 17       4008 ( 16) SMSER1: CALL    STAKFP          ; Put value on stack
1AFE-7E             4009 (  6)         LD      A,(HL)          ; Get number of coefficients
1AFF-23             4010 (  4)         INC     HL              ; Point to start of table
1B00-CD E2 17       4011 ( 16)         CALL    PHLTFP          ; Move coefficient to FPREG
1B03-06             4012               .DB      06H             ; Skip "POP AF"
1B04-F1             4013 (  9) SUMLP:  POP     AF              ; Restore count
1B05-C1             4014 (  9)         POP     BC              ; Restore number
1B06-D1             4015 (  9)         POP     DE
1B07-3D             4016 (  4)         DEC     A               ; Cont coefficients
1B08-C8             4017 ( 5+)         RET     Z               ; All done
1B09-D5             4018 ( 11)         PUSH    DE              ; Save number
1B0A-C5             4019 ( 11)         PUSH    BC
1B0B-F5             4020 ( 11)         PUSH    AF              ; Save count
1B0C-E5             4021 ( 11)         PUSH    HL              ; Save address in table
1B0D-CD 99 16       4022 ( 16)         CALL    FPMULT          ; Multiply FPREG by BCDE
1B10-E1             4023 (  9)         POP     HL              ; Restore address in table
1B11-CD F3 17       4024 ( 16)         CALL    LOADFP          ; Number at HL to BCDE
1B14-E5             4025 ( 11)         PUSH    HL              ; Save address in table
1B15-CD 5E 15       4026 ( 16)         CALL    FPADD           ; Add coefficient to FPREG
1B18-E1             4027 (  9)         POP     HL              ; Restore address in table
1B19-C3 04 1B       4028 (  9)         JP      SUMLP           ; More coefficients
1B1C-               4029
1B1C-CD A4 17       4030 ( 16) RND:    CALL    TSTSGN          ; Test sign of FPREG
1B1F-21 5E 20       4031 (  9)         LD      HL,SEED+2       ; Random number seed
1B22-FA 7D 1B       4032 ( 6+)         JP      M,RESEED        ; Negative - Re-seed
1B25-21 7F 20       4033 (  9)         LD      HL,LSTRND       ; Last random number
1B28-CD E2 17       4034 ( 16)         CALL    PHLTFP          ; Move last RND to FPREG
1B2B-21 5E 20       4035 (  9)         LD      HL,SEED+2       ; Random number seed
1B2E-C8             4036 ( 5+)         RET     Z               ; Return if RND(0)
1B2F-86             4037 (  6)         ADD     A,(HL)          ; Add (SEED)+2)
1B30-E6 07          4038 (  6)         AND     00000111B       ; 0 to 7
1B32-06 00          4039 (  6)         LD      B,0
1B34-77             4040 (  7)         LD      (HL),A          ; Re-save seed
1B35-23             4041 (  4)         INC     HL              ; Move to coefficient table
1B36-87             4042 (  4)         ADD     A,A             ; 4 bytes
1B37-87             4043 (  4)         ADD     A,A             ; per entry
1B38-4F             4044 (  4)         LD      C,A             ; BC = Offset into table
1B39-09             4045 (  7)         ADD     HL,BC           ; Point to coefficient
1B3A-CD F3 17       4046 ( 16)         CALL    LOADFP          ; Coefficient to BCDE
1B3D-CD 99 16       4047 ( 16)         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
1B40-3A 5D 20       4048 ( 12)         LD      A,(SEED+1)      ; Get (SEED+1)
1B43-3C             4049 (  4)         INC     A               ; Add 1
1B44-E6 03          4050 (  6)         AND     00000011B       ; 0 to 3
1B46-06 00          4051 (  6)         LD      B,0
1B48-FE 01          4052 (  6)         CP      1               ; Is it zero?
1B4A-88             4053 (  4)         ADC     A,B             ; Yes - Make it 1
1B4B-32 5D 20       4054 ( 13)         LD      (SEED+1),A      ; Re-save seed
1B4E-21 81 1B       4055 (  9)         LD      HL,RNDTAB-4     ; Addition table
1B51-87             4056 (  4)         ADD     A,A             ; 4 bytes
1B52-87             4057 (  4)         ADD     A,A             ; per entry
1B53-4F             4058 (  4)         LD      C,A             ; BC = Offset into table
1B54-09             4059 (  7)         ADD     HL,BC           ; Point to value
1B55-CD 4F 15       4060 ( 16)         CALL    ADDPHL          ; Add value to FPREG
1B58-CD F0 17       4061 ( 16) RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
1B5B-7B             4062 (  4)         LD      A,E             ; Get LSB
1B5C-59             4063 (  4)         LD      E,C             ; LSB = MSB
1B5D-EE 4F          4064 (  6)         XOR     01001111B       ; Fiddle around
1B5F-4F             4065 (  4)         LD      C,A             ; New MSB
1B60-36 80          4066 (  9)         LD      (HL),80H        ; Set exponent
1B62-2B             4067 (  4)         DEC     HL              ; Point to MSB
1B63-46             4068 (  6)         LD      B,(HL)          ; Get MSB
1B64-36 80          4069 (  9)         LD      (HL),80H        ; Make value -0.5
1B66-21 5C 20       4070 (  9)         LD      HL,SEED         ; Random number seed
1B69-34             4071 ( 10)         INC     (HL)            ; Count seed
1B6A-7E             4072 (  6)         LD      A,(HL)          ; Get seed
1B6B-D6 AB          4073 (  6)         SUB     171             ; Do it modulo 171
1B6D-C2 74 1B       4074 ( 6+)         JP      NZ,RND2         ; Non-zero - Ok
1B70-77             4075 (  7)         LD      (HL),A          ; Zero seed
1B71-0C             4076 (  4)         INC     C               ; Fillde about
1B72-15             4077 (  4)         DEC     D               ; with the
1B73-1C             4078 (  4)         INC     E               ; number
1B74-CD AF 15       4079 ( 16) RND2:   CALL    BNORM           ; Normalise number
1B77-21 7F 20       4080 (  9)         LD      HL,LSTRND       ; Save random number
1B7A-C3 FC 17       4081 (  9)         JP      FPTHL           ; Move FPREG to last and return
1B7D-               4082
1B7D-77             4083 (  7) RESEED: LD      (HL),A          ; Re-seed random numbers
1B7E-2B             4084 (  4)         DEC     HL
1B7F-77             4085 (  7)         LD      (HL),A
1B80-2B             4086 (  4)         DEC     HL
1B81-77             4087 (  7)         LD      (HL),A
1B82-C3 58 1B       4088 (  9)         JP      RND1            ; Return RND seed
1B85-               4089
1B85-68 B1 46 68    4090       RNDTAB: .DB   068H,0B1H,046H,068H     ; Table used by RND
1B89-99 E9 92 69    4091               .DB   099H,0E9H,092H,069H
1B8D-10 D1 75 68    4092               .DB   010H,0D1H,075H,068H
1B91-               4093
1B91-21 DB 1B       4094 (  9) COS:    LD      HL,HALFPI       ; Point to PI/2
1B94-CD 4F 15       4095 ( 16)         CALL    ADDPHL          ; Add it to PPREG
1B97-CD D5 17       4096 ( 16) SIN:    CALL    STAKFP          ; Put angle on stack
1B9A-01 49 83       4097 (  9)         LD      BC,8349H        ; BCDE = 2 PI
1B9D-11 DB 0F       4098 (  9)         LD      DE,0FDBH
1BA0-CD E5 17       4099 ( 16)         CALL    FPBCDE          ; Move 2 PI to FPREG
1BA3-C1             4100 (  9)         POP     BC              ; Restore angle
1BA4-D1             4101 (  9)         POP     DE
1BA5-CD FA 16       4102 ( 16)         CALL    DVBCDE          ; Divide angle by 2 PI
1BA8-CD D5 17       4103 ( 16)         CALL    STAKFP          ; Put it on stack
1BAB-CD 77 18       4104 ( 16)         CALL    INT             ; Get INT of result
1BAE-C1             4105 (  9)         POP     BC              ; Restore number
1BAF-D1             4106 (  9)         POP     DE
1BB0-CD 5B 15       4107 ( 16)         CALL    SUBCDE          ; Make it 0 <= value < 1
1BB3-21 DF 1B       4108 (  9)         LD      HL,QUARTR       ; Point to 0.25
1BB6-CD 55 15       4109 ( 16)         CALL    SUBPHL          ; Subtract value from 0.25
1BB9-CD A4 17       4110 ( 16)         CALL    TSTSGN          ; Test sign of value
1BBC-37             4111 (  3)         SCF                     ; Flag positive
1BBD-F2 C7 1B       4112 ( 6+)         JP      P,SIN1          ; Positive - Ok
1BC0-CD 4C 15       4113 ( 16)         CALL    ROUND           ; Add 0.5 to value
1BC3-CD A4 17       4114 ( 16)         CALL    TSTSGN          ; Test sign of value
1BC6-B7             4115 (  4)         OR      A               ; Flag negative
1BC7-F5             4116 ( 11) SIN1:   PUSH    AF              ; Save sign
1BC8-F4 CD 17       4117 ( 6+)         CALL    P,INVSGN        ; Negate value if positive
1BCB-21 DF 1B       4118 (  9)         LD      HL,QUARTR       ; Point to 0.25
1BCE-CD 4F 15       4119 ( 16)         CALL    ADDPHL          ; Add 0.25 to value
1BD1-F1             4120 (  9)         POP     AF              ; Restore sign
1BD2-D4 CD 17       4121 ( 6+)         CALL    NC,INVSGN       ; Negative - Make positive
1BD5-21 E3 1B       4122 (  9)         LD      HL,SINTAB       ; Coefficient table
1BD8-C3 EC 1A       4123 (  9)         JP      SUMSER          ; Evaluate sum of series
1BDB-               4124
1BDB-DB 0F 49 81    4125       HALFPI: .DB   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
1BDF-               4126
1BDF-00 00 00 7F    4127       QUARTR: .DB   000H,000H,000H,07FH     ; 0.25
1BE3-               4128
1BE3-05             4129       SINTAB: .DB   5                       ; Table used by SIN
1BE4-BA D7 1E 86    4130               .DB   0BAH,0D7H,01EH,086H     ; 39.711
1BE8-64 26 99 87    4131               .DB   064H,026H,099H,087H     ;-76.575
1BEC-58 34 23 87    4132               .DB   058H,034H,023H,087H     ; 81.602
1BF0-E0 5D A5 86    4133               .DB   0E0H,05DH,0A5H,086H     ;-41.342
1BF4-DA 0F 49 83    4134               .DB   0DAH,00FH,049H,083H     ;  6.2832
1BF8-               4135
1BF8-CD D5 17       4136 ( 16) TAN:    CALL    STAKFP          ; Put angle on stack
1BFB-CD 97 1B       4137 ( 16)         CALL    SIN             ; Get SIN of angle
1BFE-C1             4138 (  9)         POP     BC              ; Restore angle
1BFF-E1             4139 (  9)         POP     HL
1C00-CD D5 17       4140 ( 16)         CALL    STAKFP          ; Save SIN of angle
1C03-EB             4141 (  3)         EX      DE,HL           ; BCDE = Angle
1C04-CD E5 17       4142 ( 16)         CALL    FPBCDE          ; Angle to FPREG
1C07-CD 91 1B       4143 ( 16)         CALL    COS             ; Get COS of angle
1C0A-C3 F8 16       4144 (  9)         JP      DIV             ; TAN = SIN / COS
1C0D-               4145
1C0D-CD A4 17       4146 ( 16) ATN:    CALL    TSTSGN          ; Test sign of value
1C10-FC 38 1A       4147 ( 6+)         CALL    M,NEGAFT        ; Negate result after if -ve
1C13-FC CD 17       4148 ( 6+)         CALL    M,INVSGN        ; Negate value if -ve
1C16-3A 2C 21       4149 ( 12)         LD      A,(FPEXP)       ; Get exponent
1C19-FE 81          4150 (  6)         CP      81H             ; Number less than 1?
1C1B-DA 2A 1C       4151 ( 6+)         JP      C,ATN1          ; Yes - Get arc tangnt
1C1E-01 00 81       4152 (  9)         LD      BC,8100H        ; BCDE = 1
1C21-51             4153 (  4)         LD      D,C
1C22-59             4154 (  4)         LD      E,C
1C23-CD FA 16       4155 ( 16)         CALL    DVBCDE          ; Get reciprocal of number
1C26-21 55 15       4156 (  9)         LD      HL,SUBPHL       ; Sub angle from PI/2
1C29-E5             4157 ( 11)         PUSH    HL              ; Save for angle > 1
1C2A-21 34 1C       4158 (  9) ATN1:   LD      HL,ATNTAB       ; Coefficient table
1C2D-CD EC 1A       4159 ( 16)         CALL    SUMSER          ; Evaluate sum of series
1C30-21 DB 1B       4160 (  9)         LD      HL,HALFPI       ; PI/2 - angle in case > 1
1C33-C9             4161 (  9)         RET                     ; Number > 1 - Sub from PI/2
1C34-               4162
1C34-09             4163       ATNTAB: .DB   9                       ; Table used by ATN
1C35-4A D7 3B 78    4164               .DB   04AH,0D7H,03BH,078H     ; 1/17
1C39-02 6E 84 7B    4165               .DB   002H,06EH,084H,07BH     ;-1/15
1C3D-FE C1 2F 7C    4166               .DB   0FEH,0C1H,02FH,07CH     ; 1/13
1C41-74 31 9A 7D    4167               .DB   074H,031H,09AH,07DH     ;-1/11
1C45-84 3D 5A 7D    4168               .DB   084H,03DH,05AH,07DH     ; 1/9
1C49-C8 7F 91 7E    4169               .DB   0C8H,07FH,091H,07EH     ;-1/7
1C4D-E4 BB 4C 7E    4170               .DB   0E4H,0BBH,04CH,07EH     ; 1/5
1C51-6C AA AA 7F    4171               .DB   06CH,0AAH,0AAH,07FH     ;-1/3
1C55-00 00 00 81    4172               .DB   000H,000H,000H,081H     ; 1/1
1C59-               4173
1C59-               4174
1C59-C9             4175 (  9) ARET:   RET                     ; A RETurn instruction
1C5A-               4176
1C5A-D7             4177 ( 11) GETINP: RST         10H             ;input a character
1C5B-C9             4178 (  9)         RET
1C5C-               4179
1C5C-               4180       CLS:
1C5C-3E 0C          4181 (  6)         LD      A,CS            ; ASCII Clear screen
1C5E-C3 96 1D       4182 (  9)         JP      MONOUT          ; Output character
1C61-               4183
1C61-CD 23 15       4184 ( 16) WIDTH:  CALL    GETINT          ; Get integer 0-255
1C64-7B             4185 (  4)         LD      A,E             ; Width to A
1C65-32 87 20       4186 ( 13)         LD      (LWIDTH),A      ; Set width
1C68-C9             4187 (  9)         RET
1C69-               4188
1C69-CD C2 0D       4189 ( 16) LINES:  CALL    GETNUM          ; Get a number
1C6C-CD 07 0A       4190 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C6F-ED 53 8B 20    4191 ( 20)         LD      (LINESC),DE     ; Set lines counter
1C73-ED 53 8D 20    4192 ( 20)         LD      (LINESN),DE     ; Set lines number
1C77-C9             4193 (  9)         RET
1C78-               4194
1C78-CD 07 0A       4195 ( 16) DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
1C7B-D5             4196 ( 11)         PUSH    DE              ; Save number
1C7C-E1             4197 (  9)         POP     HL              ; Number to HL
1C7D-46             4198 (  6)         LD      B,(HL)          ; Get LSB of contents
1C7E-23             4199 (  4)         INC     HL
1C7F-7E             4200 (  6)         LD      A,(HL)          ; Get MSB of contents
1C80-C3 7D 11       4201 (  9)         JP      ABPASS          ; Return integer AB
1C83-               4202
1C83-CD C2 0D       4203 ( 16) DOKE:   CALL    GETNUM          ; Get a number
1C86-CD 07 0A       4204 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C89-D5             4205 ( 11)         PUSH    DE              ; Save address
1C8A-CD CB 07       4206 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1C8D-2C             4207               .DB      ','
1C8E-CD C2 0D       4208 ( 16)         CALL    GETNUM          ; Get a number
1C91-CD 07 0A       4209 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1C94-E3             4210 ( 16)         EX      (SP),HL         ; Save value,get address
1C95-73             4211 (  7)         LD      (HL),E          ; Save LSB of value
1C96-23             4212 (  4)         INC     HL
1C97-72             4213 (  7)         LD      (HL),D          ; Save MSB of value
1C98-E1             4214 (  9)         POP     HL              ; Restore code string address
1C99-C9             4215 (  9)         RET
1C9A-               4216
1C9A-               4217
1C9A-               4218       ; HEX$(nn) Convert 16 bit number to Hexadecimal string
1C9A-               4219
1C9A-CD C5 0D       4220 ( 16) HEX:    CALL    TSTNUM          ; Verify it's a number
1C9D-CD 07 0A       4221 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1CA0-C5             4222 ( 11)         PUSH    BC              ; Save contents of BC
1CA1-21 2E 21       4223 (  9)         LD          HL,PBUFF
1CA4-7A             4224 (  4)         LD          A,D             ; Get high order into A
1CA5-FE 00          4225 (  6)         CP      $0
1CA7-28 0C          4226 ( 6+)                 JR      Z,HEX2          ; Skip output if both high digits are zero
1CA9-CD D2 1C       4227 ( 16)         CALL    BYT2ASC         ; Convert D to ASCII
1CAC-78             4228 (  4)                 LD      A,B
1CAD-FE 30          4229 (  6)                 CP      '0'
1CAF-28 02          4230 ( 6+)                 JR      Z,HEX1          ; Don't store high digit if zero
1CB1-70             4231 (  7)         LD          (HL),B          ; Store it to PBUFF
1CB2-23             4232 (  4)         INC         HL              ; Next location
1CB3-71             4233 (  7) HEX1:   LD          (HL),C          ; Store C to PBUFF+1
1CB4-23             4234 (  4)         INC     HL              ; Next location
1CB5-7B             4235 (  4) HEX2:   LD          A,E             ; Get lower byte
1CB6-CD D2 1C       4236 ( 16)         CALL    BYT2ASC         ; Convert E to ASCII
1CB9-7A             4237 (  4)                 LD      A,D
1CBA-FE 00          4238 (  6)         CP      $0
1CBC-20 05          4239 ( 6+)                 JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
1CBE-78             4240 (  4)                 LD      A,B
1CBF-FE 30          4241 (  6)                 CP      '0'             ; If high digit of lower byte is zero then don't print
1CC1-28 02          4242 ( 6+)                 JR      Z,HEX4
1CC3-70             4243 (  7) HEX3:   LD      (HL),B          ; to PBUFF+2
1CC4-23             4244 (  4)         INC     HL              ; Next location
1CC5-71             4245 (  7) HEX4:   LD      (HL),C          ; to PBUFF+3
1CC6-23             4246 (  4)         INC     HL              ; PBUFF+4 to zero
1CC7-AF             4247 (  4)         XOR     A               ; Terminating character
1CC8-77             4248 (  7)         LD      (HL),A          ; Store zero to terminate
1CC9-23             4249 (  4)         INC     HL              ; Make sure PBUFF is terminated
1CCA-77             4250 (  7)         LD      (HL),A          ; Store the double zero there
1CCB-C1             4251 (  9)         POP     BC              ; Get BC back
1CCC-21 2E 21       4252 (  9)         LD      HL,PBUFF        ; Reset to start of PBUFF
1CCF-C3 2B 12       4253 (  9)         JP      STR1            ; Convert the PBUFF to a string and return it
1CD2-               4254
1CD2-47             4255 (  4) BYT2ASC LD      B,A             ; Save original value
1CD3-E6 0F          4256 (  6)         AND     $0F             ; Strip off upper nybble
1CD5-FE 0A          4257 (  6)         CP      $0A             ; 0-9?
1CD7-38 02          4258 ( 6+)         JR      C,ADD30         ; If A-F, add 7 more
1CD9-C6 07          4259 (  6)         ADD     A,$07           ; Bring value up to ASCII A-F
1CDB-C6 30          4260 (  6) ADD30   ADD     A,$30           ; And make ASCII
1CDD-4F             4261 (  4)         LD      C,A             ; Save converted char to C
1CDE-78             4262 (  4)         LD      A,B             ; Retrieve original value
1CDF-0F             4263 (  3)         RRCA                    ; and Rotate it right
1CE0-0F             4264 (  3)         RRCA
1CE1-0F             4265 (  3)         RRCA
1CE2-0F             4266 (  3)         RRCA
1CE3-E6 0F          4267 (  6)         AND     $0F             ; Mask off upper nybble
1CE5-FE 0A          4268 (  6)         CP      $0A             ; 0-9? < A hex?
1CE7-38 02          4269 ( 6+)         JR      C,ADD301        ; Skip Add 7
1CE9-C6 07          4270 (  6)         ADD     A,$07           ; Bring it up to ASCII A-F
1CEB-C6 30          4271 (  6) ADD301  ADD     A,$30           ; And make it full ASCII
1CED-47             4272 (  4)         LD      B,A             ; Store high order byte
1CEE-C9             4273 (  9)         RET
1CEF-               4274
1CEF-               4275       ; Convert "&Hnnnn" to FPREG
1CEF-               4276       ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
1CEF-               4277       ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
1CEF-EB             4278 (  3) HEXTFP  EX      DE,HL           ; Move code string pointer to DE
1CF0-21 00 00       4279 (  9)         LD      HL,$0000        ; Zero out the value
1CF3-CD 08 1D       4280 ( 16)         CALL    GETHEX          ; Check the number for valid hex
1CF6-DA 28 1D       4281 ( 6+)         JP      C,HXERR         ; First value wasn't hex, HX error
1CF9-18 05          4282 (  8)         JR      HEXLP1          ; Convert first character
1CFB-CD 08 1D       4283 ( 16) HEXLP   CALL    GETHEX          ; Get second and addtional characters
1CFE-38 1F          4284 ( 6+)         JR      C,HEXIT         ; Exit if not a hex character
1D00-29             4285 (  7) HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
1D01-29             4286 (  7)         ADD     HL,HL
1D02-29             4287 (  7)         ADD     HL,HL
1D03-29             4288 (  7)         ADD     HL,HL
1D04-B5             4289 (  4)         OR      L               ; Add in D0-D3 into L
1D05-6F             4290 (  4)         LD      L,A             ; Save new value
1D06-18 F3          4291 (  8)         JR      HEXLP           ; And continue until all hex characters are in
1D08-               4292
1D08-13             4293 (  4) GETHEX  INC     DE              ; Next location
1D09-1A             4294 (  6)         LD      A,(DE)          ; Load character at pointer
1D0A-FE 20          4295 (  6)         CP      ' '
1D0C-CA 08 1D       4296 ( 6+)         JP      Z,GETHEX        ; Skip spaces
1D0F-D6 30          4297 (  6)         SUB     $30             ; Get absolute value
1D11-D8             4298 ( 5+)         RET     C               ; < "0", error
1D12-FE 0A          4299 (  6)         CP      $0A
1D14-38 05          4300 ( 6+)         JR      C,NOSUB7        ; Is already in the range 0-9
1D16-D6 07          4301 (  6)         SUB     $07             ; Reduce to A-F
1D18-FE 0A          4302 (  6)         CP      $0A             ; Value should be $0A-$0F at this point
1D1A-D8             4303 ( 5+)         RET     C               ; CY set if was :            ; < = > ? @
1D1B-FE 10          4304 (  6) NOSUB7  CP      $10             ; > Greater than "F"?
1D1D-3F             4305 (  3)         CCF
1D1E-C9             4306 (  9)         RET                     ; CY set if it wasn't valid hex
1D1F-               4307
1D1F-EB             4308 (  3) HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
1D20-7A             4309 (  4)         LD      A,D             ; Load DE into AC
1D21-4B             4310 (  4)         LD      C,E             ; For prep to
1D22-E5             4311 ( 11)         PUSH    HL
1D23-CD 7C 11       4312 ( 16)         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1D26-E1             4313 (  9)         POP     HL
1D27-C9             4314 (  9)         RET
1D28-               4315
1D28-1E 26          4316 (  6) HXERR:  LD      E,HX            ; ?HEX Error
1D2A-C3 11 05       4317 (  9)         JP      ERROR
1D2D-               4318
1D2D-               4319       ; BIN$(NN) Convert integer to a 1-16 char binary string
1D2D-CD C5 0D       4320 ( 16) BIN:    CALL    TSTNUM          ; Verify it's a number
1D30-CD 07 0A       4321 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1D33-C5             4322 ( 11) BIN2:   PUSH    BC              ; Save contents of BC
1D34-21 2E 21       4323 (  9)         LD      HL,PBUFF
1D37-06 11          4324 (  6)         LD      B,17            ; One higher than max char count
1D39-               4325       ZEROSUP:                        ; Suppress leading zeros
1D39-05             4326 (  4)         DEC     B               ; Max 16 chars
1D3A-78             4327 (  4)         LD      A,B
1D3B-FE 01          4328 (  6)         CP      $01
1D3D-28 08          4329 ( 6+)         JR      Z,BITOUT        ; Always output at least one character
1D3F-CB 13          4330 (  7)         RL      E
1D41-CB 12          4331 (  7)         RL      D
1D43-30 F4          4332 ( 6+)         JR      NC,ZEROSUP
1D45-18 04          4333 (  8)         JR      BITOUT2
1D47-               4334       BITOUT:
1D47-CB 13          4335 (  7)         RL      E
1D49-CB 12          4336 (  7)         RL      D               ; Top bit now in carry
1D4B-               4337       BITOUT2:
1D4B-3E 30          4338 (  6)         LD      A,'0'           ; Char for '0'
1D4D-CE 00          4339 (  6)         ADC     A,0             ; If carry set then '0' --> '1'
1D4F-77             4340 (  7)         LD      (HL),A
1D50-23             4341 (  4)         INC     HL
1D51-05             4342 (  4)         DEC     B
1D52-20 F3          4343 ( 6+)         JR      NZ,BITOUT
1D54-AF             4344 (  4)         XOR     A               ; Terminating character
1D55-77             4345 (  7)         LD      (HL),A          ; Store zero to terminate
1D56-23             4346 (  4)         INC     HL              ; Make sure PBUFF is terminated
1D57-77             4347 (  7)         LD      (HL),A          ; Store the double zero there
1D58-C1             4348 (  9)         POP     BC
1D59-21 2E 21       4349 (  9)         LD      HL,PBUFF
1D5C-C3 2B 12       4350 (  9)         JP      STR1
1D5F-               4351
1D5F-               4352       ; Convert "&Bnnnn" to FPREG
1D5F-               4353       ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1D5F-EB             4354 (  3) BINTFP: EX      DE,HL           ; Move code string pointer to DE
1D60-21 00 00       4355 (  9)         LD      HL,$0000        ; Zero out the value
1D63-CD 7C 1D       4356 ( 16)         CALL    CHKBIN          ; Check the number for valid bin
1D66-DA 8A 1D       4357 ( 6+)         JP      C,BINERR        ; First value wasn't bin, HX error
1D69-D6 30          4358 (  6) BINIT:  SUB     '0'
1D6B-29             4359 (  7)         ADD     HL,HL           ; Rotate HL left
1D6C-B5             4360 (  4)         OR      L
1D6D-6F             4361 (  4)         LD      L,A
1D6E-CD 7C 1D       4362 ( 16)         CALL    CHKBIN          ; Get second and addtional characters
1D71-30 F6          4363 ( 6+)         JR      NC,BINIT        ; Process if a bin character
1D73-EB             4364 (  3)         EX      DE,HL           ; Value into DE, Code string into HL
1D74-7A             4365 (  4)         LD      A,D             ; Load DE into AC
1D75-4B             4366 (  4)         LD      C,E             ; For prep to
1D76-E5             4367 ( 11)         PUSH    HL
1D77-CD 7C 11       4368 ( 16)         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1D7A-E1             4369 (  9)         POP     HL
1D7B-C9             4370 (  9)         RET
1D7C-               4371
1D7C-               4372       ; Char is in A, NC if char is 0 or 1
1D7C-13             4373 (  4) CHKBIN: INC     DE
1D7D-1A             4374 (  6)         LD      A,(DE)
1D7E-FE 20          4375 (  6)         CP      ' '
1D80-CA 7C 1D       4376 ( 6+)         JP      Z,CHKBIN        ; Skip spaces
1D83-FE 30          4377 (  6)         CP      '0'             ; Set C if < '0'
1D85-D8             4378 ( 5+)         RET     C
1D86-FE 32          4379 (  6)         CP      '2'
1D88-3F             4380 (  3)         CCF                     ; Set C if > '1'
1D89-C9             4381 (  9)         RET
1D8A-               4382
1D8A-1E 28          4383 (  6) BINERR: LD      E,BN            ; ?BIN Error
1D8C-C3 11 05       4384 (  9)         JP      ERROR
1D8F-               4385
1D8F-               4386
1D8F-               4387       JJUMP1:
1D8F-DD 21 FF FF    4388 ( 12)         LD      IX,-1           ; Flag cold start
1D93-C3 61 01       4389 (  9)         JP      CSTART          ; Go and initialise
1D96-               4390
1D96-               4391       MONOUT:
1D96-C3 08 00       4392 (  9)         JP      $0008           ; output a char
1D99-               4393
1D99-               4394
1D99-               4395       MONITR:
1D99-C3 00 00       4396 (  9)         JP      $0000           ; Restart (Normally Monitor Start)
1D9C-               4397
1D9C-               4398
1D9C-3E 00          4399 (  6) INITST: LD      A,0             ; Clear break flag
1D9E-32 92 20       4400 ( 13)         LD      (BRKFLG),A
1DA1-C3 68 01       4401 (  9)         JP      INIT
1DA4-               4402
1DA4-ED 45          4403 ( 12) ARETN:  RETN                    ; Return from NMI
1DA6-               4404
1DA6-               4405
1DA6-F5             4406 ( 11) TSTBIT: PUSH    AF              ; Save bit mask
1DA7-A0             4407 (  4)         AND     B               ; Get common bits
1DA8-C1             4408 (  9)         POP     BC              ; Restore bit mask
1DA9-B8             4409 (  4)         CP      B               ; Same bit set?
1DAA-3E 00          4410 (  6)         LD      A,0             ; Return 0 in A
1DAC-C9             4411 (  9)         RET
1DAD-               4412
1DAD-CD D6 07       4413 ( 16) OUTNCR: CALL    OUTC            ; Output character in A
1DB0-C3 FD 0B       4414 (  9)         JP      PRNTCRLF        ; Output CRLF
1DB3-               4415
1DB3-               4416       .end
1DB3-               4417
