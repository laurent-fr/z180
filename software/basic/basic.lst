0000-                 18       ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0000-                 19       ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0000-                 20       ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0000-                 21       ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0000-                 22       ; the original ROM code (checksum A934H). PA
0000-                 23
0000-                 24       ; GENERAL EQUATES
0000-                 25
0003-                 26       CTRLC   .EQU    03H             ; Control "C"
0007-                 27       CTRLG   .EQU    07H             ; Control "G"
0008-                 28       BKSP    .EQU    08H             ; Back space
000A-                 29       LF      .EQU    0AH             ; Line feed
000C-                 30       CS      .EQU    0CH             ; Clear screen
000D-                 31       CR      .EQU    0DH             ; Carriage return
000F-                 32       CTRLO   .EQU    0FH             ; Control "O"
0011-                 33       CTRLQ   .EQU    11H                     ; Control "Q"
0012-                 34       CTRLR   .EQU    12H             ; Control "R"
0013-                 35       CTRLS   .EQU    13H             ; Control "S"
0015-                 36       CTRLU   .EQU    15H             ; Control "U"
001B-                 37       ESC     .EQU    1BH             ; Escape
007F-                 38       DEL     .EQU    7FH             ; Delete
0000-                 39
0000-                 40       ; BASIC WORK SPACE LOCATIONS
0000-                 41
2245-                 42       WRKSPC  .EQU    2245H             ; BASIC Work space
2248-                 43       USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
224B-                 44       OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
224C-                 45       OTPORT  .EQU    WRKSPC+7H           ; Port (p)
224E-                 46       DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
224F-                 47       DIV1    .EQU    WRKSPC+0AH           ; <- Values
2253-                 48       DIV2    .EQU    WRKSPC+0EH           ; <-   to
2257-                 49       DIV3    .EQU    WRKSPC+12H           ; <-   be
225A-                 50       DIV4    .EQU    WRKSPC+15H           ; <-inserted
225C-                 51       SEED    .EQU    WRKSPC+17H           ; Random number seed
227F-                 52       LSTRND  .EQU    WRKSPC+3AH           ; Last random number
2283-                 53       INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
2284-                 54       INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
2286-                 55       NULLS   .EQU    WRKSPC+41H           ; Number of nulls
2287-                 56       LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
2288-                 57       COMMAN  .EQU    WRKSPC+43H           ; Width for commas
2289-                 58       NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
228A-                 59       CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
228B-                 60       LINESC  .EQU    WRKSPC+46H           ; Lines counter
228D-                 61       LINESN  .EQU    WRKSPC+48H           ; Lines number
228F-                 62       CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
2291-                 63       NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
2292-                 64       BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
2293-                 65       RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
2296-                 66       POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
2299-                 67       PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
229C-                 68       RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
229F-                 69       STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
22A1-                 70       LINEAT  .EQU    WRKSPC+5CH           ; Current line number
22A3-                 71       BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
22A6-                 72       BUFFER  .EQU    WRKSPC+61H           ; Input buffer
22AB-                 73       STACK   .EQU    WRKSPC+66H           ; Initial stack
22F0-                 74       CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
22F1-                 75       LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
22F2-                 76       TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
22F3-                 77       DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
22F4-                 78       LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
22F6-                 79       TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
22F8-                 80       TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
2304-                 81       TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
2308-                 82       STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
230A-                 83       CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
230C-                 84       LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
230E-                 85       DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
2310-                 86       FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
2311-                 87       LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
2312-                 88       READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
2313-                 89       BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
2315-                 90       NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
2317-                 91       ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
2319-                 92       CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
231B-                 93       PROGND  .EQU    WRKSPC+0D6H          ; End of program
231D-                 94       VAREND  .EQU    WRKSPC+0D8H          ; End of variables
231F-                 95       ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
2321-                 96       NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
2323-                 97       FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
2325-                 98       FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
2329-                 99       FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
232C-                100       FPEXP   .EQU    FPREG+3         ; Floating point exponent
232D-                101       SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
232E-                102       PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
233B-                103       MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
233E-                104       PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
23A2-                105       STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0000-                106
0000-                107       ; BASIC ERROR CODE VALUES
0000-                108
0000-                109       NF      .EQU    00H             ; NEXT without FOR
0002-                110       SN      .EQU    02H             ; Syntax error
0004-                111       RG      .EQU    04H             ; RETURN without GOSUB
0006-                112       OD      .EQU    06H             ; Out of DATA
0008-                113       FC      .EQU    08H             ; Function call error
000A-                114       OV      .EQU    0AH             ; Overflow
000C-                115       OM      .EQU    0CH             ; Out of memory
000E-                116       UL      .EQU    0EH             ; Undefined line number
0010-                117       BS      .EQU    10H             ; Bad subscript
0012-                118       DD      .EQU    12H             ; Re-DIMensioned array
0014-                119       DZ      .EQU    14H             ; Division by zero (/0)
0016-                120       ID      .EQU    16H             ; Illegal direct
0018-                121       TM      .EQU    18H             ; Type miss-match
001A-                122       OS      .EQU    1AH             ; Out of string space
001C-                123       LS      .EQU    1CH             ; String too long
001E-                124       ST      .EQU    1EH             ; String formula too complex
0020-                125       CN      .EQU    20H             ; Can't CONTinue
0022-                126       UF      .EQU    22H             ; UnDEFined FN function
0024-                127       MO      .EQU    24H             ; Missing operand
0026-                128       HX      .EQU    26H             ; HEX error
0028-                129       BN      .EQU    28H             ; BIN error
0000-                130
0000-                131               ;.ORG    00150H
0300-                132               .ORG    00300H
0300-                133
0300-C3 06 03        134 (  9) COLD:   JP      STARTB          ; Jump for cold start
0303-C3 A4 03        135 (  9) WARM:   JP      WARMST          ; Jump for warm start
0306-                136       STARTB:
0306-DD 21 00 00     137 ( 12)         LD      IX,0            ; Flag cold start
030A-C3 11 03        138 (  9)         JP      CSTART          ; Jump to initialise
030D-                139
030D-B7 0B           140               .DW   DEINT           ; Get integer -32768 to 32767
030F-2D 13           141               .DW   ABPASS          ; Return integer in AB
0311-                142
0311-                143
0311-21 45 22        144 (  9) CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0314-F9              145 (  4)         LD      SP,HL           ; Set up a temporary stack
0315-C3 4C 1F        146 (  9)         JP      INITST          ; Go to initialise
0318-                147
0318-11 DE 05        148 (  9) INIT:   LD      DE,INITAB       ; Initialise workspace
031B-06 63           149 (  6)         LD      B,INITBE-INITAB+3 ; Bytes to copy
031D-21 45 22        150 (  9)         LD      HL,WRKSPC       ; Into workspace RAM
0320-1A              151 (  6) COPY:   LD      A,(DE)          ; Get source
0321-77              152 (  7)         LD      (HL),A          ; To destination
0322-23              153 (  4)         INC     HL              ; Next destination
0323-13              154 (  4)         INC     DE              ; Next source
0324-05              155 (  4)         DEC     B               ; Count bytes
0325-C2 20 03        156 ( 6+)         JP      NZ,COPY         ; More to move
0328-F9              157 (  4)         LD      SP,HL           ; Temporary stack
0329-CD DF 07        158 ( 16)         CALL    CLREG           ; Clear registers and stack
032C-CD AD 0D        159 ( 16)         CALL    PRNTCRLF        ; Output CRLF
032F-32 EF 22        160 ( 13)         LD      (BUFFER+72+1),A ; Mark end of buffer
0332-32 3E 23        161 ( 13)         LD      (PROGST),A      ; Initialise program area
0335-21 F3 03        162 (  9) MSIZE:  LD      HL,MEMMSG       ; Point to message
0338-CD 4B 14        163 ( 16)         CALL    PRS             ; Output "Memory size"
033B-CD FC 07        164 ( 16)         CALL    PROMPT          ; Get input with '?'
033E-CD 05 0B        165 ( 16)         CALL    GETCHR          ; Get next character
0341-B7              166 (  4)         OR      A               ; Set flags
0342-C2 5A 03        167 ( 6+)         JP      NZ,TSTMEM       ; If number - Test if RAM there
0345-21 A2 23        168 (  9)         LD      HL,STLOOK       ; Point to start of RAM
0348-23              169 (  4) MLOOP:  INC     HL              ; Next byte
0349-7C              170 (  4)         LD      A,H             ; Above address FFFF ?
034A-B5              171 (  4)         OR      L
034B-CA 6C 03        172 ( 6+)         JP      Z,SETTOP        ; Yes - 64K RAM
034E-7E              173 (  6)         LD      A,(HL)          ; Get contents
034F-47              174 (  4)         LD      B,A             ; Save it
0350-2F              175 (  3)         CPL                     ; Flip all bits
0351-77              176 (  7)         LD      (HL),A          ; Put it back
0352-BE              177 (  6)         CP      (HL)            ; RAM there if same
0353-70              178 (  7)         LD      (HL),B          ; Restore old contents
0354-CA 48 03        179 ( 6+)         JP      Z,MLOOP         ; If RAM - test next byte
0357-C3 6C 03        180 (  9)         JP      SETTOP          ; Top of RAM found
035A-                181
035A-CD D1 0B        182 ( 16) TSTMEM: CALL    ATOH            ; Get high memory into DE
035D-B7              183 (  4)         OR      A               ; Set flags on last byte
035E-C2 AD 06        184 ( 6+)         JP      NZ,SNERR        ; ?SN Error if bad character
0361-EB              185 (  3)         EX      DE,HL           ; Address into HL
0362-2B              186 (  4)         DEC     HL              ; Back one byte
0363-3E D9           187 (  6)         LD      A,11011001B     ; Test byte
0365-46              188 (  6)         LD      B,(HL)          ; Get old contents
0366-77              189 (  7)         LD      (HL),A          ; Load test byte
0367-BE              190 (  6)         CP      (HL)            ; RAM there if same
0368-70              191 (  7)         LD      (HL),B          ; Restore old contents
0369-C2 35 03        192 ( 6+)         JP      NZ,MSIZE        ; Ask again if no RAM
036C-                193
036C-2B              194 (  4) SETTOP: DEC     HL              ; Back one byte
036D-11 A1 23        195 (  9)         LD      DE,STLOOK-1     ; See if enough RAM
0370-CD 75 09        196 ( 16)         CALL    CPDEHL          ; Compare DE with HL
0373-DA 35 03        197 ( 6+)         JP      C,MSIZE         ; Ask again if not enough RAM
0376-11 CE FF        198 (  9)         LD      DE,0-50         ; 50 Bytes string space
0379-22 F4 22        199 ( 20)         LD      (LSTRAM),HL     ; Save last available RAM
037C-19              200 (  7)         ADD     HL,DE           ; Allocate string space
037D-22 9F 22        201 ( 20)         LD      (STRSPC),HL     ; Save string space
0380-CD BA 07        202 ( 16)         CALL    CLRPTR          ; Clear program area
0383-2A 9F 22        203 ( 15)         LD      HL,(STRSPC)     ; Get end of memory
0386-11 EF FF        204 (  9)         LD      DE,0-17         ; Offset for free bytes
0389-19              205 (  7)         ADD     HL,DE           ; Adjust HL
038A-11 3E 23        206 (  9)         LD      DE,PROGST       ; Start of program text
038D-7D              207 (  4)         LD      A,L             ; Get LSB
038E-93              208 (  4)         SUB     E               ; Adjust it
038F-6F              209 (  4)         LD      L,A             ; Re-save
0390-7C              210 (  4)         LD      A,H             ; Get MSB
0391-9A              211 (  4)         SBC     A,D             ; Adjust it
0392-67              212 (  4)         LD      H,A             ; Re-save
0393-E5              213 ( 11)         PUSH    HL              ; Save bytes free
0394-21 BC 03        214 (  9)         LD      HL,SIGNON       ; Sign-on message
0397-CD 4B 14        215 ( 16)         CALL    PRS             ; Output string
039A-E1              216 (  9)         POP     HL              ; Get bytes free back
039B-CD EE 1A        217 ( 16)         CALL    PRNTHL          ; Output amount of free memory
039E-21 AD 03        218 (  9)         LD      HL,BFREE        ; " Bytes free" message
03A1-CD 4B 14        219 ( 16)         CALL    PRS             ; Output string
03A4-                220
03A4-31 AB 22        221 (  9) WARMST: LD      SP,STACK        ; Temporary stack
03A7-CD DF 07        222 ( 16) BRKRET: CALL    CLREG           ; Clear registers and stack
03AA-C3 F8 06        223 (  9)         JP      PRNTOK          ; Go to get command line
03AD-                224
03AD-20 42 79 74 
     65 73 20 66 
     72 65 65 0D 
     0A 00 00        225       BFREE:  .DB   " Bytes free",CR,LF,0,0
03BC-                226
03BC-5A 38 30 20 
     42 41 53 49 
     43 20 56 65 
     72 20 34 2E 
     37 62 0D 0A     227       SIGNON: .DB   "Z80 BASIC Ver 4.7b",CR,LF
03D0-43 6F 70 79 
     72 69 67 68 
     74 20 28 43 
     29              228               .DB   "Copyright ",40,"C",41
03DD-20 31 39 37 
     38 20 62 79 
     20 4D 69 63 
     72 6F 73 6F 
     66 74 0D 0A 
     00 00           229               .DB   " 1978 by Microsoft",CR,LF,0,0
03F3-                230
03F3-4D 65 6D 6F 
     72 79 20 74 
     6F 70 00        231       MEMMSG: .DB   "Memory top",0
03FE-                232
03FE-                233       ; FUNCTION ADDRESS TABLE
03FE-                234
03FE-63 19           235       FNCTAB: .DW   SGN
0400-27 1A           236               .DW   INT
0402-79 19           237               .DW   ABS
0404-48 22           238               .DW   USR
0406-0B 13           239               .DW   FRE
0408-90 16           240               .DW   INP
040A-39 13           241               .DW   POS
040C-ED 1B           242               .DW   SQR
040E-CC 1C           243               .DW   RND
0410-08 18           244               .DW   LOG
0412-3B 1C           245               .DW   EXP
0414-41 1D           246               .DW   COS
0416-47 1D           247               .DW   SIN
0418-A8 1D           248               .DW   TAN
041A-BD 1D           249               .DW   ATN
041C-E4 16           250               .DW   PEEK
041E-28 1E           251               .DW   DEEK
0420-96 22           252               .DW   POINT
0422-BD 15           253               .DW   LEN
0424-D5 13           254               .DW   STR
0426-57 16           255               .DW   VAL
0428-CC 15           256               .DW   ASC
042A-DD 15           257               .DW   CHR
042C-4A 1E           258               .DW   HEX
042E-DD 1E           259               .DW   BIN
0430-ED 15           260               .DW   LEFT
0432-1D 16           261               .DW   RIGHT
0434-27 16           262               .DW   MID
0436-                263
0436-                264       ; RESERVED WORD LIST
0436-                265
0436-C5              266       WORDS:  .AT   'E'
0437-4E 44           267               .DB "ND"
0439-C6              268               .AT   'F'
043A-4F 52           269               .DB "OR"
043C-CE              270               .AT   'N'
043D-45 58 54        271               .DB "EXT"
0440-C4              272               .AT   'D'
0441-41 54 41        273               .DB "ATA"
0444-C9              274               .AT   'I'
0445-4E 50 55 54     275               .DB "NPUT"
0449-C4              276               .AT   'D'
044A-49 4D           277               .DB "IM"
044C-D2              278               .AT   'R'
044D-45 41 44        279               .DB "EAD"
0450-CC              280               .AT   'L'
0451-45 54           281               .DB "ET"
0453-C7              282               .AT   'G'
0454-4F 54 4F        283               .DB "OTO"
0457-D2              284               .AT   'R'
0458-55 4E           285               .DB "UN"
045A-C9              286               .AT   'I'
045B-46              287               .DB "F"
045C-D2              288               .AT   'R'
045D-45 53 54 4F 
     52 45           289               .DB "ESTORE"
0463-C7              290               .AT   'G'
0464-4F 53 55 42     291               .DB "OSUB"
0468-D2              292               .AT   'R'
0469-45 54 55 52 
     4E              293               .DB "ETURN"
046E-D2              294               .AT   'R'
046F-45 4D           295               .DB "EM"
0471-D3              296               .AT   'S'
0472-54 4F 50        297               .DB "TOP"
0475-CF              298               .AT   'O'
0476-55 54           299               .DB "UT"
0478-CF              300               .AT   'O'
0479-4E              301               .DB "N"
047A-CE              302               .AT   'N'
047B-55 4C 4C        303               .DB "ULL"
047E-D7              304               .AT   'W'
047F-41 49 54        305               .DB "AIT"
0482-C4              306               .AT   'D'
0483-45 46           307               .DB "EF"
0485-D0              308               .AT   'P'
0486-4F 4B 45        309               .DB "OKE"
0489-C4              310               .AT   'D'
048A-4F 4B 45        311               .DB "OKE"
048D-D3              312               .AT   'S'
048E-43 52 45 45 
     4E              313               .DB "CREEN"
0493-CC              314               .AT   'L'
0494-49 4E 45 53     315               .DB "INES"
0498-C3              316               .AT   'C'
0499-4C 53           317               .DB "LS"
049B-D7              318               .AT   'W'
049C-49 44 54 48     319               .DB "IDTH"
04A0-CD              320               .AT   'M'
04A1-4F 4E 49 54 
     4F 52           321               .DB "ONITOR"
04A7-D3              322               .AT   'S'
04A8-45 54           323               .DB "ET"
04AA-D2              324               .AT   'R'
04AB-45 53 45 54     325               .DB "ESET"
04AF-D0              326               .AT   'P'
04B0-52 49 4E 54     327               .DB "RINT"
04B4-C3              328               .AT   'C'
04B5-4F 4E 54        329               .DB "ONT"
04B8-CC              330               .AT   'L'
04B9-49 53 54        331               .DB "IST"
04BC-C3              332               .AT   'C'
04BD-4C 45 41 52     333               .DB "LEAR"
04C1-C3              334               .AT   'C'
04C2-4C 4F 41 44     335               .DB "LOAD"
04C6-C3              336               .AT   'C'
04C7-53 41 56 45     337               .DB "SAVE"
04CB-CE              338               .AT   'N'
04CC-45 57           339               .DB "EW"
04CE-                340
04CE-D4              341               .AT   'T'
04CF-41 42 28        342               .DB "AB("
04D2-D4              343               .AT   'T'
04D3-4F              344               .DB "O"
04D4-C6              345               .AT   'F'
04D5-4E              346               .DB "N"
04D6-D3              347               .AT   'S'
04D7-50 43 28        348               .DB "PC("
04DA-D4              349               .AT   'T'
04DB-48 45 4E        350               .DB "HEN"
04DE-CE              351               .AT   'N'
04DF-4F 54           352               .DB "OT"
04E1-D3              353               .AT   'S'
04E2-54 45 50        354               .DB "TEP"
04E5-                355
04E5-AB              356               .AT   '+'
04E6-AD              357               .AT   '-'
04E7-AA              358               .AT   '*'
04E8-AF              359               .AT   '/'
04E9-DE              360               .AT   '^'
04EA-C1              361               .AT   'A'
04EB-4E 44           362               .DB "ND"
04ED-CF              363               .AT   'O'
04EE-52              364               .DB "R"
04EF-BE              365               .AT   '>'
04F0-BD              366               .AT   '='
04F1-BC              367               .AT   '<'
04F2-                368
04F2-D3              369               .AT   'S'
04F3-47 4E           370               .DB "GN"
04F5-C9              371               .AT   'I'
04F6-4E 54           372               .DB "NT"
04F8-C1              373               .AT   'A'
04F9-42 53           374               .DB "BS"
04FB-D5              375               .AT   'U'
04FC-53 52           376               .DB "SR"
04FE-C6              377               .AT   'F'
04FF-52 45           378               .DB "RE"
0501-C9              379               .AT   'I'
0502-4E 50           380               .DB "NP"
0504-D0              381               .AT   'P'
0505-4F 53           382               .DB "OS"
0507-D3              383               .AT   'S'
0508-51 52           384               .DB "QR"
050A-D2              385               .AT   'R'
050B-4E 44           386               .DB "ND"
050D-CC              387               .AT   'L'
050E-4F 47           388               .DB "OG"
0510-C5              389               .AT   'E'
0511-58 50           390               .DB "XP"
0513-C3              391               .AT   'C'
0514-4F 53           392               .DB "OS"
0516-D3              393               .AT   'S'
0517-49 4E           394               .DB "IN"
0519-D4              395               .AT   'T'
051A-41 4E           396               .DB "AN"
051C-C1              397               .AT   'A'
051D-54 4E           398               .DB "TN"
051F-D0              399               .AT   'P'
0520-45 45 4B        400               .DB "EEK"
0523-C4              401               .AT   'D'
0524-45 45 4B        402               .DB "EEK"
0527-D0              403               .AT   'P'
0528-4F 49 4E 54     404               .DB "OINT"
052C-CC              405               .AT   'L'
052D-45 4E           406               .DB "EN"
052F-D3              407               .AT   'S'
0530-54 52 24        408               .DB "TR$"
0533-D6              409               .AT   'V'
0534-41 4C           410               .DB "AL"
0536-C1              411               .AT   'A'
0537-53 43           412               .DB "SC"
0539-C3              413               .AT   'C'
053A-48 52 24        414               .DB "HR$"
053D-C8              415               .AT   'H'
053E-45 58 24        416               .DB "EX$"
0541-C2              417               .AT   'B'
0542-49 4E 24        418               .DB "IN$"
0545-CC              419               .AT   'L'
0546-45 46 54 24     420               .DB "EFT$"
054A-D2              421               .AT   'R'
054B-49 47 48 54 
     24              422               .DB "IGHT$"
0550-CD              423               .AT   'M'
0551-49 44 24        424               .DB "ID$"
0554-80              425               .DB   80H             ; End of list marker
0555-                426
0555-                427       ; KEYWORD ADDRESS TABLE
0555-                428
0555-4F 0B           429       WORDTB: .DW   PEND
0557-4C 0A           430               .DW   FOR
0559-27 0F           431               .DW   NEXT
055B-9C 0C           432               .DW   DATA
055D-2E 0E           433               .DW   INPUT
055F-63 11           434               .DW   DIM
0561-5D 0E           435               .DW   READ
0563-B3 0C           436               .DW   LET
0565-59 0C           437               .DW   GOTO
0567-3C 0C           438               .DW   RUN
0569-2B 0D           439               .DW   IF
056B-15 0B           440               .DW   RESTOR
056D-48 0C           441               .DW   GOSUB
056F-77 0C           442               .DW   RETURN
0571-9E 0C           443               .DW   REM
0573-4D 0B           444               .DW   STOP
0575-9C 16           445               .DW   POUT
0577-0D 0D           446               .DW   ON
0579-8E 0B           447               .DW   NULL
057B-A2 16           448               .DW   WAIT
057D-41 13           449               .DW   DEF
057F-EB 16           450               .DW   POKE
0581-33 1E           451               .DW   DOKE
0583-9E 0C           452               .DW   REM
0585-19 1E           453               .DW   LINES
0587-0C 1E           454               .DW   CLS
0589-11 1E           455               .DW   WIDTH
058B-49 1F           456               .DW   MONITR
058D-99 22           457               .DW   PSET
058F-9C 22           458               .DW   RESET
0591-4F 0D           459               .DW   PRINT
0593-7B 0B           460               .DW   CONT
0595-C1 09           461               .DW   LIST
0597-F6 0B           462               .DW   CLEAR
0599-9E 0C           463               .DW   REM
059B-9E 0C           464               .DW   REM
059D-B9 07           465               .DW   NEW
059F-                466
059F-                467       ; RESERVED WORD TOKEN VALUES
059F-                468
0080-                469       ZEND    .EQU    080H            ; END
0081-                470       ZFOR    .EQU    081H            ; FOR
0083-                471       ZDATA   .EQU    083H            ; DATA
0088-                472       ZGOTO   .EQU    088H            ; GOTO
008C-                473       ZGOSUB  .EQU    08CH            ; GOSUB
008E-                474       ZREM    .EQU    08EH            ; REM
009E-                475       ZPRINT  .EQU    09EH            ; PRINT
00A4-                476       ZNEW    .EQU    0A4H            ; NEW
059F-                477
00A5-                478       ZTAB    .EQU    0A5H            ; TAB
00A6-                479       ZTO     .EQU    0A6H            ; TO
00A7-                480       ZFN     .EQU    0A7H            ; FN
00A8-                481       ZSPC    .EQU    0A8H            ; SPC
00A9-                482       ZTHEN   .EQU    0A9H            ; THEN
00AA-                483       ZNOT    .EQU    0AAH            ; NOT
00AB-                484       ZSTEP   .EQU    0ABH            ; STEP
059F-                485
00AC-                486       ZPLUS   .EQU    0ACH            ; +
00AD-                487       ZMINUS  .EQU    0ADH            ; -
00AE-                488       ZTIMES  .EQU    0AEH            ; *
00AF-                489       ZDIV    .EQU    0AFH            ; /
00B2-                490       ZOR     .EQU    0B2H            ; OR
00B3-                491       ZGTR    .EQU    0B3H            ; >
00B4-                492       ZEQUAL  .EQU    0B4H            ; M
00B5-                493       ZLTH    .EQU    0B5H            ; <
00B6-                494       ZSGN    .EQU    0B6H            ; SGN
00C7-                495       ZPOINT  .EQU    0C7H            ; POINT
00CD-                496       ZLEFT   .EQU    0CDH +2         ; LEFT$
059F-                497
059F-                498       ; ARITHMETIC PRECEDENCE TABLE
059F-                499
059F-79              500       PRITAB: .DB   79H             ; Precedence value
05A0-D5 1A           501               .DW   PADD            ; FPREG = <last> + FPREG
05A2-                502
05A2-79              503               .DB   79H             ; Precedence value
05A3-09 17           504               .DW   PSUB            ; FPREG = <last> - FPREG
05A5-                505
05A5-7C              506               .DB   7CH             ; Precedence value
05A6-47 18           507               .DW   MULT            ; PPREG = <last> * FPREG
05A8-                508
05A8-7C              509               .DB   7CH             ; Precedence value
05A9-A8 18           510               .DW   DIV             ; FPREG = <last> / FPREG
05AB-                511
05AB-7F              512               .DB   7FH             ; Precedence value
05AC-F6 1B           513               .DW   POWER           ; FPREG = <last> ^ FPREG
05AE-                514
05AE-50              515               .DB   50H             ; Precedence value
05AF-BC 10           516               .DW   PAND            ; FPREG = <last> AND FPREG
05B1-                517
05B1-46              518               .DB   46H             ; Precedence value
05B2-BB 10           519               .DW   POR             ; FPREG = <last> OR FPREG
05B4-                520
05B4-                521       ; BASIC ERROR CODE LIST
05B4-                522
05B4-4E 46           523       ERRORS: .DB   "NF"            ; NEXT without FOR
05B6-53 4E           524               .DB   "SN"            ; Syntax error
05B8-52 47           525               .DB   "RG"            ; RETURN without GOSUB
05BA-4F 44           526               .DB   "OD"            ; Out of DATA
05BC-46 43           527               .DB   "FC"            ; Illegal function call
05BE-4F 56           528               .DB   "OV"            ; Overflow error
05C0-4F 4D           529               .DB   "OM"            ; Out of memory
05C2-55 4C           530               .DB   "UL"            ; Undefined line
05C4-42 53           531               .DB   "BS"            ; Bad subscript
05C6-44 44           532               .DB   "DD"            ; Re-DIMensioned array
05C8-2F 30           533               .DB   "/0"            ; Division by zero
05CA-49 44           534               .DB   "ID"            ; Illegal direct
05CC-54 4D           535               .DB   "TM"            ; Type mis-match
05CE-4F 53           536               .DB   "OS"            ; Out of string space
05D0-4C 53           537               .DB   "LS"            ; String too long
05D2-53 54           538               .DB   "ST"            ; String formula too complex
05D4-43 4E           539               .DB   "CN"            ; Can't CONTinue
05D6-55 46           540               .DB   "UF"            ; Undefined FN function
05D8-4D 4F           541               .DB   "MO"            ; Missing operand
05DA-48 58           542               .DB   "HX"            ; HEX error
05DC-42 4E           543               .DB   "BN"            ; BIN error
05DE-                544
05DE-                545       ; INITIALISATION TABLE -------------------------------------------------------
05DE-                546
05DE-C3 A4 03        547 (  9) INITAB: JP      WARMST          ; Warm start jump
05E1-C3 CC 0B        548 (  9)         JP      FCERR           ; "USR (X)" jump (Set to Error)
05E4-D3 00           549 ( 10)         OUT     (0),A           ; "OUT p,n" skeleton
05E6-C9              550 (  9)         RET
05E7-D6 00           551 (  6)         SUB     0               ; Division support routine
05E9-6F              552 (  4)         LD      L,A
05EA-7C              553 (  4)         LD      A,H
05EB-DE 00           554 (  6)         SBC     A,0
05ED-67              555 (  4)         LD      H,A
05EE-78              556 (  4)         LD      A,B
05EF-DE 00           557 (  6)         SBC     A,0
05F1-47              558 (  4)         LD      B,A
05F2-3E 00           559 (  6)         LD      A,0
05F4-C9              560 (  9)         RET
05F5-00 00 00        561               .DB   0,0,0                   ; Random number seed table used by RND
05F8-35 4A CA 99     562               .DB   035H,04AH,0CAH,099H     ;-2.65145E+07
05FC-39 1C 76 98     563               .DB   039H,01CH,076H,098H     ; 1.61291E+07
0600-22 95 B3 98     564               .DB   022H,095H,0B3H,098H     ;-1.17691E+07
0604-0A DD 47 98     565               .DB   00AH,0DDH,047H,098H     ; 1.30983E+07
0608-53 D1 99 99     566               .DB   053H,0D1H,099H,099H     ;-2-01612E+07
060C-0A 1A 9F 98     567               .DB   00AH,01AH,09FH,098H     ;-1.04269E+07
0610-65 BC CD 98     568               .DB   065H,0BCH,0CDH,098H     ;-1.34831E+07
0614-D6 77 3E 98     569               .DB   0D6H,077H,03EH,098H     ; 1.24825E+07
0618-52 C7 4F 80     570               .DB   052H,0C7H,04FH,080H     ; Last random number
061C-DB 00           571 (  9)         IN      A,(0)           ; INP (x) skeleton
061E-C9              572 (  9)         RET
061F-01              573               .DB   1               ; POS (x) number (1)
0620-FF              574               .DB   255             ; Terminal width (255 = no auto CRLF)
0621-1C              575               .DB   28              ; Width for commas (3 columns)
0622-00              576               .DB   0               ; No nulls after input bytes
0623-00              577               .DB   0               ; Output enabled (^O off)
0624-14 00           578               .DW   20              ; Initial lines counter
0626-14 00           579               .DW   20              ; Initial lines number
0628-00 00           580               .DW   0               ; Array load/save check sum
062A-00              581               .DB   0               ; Break not by NMI
062B-00              582               .DB   0               ; Break flag
062C-C3 F2 08        583 (  9)         JP      TTYLIN          ; Input reflection (set to TTY)
062F-C3 00 00        584 (  9)         JP      $0000           ; POINT reflection unused
0632-C3 00 00        585 (  9)         JP      $0000           ; SET reflection
0635-C3 00 00        586 (  9)         JP      $0000           ; RESET reflection
0638-A2 23           587               .DW   STLOOK          ; Temp string space
063A-FE FF           588               .DW   -2              ; Current line number (cold)
063C-3F 23           589               .DW   PROGST+1        ; Start of program text
063E-                590       INITBE:
063E-                591
063E-                592       ; END OF INITIALISATION TABLE ---------------------------------------------------
063E-                593
063E-20 45 72 72 
     6F 72 00        594       ERRMSG: .DB   " Error",0
0645-20 69 6E 20 
     00              595       INMSG:  .DB   " in ",0
0649-                596       ZERBYT  .EQU    $-1             ; A zero byte
064A-4F 6B 0D 0A 
     00 00           597       OKMSG:  .DB   "Ok",CR,LF,0,0
0650-42 72 65 61 
     6B 00           598       BRKMSG: .DB   "Break",0
0656-                599
0656-21 04 00        600 (  9) BAKSTK: LD      HL,4            ; Look for "FOR" block with
0659-39              601 (  7)         ADD     HL,SP           ; same index as specified
065A-7E              602 (  6) LOKFOR: LD      A,(HL)          ; Get block ID
065B-23              603 (  4)         INC     HL              ; Point to index address
065C-FE 81           604 (  6)         CP      ZFOR            ; Is it a "FOR" token
065E-C0              605 ( 5+)         RET     NZ              ; No - exit
065F-4E              606 (  6)         LD      C,(HL)          ; BC = Address of "FOR" index
0660-23              607 (  4)         INC     HL
0661-46              608 (  6)         LD      B,(HL)
0662-23              609 (  4)         INC     HL              ; Point to sign of STEP
0663-E5              610 ( 11)         PUSH    HL              ; Save pointer to sign
0664-69              611 (  4)         LD      L,C             ; HL = address of "FOR" index
0665-60              612 (  4)         LD      H,B
0666-7A              613 (  4)         LD      A,D             ; See if an index was specified
0667-B3              614 (  4)         OR      E               ; DE = 0 if no index specified
0668-EB              615 (  3)         EX      DE,HL           ; Specified index into HL
0669-CA 70 06        616 ( 6+)         JP      Z,INDFND        ; Skip if no index given
066C-EB              617 (  3)         EX      DE,HL           ; Index back into DE
066D-CD 75 09        618 ( 16)         CALL    CPDEHL          ; Compare index with one given
0670-01 0D 00        619 (  9) INDFND: LD      BC,16-3         ; Offset to next block
0673-E1              620 (  9)         POP     HL              ; Restore pointer to sign
0674-C8              621 ( 5+)         RET     Z               ; Return if block found
0675-09              622 (  7)         ADD     HL,BC           ; Point to next block
0676-C3 5A 06        623 (  9)         JP      LOKFOR          ; Keep on looking
0679-                624
0679-CD 93 06        625 ( 16) MOVUP:  CALL    ENFMEM          ; See if enough memory
067C-C5              626 ( 11) MOVSTR: PUSH    BC              ; Save end of source
067D-E3              627 ( 16)         EX      (SP),HL         ; Swap source and dest" end
067E-C1              628 (  9)         POP     BC              ; Get end of destination
067F-CD 75 09        629 ( 16) MOVLP:  CALL    CPDEHL          ; See if list moved
0682-7E              630 (  6)         LD      A,(HL)          ; Get byte
0683-02              631 (  7)         LD      (BC),A          ; Move it
0684-C8              632 ( 5+)         RET     Z               ; Exit if all done
0685-0B              633 (  4)         DEC     BC              ; Next byte to move to
0686-2B              634 (  4)         DEC     HL              ; Next byte to move
0687-C3 7F 06        635 (  9)         JP      MOVLP           ; Loop until all bytes moved
068A-                636
068A-E5              637 ( 11) CHKSTK: PUSH    HL              ; Save code string address
068B-2A 1F 23        638 ( 15)         LD      HL,(ARREND)     ; Lowest free memory
068E-06 00           639 (  6)         LD      B,0             ; BC = Number of levels to test
0690-09              640 (  7)         ADD     HL,BC           ; 2 Bytes for each level
0691-09              641 (  7)         ADD     HL,BC
0692-3E              642               .DB   3EH             ; Skip "PUSH HL"
0693-E5              643 ( 11) ENFMEM: PUSH    HL              ; Save code string address
0694-3E D0           644 (  6)         LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0696-95              645 (  4)         SUB     L
0697-6F              646 (  4)         LD      L,A
0698-3E FF           647 (  6)         LD      A,0FFH ;HIGH (-48) ; 48 Bytes minimum RAM
069A-9C              648 (  4)         SBC     A,H
069B-DA A2 06        649 ( 6+)         JP      C,OMERR         ; Not enough - ?OM Error
069E-67              650 (  4)         LD      H,A
069F-39              651 (  7)         ADD     HL,SP           ; Test if stack is overflowed
06A0-E1              652 (  9)         POP     HL              ; Restore code string address
06A1-D8              653 ( 5+)         RET     C               ; Return if enough mmory
06A2-1E 0C           654 (  6) OMERR:  LD      E,OM            ; ?OM Error
06A4-C3 C1 06        655 (  9)         JP      ERROR
06A7-                656
06A7-2A 0E 23        657 ( 15) DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
06AA-22 A1 22        658 ( 20)         LD      (LINEAT),HL     ; Save as current line
06AD-1E 02           659 (  6) SNERR:  LD      E,SN            ; ?SN Error
06AF-01              660               .DB   01H             ; Skip "LD E,DZ"
06B0-1E 14           661 (  6) DZERR:  LD      E,DZ            ; ?/0 Error
06B2-01              662               .DB   01H             ; Skip "LD E,NF"
06B3-1E 00           663 (  6) NFERR:  LD      E,NF            ; ?NF Error
06B5-01              664               .DB   01H             ; Skip "LD E,DD"
06B6-1E 12           665 (  6) DDERR:  LD      E,DD            ; ?DD Error
06B8-01              666               .DB   01H             ; Skip "LD E,UF"
06B9-1E 22           667 (  6) UFERR:  LD      E,UF            ; ?UF Error
06BB-01              668               .DB   01H             ; Skip "LD E,OV
06BC-1E 0A           669 (  6) OVERR:  LD      E,OV            ; ?OV Error
06BE-01              670               .DB   01H             ; Skip "LD E,TM"
06BF-1E 18           671 (  6) TMERR:  LD      E,TM            ; ?TM Error
06C1-                672
06C1-CD DF 07        673 ( 16) ERROR:  CALL    CLREG           ; Clear registers and stack
06C4-32 8A 22        674 ( 13)         LD      (CTLOFG),A      ; Enable output (A is 0)
06C7-CD A0 0D        675 ( 16)         CALL    STTLIN          ; Start new line
06CA-21 B4 05        676 (  9)         LD      HL,ERRORS       ; Point to error codes
06CD-57              677 (  4)         LD      D,A             ; D = 0 (A is 0)
06CE-3E 3F           678 (  6)         LD      A,'?'
06D0-CD 86 09        679 ( 16)         CALL    OUTC            ; Output '?'
06D3-19              680 (  7)         ADD     HL,DE           ; Offset to correct error code
06D4-7E              681 (  6)         LD      A,(HL)          ; First character
06D5-CD 86 09        682 ( 16)         CALL    OUTC            ; Output it
06D8-CD 05 0B        683 ( 16)         CALL    GETCHR          ; Get next character
06DB-CD 86 09        684 ( 16)         CALL    OUTC            ; Output it
06DE-21 3E 06        685 (  9)         LD      HL,ERRMSG       ; "Error" message
06E1-CD 4B 14        686 ( 16) ERRIN:  CALL    PRS             ; Output message
06E4-2A A1 22        687 ( 15)         LD      HL,(LINEAT)     ; Get line of error
06E7-11 FE FF        688 (  9)         LD      DE,-2           ; Cold start error if -2
06EA-CD 75 09        689 ( 16)         CALL    CPDEHL          ; See if cold start error
06ED-CA 11 03        690 ( 6+)         JP      Z,CSTART        ; Cold start error - Restart
06F0-7C              691 (  4)         LD      A,H             ; Was it a direct error?
06F1-A5              692 (  4)         AND     L               ; Line = -1 if direct error
06F2-3C              693 (  4)         INC     A
06F3-C4 E6 1A        694 ( 6+)         CALL    NZ,LINEIN       ; No - output line of error
06F6-3E              695               .DB   3EH             ; Skip "POP BC"
06F7-C1              696 (  9) POPNOK: POP     BC              ; Drop address in input buffer
06F8-                697
06F8-AF              698 (  4) PRNTOK: XOR     A               ; Output "Ok" and get command
06F9-32 8A 22        699 ( 13)         LD      (CTLOFG),A      ; Enable output
06FC-CD A0 0D        700 ( 16)         CALL    STTLIN          ; Start new line
06FF-21 4A 06        701 (  9)         LD      HL,OKMSG        ; "Ok" message
0702-CD 4B 14        702 ( 16)         CALL    PRS             ; Output "Ok"
0705-21 FF FF        703 (  9) GETCMD: LD      HL,-1           ; Flag direct mode
0708-22 A1 22        704 ( 20)         LD      (LINEAT),HL     ; Save as current line
070B-CD F2 08        705 ( 16)         CALL    GETLIN          ; Get an input line
070E-DA 05 07        706 ( 6+)         JP      C,GETCMD        ; Get line again if break
0711-CD 05 0B        707 ( 16)         CALL    GETCHR          ; Get first character
0714-3C              708 (  4)         INC     A               ; Test if end of line
0715-3D              709 (  4)         DEC     A               ; Without affecting Carry
0716-CA 05 07        710 ( 6+)         JP      Z,GETCMD        ; Nothing entered - Get another
0719-F5              711 ( 11)         PUSH    AF              ; Save Carry status
071A-CD D1 0B        712 ( 16)         CALL    ATOH            ; Get line number into DE
071D-D5              713 ( 11)         PUSH    DE              ; Save line number
071E-CD 09 08        714 ( 16)         CALL    CRUNCH          ; Tokenise rest of line
0721-47              715 (  4)         LD      B,A             ; Length of tokenised line
0722-D1              716 (  9)         POP     DE              ; Restore line number
0723-F1              717 (  9)         POP     AF              ; Restore Carry
0724-D2 E5 0A        718 ( 6+)         JP      NC,EXCUTE       ; No line number - Direct mode
0727-D5              719 ( 11)         PUSH    DE              ; Save line number
0728-C5              720 ( 11)         PUSH    BC              ; Save length of tokenised line
0729-AF              721 (  4)         XOR     A
072A-32 11 23        722 ( 13)         LD      (LSTBIN),A      ; Clear last byte input
072D-CD 05 0B        723 ( 16)         CALL    GETCHR          ; Get next character
0730-B7              724 (  4)         OR      A               ; Set flags
0731-F5              725 ( 11)         PUSH    AF              ; And save them
0732-CD 99 07        726 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0735-DA 3E 07        727 ( 6+)         JP      C,LINFND        ; Jump if line found
0738-F1              728 (  9)         POP     AF              ; Get status
0739-F5              729 ( 11)         PUSH    AF              ; And re-save
073A-CA 72 0C        730 ( 6+)         JP      Z,ULERR         ; Nothing after number - Error
073D-B7              731 (  4)         OR      A               ; Clear Carry
073E-C5              732 ( 11) LINFND: PUSH    BC              ; Save address of line in prog
073F-D2 55 07        733 ( 6+)         JP      NC,INEWLN       ; Line not found - Insert new
0742-EB              734 (  3)         EX      DE,HL           ; Next line address in DE
0743-2A 1B 23        735 ( 15)         LD      HL,(PROGND)     ; End of program
0746-1A              736 (  6) SFTPRG: LD      A,(DE)          ; Shift rest of program down
0747-02              737 (  7)         LD      (BC),A
0748-03              738 (  4)         INC     BC              ; Next destination
0749-13              739 (  4)         INC     DE              ; Next source
074A-CD 75 09        740 ( 16)         CALL    CPDEHL          ; All done?
074D-C2 46 07        741 ( 6+)         JP      NZ,SFTPRG       ; More to do
0750-60              742 (  4)         LD      H,B             ; HL - New end of program
0751-69              743 (  4)         LD      L,C
0752-22 1B 23        744 ( 20)         LD      (PROGND),HL     ; Update end of program
0755-                745
0755-D1              746 (  9) INEWLN: POP     DE              ; Get address of line,
0756-F1              747 (  9)         POP     AF              ; Get status
0757-CA 7C 07        748 ( 6+)         JP      Z,SETPTR        ; No text - Set up pointers
075A-2A 1B 23        749 ( 15)         LD      HL,(PROGND)     ; Get end of program
075D-E3              750 ( 16)         EX      (SP),HL         ; Get length of input line
075E-C1              751 (  9)         POP     BC              ; End of program to BC
075F-09              752 (  7)         ADD     HL,BC           ; Find new end
0760-E5              753 ( 11)         PUSH    HL              ; Save new end
0761-CD 79 06        754 ( 16)         CALL    MOVUP           ; Make space for line
0764-E1              755 (  9)         POP     HL              ; Restore new end
0765-22 1B 23        756 ( 20)         LD      (PROGND),HL     ; Update end of program pointer
0768-EB              757 (  3)         EX      DE,HL           ; Get line to move up in HL
0769-74              758 (  7)         LD      (HL),H          ; Save MSB
076A-D1              759 (  9)         POP     DE              ; Get new line number
076B-23              760 (  4)         INC     HL              ; Skip pointer
076C-23              761 (  4)         INC     HL
076D-73              762 (  7)         LD      (HL),E          ; Save LSB of line number
076E-23              763 (  4)         INC     HL
076F-72              764 (  7)         LD      (HL),D          ; Save MSB of line number
0770-23              765 (  4)         INC     HL              ; To first byte in line
0771-11 A6 22        766 (  9)         LD      DE,BUFFER       ; Copy buffer to program
0774-1A              767 (  6) MOVBUF: LD      A,(DE)          ; Get source
0775-77              768 (  7)         LD      (HL),A          ; Save destinations
0776-23              769 (  4)         INC     HL              ; Next source
0777-13              770 (  4)         INC     DE              ; Next destination
0778-B7              771 (  4)         OR      A               ; Done?
0779-C2 74 07        772 ( 6+)         JP      NZ,MOVBUF       ; No - Repeat
077C-CD C5 07        773 ( 16) SETPTR: CALL    RUNFST          ; Set line pointers
077F-23              774 (  4)         INC     HL              ; To LSB of pointer
0780-EB              775 (  3)         EX      DE,HL           ; Address to DE
0781-62              776 (  4) PTRLP:  LD      H,D             ; Address to HL
0782-6B              777 (  4)         LD      L,E
0783-7E              778 (  6)         LD      A,(HL)          ; Get LSB of pointer
0784-23              779 (  4)         INC     HL              ; To MSB of pointer
0785-B6              780 (  6)         OR      (HL)            ; Compare with MSB pointer
0786-CA 05 07        781 ( 6+)         JP      Z,GETCMD        ; Get command line if end
0789-23              782 (  4)         INC     HL              ; To LSB of line number
078A-23              783 (  4)         INC     HL              ; Skip line number
078B-23              784 (  4)         INC     HL              ; Point to first byte in line
078C-AF              785 (  4)         XOR     A               ; Looking for 00 byte
078D-BE              786 (  6) FNDEND: CP      (HL)            ; Found end of line?
078E-23              787 (  4)         INC     HL              ; Move to next byte
078F-C2 8D 07        788 ( 6+)         JP      NZ,FNDEND       ; No - Keep looking
0792-EB              789 (  3)         EX      DE,HL           ; Next line address to HL
0793-73              790 (  7)         LD      (HL),E          ; Save LSB of pointer
0794-23              791 (  4)         INC     HL
0795-72              792 (  7)         LD      (HL),D          ; Save MSB of pointer
0796-C3 81 07        793 (  9)         JP      PTRLP           ; Do next line
0799-                794
0799-2A A3 22        795 ( 15) SRCHLN: LD      HL,(BASTXT)     ; Start of program text
079C-44              796 (  4) SRCHLP: LD      B,H             ; BC = Address to look at
079D-4D              797 (  4)         LD      C,L
079E-7E              798 (  6)         LD      A,(HL)          ; Get address of next line
079F-23              799 (  4)         INC     HL
07A0-B6              800 (  6)         OR      (HL)            ; End of program found?
07A1-2B              801 (  4)         DEC     HL
07A2-C8              802 ( 5+)         RET     Z               ; Yes - Line not found
07A3-23              803 (  4)         INC     HL
07A4-23              804 (  4)         INC     HL
07A5-7E              805 (  6)         LD      A,(HL)          ; Get LSB of line number
07A6-23              806 (  4)         INC     HL
07A7-66              807 (  6)         LD      H,(HL)          ; Get MSB of line number
07A8-6F              808 (  4)         LD      L,A
07A9-CD 75 09        809 ( 16)         CALL    CPDEHL          ; Compare with line in DE
07AC-60              810 (  4)         LD      H,B             ; HL = Start of this line
07AD-69              811 (  4)         LD      L,C
07AE-7E              812 (  6)         LD      A,(HL)          ; Get LSB of next line address
07AF-23              813 (  4)         INC     HL
07B0-66              814 (  6)         LD      H,(HL)          ; Get MSB of next line address
07B1-6F              815 (  4)         LD      L,A             ; Next line to HL
07B2-3F              816 (  3)         CCF
07B3-C8              817 ( 5+)         RET     Z               ; Lines found - Exit
07B4-3F              818 (  3)         CCF
07B5-D0              819 ( 5+)         RET     NC              ; Line not found,at line after
07B6-C3 9C 07        820 (  9)         JP      SRCHLP          ; Keep looking
07B9-                821
07B9-C0              822 ( 5+) NEW:    RET     NZ              ; Return if any more on line
07BA-2A A3 22        823 ( 15) CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
07BD-AF              824 (  4)         XOR     A               ; Set program area to empty
07BE-77              825 (  7)         LD      (HL),A          ; Save LSB = 00
07BF-23              826 (  4)         INC     HL
07C0-77              827 (  7)         LD      (HL),A          ; Save MSB = 00
07C1-23              828 (  4)         INC     HL
07C2-22 1B 23        829 ( 20)         LD      (PROGND),HL     ; Set program end
07C5-                830
07C5-2A A3 22        831 ( 15) RUNFST: LD      HL,(BASTXT)     ; Clear all variables
07C8-2B              832 (  4)         DEC     HL
07C9-                833
07C9-22 13 23        834 ( 20) INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
07CC-2A F4 22        835 ( 15)         LD      HL,(LSTRAM)     ; Get end of RAM
07CF-22 08 23        836 ( 20)         LD      (STRBOT),HL     ; Clear string space
07D2-AF              837 (  4)         XOR     A
07D3-CD 15 0B        838 ( 16)         CALL    RESTOR          ; Reset DATA pointers
07D6-2A 1B 23        839 ( 15)         LD      HL,(PROGND)     ; Get end of program
07D9-22 1D 23        840 ( 20)         LD      (VAREND),HL     ; Clear variables
07DC-22 1F 23        841 ( 20)         LD      (ARREND),HL     ; Clear arrays
07DF-                842
07DF-C1              843 (  9) CLREG:  POP     BC              ; Save return address
07E0-2A 9F 22        844 ( 15)         LD      HL,(STRSPC)     ; Get end of working RAN
07E3-F9              845 (  4)         LD      SP,HL           ; Set stack
07E4-21 F8 22        846 (  9)         LD      HL,TMSTPL       ; Temporary string pool
07E7-22 F6 22        847 ( 20)         LD      (TMSTPT),HL     ; Reset temporary string ptr
07EA-AF              848 (  4)         XOR     A               ; A = 00
07EB-6F              849 (  4)         LD      L,A             ; HL = 0000
07EC-67              850 (  4)         LD      H,A
07ED-22 19 23        851 ( 20)         LD      (CONTAD),HL     ; No CONTinue
07F0-32 10 23        852 ( 13)         LD      (FORFLG),A      ; Clear FOR flag
07F3-22 23 23        853 ( 20)         LD      (FNRGNM),HL     ; Clear FN argument
07F6-E5              854 ( 11)         PUSH    HL              ; HL = 0000
07F7-C5              855 ( 11)         PUSH    BC              ; Put back return
07F8-2A 13 23        856 ( 15) DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
07FB-C9              857 (  9)         RET                     ; Return to execution driver
07FC-                858
07FC-3E 3F           859 (  6) PROMPT: LD      A,'?'           ; '?'
07FE-CD 86 09        860 ( 16)         CALL    OUTC            ; Output character
0801-3E 20           861 (  6)         LD      A,' '           ; Space
0803-CD 86 09        862 ( 16)         CALL    OUTC            ; Output character
0806-C3 93 22        863 (  9)         JP      RINPUT          ; Get input line
0809-                864
0809-AF              865 (  4) CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
080A-32 F3 22        866 ( 13)         LD      (DATFLG),A      ; Reset literal flag
080D-0E 05           867 (  6)         LD      C,2+3           ; 2 byte number and 3 nulls
080F-11 A6 22        868 (  9)         LD      DE,BUFFER       ; Start of input buffer
0812-7E              869 (  6) CRNCLP: LD      A,(HL)          ; Get byte
0813-FE 20           870 (  6)         CP      ' '             ; Is it a space?
0815-CA 91 08        871 ( 6+)         JP      Z,MOVDIR        ; Yes - Copy direct
0818-47              872 (  4)         LD      B,A             ; Save character
0819-FE 22           873 (  6)         CP      '"'             ; Is it a quote?
081B-CA B1 08        874 ( 6+)         JP      Z,CPYLIT        ; Yes - Copy literal string
081E-B7              875 (  4)         OR      A               ; Is it end of buffer?
081F-CA B8 08        876 ( 6+)         JP      Z,ENDBUF        ; Yes - End buffer
0822-3A F3 22        877 ( 12)         LD      A,(DATFLG)      ; Get data type
0825-B7              878 (  4)         OR      A               ; Literal?
0826-7E              879 (  6)         LD      A,(HL)          ; Get byte to copy
0827-C2 91 08        880 ( 6+)         JP      NZ,MOVDIR       ; Literal - Copy direct
082A-FE 3F           881 (  6)         CP      '?'             ; Is it '?' short for PRINT
082C-3E 9E           882 (  6)         LD      A,ZPRINT        ; "PRINT" token
082E-CA 91 08        883 ( 6+)         JP      Z,MOVDIR        ; Yes - replace it
0831-7E              884 (  6)         LD      A,(HL)          ; Get byte again
0832-FE 30           885 (  6)         CP      '0'             ; Is it less than '0'
0834-DA 3C 08        886 ( 6+)         JP      C,FNDWRD        ; Yes - Look for reserved words
0837-FE 3C           887 (  6)         CP      60 ; ";"+1           ; Is it "0123456789:;" ?
0839-DA 91 08        888 ( 6+)         JP      C,MOVDIR        ; Yes - copy it direct
083C-D5              889 ( 11) FNDWRD: PUSH    DE              ; Look for reserved words
083D-11 35 04        890 (  9)         LD      DE,WORDS-1      ; Point to table
0840-C5              891 ( 11)         PUSH    BC              ; Save count
0841-01 8D 08        892 (  9)         LD      BC,RETNAD       ; Where to return to
0844-C5              893 ( 11)         PUSH    BC              ; Save return address
0845-06 7F           894 (  6)         LD      B,ZEND-1        ; First token value -1
0847-7E              895 (  6)         LD      A,(HL)          ; Get byte
0848-FE 61           896 (  6)         CP      'a'             ; Less than 'a' ?
084A-DA 55 08        897 ( 6+)         JP      C,SEARCH        ; Yes - search for words
084D-FE 7B           898 (  6)         CP      'z'+1           ; Greater than 'z' ?
084F-D2 55 08        899 ( 6+)         JP      NC,SEARCH       ; Yes - search for words
0852-E6 5F           900 (  6)         AND     01011111B       ; Force upper case
0854-77              901 (  7)         LD      (HL),A          ; Replace byte
0855-4E              902 (  6) SEARCH: LD      C,(HL)          ; Search for a word
0856-EB              903 (  3)         EX      DE,HL
0857-23              904 (  4) GETNXT: INC     HL              ; Get next reserved word
0858-B6              905 (  6)         OR      (HL)            ; Start of word?
0859-F2 57 08        906 ( 6+)         JP      P,GETNXT        ; No - move on
085C-04              907 (  4)         INC     B               ; Increment token value
085D-7E              908 (  6)         LD      A, (HL)         ; Get byte from table
085E-E6 7F           909 (  6)         AND     01111111B       ; Strip bit 7
0860-C8              910 ( 5+)         RET     Z               ; Return if end of list
0861-B9              911 (  4)         CP      C               ; Same character as in buffer?
0862-C2 57 08        912 ( 6+)         JP      NZ,GETNXT       ; No - get next word
0865-EB              913 (  3)         EX      DE,HL
0866-E5              914 ( 11)         PUSH    HL              ; Save start of word
0867-                915
0867-13              916 (  4) NXTBYT: INC     DE              ; Look through rest of word
0868-1A              917 (  6)         LD      A,(DE)          ; Get byte from table
0869-B7              918 (  4)         OR      A               ; End of word ?
086A-FA 89 08        919 ( 6+)         JP      M,MATCH         ; Yes - Match found
086D-4F              920 (  4)         LD      C,A             ; Save it
086E-78              921 (  4)         LD      A,B             ; Get token value
086F-FE 88           922 (  6)         CP      ZGOTO           ; Is it "GOTO" token ?
0871-C2 78 08        923 ( 6+)         JP      NZ,NOSPC        ; No - Don't allow spaces
0874-CD 05 0B        924 ( 16)         CALL    GETCHR          ; Get next character
0877-2B              925 (  4)         DEC     HL              ; Cancel increment from GETCHR
0878-23              926 (  4) NOSPC:  INC     HL              ; Next byte
0879-7E              927 (  6)         LD      A,(HL)          ; Get byte
087A-FE 61           928 (  6)         CP      'a'             ; Less than 'a' ?
087C-DA 81 08        929 ( 6+)         JP      C,NOCHNG        ; Yes - don't change
087F-E6 5F           930 (  6)         AND     01011111B       ; Make upper case
0881-B9              931 (  4) NOCHNG: CP      C               ; Same as in buffer ?
0882-CA 67 08        932 ( 6+)         JP      Z,NXTBYT        ; Yes - keep testing
0885-E1              933 (  9)         POP     HL              ; Get back start of word
0886-C3 55 08        934 (  9)         JP      SEARCH          ; Look at next word
0889-                935
0889-48              936 (  4) MATCH:  LD      C,B             ; Word found - Save token value
088A-F1              937 (  9)         POP     AF              ; Throw away return
088B-EB              938 (  3)         EX      DE,HL
088C-C9              939 (  9)         RET                     ; Return to "RETNAD"
088D-EB              940 (  3) RETNAD: EX      DE,HL           ; Get address in string
088E-79              941 (  4)         LD      A,C             ; Get token value
088F-C1              942 (  9)         POP     BC              ; Restore buffer length
0890-D1              943 (  9)         POP     DE              ; Get destination address
0891-23              944 (  4) MOVDIR: INC     HL              ; Next source in buffer
0892-12              945 (  7)         LD      (DE),A          ; Put byte in buffer
0893-13              946 (  4)         INC     DE              ; Move up buffer
0894-0C              947 (  4)         INC     C               ; Increment length of buffer
0895-D6 3A           948 (  6)         SUB     ':'             ; End of statement?
0897-CA 9F 08        949 ( 6+)         JP      Z,SETLIT        ; Jump if multi-statement line
089A-FE 49           950 (  6)         CP      ZDATA-3AH       ; Is it DATA statement ?
089C-C2 A2 08        951 ( 6+)         JP      NZ,TSTREM       ; No - see if REM
089F-32 F3 22        952 ( 13) SETLIT: LD      (DATFLG),A      ; Set literal flag
08A2-D6 54           953 (  6) TSTREM: SUB     ZREM-3AH        ; Is it REM?
08A4-C2 12 08        954 ( 6+)         JP      NZ,CRNCLP       ; No - Leave flag
08A7-47              955 (  4)         LD      B,A             ; Copy rest of buffer
08A8-7E              956 (  6) NXTCHR: LD      A,(HL)          ; Get byte
08A9-B7              957 (  4)         OR      A               ; End of line ?
08AA-CA B8 08        958 ( 6+)         JP      Z,ENDBUF        ; Yes - Terminate buffer
08AD-B8              959 (  4)         CP      B               ; End of statement ?
08AE-CA 91 08        960 ( 6+)         JP      Z,MOVDIR        ; Yes - Get next one
08B1-23              961 (  4) CPYLIT: INC     HL              ; Move up source string
08B2-12              962 (  7)         LD      (DE),A          ; Save in destination
08B3-0C              963 (  4)         INC     C               ; Increment length
08B4-13              964 (  4)         INC     DE              ; Move up destination
08B5-C3 A8 08        965 (  9)         JP      NXTCHR          ; Repeat
08B8-                966
08B8-21 A5 22        967 (  9) ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
08BB-12              968 (  7)         LD      (DE),A          ; Mark end of buffer (A = 00)
08BC-13              969 (  4)         INC     DE
08BD-12              970 (  7)         LD      (DE),A          ; A = 00
08BE-13              971 (  4)         INC     DE
08BF-12              972 (  7)         LD      (DE),A          ; A = 00
08C0-C9              973 (  9)         RET
08C1-                974
08C1-3A 89 22        975 ( 12) DODEL:  LD      A,(NULFLG)      ; Get null flag status
08C4-B7              976 (  4)         OR      A               ; Is it zero?
08C5-3E 00           977 (  6)         LD      A,0             ; Zero A - Leave flags
08C7-32 89 22        978 ( 13)         LD      (NULFLG),A      ; Zero null flag
08CA-C2 D5 08        979 ( 6+)         JP      NZ,ECHDEL       ; Set - Echo it
08CD-05              980 (  4)         DEC     B               ; Decrement length
08CE-CA F2 08        981 ( 6+)         JP      Z,GETLIN        ; Get line again if empty
08D1-CD 86 09        982 ( 16)         CALL    OUTC            ; Output null character
08D4-3E              983               .DB   3EH             ; Skip "DEC B"
08D5-05              984 (  4) ECHDEL: DEC     B               ; Count bytes in buffer
08D6-2B              985 (  4)         DEC     HL              ; Back space buffer
08D7-CA E9 08        986 ( 6+)         JP      Z,OTKLN         ; No buffer - Try again
08DA-7E              987 (  6)         LD      A,(HL)          ; Get deleted byte
08DB-CD 86 09        988 ( 16)         CALL    OUTC            ; Echo it
08DE-C3 FB 08        989 (  9)         JP      MORINP          ; Get more input
08E1-                990
08E1-05              991 (  4) DELCHR: DEC     B               ; Count bytes in buffer
08E2-2B              992 (  4)         DEC     HL              ; Back space buffer
08E3-CD 86 09        993 ( 16)         CALL    OUTC            ; Output character in A
08E6-C2 FB 08        994 ( 6+)         JP      NZ,MORINP       ; Not end - Get more
08E9-CD 86 09        995 ( 16) OTKLN:  CALL    OUTC            ; Output character in A
08EC-CD AD 0D        996 ( 16) KILIN:  CALL    PRNTCRLF        ; Output CRLF
08EF-C3 F2 08        997 (  9)         JP      TTYLIN          ; Get line again
08F2-                998
08F2-                999       GETLIN:
08F2-21 A6 22       1000 (  9) TTYLIN: LD      HL,BUFFER       ; Get a line by character
08F5-06 01          1001 (  6)         LD      B,1             ; Set buffer as empty
08F7-AF             1002 (  4)         XOR     A
08F8-32 89 22       1003 ( 13)         LD      (NULFLG),A      ; Clear null flag
08FB-CD B0 09       1004 ( 16) MORINP: CALL    CLOTST          ; Get character and test ^O
08FE-4F             1005 (  4)         LD      C,A             ; Save character in C
08FF-FE 7F          1006 (  6)         CP      DEL             ; Delete character?
0901-CA C1 08       1007 ( 6+)         JP      Z,DODEL         ; Yes - Process it
0904-3A 89 22       1008 ( 12)         LD      A,(NULFLG)      ; Get null flag
0907-B7             1009 (  4)         OR      A               ; Test null flag status
0908-CA 14 09       1010 ( 6+)         JP      Z,PROCES        ; Reset - Process character
090B-3E 00          1011 (  6)         LD      A,0             ; Set a null
090D-CD 86 09       1012 ( 16)         CALL    OUTC            ; Output null
0910-AF             1013 (  4)         XOR     A               ; Clear A
0911-32 89 22       1014 ( 13)         LD      (NULFLG),A      ; Reset null flag
0914-79             1015 (  4) PROCES: LD      A,C             ; Get character
0915-FE 07          1016 (  6)         CP      CTRLG           ; Bell?
0917-CA 58 09       1017 ( 6+)         JP      Z,PUTCTL        ; Yes - Save it
091A-FE 03          1018 (  6)         CP      CTRLC           ; Is it control "C"?
091C-CC AD 0D       1019 ( 6+)         CALL    Z,PRNTCRLF      ; Yes - Output CRLF
091F-37             1020 (  3)         SCF                     ; Flag break
0920-C8             1021 ( 5+)         RET     Z               ; Return if control "C"
0921-FE 0D          1022 (  6)         CP      CR              ; Is it enter?
0923-CA A8 0D       1023 ( 6+)         JP      Z,ENDINP        ; Yes - Terminate input
0926-FE 15          1024 (  6)         CP      CTRLU           ; Is it control "U"?
0928-CA EC 08       1025 ( 6+)         JP      Z,KILIN         ; Yes - Get another line
092B-FE 40          1026 (  6)         CP      '@'             ; Is it "kill line"?
092D-CA E9 08       1027 ( 6+)         JP      Z,OTKLN         ; Yes - Kill line
0930-FE 5F          1028 (  6)         CP      '_'             ; Is it delete?
0932-CA E1 08       1029 ( 6+)         JP      Z,DELCHR        ; Yes - Delete character
0935-FE 08          1030 (  6)         CP      BKSP            ; Is it backspace?
0937-CA E1 08       1031 ( 6+)         JP      Z,DELCHR        ; Yes - Delete character
093A-FE 12          1032 (  6)         CP      CTRLR           ; Is it control "R"?
093C-C2 53 09       1033 ( 6+)         JP      NZ,PUTBUF       ; No - Put in buffer
093F-C5             1034 ( 11)         PUSH    BC              ; Save buffer length
0940-D5             1035 ( 11)         PUSH    DE              ; Save DE
0941-E5             1036 ( 11)         PUSH    HL              ; Save buffer address
0942-36 00          1037 (  9)         LD      (HL),0          ; Mark end of buffer
0944-CD 5D 1F       1038 ( 16)         CALL    OUTNCR          ; Output and do CRLF
0947-21 A6 22       1039 (  9)         LD      HL,BUFFER       ; Point to buffer start
094A-CD 4B 14       1040 ( 16)         CALL    PRS             ; Output buffer
094D-E1             1041 (  9)         POP     HL              ; Restore buffer address
094E-D1             1042 (  9)         POP     DE              ; Restore DE
094F-C1             1043 (  9)         POP     BC              ; Restore buffer length
0950-C3 FB 08       1044 (  9)         JP      MORINP          ; Get another character
0953-               1045
0953-FE 20          1046 (  6) PUTBUF: CP      ' '             ; Is it a control code?
0955-DA FB 08       1047 ( 6+)         JP      C,MORINP        ; Yes - Ignore
0958-78             1048 (  4) PUTCTL: LD      A,B             ; Get number of bytes in buffer
0959-FE 49          1049 (  6)         CP      72+1            ; Test for line overflow
095B-3E 07          1050 (  6)         LD      A,CTRLG         ; Set a bell
095D-D2 6D 09       1051 ( 6+)         JP      NC,OUTNBS       ; Ring bell if buffer full
0960-79             1052 (  4)         LD      A,C             ; Get character
0961-71             1053 (  7)         LD      (HL),C          ; Save in buffer
0962-32 11 23       1054 ( 13)         LD      (LSTBIN),A      ; Save last input byte
0965-23             1055 (  4)         INC     HL              ; Move up buffer
0966-04             1056 (  4)         INC     B               ; Increment length
0967-CD 86 09       1057 ( 16) OUTIT:  CALL    OUTC            ; Output the character entered
096A-C3 FB 08       1058 (  9)         JP      MORINP          ; Get another character
096D-               1059
096D-CD 86 09       1060 ( 16) OUTNBS: CALL    OUTC            ; Output bell and back over it
0970-3E 08          1061 (  6)         LD      A,BKSP          ; Set back space
0972-C3 67 09       1062 (  9)         JP      OUTIT           ; Output it and get more
0975-               1063
0975-7C             1064 (  4) CPDEHL: LD      A,H             ; Get H
0976-92             1065 (  4)         SUB     D               ; Compare with D
0977-C0             1066 ( 5+)         RET     NZ              ; Different - Exit
0978-7D             1067 (  4)         LD      A,L             ; Get L
0979-93             1068 (  4)         SUB     E               ; Compare with E
097A-C9             1069 (  9)         RET                     ; Return status
097B-               1070
097B-7E             1071 (  6) CHKSYN: LD      A,(HL)          ; Check syntax of character
097C-E3             1072 ( 16)         EX      (SP),HL         ; Address of test byte
097D-BE             1073 (  6)         CP      (HL)            ; Same as in code string?
097E-23             1074 (  4)         INC     HL              ; Return address
097F-E3             1075 ( 16)         EX      (SP),HL         ; Put it back
0980-CA 05 0B       1076 ( 6+)         JP      Z,GETCHR        ; Yes - Get next character
0983-C3 AD 06       1077 (  9)         JP      SNERR           ; Different - ?SN Error
0986-               1078
0986-F5             1079 ( 11) OUTC:   PUSH    AF              ; Save character
0987-3A 8A 22       1080 ( 12)         LD      A,(CTLOFG)      ; Get control "O" flag
098A-B7             1081 (  4)         OR      A               ; Is it set?
098B-C2 80 14       1082 ( 6+)         JP      NZ,POPAF        ; Yes - don't output
098E-F1             1083 (  9)         POP     AF              ; Restore character
098F-C5             1084 ( 11)         PUSH    BC              ; Save buffer length
0990-F5             1085 ( 11)         PUSH    AF              ; Save character
0991-FE 20          1086 (  6)         CP      ' '             ; Is it a control code?
0993-DA AA 09       1087 ( 6+)         JP      C,DINPOS        ; Yes - Don't INC POS(X)
0996-3A 87 22       1088 ( 12)         LD      A,(LWIDTH)      ; Get line width
0999-47             1089 (  4)         LD      B,A             ; To B
099A-3A F0 22       1090 ( 12)         LD      A,(CURPOS)      ; Get cursor position
099D-04             1091 (  4)         INC     B               ; Width 255?
099E-CA A6 09       1092 ( 6+)         JP      Z,INCLEN        ; Yes - No width limit
09A1-05             1093 (  4)         DEC     B               ; Restore width
09A2-B8             1094 (  4)         CP      B               ; At end of line?
09A3-CC AD 0D       1095 ( 6+)         CALL    Z,PRNTCRLF      ; Yes - output CRLF
09A6-3C             1096 (  4) INCLEN: INC     A               ; Move on one character
09A7-32 F0 22       1097 ( 13)         LD      (CURPOS),A      ; Save new position
09AA-F1             1098 (  9) DINPOS: POP     AF              ; Restore character
09AB-C1             1099 (  9)         POP     BC              ; Restore buffer length
09AC-CD 46 1F       1100 ( 16)         CALL    MONOUT          ; Send it
09AF-C9             1101 (  9)         RET
09B0-               1102
09B0-CD 0A 1E       1103 ( 16) CLOTST: CALL    GETINP          ; Get input character
09B3-E6 7F          1104 (  6)         AND     01111111B       ; Strip bit 7
09B5-FE 0F          1105 (  6)         CP      CTRLO           ; Is it control "O"?
09B7-C0             1106 ( 5+)         RET     NZ              ; No don't flip flag
09B8-3A 8A 22       1107 ( 12)         LD      A,(CTLOFG)      ; Get flag
09BB-2F             1108 (  3)         CPL                     ; Flip it
09BC-32 8A 22       1109 ( 13)         LD      (CTLOFG),A      ; Put it back
09BF-AF             1110 (  4)         XOR     A               ; Null character
09C0-C9             1111 (  9)         RET
09C1-               1112
09C1-CD D1 0B       1113 ( 16) LIST:   CALL    ATOH            ; ASCII number to DE
09C4-C0             1114 ( 5+)         RET     NZ              ; Return if anything extra
09C5-C1             1115 (  9)         POP     BC              ; Rubbish - Not needed
09C6-CD 99 07       1116 ( 16)         CALL    SRCHLN          ; Search for line number in DE
09C9-C5             1117 ( 11)         PUSH    BC              ; Save address of line
09CA-CD 17 0A       1118 ( 16)         CALL    SETLIN          ; Set up lines counter
09CD-E1             1119 (  9) LISTLP: POP     HL              ; Restore address of line
09CE-4E             1120 (  6)         LD      C,(HL)          ; Get LSB of next line
09CF-23             1121 (  4)         INC     HL
09D0-46             1122 (  6)         LD      B,(HL)          ; Get MSB of next line
09D1-23             1123 (  4)         INC     HL
09D2-78             1124 (  4)         LD      A,B             ; BC = 0 (End of program)?
09D3-B1             1125 (  4)         OR      C
09D4-CA F8 06       1126 ( 6+)         JP      Z,PRNTOK        ; Yes - Go to command mode
09D7-CD 20 0A       1127 ( 16)         CALL    COUNT           ; Count lines
09DA-CD 30 0B       1128 ( 16)         CALL    TSTBRK          ; Test for break key
09DD-C5             1129 ( 11)         PUSH    BC              ; Save address of next line
09DE-CD AD 0D       1130 ( 16)         CALL    PRNTCRLF        ; Output CRLF
09E1-5E             1131 (  6)         LD      E,(HL)          ; Get LSB of line number
09E2-23             1132 (  4)         INC     HL
09E3-56             1133 (  6)         LD      D,(HL)          ; Get MSB of line number
09E4-23             1134 (  4)         INC     HL
09E5-E5             1135 ( 11)         PUSH    HL              ; Save address of line start
09E6-EB             1136 (  3)         EX      DE,HL           ; Line number to HL
09E7-CD EE 1A       1137 ( 16)         CALL    PRNTHL          ; Output line number in decimal
09EA-3E 20          1138 (  6)         LD      A,' '           ; Space after line number
09EC-E1             1139 (  9)         POP     HL              ; Restore start of line address
09ED-CD 86 09       1140 ( 16) LSTLP2: CALL    OUTC            ; Output character in A
09F0-7E             1141 (  6) LSTLP3: LD      A,(HL)          ; Get next byte in line
09F1-B7             1142 (  4)         OR      A               ; End of line?
09F2-23             1143 (  4)         INC     HL              ; To next byte in line
09F3-CA CD 09       1144 ( 6+)         JP      Z,LISTLP        ; Yes - get next line
09F6-F2 ED 09       1145 ( 6+)         JP      P,LSTLP2        ; No token - output it
09F9-D6 7F          1146 (  6)         SUB     ZEND-1          ; Find and output word
09FB-4F             1147 (  4)         LD      C,A             ; Token offset+1 to C
09FC-11 36 04       1148 (  9)         LD      DE,WORDS        ; Reserved word list
09FF-1A             1149 (  6) FNDTOK: LD      A,(DE)          ; Get character in list
0A00-13             1150 (  4)         INC     DE              ; Move on to next
0A01-B7             1151 (  4)         OR      A               ; Is it start of word?
0A02-F2 FF 09       1152 ( 6+)         JP      P,FNDTOK        ; No - Keep looking for word
0A05-0D             1153 (  4)         DEC     C               ; Count words
0A06-C2 FF 09       1154 ( 6+)         JP      NZ,FNDTOK       ; Not there - keep looking
0A09-E6 7F          1155 (  6) OUTWRD: AND     01111111B       ; Strip bit 7
0A0B-CD 86 09       1156 ( 16)         CALL    OUTC            ; Output first character
0A0E-1A             1157 (  6)         LD      A,(DE)          ; Get next character
0A0F-13             1158 (  4)         INC     DE              ; Move on to next
0A10-B7             1159 (  4)         OR      A               ; Is it end of word?
0A11-F2 09 0A       1160 ( 6+)         JP      P,OUTWRD        ; No - output the rest
0A14-C3 F0 09       1161 (  9)         JP      LSTLP3          ; Next byte in line
0A17-               1162
0A17-E5             1163 ( 11) SETLIN: PUSH    HL              ; Set up LINES counter
0A18-2A 8D 22       1164 ( 15)         LD      HL,(LINESN)     ; Get LINES number
0A1B-22 8B 22       1165 ( 20)         LD      (LINESC),HL     ; Save in LINES counter
0A1E-E1             1166 (  9)         POP     HL
0A1F-C9             1167 (  9)         RET
0A20-               1168
0A20-E5             1169 ( 11) COUNT:  PUSH    HL              ; Save code string address
0A21-D5             1170 ( 11)         PUSH    DE
0A22-2A 8B 22       1171 ( 15)         LD      HL,(LINESC)     ; Get LINES counter
0A25-11 FF FF       1172 (  9)         LD      DE,-1
0A28-ED 5A          1173 ( 10)         ADC     HL,DE           ; Decrement
0A2A-22 8B 22       1174 ( 20)         LD      (LINESC),HL     ; Put it back
0A2D-D1             1175 (  9)         POP     DE
0A2E-E1             1176 (  9)         POP     HL              ; Restore code string address
0A2F-F0             1177 ( 5+)         RET     P               ; Return if more lines to go
0A30-E5             1178 ( 11)         PUSH    HL              ; Save code string address
0A31-2A 8D 22       1179 ( 15)         LD      HL,(LINESN)     ; Get LINES number
0A34-22 8B 22       1180 ( 20)         LD      (LINESC),HL     ; Reset LINES counter
0A37-CD 0A 1E       1181 ( 16)         CALL    GETINP          ; Get input character
0A3A-FE 03          1182 (  6)         CP      CTRLC           ; Is it control "C"?
0A3C-CA 43 0A       1183 ( 6+)         JP      Z,RSLNBK        ; Yes - Reset LINES and break
0A3F-E1             1184 (  9)         POP     HL              ; Restore code string address
0A40-C3 20 0A       1185 (  9)         JP      COUNT           ; Keep on counting
0A43-               1186
0A43-2A 8D 22       1187 ( 15) RSLNBK: LD      HL,(LINESN)     ; Get LINES number
0A46-22 8B 22       1188 ( 20)         LD      (LINESC),HL     ; Reset LINES counter
0A49-C3 A7 03       1189 (  9)         JP      BRKRET          ; Go and output "Break"
0A4C-               1190
0A4C-3E 64          1191 (  6) FOR:    LD      A,64H           ; Flag "FOR" assignment
0A4E-32 10 23       1192 ( 13)         LD      (FORFLG),A      ; Save "FOR" flag
0A51-CD B3 0C       1193 ( 16)         CALL    LET             ; Set up initial index
0A54-C1             1194 (  9)         POP     BC              ; Drop RETurn address
0A55-E5             1195 ( 11)         PUSH    HL              ; Save code string address
0A56-CD 9C 0C       1196 ( 16)         CALL    DATA            ; Get next statement address
0A59-22 0C 23       1197 ( 20)         LD      (LOOPST),HL     ; Save it for start of loop
0A5C-21 02 00       1198 (  9)         LD      HL,2            ; Offset for "FOR" block
0A5F-39             1199 (  7)         ADD     HL,SP           ; Point to it
0A60-CD 5A 06       1200 ( 16) FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
0A63-D1             1201 (  9)         POP     DE              ; Get code string address
0A64-C2 7C 0A       1202 ( 6+)         JP      NZ,FORFND       ; No nesting found
0A67-09             1203 (  7)         ADD     HL,BC           ; Move into "FOR" block
0A68-D5             1204 ( 11)         PUSH    DE              ; Save code string address
0A69-2B             1205 (  4)         DEC     HL
0A6A-56             1206 (  6)         LD      D,(HL)          ; Get MSB of loop statement
0A6B-2B             1207 (  4)         DEC     HL
0A6C-5E             1208 (  6)         LD      E,(HL)          ; Get LSB of loop statement
0A6D-23             1209 (  4)         INC     HL
0A6E-23             1210 (  4)         INC     HL
0A6F-E5             1211 ( 11)         PUSH    HL              ; Save block address
0A70-2A 0C 23       1212 ( 15)         LD      HL,(LOOPST)     ; Get address of loop statement
0A73-CD 75 09       1213 ( 16)         CALL    CPDEHL          ; Compare the FOR loops
0A76-E1             1214 (  9)         POP     HL              ; Restore block address
0A77-C2 60 0A       1215 ( 6+)         JP      NZ,FORSLP       ; Different FORs - Find another
0A7A-D1             1216 (  9)         POP     DE              ; Restore code string address
0A7B-F9             1217 (  4)         LD      SP,HL           ; Remove all nested loops
0A7C-               1218
0A7C-EB             1219 (  3) FORFND: EX      DE,HL           ; Code string address to HL
0A7D-0E 08          1220 (  6)         LD      C,8
0A7F-CD 8A 06       1221 ( 16)         CALL    CHKSTK          ; Check for 8 levels of stack
0A82-E5             1222 ( 11)         PUSH    HL              ; Save code string address
0A83-2A 0C 23       1223 ( 15)         LD      HL,(LOOPST)     ; Get first statement of loop
0A86-E3             1224 ( 16)         EX      (SP),HL         ; Save and restore code string
0A87-E5             1225 ( 11)         PUSH    HL              ; Re-save code string address
0A88-2A A1 22       1226 ( 15)         LD      HL,(LINEAT)     ; Get current line number
0A8B-E3             1227 ( 16)         EX      (SP),HL         ; Save and restore code string
0A8C-CD 75 0F       1228 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0A8F-CD 7B 09       1229 ( 16)         CALL    CHKSYN          ; Make sure "TO" is next
0A92-A6             1230               .DB   ZTO          ; "TO" token
0A93-CD 72 0F       1231 ( 16)         CALL    GETNUM          ; Get "TO" expression value
0A96-E5             1232 ( 11)         PUSH    HL              ; Save code string address
0A97-CD A0 19       1233 ( 16)         CALL    BCDEFP          ; Move "TO" value to BCDE
0A9A-E1             1234 (  9)         POP     HL              ; Restore code string address
0A9B-C5             1235 ( 11)         PUSH    BC              ; Save "TO" value in block
0A9C-D5             1236 ( 11)         PUSH    DE
0A9D-01 00 81       1237 (  9)         LD      BC,8100H        ; BCDE - 1 (default STEP)
0AA0-51             1238 (  4)         LD      D,C             ; C=0
0AA1-5A             1239 (  4)         LD      E,D             ; D=0
0AA2-7E             1240 (  6)         LD      A,(HL)          ; Get next byte in code string
0AA3-FE AB          1241 (  6)         CP      ZSTEP           ; See if "STEP" is stated
0AA5-3E 01          1242 (  6)         LD      A,1             ; Sign of step = 1
0AA7-C2 B8 0A       1243 ( 6+)         JP      NZ,SAVSTP       ; No STEP given - Default to 1
0AAA-CD 05 0B       1244 ( 16)         CALL    GETCHR          ; Jump over "STEP" token
0AAD-CD 72 0F       1245 ( 16)         CALL    GETNUM          ; Get step value
0AB0-E5             1246 ( 11)         PUSH    HL              ; Save code string address
0AB1-CD A0 19       1247 ( 16)         CALL    BCDEFP          ; Move STEP to BCDE
0AB4-CD 54 19       1248 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
0AB7-E1             1249 (  9)         POP     HL              ; Restore code string address
0AB8-C5             1250 ( 11) SAVSTP: PUSH    BC              ; Save the STEP value in block
0AB9-D5             1251 ( 11)         PUSH    DE
0ABA-F5             1252 ( 11)         PUSH    AF              ; Save sign of STEP
0ABB-33             1253 (  4)         INC     SP              ; Don't save flags
0ABC-E5             1254 ( 11)         PUSH    HL              ; Save code string address
0ABD-2A 13 23       1255 ( 15)         LD      HL,(BRKLIN)     ; Get address of index variable
0AC0-E3             1256 ( 16)         EX      (SP),HL         ; Save and restore code string
0AC1-06 81          1257 (  6) PUTFID: LD      B,ZFOR          ; "FOR" block marker
0AC3-C5             1258 ( 11)         PUSH    BC              ; Save it
0AC4-33             1259 (  4)         INC     SP              ; Don't save C
0AC5-               1260
0AC5-CD 30 0B       1261 ( 16) RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
0AC8-22 13 23       1262 ( 20)         LD      (BRKLIN),HL     ; Save code address for break
0ACB-7E             1263 (  6)         LD      A,(HL)          ; Get next byte in code string
0ACC-FE 3A          1264 (  6)         CP      ':'             ; Multi statement line?
0ACE-CA E5 0A       1265 ( 6+)         JP      Z,EXCUTE        ; Yes - Execute it
0AD1-B7             1266 (  4)         OR      A               ; End of line?
0AD2-C2 AD 06       1267 ( 6+)         JP      NZ,SNERR        ; No - Syntax error
0AD5-23             1268 (  4)         INC     HL              ; Point to address of next line
0AD6-7E             1269 (  6)         LD      A,(HL)          ; Get LSB of line pointer
0AD7-23             1270 (  4)         INC     HL
0AD8-B6             1271 (  6)         OR      (HL)            ; Is it zero (End of prog)?
0AD9-CA 57 0B       1272 ( 6+)         JP      Z,ENDPRG        ; Yes - Terminate execution
0ADC-23             1273 (  4)         INC     HL              ; Point to line number
0ADD-5E             1274 (  6)         LD      E,(HL)          ; Get LSB of line number
0ADE-23             1275 (  4)         INC     HL
0ADF-56             1276 (  6)         LD      D,(HL)          ; Get MSB of line number
0AE0-EB             1277 (  3)         EX      DE,HL           ; Line number to HL
0AE1-22 A1 22       1278 ( 20)         LD      (LINEAT),HL     ; Save as current line number
0AE4-EB             1279 (  3)         EX      DE,HL           ; Line number back to DE
0AE5-CD 05 0B       1280 ( 16) EXCUTE: CALL    GETCHR          ; Get key word
0AE8-11 C5 0A       1281 (  9)         LD      DE,RUNCNT       ; Where to RETurn to
0AEB-D5             1282 ( 11)         PUSH    DE              ; Save for RETurn
0AEC-C8             1283 ( 5+) IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
0AED-D6 80          1284 (  6) ONJMP:  SUB     ZEND            ; Is it a token?
0AEF-DA B3 0C       1285 ( 6+)         JP      C,LET           ; No - try to assign it
0AF2-FE 25          1286 (  6)         CP      ZNEW+1-ZEND     ; END to NEW ?
0AF4-D2 AD 06       1287 ( 6+)         JP      NC,SNERR        ; Not a key word - ?SN Error
0AF7-07             1288 (  3)         RLCA                    ; Double it
0AF8-4F             1289 (  4)         LD      C,A             ; BC = Offset into table
0AF9-06 00          1290 (  6)         LD      B,0
0AFB-EB             1291 (  3)         EX      DE,HL           ; Save code string address
0AFC-21 55 05       1292 (  9)         LD      HL,WORDTB       ; Keyword address table
0AFF-09             1293 (  7)         ADD     HL,BC           ; Point to routine address
0B00-4E             1294 (  6)         LD      C,(HL)          ; Get LSB of routine address
0B01-23             1295 (  4)         INC     HL
0B02-46             1296 (  6)         LD      B,(HL)          ; Get MSB of routine address
0B03-C5             1297 ( 11)         PUSH    BC              ; Save routine address
0B04-EB             1298 (  3)         EX      DE,HL           ; Restore code string address
0B05-               1299
0B05-23             1300 (  4) GETCHR: INC     HL              ; Point to next character
0B06-7E             1301 (  6)         LD      A,(HL)          ; Get next code string byte
0B07-FE 3A          1302 (  6)         CP      ':'             ; Z if ':'
0B09-D0             1303 ( 5+)         RET     NC              ; NC if > "9"
0B0A-FE 20          1304 (  6)         CP      ' '
0B0C-CA 05 0B       1305 ( 6+)         JP      Z,GETCHR        ; Skip over spaces
0B0F-FE 30          1306 (  6)         CP      '0'
0B11-3F             1307 (  3)         CCF                     ; NC if < '0'
0B12-3C             1308 (  4)         INC     A               ; Test for zero - Leave carry
0B13-3D             1309 (  4)         DEC     A               ; Z if Null
0B14-C9             1310 (  9)         RET
0B15-               1311
0B15-EB             1312 (  3) RESTOR: EX      DE,HL           ; Save code string address
0B16-2A A3 22       1313 ( 15)         LD      HL,(BASTXT)     ; Point to start of program
0B19-CA 2A 0B       1314 ( 6+)         JP      Z,RESTNL        ; Just RESTORE - reset pointer
0B1C-EB             1315 (  3)         EX      DE,HL           ; Restore code string address
0B1D-CD D1 0B       1316 ( 16)         CALL    ATOH            ; Get line number to DE
0B20-E5             1317 ( 11)         PUSH    HL              ; Save code string address
0B21-CD 99 07       1318 ( 16)         CALL    SRCHLN          ; Search for line number in DE
0B24-60             1319 (  4)         LD      H,B             ; HL = Address of line
0B25-69             1320 (  4)         LD      L,C
0B26-D1             1321 (  9)         POP     DE              ; Restore code string address
0B27-D2 72 0C       1322 ( 6+)         JP      NC,ULERR        ; ?UL Error if not found
0B2A-2B             1323 (  4) RESTNL: DEC     HL              ; Byte before DATA statement
0B2B-22 21 23       1324 ( 20) UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
0B2E-EB             1325 (  3)         EX      DE,HL           ; Restore code string address
0B2F-C9             1326 (  9)         RET
0B30-               1327
0B30-               1328
0B30-DF             1329 ( 11) TSTBRK: RST     18H             ; Check input status
0B31-C8             1330 ( 5+)         RET     Z               ; No key, go back
0B32-D7             1331 ( 11)         RST     10H             ; Get the key into A
0B33-FE 1B          1332 (  6)         CP      ESC             ; Escape key?
0B35-28 11          1333 ( 6+)         JR      Z,BRK           ; Yes, break
0B37-FE 03          1334 (  6)         CP      CTRLC           ; <Ctrl-C>
0B39-28 0D          1335 ( 6+)         JR      Z,BRK           ; Yes, break
0B3B-FE 13          1336 (  6)         CP      CTRLS           ; Stop scrolling?
0B3D-C0             1337 ( 5+)         RET     NZ              ; Other key, ignore
0B3E-               1338
0B3E-               1339
0B3E-D7             1340 ( 11) STALL:  RST     10H             ; Wait for key
0B3F-FE 11          1341 (  6)         CP      CTRLQ           ; Resume scrolling?
0B41-C8             1342 ( 5+)         RET      Z              ; Release the chokehold
0B42-FE 03          1343 (  6)         CP      CTRLC           ; Second break?
0B44-28 07          1344 ( 6+)         JR      Z,STOP          ; Break during hold exits prog
0B46-18 F6          1345 (  8)         JR      STALL           ; Loop until <Ctrl-Q> or <brk>
0B48-               1346
0B48-3E FF          1347 (  6) BRK     LD      A,$FF           ; Set BRKFLG
0B4A-32 92 22       1348 ( 13)         LD      (BRKFLG),A      ; Store it
0B4D-               1349
0B4D-               1350
0B4D-C0             1351 ( 5+) STOP:   RET     NZ              ; Exit if anything else
0B4E-F6             1352               .DB   0F6H            ; Flag "STOP"
0B4F-C0             1353 ( 5+) PEND:   RET     NZ              ; Exit if anything else
0B50-22 13 23       1354 ( 20)         LD      (BRKLIN),HL     ; Save point of break
0B53-21             1355               .DB   21H             ; Skip "OR 11111111B"
0B54-F6 FF          1356 (  6) INPBRK: OR      11111111B       ; Flag "Break" wanted
0B56-C1             1357 (  9)         POP     BC              ; Return not needed and more
0B57-2A A1 22       1358 ( 15) ENDPRG: LD      HL,(LINEAT)     ; Get current line number
0B5A-F5             1359 ( 11)         PUSH    AF              ; Save STOP / END status
0B5B-7D             1360 (  4)         LD      A,L             ; Is it direct break?
0B5C-A4             1361 (  4)         AND     H
0B5D-3C             1362 (  4)         INC     A               ; Line is -1 if direct break
0B5E-CA 6A 0B       1363 ( 6+)         JP      Z,NOLIN         ; Yes - No line number
0B61-22 17 23       1364 ( 20)         LD      (ERRLIN),HL     ; Save line of break
0B64-2A 13 23       1365 ( 15)         LD      HL,(BRKLIN)     ; Get point of break
0B67-22 19 23       1366 ( 20)         LD      (CONTAD),HL     ; Save point to CONTinue
0B6A-AF             1367 (  4) NOLIN:  XOR     A
0B6B-32 8A 22       1368 ( 13)         LD      (CTLOFG),A      ; Enable output
0B6E-CD A0 0D       1369 ( 16)         CALL    STTLIN          ; Start a new line
0B71-F1             1370 (  9)         POP     AF              ; Restore STOP / END status
0B72-21 50 06       1371 (  9)         LD      HL,BRKMSG       ; "Break" message
0B75-C2 E1 06       1372 ( 6+)         JP      NZ,ERRIN        ; "in line" wanted?
0B78-C3 F8 06       1373 (  9)         JP      PRNTOK          ; Go to command mode
0B7B-               1374
0B7B-2A 19 23       1375 ( 15) CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
0B7E-7C             1376 (  4)         LD      A,H             ; Is it zero?
0B7F-B5             1377 (  4)         OR      L
0B80-1E 20          1378 (  6)         LD      E,CN            ; ?CN Error
0B82-CA C1 06       1379 ( 6+)         JP      Z,ERROR         ; Yes - output "?CN Error"
0B85-EB             1380 (  3)         EX      DE,HL           ; Save code string address
0B86-2A 17 23       1381 ( 15)         LD      HL,(ERRLIN)     ; Get line of last break
0B89-22 A1 22       1382 ( 20)         LD      (LINEAT),HL     ; Set up current line number
0B8C-EB             1383 (  3)         EX      DE,HL           ; Restore code string address
0B8D-C9             1384 (  9)         RET                     ; CONTinue where left off
0B8E-               1385
0B8E-CD D3 16       1386 ( 16) NULL:   CALL    GETINT          ; Get integer 0-255
0B91-C0             1387 ( 5+)         RET     NZ              ; Return if bad value
0B92-32 86 22       1388 ( 13)         LD      (NULLS),A       ; Set nulls number
0B95-C9             1389 (  9)         RET
0B96-               1390
0B96-               1391
0B96-E5             1392 ( 11) ACCSUM: PUSH    HL              ; Save address in array
0B97-2A 8F 22       1393 ( 15)         LD      HL,(CHKSUM)     ; Get check sum
0B9A-06 00          1394 (  6)         LD      B,0             ; BC - Value of byte
0B9C-4F             1395 (  4)         LD      C,A
0B9D-09             1396 (  7)         ADD     HL,BC           ; Add byte to check sum
0B9E-22 8F 22       1397 ( 20)         LD      (CHKSUM),HL     ; Re-save check sum
0BA1-E1             1398 (  9)         POP     HL              ; Restore address in array
0BA2-C9             1399 (  9)         RET
0BA3-               1400
0BA3-7E             1401 (  6) CHKLTR: LD      A,(HL)          ; Get byte
0BA4-FE 41          1402 (  6)         CP      'A'             ; < 'a' ?
0BA6-D8             1403 ( 5+)         RET     C               ; Carry set if not letter
0BA7-FE 5B          1404 (  6)         CP      'Z'+1           ; > 'z' ?
0BA9-3F             1405 (  3)         CCF
0BAA-C9             1406 (  9)         RET                     ; Carry set if not letter
0BAB-               1407
0BAB-CD 05 0B       1408 ( 16) FPSINT: CALL    GETCHR          ; Get next character
0BAE-CD 72 0F       1409 ( 16) POSINT: CALL    GETNUM          ; Get integer 0 to 32767
0BB1-CD 54 19       1410 ( 16) DEPINT: CALL    TSTSGN          ; Test sign of FPREG
0BB4-FA CC 0B       1411 ( 6+)         JP      M,FCERR         ; Negative - ?FC Error
0BB7-3A 2C 23       1412 ( 12) DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
0BBA-FE 90          1413 (  6)         CP      80H+16          ; Exponent in range (16 bits)?
0BBC-DA FC 19       1414 ( 6+)         JP      C,FPINT         ; Yes - convert it
0BBF-01 80 90       1415 (  9)         LD      BC,9080H        ; BCDE = -32768
0BC2-11 00 00       1416 (  9)         LD      DE,0000
0BC5-E5             1417 ( 11)         PUSH    HL              ; Save code string address
0BC6-CD CF 19       1418 ( 16)         CALL    CMPNUM          ; Compare FPREG with BCDE
0BC9-E1             1419 (  9)         POP     HL              ; Restore code string address
0BCA-51             1420 (  4)         LD      D,C             ; MSB to D
0BCB-C8             1421 ( 5+)         RET     Z               ; Return if in range
0BCC-1E 08          1422 (  6) FCERR:  LD      E,FC            ; ?FC Error
0BCE-C3 C1 06       1423 (  9)         JP      ERROR           ; Output error-
0BD1-               1424
0BD1-2B             1425 (  4) ATOH:   DEC     HL              ; ASCII number to DE binary
0BD2-11 00 00       1426 (  9) GETLN:  LD      DE,0            ; Get number to DE
0BD5-CD 05 0B       1427 ( 16) GTLNLP: CALL    GETCHR          ; Get next character
0BD8-D0             1428 ( 5+)         RET     NC              ; Exit if not a digit
0BD9-E5             1429 ( 11)         PUSH    HL              ; Save code string address
0BDA-F5             1430 ( 11)         PUSH    AF              ; Save digit
0BDB-21 98 19       1431 (  9)         LD      HL,65529/10     ; Largest number 65529
0BDE-CD 75 09       1432 ( 16)         CALL    CPDEHL          ; Number in range?
0BE1-DA AD 06       1433 ( 6+)         JP      C,SNERR         ; No - ?SN Error
0BE4-62             1434 (  4)         LD      H,D             ; HL = Number
0BE5-6B             1435 (  4)         LD      L,E
0BE6-19             1436 (  7)         ADD     HL,DE           ; Times 2
0BE7-29             1437 (  7)         ADD     HL,HL           ; Times 4
0BE8-19             1438 (  7)         ADD     HL,DE           ; Times 5
0BE9-29             1439 (  7)         ADD     HL,HL           ; Times 10
0BEA-F1             1440 (  9)         POP     AF              ; Restore digit
0BEB-D6 30          1441 (  6)         SUB     '0'             ; Make it 0 to 9
0BED-5F             1442 (  4)         LD      E,A             ; DE = Value of digit
0BEE-16 00          1443 (  6)         LD      D,0
0BF0-19             1444 (  7)         ADD     HL,DE           ; Add to number
0BF1-EB             1445 (  3)         EX      DE,HL           ; Number to DE
0BF2-E1             1446 (  9)         POP     HL              ; Restore code string address
0BF3-C3 D5 0B       1447 (  9)         JP      GTLNLP          ; Go to next character
0BF6-               1448
0BF6-CA C9 07       1449 ( 6+) CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
0BF9-CD AE 0B       1450 ( 16)         CALL    POSINT          ; Get integer 0 to 32767 to DE
0BFC-2B             1451 (  4)         DEC     HL              ; Cancel increment
0BFD-CD 05 0B       1452 ( 16)         CALL    GETCHR          ; Get next character
0C00-E5             1453 ( 11)         PUSH    HL              ; Save code string address
0C01-2A F4 22       1454 ( 15)         LD      HL,(LSTRAM)     ; Get end of RAM
0C04-CA 19 0C       1455 ( 6+)         JP      Z,STORED        ; No value given - Use stored
0C07-E1             1456 (  9)         POP     HL              ; Restore code string address
0C08-CD 7B 09       1457 ( 16)         CALL    CHKSYN          ; Check for comma
0C0B-2C             1458               .DB      ','
0C0C-D5             1459 ( 11)         PUSH    DE              ; Save number
0C0D-CD AE 0B       1460 ( 16)         CALL    POSINT          ; Get integer 0 to 32767
0C10-2B             1461 (  4)         DEC     HL              ; Cancel increment
0C11-CD 05 0B       1462 ( 16)         CALL    GETCHR          ; Get next character
0C14-C2 AD 06       1463 ( 6+)         JP      NZ,SNERR        ; ?SN Error if more on line
0C17-E3             1464 ( 16)         EX      (SP),HL         ; Save code string address
0C18-EB             1465 (  3)         EX      DE,HL           ; Number to DE
0C19-7D             1466 (  4) STORED: LD      A,L             ; Get LSB of new RAM top
0C1A-93             1467 (  4)         SUB     E               ; Subtract LSB of string space
0C1B-5F             1468 (  4)         LD      E,A             ; Save LSB
0C1C-7C             1469 (  4)         LD      A,H             ; Get MSB of new RAM top
0C1D-9A             1470 (  4)         SBC     A,D             ; Subtract MSB of string space
0C1E-57             1471 (  4)         LD      D,A             ; Save MSB
0C1F-DA A2 06       1472 ( 6+)         JP      C,OMERR         ; ?OM Error if not enough mem
0C22-E5             1473 ( 11)         PUSH    HL              ; Save RAM top
0C23-2A 1B 23       1474 ( 15)         LD      HL,(PROGND)     ; Get program end
0C26-01 28 00       1475 (  9)         LD      BC,40           ; 40 Bytes minimum working RAM
0C29-09             1476 (  7)         ADD     HL,BC           ; Get lowest address
0C2A-CD 75 09       1477 ( 16)         CALL    CPDEHL          ; Enough memory?
0C2D-D2 A2 06       1478 ( 6+)         JP      NC,OMERR        ; No - ?OM Error
0C30-EB             1479 (  3)         EX      DE,HL           ; RAM top to HL
0C31-22 9F 22       1480 ( 20)         LD      (STRSPC),HL     ; Set new string space
0C34-E1             1481 (  9)         POP     HL              ; End of memory to use
0C35-22 F4 22       1482 ( 20)         LD      (LSTRAM),HL     ; Set new top of RAM
0C38-E1             1483 (  9)         POP     HL              ; Restore code string address
0C39-C3 C9 07       1484 (  9)         JP      INTVAR          ; Initialise variables
0C3C-               1485
0C3C-CA C5 07       1486 ( 6+) RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
0C3F-CD C9 07       1487 ( 16)         CALL    INTVAR          ; Initialise variables
0C42-01 C5 0A       1488 (  9)         LD      BC,RUNCNT       ; Execution driver loop
0C45-C3 58 0C       1489 (  9)         JP      RUNLIN          ; RUN from line number
0C48-               1490
0C48-0E 03          1491 (  6) GOSUB:  LD      C,3             ; 3 Levels of stack needed
0C4A-CD 8A 06       1492 ( 16)         CALL    CHKSTK          ; Check for 3 levels of stack
0C4D-C1             1493 (  9)         POP     BC              ; Get return address
0C4E-E5             1494 ( 11)         PUSH    HL              ; Save code string for RETURN
0C4F-E5             1495 ( 11)         PUSH    HL              ; And for GOSUB routine
0C50-2A A1 22       1496 ( 15)         LD      HL,(LINEAT)     ; Get current line
0C53-E3             1497 ( 16)         EX      (SP),HL         ; Into stack - Code string out
0C54-3E 8C          1498 (  6)         LD      A,ZGOSUB        ; "GOSUB" token
0C56-F5             1499 ( 11)         PUSH    AF              ; Save token
0C57-33             1500 (  4)         INC     SP              ; Don't save flags
0C58-               1501
0C58-C5             1502 ( 11) RUNLIN: PUSH    BC              ; Save return address
0C59-CD D1 0B       1503 ( 16) GOTO:   CALL    ATOH            ; ASCII number to DE binary
0C5C-CD 9E 0C       1504 ( 16)         CALL    REM             ; Get end of line
0C5F-E5             1505 ( 11)         PUSH    HL              ; Save end of line
0C60-2A A1 22       1506 ( 15)         LD      HL,(LINEAT)     ; Get current line
0C63-CD 75 09       1507 ( 16)         CALL    CPDEHL          ; Line after current?
0C66-E1             1508 (  9)         POP     HL              ; Restore end of line
0C67-23             1509 (  4)         INC     HL              ; Start of next line
0C68-DC 9C 07       1510 ( 6+)         CALL    C,SRCHLP        ; Line is after current line
0C6B-D4 99 07       1511 ( 6+)         CALL    NC,SRCHLN       ; Line is before current line
0C6E-60             1512 (  4)         LD      H,B             ; Set up code string address
0C6F-69             1513 (  4)         LD      L,C
0C70-2B             1514 (  4)         DEC     HL              ; Incremented after
0C71-D8             1515 ( 5+)         RET     C               ; Line found
0C72-1E 0E          1516 (  6) ULERR:  LD      E,UL            ; ?UL Error
0C74-C3 C1 06       1517 (  9)         JP      ERROR           ; Output error message
0C77-               1518
0C77-C0             1519 ( 5+) RETURN: RET     NZ              ; Return if not just RETURN
0C78-16 FF          1520 (  6)         LD      D,-1            ; Flag "GOSUB" search
0C7A-CD 56 06       1521 ( 16)         CALL    BAKSTK          ; Look "GOSUB" block
0C7D-F9             1522 (  4)         LD      SP,HL           ; Kill all FORs in subroutine
0C7E-FE 8C          1523 (  6)         CP      ZGOSUB          ; Test for "GOSUB" token
0C80-1E 04          1524 (  6)         LD      E,RG            ; ?RG Error
0C82-C2 C1 06       1525 ( 6+)         JP      NZ,ERROR        ; Error if no "GOSUB" found
0C85-E1             1526 (  9)         POP     HL              ; Get RETURN line number
0C86-22 A1 22       1527 ( 20)         LD      (LINEAT),HL     ; Save as current
0C89-23             1528 (  4)         INC     HL              ; Was it from direct statement?
0C8A-7C             1529 (  4)         LD      A,H
0C8B-B5             1530 (  4)         OR      L               ; Return to line
0C8C-C2 96 0C       1531 ( 6+)         JP      NZ,RETLIN       ; No - Return to line
0C8F-3A 11 23       1532 ( 12)         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
0C92-B7             1533 (  4)         OR      A               ; If so buffer is corrupted
0C93-C2 F7 06       1534 ( 6+)         JP      NZ,POPNOK       ; Yes - Go to command mode
0C96-21 C5 0A       1535 (  9) RETLIN: LD      HL,RUNCNT       ; Execution driver loop
0C99-E3             1536 ( 16)         EX      (SP),HL         ; Into stack - Code string out
0C9A-3E             1537               .DB      3EH             ; Skip "POP HL"
0C9B-E1             1538 (  9) NXTDTA: POP     HL              ; Restore code string address
0C9C-               1539
0C9C-01 3A          1540       DATA:   .DB      01H,3AH         ; ':' End of statement
0C9E-0E 00          1541 (  6) REM:    LD      C,0             ; 00  End of statement
0CA0-06 00          1542 (  6)         LD      B,0
0CA2-79             1543 (  4) NXTSTL: LD      A,C             ; Statement and byte
0CA3-48             1544 (  4)         LD      C,B
0CA4-47             1545 (  4)         LD      B,A             ; Statement end byte
0CA5-7E             1546 (  6) NXTSTT: LD      A,(HL)          ; Get byte
0CA6-B7             1547 (  4)         OR      A               ; End of line?
0CA7-C8             1548 ( 5+)         RET     Z               ; Yes - Exit
0CA8-B8             1549 (  4)         CP      B               ; End of statement?
0CA9-C8             1550 ( 5+)         RET     Z               ; Yes - Exit
0CAA-23             1551 (  4)         INC     HL              ; Next byte
0CAB-FE 22          1552 (  6)         CP      '"'             ; Literal string?
0CAD-CA A2 0C       1553 ( 6+)         JP      Z,NXTSTL        ; Yes - Look for another '"'
0CB0-C3 A5 0C       1554 (  9)         JP      NXTSTT          ; Keep looking
0CB3-               1555
0CB3-CD 68 11       1556 ( 16) LET:    CALL    GETVAR          ; Get variable name
0CB6-CD 7B 09       1557 ( 16)         CALL    CHKSYN          ; Make sure "=" follows
0CB9-B4             1558               .DB      ZEQUAL          ; "=" token
0CBA-D5             1559 ( 11)         PUSH    DE              ; Save address of variable
0CBB-3A F2 22       1560 ( 12)         LD      A,(TYPE)        ; Get data type
0CBE-F5             1561 ( 11)         PUSH    AF              ; Save type
0CBF-CD 84 0F       1562 ( 16)         CALL    EVAL            ; Evaluate expression
0CC2-F1             1563 (  9)         POP     AF              ; Restore type
0CC3-E3             1564 ( 16)         EX      (SP),HL         ; Save code - Get var addr
0CC4-22 13 23       1565 ( 20)         LD      (BRKLIN),HL     ; Save address of variable
0CC7-1F             1566 (  3)         RRA                     ; Adjust type
0CC8-CD 77 0F       1567 ( 16)         CALL    CHKTYP          ; Check types are the same
0CCB-CA 06 0D       1568 ( 6+)         JP      Z,LETNUM        ; Numeric - Move value
0CCE-E5             1569 ( 11) LETSTR: PUSH    HL              ; Save address of string var
0CCF-2A 29 23       1570 ( 15)         LD      HL,(FPREG)      ; Pointer to string entry
0CD2-E5             1571 ( 11)         PUSH    HL              ; Save it on stack
0CD3-23             1572 (  4)         INC     HL              ; Skip over length
0CD4-23             1573 (  4)         INC     HL
0CD5-5E             1574 (  6)         LD      E,(HL)          ; LSB of string address
0CD6-23             1575 (  4)         INC     HL
0CD7-56             1576 (  6)         LD      D,(HL)          ; MSB of string address
0CD8-2A A3 22       1577 ( 15)         LD      HL,(BASTXT)     ; Point to start of program
0CDB-CD 75 09       1578 ( 16)         CALL    CPDEHL          ; Is string before program?
0CDE-D2 F5 0C       1579 ( 6+)         JP      NC,CRESTR       ; Yes - Create string entry
0CE1-2A 9F 22       1580 ( 15)         LD      HL,(STRSPC)     ; Point to string space
0CE4-CD 75 09       1581 ( 16)         CALL    CPDEHL          ; Is string literal in program?
0CE7-D1             1582 (  9)         POP     DE              ; Restore address of string
0CE8-D2 FD 0C       1583 ( 6+)         JP      NC,MVSTPT       ; Yes - Set up pointer
0CEB-21 04 23       1584 (  9)         LD      HL,TMPSTR       ; Temporary string pool
0CEE-CD 75 09       1585 ( 16)         CALL    CPDEHL          ; Is string in temporary pool?
0CF1-D2 FD 0C       1586 ( 6+)         JP      NC,MVSTPT       ; No - Set up pointer
0CF4-3E             1587               .DB   3EH             ; Skip "POP DE"
0CF5-D1             1588 (  9) CRESTR: POP     DE              ; Restore address of string
0CF6-CD AC 15       1589 ( 16)         CALL    BAKTMP          ; Back to last tmp-str entry
0CF9-EB             1590 (  3)         EX      DE,HL           ; Address of string entry
0CFA-CD E5 13       1591 ( 16)         CALL    SAVSTR          ; Save string in string area
0CFD-CD AC 15       1592 ( 16) MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
0D00-E1             1593 (  9)         POP     HL              ; Get string pointer
0D01-CD AF 19       1594 ( 16)         CALL    DETHL4          ; Move string pointer to var
0D04-E1             1595 (  9)         POP     HL              ; Restore code string address
0D05-C9             1596 (  9)         RET
0D06-               1597
0D06-E5             1598 ( 11) LETNUM: PUSH    HL              ; Save address of variable
0D07-CD AC 19       1599 ( 16)         CALL    FPTHL           ; Move value to variable
0D0A-D1             1600 (  9)         POP     DE              ; Restore address of variable
0D0B-E1             1601 (  9)         POP     HL              ; Restore code string address
0D0C-C9             1602 (  9)         RET
0D0D-               1603
0D0D-CD D3 16       1604 ( 16) ON:     CALL    GETINT          ; Get integer 0-255
0D10-7E             1605 (  6)         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
0D11-47             1606 (  4)         LD      B,A             ; Save in B
0D12-FE 8C          1607 (  6)         CP      ZGOSUB          ; "GOSUB" token?
0D14-CA 1C 0D       1608 ( 6+)         JP      Z,ONGO          ; Yes - Find line number
0D17-CD 7B 09       1609 ( 16)         CALL    CHKSYN          ; Make sure it's "GOTO"
0D1A-88             1610               .DB   ZGOTO           ; "GOTO" token
0D1B-2B             1611 (  4)         DEC     HL              ; Cancel increment
0D1C-4B             1612 (  4) ONGO:   LD      C,E             ; Integer of branch value
0D1D-0D             1613 (  4) ONGOLP: DEC     C               ; Count branches
0D1E-78             1614 (  4)         LD      A,B             ; Get "GOTO" or "GOSUB" token
0D1F-CA ED 0A       1615 ( 6+)         JP      Z,ONJMP         ; Go to that line if right one
0D22-CD D2 0B       1616 ( 16)         CALL    GETLN           ; Get line number to DE
0D25-FE 2C          1617 (  6)         CP      ','             ; Another line number?
0D27-C0             1618 ( 5+)         RET     NZ              ; No - Drop through
0D28-C3 1D 0D       1619 (  9)         JP      ONGOLP          ; Yes - loop
0D2B-               1620
0D2B-CD 84 0F       1621 ( 16) IF:     CALL    EVAL            ; Evaluate expression
0D2E-7E             1622 (  6)         LD      A,(HL)          ; Get token
0D2F-FE 88          1623 (  6)         CP      ZGOTO           ; "GOTO" token?
0D31-CA 39 0D       1624 ( 6+)         JP      Z,IFGO          ; Yes - Get line
0D34-CD 7B 09       1625 ( 16)         CALL    CHKSYN          ; Make sure it's "THEN"
0D37-A9             1626               .DB      ZTHEN           ; "THEN" token
0D38-2B             1627 (  4)         DEC     HL              ; Cancel increment
0D39-CD 75 0F       1628 ( 16) IFGO:   CALL    TSTNUM          ; Make sure it's numeric
0D3C-CD 54 19       1629 ( 16)         CALL    TSTSGN          ; Test state of expression
0D3F-CA 9E 0C       1630 ( 6+)         JP      Z,REM           ; False - Drop through
0D42-CD 05 0B       1631 ( 16)         CALL    GETCHR          ; Get next character
0D45-DA 59 0C       1632 ( 6+)         JP      C,GOTO          ; Number - GOTO that line
0D48-C3 EC 0A       1633 (  9)         JP      IFJMP           ; Otherwise do statement
0D4B-               1634
0D4B-2B             1635 (  4) MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
0D4C-CD 05 0B       1636 ( 16)         CALL    GETCHR          ; Get next character
0D4F-CA AD 0D       1637 ( 6+) PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
0D52-C8             1638 ( 5+) PRNTLP: RET     Z               ; End of list - Exit
0D53-FE A5          1639 (  6)         CP      ZTAB            ; "TAB(" token?
0D55-CA E0 0D       1640 ( 6+)         JP      Z,DOTAB         ; Yes - Do TAB routine
0D58-FE A8          1641 (  6)         CP      ZSPC            ; "SPC(" token?
0D5A-CA E0 0D       1642 ( 6+)         JP      Z,DOTAB         ; Yes - Do SPC routine
0D5D-E5             1643 ( 11)         PUSH    HL              ; Save code string address
0D5E-FE 2C          1644 (  6)         CP      ','             ; Comma?
0D60-CA C9 0D       1645 ( 6+)         JP      Z,DOCOM         ; Yes - Move to next zone
0D63-FE 3B          1646 (  6)         CP      59 ;";"         ; Semi-colon?
0D65-CA 03 0E       1647 ( 6+)         JP      Z,NEXITM        ; Do semi-colon routine
0D68-C1             1648 (  9)         POP     BC              ; Code string address to BC
0D69-CD 84 0F       1649 ( 16)         CALL    EVAL            ; Evaluate expression
0D6C-E5             1650 ( 11)         PUSH    HL              ; Save code string address
0D6D-3A F2 22       1651 ( 12)         LD      A,(TYPE)        ; Get variable type
0D70-B7             1652 (  4)         OR      A               ; Is it a string variable?
0D71-C2 99 0D       1653 ( 6+)         JP      NZ,PRNTST       ; Yes - Output string contents
0D74-CD F9 1A       1654 ( 16)         CALL    NUMASC          ; Convert number to text
0D77-CD 09 14       1655 ( 16)         CALL    CRTST           ; Create temporary string
0D7A-36 20          1656 (  9)         LD      (HL),' '        ; Followed by a space
0D7C-2A 29 23       1657 ( 15)         LD      HL,(FPREG)      ; Get length of output
0D7F-34             1658 ( 10)         INC     (HL)            ; Plus 1 for the space
0D80-2A 29 23       1659 ( 15)         LD      HL,(FPREG)      ; < Not needed >
0D83-3A 87 22       1660 ( 12)         LD      A,(LWIDTH)      ; Get width of line
0D86-47             1661 (  4)         LD      B,A             ; To B
0D87-04             1662 (  4)         INC     B               ; Width 255 (No limit)?
0D88-CA 95 0D       1663 ( 6+)         JP      Z,PRNTNB        ; Yes - Output number string
0D8B-04             1664 (  4)         INC     B               ; Adjust it
0D8C-3A F0 22       1665 ( 12)         LD      A,(CURPOS)      ; Get cursor position
0D8F-86             1666 (  6)         ADD     A,(HL)          ; Add length of string
0D90-3D             1667 (  4)         DEC     A               ; Adjust it
0D91-B8             1668 (  4)         CP      B               ; Will output fit on this line?
0D92-D4 AD 0D       1669 ( 6+)         CALL    NC,PRNTCRLF     ; No - CRLF first
0D95-CD 4E 14       1670 ( 16) PRNTNB: CALL    PRS1            ; Output string at (HL)
0D98-AF             1671 (  4)         XOR     A               ; Skip CALL by setting 'z' flag
0D99-C4 4E 14       1672 ( 6+) PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
0D9C-E1             1673 (  9)         POP     HL              ; Restore code string address
0D9D-C3 4B 0D       1674 (  9)         JP      MRPRNT          ; See if more to PRINT
0DA0-               1675
0DA0-3A F0 22       1676 ( 12) STTLIN: LD      A,(CURPOS)      ; Make sure on new line
0DA3-B7             1677 (  4)         OR      A               ; Already at start?
0DA4-C8             1678 ( 5+)         RET     Z               ; Yes - Do nothing
0DA5-C3 AD 0D       1679 (  9)         JP      PRNTCRLF        ; Start a new line
0DA8-               1680
0DA8-36 00          1681 (  9) ENDINP: LD      (HL),0          ; Mark end of buffer
0DAA-21 A5 22       1682 (  9)         LD      HL,BUFFER-1     ; Point to buffer
0DAD-3E 0D          1683 (  6) PRNTCRLF: LD    A,CR            ; Load a CR
0DAF-CD 86 09       1684 ( 16)         CALL    OUTC            ; Output character
0DB2-3E 0A          1685 (  6)         LD      A,LF            ; Load a LF
0DB4-CD 86 09       1686 ( 16)         CALL    OUTC            ; Output character
0DB7-AF             1687 (  4) DONULL: XOR     A               ; Set to position 0
0DB8-32 F0 22       1688 ( 13)         LD      (CURPOS),A      ; Store it
0DBB-3A 86 22       1689 ( 12)         LD      A,(NULLS)       ; Get number of nulls
0DBE-3D             1690 (  4) NULLP:  DEC     A               ; Count them
0DBF-C8             1691 ( 5+)         RET     Z               ; Return if done
0DC0-F5             1692 ( 11)         PUSH    AF              ; Save count
0DC1-AF             1693 (  4)         XOR     A               ; Load a null
0DC2-CD 86 09       1694 ( 16)         CALL    OUTC            ; Output it
0DC5-F1             1695 (  9)         POP     AF              ; Restore count
0DC6-C3 BE 0D       1696 (  9)         JP      NULLP           ; Keep counting
0DC9-               1697
0DC9-3A 88 22       1698 ( 12) DOCOM:  LD      A,(COMMAN)      ; Get comma width
0DCC-47             1699 (  4)         LD      B,A             ; Save in B
0DCD-3A F0 22       1700 ( 12)         LD      A,(CURPOS)      ; Get current position
0DD0-B8             1701 (  4)         CP      B               ; Within the limit?
0DD1-D4 AD 0D       1702 ( 6+)         CALL    NC,PRNTCRLF     ; No - output CRLF
0DD4-D2 03 0E       1703 ( 6+)         JP      NC,NEXITM       ; Get next item
0DD7-D6 0E          1704 (  6) ZONELP: SUB     14              ; Next zone of 14 characters
0DD9-D2 D7 0D       1705 ( 6+)         JP      NC,ZONELP       ; Repeat if more zones
0DDC-2F             1706 (  3)         CPL                     ; Number of spaces to output
0DDD-C3 F8 0D       1707 (  9)         JP      ASPCS           ; Output them
0DE0-               1708
0DE0-F5             1709 ( 11) DOTAB:  PUSH    AF              ; Save token
0DE1-CD D0 16       1710 ( 16)         CALL    FNDNUM          ; Evaluate expression
0DE4-CD 7B 09       1711 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
0DE7-29             1712               .DB   ")"
0DE8-2B             1713 (  4)         DEC     HL              ; Back space on to ")"
0DE9-F1             1714 (  9)         POP     AF              ; Restore token
0DEA-D6 A8          1715 (  6)         SUB     ZSPC            ; Was it "SPC(" ?
0DEC-E5             1716 ( 11)         PUSH    HL              ; Save code string address
0DED-CA F3 0D       1717 ( 6+)         JP      Z,DOSPC         ; Yes - Do 'E' spaces
0DF0-3A F0 22       1718 ( 12)         LD      A,(CURPOS)      ; Get current position
0DF3-2F             1719 (  3) DOSPC:  CPL                     ; Number of spaces to print to
0DF4-83             1720 (  4)         ADD     A,E             ; Total number to print
0DF5-D2 03 0E       1721 ( 6+)         JP      NC,NEXITM       ; TAB < Current POS(X)
0DF8-3C             1722 (  4) ASPCS:  INC     A               ; Output A spaces
0DF9-47             1723 (  4)         LD      B,A             ; Save number to print
0DFA-3E 20          1724 (  6)         LD      A,' '           ; Space
0DFC-CD 86 09       1725 ( 16) SPCLP:  CALL    OUTC            ; Output character in A
0DFF-05             1726 (  4)         DEC     B               ; Count them
0E00-C2 FC 0D       1727 ( 6+)         JP      NZ,SPCLP        ; Repeat if more
0E03-E1             1728 (  9) NEXITM: POP     HL              ; Restore code string address
0E04-CD 05 0B       1729 ( 16)         CALL    GETCHR          ; Get next character
0E07-C3 52 0D       1730 (  9)         JP      PRNTLP          ; More to print
0E0A-               1731
0E0A-3F 52 65 64 
     6F 20 66 72 
     6F 6D 20 73 
     74 61 72 74 
     0D 0A 00       1732       REDO:   .DB   "?Redo from start",CR,LF,0
0E1D-               1733
0E1D-3A 12 23       1734 ( 12) BADINP: LD      A,(READFG)      ; READ or INPUT?
0E20-B7             1735 (  4)         OR      A
0E21-C2 A7 06       1736 ( 6+)         JP      NZ,DATSNR       ; READ - ?SN Error
0E24-C1             1737 (  9)         POP     BC              ; Throw away code string addr
0E25-21 0A 0E       1738 (  9)         LD      HL,REDO         ; "Redo from start" message
0E28-CD 4B 14       1739 ( 16)         CALL    PRS             ; Output string
0E2B-C3 F8 07       1740 (  9)         JP      DOAGN           ; Do last INPUT again
0E2E-               1741
0E2E-CD B6 13       1742 ( 16) INPUT:  CALL    IDTEST          ; Test for illegal direct
0E31-7E             1743 (  6)         LD      A,(HL)          ; Get character after "INPUT"
0E32-FE 22          1744 (  6)         CP      '"'             ; Is there a prompt string?
0E34-3E 00          1745 (  6)         LD      A,0             ; Clear A and leave flags
0E36-32 8A 22       1746 ( 13)         LD      (CTLOFG),A      ; Enable output
0E39-C2 48 0E       1747 ( 6+)         JP      NZ,NOPMPT       ; No prompt - get input
0E3C-CD 0A 14       1748 ( 16)         CALL    QTSTR           ; Get string terminated by '"'
0E3F-CD 7B 09       1749 ( 16)         CALL    CHKSYN          ; Check for ';' after prompt
0E42-3B             1750               .DB   ';'
0E43-E5             1751 ( 11)         PUSH    HL              ; Save code string address
0E44-CD 4E 14       1752 ( 16)         CALL    PRS1            ; Output prompt string
0E47-3E             1753               .DB   3EH             ; Skip "PUSH HL"
0E48-E5             1754 ( 11) NOPMPT: PUSH    HL              ; Save code string address
0E49-CD FC 07       1755 ( 16)         CALL    PROMPT          ; Get input with "? " prompt
0E4C-C1             1756 (  9)         POP     BC              ; Restore code string address
0E4D-DA 54 0B       1757 ( 6+)         JP      C,INPBRK        ; Break pressed - Exit
0E50-23             1758 (  4)         INC     HL              ; Next byte
0E51-7E             1759 (  6)         LD      A,(HL)          ; Get it
0E52-B7             1760 (  4)         OR      A               ; End of line?
0E53-2B             1761 (  4)         DEC     HL              ; Back again
0E54-C5             1762 ( 11)         PUSH    BC              ; Re-save code string address
0E55-CA 9B 0C       1763 ( 6+)         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
0E58-36 2C          1764 (  9)         LD      (HL),','        ; Store comma as separator
0E5A-C3 62 0E       1765 (  9)         JP      NXTITM          ; Get next item
0E5D-               1766
0E5D-E5             1767 ( 11) READ:   PUSH    HL              ; Save code string address
0E5E-2A 21 23       1768 ( 15)         LD      HL,(NXTDAT)     ; Next DATA statement
0E61-F6             1769               .DB   0F6H            ; Flag "READ"
0E62-AF             1770 (  4) NXTITM: XOR     A               ; Flag "INPUT"
0E63-32 12 23       1771 ( 13)         LD      (READFG),A      ; Save "READ"/"INPUT" flag
0E66-E3             1772 ( 16)         EX      (SP),HL         ; Get code str' , Save pointer
0E67-C3 6E 0E       1773 (  9)         JP      GTVLUS          ; Get values
0E6A-               1774
0E6A-CD 7B 09       1775 ( 16) NEDMOR: CALL    CHKSYN          ; Check for comma between items
0E6D-2C             1776               .DB      ','
0E6E-CD 68 11       1777 ( 16) GTVLUS: CALL    GETVAR          ; Get variable name
0E71-E3             1778 ( 16)         EX      (SP),HL         ; Save code str" , Get pointer
0E72-D5             1779 ( 11)         PUSH    DE              ; Save variable address
0E73-7E             1780 (  6)         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
0E74-FE 2C          1781 (  6)         CP      ','             ; Comma?
0E76-CA 96 0E       1782 ( 6+)         JP      Z,ANTVLU        ; Yes - Get another value
0E79-3A 12 23       1783 ( 12)         LD      A,(READFG)      ; Is it READ?
0E7C-B7             1784 (  4)         OR      A
0E7D-C2 03 0F       1785 ( 6+)         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
0E80-3E 3F          1786 (  6)         LD      A,'?'           ; More INPUT needed
0E82-CD 86 09       1787 ( 16)         CALL    OUTC            ; Output character
0E85-CD FC 07       1788 ( 16)         CALL    PROMPT          ; Get INPUT with prompt
0E88-D1             1789 (  9)         POP     DE              ; Variable address
0E89-C1             1790 (  9)         POP     BC              ; Code string address
0E8A-DA 54 0B       1791 ( 6+)         JP      C,INPBRK        ; Break pressed
0E8D-23             1792 (  4)         INC     HL              ; Point to next DATA byte
0E8E-7E             1793 (  6)         LD      A,(HL)          ; Get byte
0E8F-B7             1794 (  4)         OR      A               ; Is it zero (No input) ?
0E90-2B             1795 (  4)         DEC     HL              ; Back space INPUT pointer
0E91-C5             1796 ( 11)         PUSH    BC              ; Save code string address
0E92-CA 9B 0C       1797 ( 6+)         JP      Z,NXTDTA        ; Find end of buffer
0E95-D5             1798 ( 11)         PUSH    DE              ; Save variable address
0E96-3A F2 22       1799 ( 12) ANTVLU: LD      A,(TYPE)        ; Check data type
0E99-B7             1800 (  4)         OR      A               ; Is it numeric?
0E9A-CA C0 0E       1801 ( 6+)         JP      Z,INPBIN        ; Yes - Convert to binary
0E9D-CD 05 0B       1802 ( 16)         CALL    GETCHR          ; Get next character
0EA0-57             1803 (  4)         LD      D,A             ; Save input character
0EA1-47             1804 (  4)         LD      B,A             ; Again
0EA2-FE 22          1805 (  6)         CP      '"'             ; Start of literal sting?"
0EA4-CA B4 0E       1806 ( 6+)         JP      Z,STRENT        ; Yes - Create string entry
0EA7-3A 12 23       1807 ( 12)         LD      A,(READFG)      ; "READ" or "INPUT" ?
0EAA-B7             1808 (  4)         OR      A
0EAB-57             1809 (  4)         LD      D,A             ; Save 00 if "INPUT"
0EAC-CA B1 0E       1810 ( 6+)         JP      Z,ITMSEP        ; "INPUT" - End with 00
0EAF-16 3A          1811 (  6)         LD      D,':'           ; "DATA" - End with 00 or ':'
0EB1-06 2C          1812 (  6) ITMSEP: LD      B,','           ; Item separator
0EB3-2B             1813 (  4)         DEC     HL              ; Back space for DTSTR
0EB4-CD 0D 14       1814 ( 16) STRENT: CALL    DTSTR           ; Get string terminated by D
0EB7-EB             1815 (  3)         EX      DE,HL           ; String address to DE
0EB8-21 CB 0E       1816 (  9)         LD      HL,LTSTND       ; Where to go after LETSTR
0EBB-E3             1817 ( 16)         EX      (SP),HL         ; Save HL , get input pointer
0EBC-D5             1818 ( 11)         PUSH    DE              ; Save address of string
0EBD-C3 CE 0C       1819 (  9)         JP      LETSTR          ; Assign string to variable
0EC0-               1820
0EC0-CD 05 0B       1821 ( 16) INPBIN: CALL    GETCHR          ; Get next character
0EC3-CD 5B 1A       1822 ( 16)         CALL    ASCTFP          ; Convert ASCII to FP number
0EC6-E3             1823 ( 16)         EX      (SP),HL         ; Save input ptr, Get var addr
0EC7-CD AC 19       1824 ( 16)         CALL    FPTHL           ; Move FPREG to variable
0ECA-E1             1825 (  9)         POP     HL              ; Restore input pointer
0ECB-2B             1826 (  4) LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
0ECC-CD 05 0B       1827 ( 16)         CALL    GETCHR          ; Get next character
0ECF-CA D7 0E       1828 ( 6+)         JP      Z,MORDT         ; End of line - More needed?
0ED2-FE 2C          1829 (  6)         CP      ','             ; Another value?
0ED4-C2 1D 0E       1830 ( 6+)         JP      NZ,BADINP       ; No - Bad input
0ED7-E3             1831 ( 16) MORDT:  EX      (SP),HL         ; Get code string address
0ED8-2B             1832 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
0ED9-CD 05 0B       1833 ( 16)         CALL    GETCHR          ; Get next character
0EDC-C2 6A 0E       1834 ( 6+)         JP      NZ,NEDMOR       ; More needed - Get it
0EDF-D1             1835 (  9)         POP     DE              ; Restore DATA pointer
0EE0-3A 12 23       1836 ( 12)         LD      A,(READFG)      ; "READ" or "INPUT" ?
0EE3-B7             1837 (  4)         OR      A
0EE4-EB             1838 (  3)         EX      DE,HL           ; DATA pointer to HL
0EE5-C2 2B 0B       1839 ( 6+)         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
0EE8-D5             1840 ( 11)         PUSH    DE              ; Save code string address
0EE9-B6             1841 (  6)         OR      (HL)            ; More input given?
0EEA-21 F2 0E       1842 (  9)         LD      HL,EXTIG        ; "?Extra ignored" message
0EED-C4 4B 14       1843 ( 6+)         CALL    NZ,PRS          ; Output string if extra given
0EF0-E1             1844 (  9)         POP     HL              ; Restore code string address
0EF1-C9             1845 (  9)         RET
0EF2-               1846
0EF2-3F 45 78 74 
     72 61 20 69 
     67 6E 6F 72 
     65 64 0D 0A 
     00             1847       EXTIG:  .DB   "?Extra ignored",CR,LF,0
0F03-               1848
0F03-CD 9C 0C       1849 ( 16) FDTLP:  CALL    DATA            ; Get next statement
0F06-B7             1850 (  4)         OR      A               ; End of line?
0F07-C2 1C 0F       1851 ( 6+)         JP      NZ,FANDT        ; No - See if DATA statement
0F0A-23             1852 (  4)         INC     HL
0F0B-7E             1853 (  6)         LD      A,(HL)          ; End of program?
0F0C-23             1854 (  4)         INC     HL
0F0D-B6             1855 (  6)         OR      (HL)            ; 00 00 Ends program
0F0E-1E 06          1856 (  6)         LD      E,OD            ; ?OD Error
0F10-CA C1 06       1857 ( 6+)         JP      Z,ERROR         ; Yes - Out of DATA
0F13-23             1858 (  4)         INC     HL
0F14-5E             1859 (  6)         LD      E,(HL)          ; LSB of line number
0F15-23             1860 (  4)         INC     HL
0F16-56             1861 (  6)         LD      D,(HL)          ; MSB of line number
0F17-EB             1862 (  3)         EX      DE,HL
0F18-22 0E 23       1863 ( 20)         LD      (DATLIN),HL     ; Set line of current DATA item
0F1B-EB             1864 (  3)         EX      DE,HL
0F1C-CD 05 0B       1865 ( 16) FANDT:  CALL    GETCHR          ; Get next character
0F1F-FE 83          1866 (  6)         CP      ZDATA           ; "DATA" token
0F21-C2 03 0F       1867 ( 6+)         JP      NZ,FDTLP        ; No "DATA" - Keep looking
0F24-C3 96 0E       1868 (  9)         JP      ANTVLU          ; Found - Convert input
0F27-               1869
0F27-11 00 00       1870 (  9) NEXT:   LD      DE,0            ; In case no index given
0F2A-C4 68 11       1871 ( 6+) NEXT1:  CALL    NZ,GETVAR       ; Get index address
0F2D-22 13 23       1872 ( 20)         LD      (BRKLIN),HL     ; Save code string address
0F30-CD 56 06       1873 ( 16)         CALL    BAKSTK          ; Look for "FOR" block
0F33-C2 B3 06       1874 ( 6+)         JP      NZ,NFERR        ; No "FOR" - ?NF Error
0F36-F9             1875 (  4)         LD      SP,HL           ; Clear nested loops
0F37-D5             1876 ( 11)         PUSH    DE              ; Save index address
0F38-7E             1877 (  6)         LD      A,(HL)          ; Get sign of STEP
0F39-23             1878 (  4)         INC     HL
0F3A-F5             1879 ( 11)         PUSH    AF              ; Save sign of STEP
0F3B-D5             1880 ( 11)         PUSH    DE              ; Save index address
0F3C-CD 92 19       1881 ( 16)         CALL    PHLTFP          ; Move index value to FPREG
0F3F-E3             1882 ( 16)         EX      (SP),HL         ; Save address of TO value
0F40-E5             1883 ( 11)         PUSH    HL              ; Save address of index
0F41-CD FF 16       1884 ( 16)         CALL    ADDPHL          ; Add STEP to index value
0F44-E1             1885 (  9)         POP     HL              ; Restore address of index
0F45-CD AC 19       1886 ( 16)         CALL    FPTHL           ; Move value to index variable
0F48-E1             1887 (  9)         POP     HL              ; Restore address of TO value
0F49-CD A3 19       1888 ( 16)         CALL    LOADFP          ; Move TO value to BCDE
0F4C-E5             1889 ( 11)         PUSH    HL              ; Save address of line of FOR
0F4D-CD CF 19       1890 ( 16)         CALL    CMPNUM          ; Compare index with TO value
0F50-E1             1891 (  9)         POP     HL              ; Restore address of line num
0F51-C1             1892 (  9)         POP     BC              ; Address of sign of STEP
0F52-90             1893 (  4)         SUB     B               ; Compare with expected sign
0F53-CD A3 19       1894 ( 16)         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
0F56-CA 62 0F       1895 ( 6+)         JP      Z,KILFOR        ; Loop finished - Terminate it
0F59-EB             1896 (  3)         EX      DE,HL           ; Loop statement line number
0F5A-22 A1 22       1897 ( 20)         LD      (LINEAT),HL     ; Set loop line number
0F5D-69             1898 (  4)         LD      L,C             ; Set code string to loop
0F5E-60             1899 (  4)         LD      H,B
0F5F-C3 C1 0A       1900 (  9)         JP      PUTFID          ; Put back "FOR" and continue
0F62-               1901
0F62-F9             1902 (  4) KILFOR: LD      SP,HL           ; Remove "FOR" block
0F63-2A 13 23       1903 ( 15)         LD      HL,(BRKLIN)     ; Code string after "NEXT"
0F66-7E             1904 (  6)         LD      A,(HL)          ; Get next byte in code string
0F67-FE 2C          1905 (  6)         CP      ','             ; More NEXTs ?
0F69-C2 C5 0A       1906 ( 6+)         JP      NZ,RUNCNT       ; No - Do next statement
0F6C-CD 05 0B       1907 ( 16)         CALL    GETCHR          ; Position to index name
0F6F-CD 2A 0F       1908 ( 16)         CALL    NEXT1           ; Re-enter NEXT routine
0F72-               1909       ; < will not RETurn to here , Exit to RUNCNT or Loop >
0F72-               1910
0F72-CD 84 0F       1911 ( 16) GETNUM: CALL    EVAL            ; Get a numeric expression
0F75-F6             1912       TSTNUM: .DB      0F6H            ; Clear carry (numeric)
0F76-37             1913 (  3) TSTSTR: SCF                     ; Set carry (string)
0F77-3A F2 22       1914 ( 12) CHKTYP: LD      A,(TYPE)        ; Check types match
0F7A-8F             1915 (  4)         ADC     A,A             ; Expected + actual
0F7B-B7             1916 (  4)         OR      A               ; Clear carry , set parity
0F7C-E8             1917 ( 5+)         RET     PE              ; Even parity - Types match
0F7D-C3 BF 06       1918 (  9)         JP      TMERR           ; Different types - Error
0F80-               1919
0F80-CD 7B 09       1920 ( 16) OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
0F83-28             1921               .DB   "("
0F84-2B             1922 (  4) EVAL:   DEC     HL              ; Evaluate expression & save
0F85-16 00          1923 (  6)         LD      D,0             ; Precedence value
0F87-D5             1924 ( 11) EVAL1:  PUSH    DE              ; Save precedence
0F88-0E 01          1925 (  6)         LD      C,1
0F8A-CD 8A 06       1926 ( 16)         CALL    CHKSTK          ; Check for 1 level of stack
0F8D-CD FB 0F       1927 ( 16)         CALL    OPRND           ; Get next expression value
0F90-22 15 23       1928 ( 20) EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
0F93-2A 15 23       1929 ( 15) EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
0F96-C1             1930 (  9)         POP     BC              ; Precedence value and operator
0F97-78             1931 (  4)         LD      A,B             ; Get precedence value
0F98-FE 78          1932 (  6)         CP      78H             ; "AND" or "OR" ?
0F9A-D4 75 0F       1933 ( 6+)         CALL    NC,TSTNUM       ; No - Make sure it's a number
0F9D-7E             1934 (  6)         LD      A,(HL)          ; Get next operator / function
0F9E-16 00          1935 (  6)         LD      D,0             ; Clear Last relation
0FA0-D6 B3          1936 (  6) RLTLP:  SUB     ZGTR            ; ">" Token
0FA2-DA BC 0F       1937 ( 6+)         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
0FA5-FE 03          1938 (  6)         CP      ZLTH+1-ZGTR     ; < = >
0FA7-D2 BC 0F       1939 ( 6+)         JP      NC,FOPRND       ; Function - Call it
0FAA-FE 01          1940 (  6)         CP      ZEQUAL-ZGTR     ; "="
0FAC-17             1941 (  3)         RLA                     ; <- Test for legal
0FAD-AA             1942 (  4)         XOR     D               ; <- combinations of < = >
0FAE-BA             1943 (  4)         CP      D               ; <- by combining last token
0FAF-57             1944 (  4)         LD      D,A             ; <- with current one
0FB0-DA AD 06       1945 ( 6+)         JP      C,SNERR         ; Error if "<<' '==" or ">>"
0FB3-22 0A 23       1946 ( 20)         LD      (CUROPR),HL     ; Save address of current token
0FB6-CD 05 0B       1947 ( 16)         CALL    GETCHR          ; Get next character
0FB9-C3 A0 0F       1948 (  9)         JP      RLTLP           ; Treat the two as one
0FBC-               1949
0FBC-7A             1950 (  4) FOPRND: LD      A,D             ; < = > found ?
0FBD-B7             1951 (  4)         OR      A
0FBE-C2 E3 10       1952 ( 6+)         JP      NZ,TSTRED       ; Yes - Test for reduction
0FC1-7E             1953 (  6)         LD      A,(HL)          ; Get operator token
0FC2-22 0A 23       1954 ( 20)         LD      (CUROPR),HL     ; Save operator address
0FC5-D6 AC          1955 (  6)         SUB     ZPLUS           ; Operator or function?
0FC7-D8             1956 ( 5+)         RET     C               ; Neither - Exit
0FC8-FE 07          1957 (  6)         CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
0FCA-D0             1958 ( 5+)         RET     NC              ; No - Exit
0FCB-5F             1959 (  4)         LD      E,A             ; Coded operator
0FCC-3A F2 22       1960 ( 12)         LD      A,(TYPE)        ; Get data type
0FCF-3D             1961 (  4)         DEC     A               ; FF = numeric , 00 = string
0FD0-B3             1962 (  4)         OR      E               ; Combine with coded operator
0FD1-7B             1963 (  4)         LD      A,E             ; Get coded operator
0FD2-CA 41 15       1964 ( 6+)         JP      Z,CONCAT        ; String concatenation
0FD5-07             1965 (  3)         RLCA                    ; Times 2
0FD6-83             1966 (  4)         ADD     A,E             ; Times 3
0FD7-5F             1967 (  4)         LD      E,A             ; To DE (D is 0)
0FD8-21 9F 05       1968 (  9)         LD      HL,PRITAB       ; Precedence table
0FDB-19             1969 (  7)         ADD     HL,DE           ; To the operator concerned
0FDC-78             1970 (  4)         LD      A,B             ; Last operator precedence
0FDD-56             1971 (  6)         LD      D,(HL)          ; Get evaluation precedence
0FDE-BA             1972 (  4)         CP      D               ; Compare with eval precedence
0FDF-D0             1973 ( 5+)         RET     NC              ; Exit if higher precedence
0FE0-23             1974 (  4)         INC     HL              ; Point to routine address
0FE1-CD 75 0F       1975 ( 16)         CALL    TSTNUM          ; Make sure it's a number
0FE4-               1976
0FE4-C5             1977 ( 11) STKTHS: PUSH    BC              ; Save last precedence & token
0FE5-01 93 0F       1978 (  9)         LD      BC,EVAL3        ; Where to go on prec' break
0FE8-C5             1979 ( 11)         PUSH    BC              ; Save on stack for return
0FE9-43             1980 (  4)         LD      B,E             ; Save operator
0FEA-4A             1981 (  4)         LD      C,D             ; Save precedence
0FEB-CD 85 19       1982 ( 16)         CALL    STAKFP          ; Move value to stack
0FEE-58             1983 (  4)         LD      E,B             ; Restore operator
0FEF-51             1984 (  4)         LD      D,C             ; Restore precedence
0FF0-4E             1985 (  6)         LD      C,(HL)          ; Get LSB of routine address
0FF1-23             1986 (  4)         INC     HL
0FF2-46             1987 (  6)         LD      B,(HL)          ; Get MSB of routine address
0FF3-23             1988 (  4)         INC     HL
0FF4-C5             1989 ( 11)         PUSH    BC              ; Save routine address
0FF5-2A 0A 23       1990 ( 15)         LD      HL,(CUROPR)     ; Address of current operator
0FF8-C3 87 0F       1991 (  9)         JP      EVAL1           ; Loop until prec' break
0FFB-               1992
0FFB-AF             1993 (  4) OPRND:  XOR     A               ; Get operand routine
0FFC-32 F2 22       1994 ( 13)         LD      (TYPE),A        ; Set numeric expected
0FFF-CD 05 0B       1995 ( 16)         CALL    GETCHR          ; Get next character
1002-1E 24          1996 (  6)         LD      E,MO            ; ?MO Error
1004-CA C1 06       1997 ( 6+)         JP      Z,ERROR         ; No operand - Error
1007-DA 5B 1A       1998 ( 6+)         JP      C,ASCTFP        ; Number - Get value
100A-CD A3 0B       1999 ( 16)         CALL    CHKLTR          ; See if a letter
100D-D2 62 10       2000 ( 6+)         JP      NC,CONVAR       ; Letter - Find variable
1010-FE 26          2001 (  6)         CP      '&'                             ; &H = HEX, &B = BINARY
1012-20 12          2002 ( 6+)         JR      NZ,NOTAMP
1014-CD 05 0B       2003 ( 16)         CALL    GETCHR          ; Get next character
1017-FE 48          2004 (  6)         CP      'H'             ; Hex number indicated? [function added]
1019-CA 9F 1E       2005 ( 6+)         JP      Z,HEXTFP        ; Convert Hex to FPREG
101C-FE 42          2006 (  6)         CP      'B'             ; Binary number indicated? [function added]
101E-CA 0F 1F       2007 ( 6+)         JP      Z,BINTFP        ; Convert Bin to FPREG
1021-1E 02          2008 (  6)         LD      E,SN            ; If neither then a ?SN Error
1023-CA C1 06       2009 ( 6+)         JP      Z,ERROR         ;
1026-FE AC          2010 (  6) NOTAMP: CP      ZPLUS           ; '+' Token ?
1028-CA FB 0F       2011 ( 6+)         JP      Z,OPRND         ; Yes - Look for operand
102B-FE 2E          2012 (  6)         CP      '.'             ; '.' ?
102D-CA 5B 1A       2013 ( 6+)         JP      Z,ASCTFP        ; Yes - Create FP number
1030-FE AD          2014 (  6)         CP      ZMINUS          ; '-' Token ?
1032-CA 51 10       2015 ( 6+)         JP      Z,MINUS         ; Yes - Do minus
1035-FE 22          2016 (  6)         CP      '"'             ; Literal string ?
1037-CA 0A 14       2017 ( 6+)         JP      Z,QTSTR         ; Get string terminated by '"'
103A-FE AA          2018 (  6)         CP      ZNOT            ; "NOT" Token ?
103C-CA 43 11       2019 ( 6+)         JP      Z,EVNOT         ; Yes - Eval NOT expression
103F-FE A7          2020 (  6)         CP      ZFN             ; "FN" Token ?
1041-CA 6E 13       2021 ( 6+)         JP      Z,DOFN          ; Yes - Do FN routine
1044-D6 B6          2022 (  6)         SUB     ZSGN            ; Is it a function?
1046-D2 73 10       2023 ( 6+)         JP      NC,FNOFST       ; Yes - Evaluate function
1049-CD 80 0F       2024 ( 16) EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
104C-CD 7B 09       2025 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
104F-29             2026               .DB   ")"
1050-C9             2027 (  9)         RET
1051-               2028
1051-16 7D          2029 (  6) MINUS:  LD      D,7DH           ; '-' precedence
1053-CD 87 0F       2030 ( 16)         CALL    EVAL1           ; Evaluate until prec' break
1056-2A 15 23       2031 ( 15)         LD      HL,(NXTOPR)     ; Get next operator address
1059-E5             2032 ( 11)         PUSH    HL              ; Save next operator address
105A-CD 7D 19       2033 ( 16)         CALL    INVSGN          ; Negate value
105D-CD 75 0F       2034 ( 16) RETNUM: CALL    TSTNUM          ; Make sure it's a number
1060-E1             2035 (  9)         POP     HL              ; Restore next operator address
1061-C9             2036 (  9)         RET
1062-               2037
1062-CD 68 11       2038 ( 16) CONVAR: CALL    GETVAR          ; Get variable address to DE
1065-E5             2039 ( 11) FRMEVL: PUSH    HL              ; Save code string address
1066-EB             2040 (  3)         EX      DE,HL           ; Variable address to HL
1067-22 29 23       2041 ( 20)         LD      (FPREG),HL      ; Save address of variable
106A-3A F2 22       2042 ( 12)         LD      A,(TYPE)        ; Get type
106D-B7             2043 (  4)         OR      A               ; Numeric?
106E-CC 92 19       2044 ( 6+)         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1071-E1             2045 (  9)         POP     HL              ; Restore code string address
1072-C9             2046 (  9)         RET
1073-               2047
1073-06 00          2048 (  6) FNOFST: LD      B,0             ; Get address of function
1075-07             2049 (  3)         RLCA                    ; Double function offset
1076-4F             2050 (  4)         LD      C,A             ; BC = Offset in function table
1077-C5             2051 ( 11)         PUSH    BC              ; Save adjusted token value
1078-CD 05 0B       2052 ( 16)         CALL    GETCHR          ; Get next character
107B-79             2053 (  4)         LD      A,C             ; Get adjusted token value
107C-FE 31          2054 (  6)         CP      031H ; 2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT$ or MID$ ?
107E-DA 9A 10       2055 ( 6+)         JP      C,FNVAL         ; No - Do function
1081-CD 80 0F       2056 ( 16)         CALL    OPNPAR          ; Evaluate expression  (X,...
1084-CD 7B 09       2057 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1087-2C             2058               .DB      ','
1088-CD 76 0F       2059 ( 16)         CALL    TSTSTR          ; Make sure it's a string
108B-EB             2060 (  3)         EX      DE,HL           ; Save code string address
108C-2A 29 23       2061 ( 15)         LD      HL,(FPREG)      ; Get address of string
108F-E3             2062 ( 16)         EX      (SP),HL         ; Save address of string
1090-E5             2063 ( 11)         PUSH    HL              ; Save adjusted token value
1091-EB             2064 (  3)         EX      DE,HL           ; Restore code string address
1092-CD D3 16       2065 ( 16)         CALL    GETINT          ; Get integer 0-255
1095-EB             2066 (  3)         EX      DE,HL           ; Save code string address
1096-E3             2067 ( 16)         EX      (SP),HL         ; Save integer,HL = adj' token
1097-C3 A2 10       2068 (  9)         JP      GOFUNC          ; Jump to string function
109A-               2069
109A-CD 49 10       2070 ( 16) FNVAL:  CALL    EVLPAR          ; Evaluate expression
109D-E3             2071 ( 16)         EX      (SP),HL         ; HL = Adjusted token value
109E-11 5D 10       2072 (  9)         LD      DE,RETNUM       ; Return number from function
10A1-D5             2073 ( 11)         PUSH    DE              ; Save on stack
10A2-01 FE 03       2074 (  9) GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
10A5-09             2075 (  7)         ADD     HL,BC           ; Point to right address
10A6-4E             2076 (  6)         LD      C,(HL)          ; Get LSB of address
10A7-23             2077 (  4)         INC     HL              ;
10A8-66             2078 (  6)         LD      H,(HL)          ; Get MSB of address
10A9-69             2079 (  4)         LD      L,C             ; Address to HL
10AA-E9             2080 (  3)         JP      (HL)            ; Jump to function
10AB-               2081
10AB-15             2082 (  4) SGNEXP: DEC     D               ; Dee to flag negative exponent
10AC-FE AD          2083 (  6)         CP      ZMINUS          ; '-' token ?
10AE-C8             2084 ( 5+)         RET     Z               ; Yes - Return
10AF-FE 2D          2085 (  6)         CP      '-'             ; '-' ASCII ?
10B1-C8             2086 ( 5+)         RET     Z               ; Yes - Return
10B2-14             2087 (  4)         INC     D               ; Inc to flag positive exponent
10B3-FE 2B          2088 (  6)         CP      '+'             ; '+' ASCII ?
10B5-C8             2089 ( 5+)         RET     Z               ; Yes - Return
10B6-FE AC          2090 (  6)         CP      ZPLUS           ; '+' token ?
10B8-C8             2091 ( 5+)         RET     Z               ; Yes - Return
10B9-2B             2092 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
10BA-C9             2093 (  9)         RET                     ; Return "NZ"
10BB-               2094
10BB-F6             2095       POR:    .DB      0F6H            ; Flag "OR"
10BC-AF             2096 (  4) PAND:   XOR     A               ; Flag "AND"
10BD-F5             2097 ( 11)         PUSH    AF              ; Save "AND" / "OR" flag
10BE-CD 75 0F       2098 ( 16)         CALL    TSTNUM          ; Make sure it's a number
10C1-CD B7 0B       2099 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
10C4-F1             2100 (  9)         POP     AF              ; Restore "AND" / "OR" flag
10C5-EB             2101 (  3)         EX      DE,HL           ; <- Get last
10C6-C1             2102 (  9)         POP     BC              ; <-  value
10C7-E3             2103 ( 16)         EX      (SP),HL         ; <-  from
10C8-EB             2104 (  3)         EX      DE,HL           ; <-  stack
10C9-CD 95 19       2105 ( 16)         CALL    FPBCDE          ; Move last value to FPREG
10CC-F5             2106 ( 11)         PUSH    AF              ; Save "AND" / "OR" flag
10CD-CD B7 0B       2107 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
10D0-F1             2108 (  9)         POP     AF              ; Restore "AND" / "OR" flag
10D1-C1             2109 (  9)         POP     BC              ; Get value
10D2-79             2110 (  4)         LD      A,C             ; Get LSB
10D3-21 2C 13       2111 (  9)         LD      HL,ACPASS       ; Address of save AC as current
10D6-C2 DE 10       2112 ( 6+)         JP      NZ,POR1         ; Jump if OR
10D9-A3             2113 (  4)         AND     E               ; "AND" LSBs
10DA-4F             2114 (  4)         LD      C,A             ; Save LSB
10DB-78             2115 (  4)         LD      A,B             ; Get MBS
10DC-A2             2116 (  4)         AND     D               ; "AND" MSBs
10DD-E9             2117 (  3)         JP      (HL)            ; Save AC as current (ACPASS)
10DE-               2118
10DE-B3             2119 (  4) POR1:   OR      E               ; "OR" LSBs
10DF-4F             2120 (  4)         LD      C,A             ; Save LSB
10E0-78             2121 (  4)         LD      A,B             ; Get MSB
10E1-B2             2122 (  4)         OR      D               ; "OR" MSBs
10E2-E9             2123 (  3)         JP      (HL)            ; Save AC as current (ACPASS)
10E3-               2124
10E3-21 F5 10       2125 (  9) TSTRED: LD      HL,CMPLOG       ; Logical compare routine
10E6-3A F2 22       2126 ( 12)         LD      A,(TYPE)        ; Get data type
10E9-1F             2127 (  3)         RRA                     ; Carry set = string
10EA-7A             2128 (  4)         LD      A,D             ; Get last precedence value
10EB-17             2129 (  3)         RLA                     ; Times 2 plus carry
10EC-5F             2130 (  4)         LD      E,A             ; To E
10ED-16 64          2131 (  6)         LD      D,64H           ; Relational precedence
10EF-78             2132 (  4)         LD      A,B             ; Get current precedence
10F0-BA             2133 (  4)         CP      D               ; Compare with last
10F1-D0             2134 ( 5+)         RET     NC              ; Eval if last was rel' or log'
10F2-C3 E4 0F       2135 (  9)         JP      STKTHS          ; Stack this one and get next
10F5-               2136
10F5-F7 10          2137       CMPLOG: .DW   CMPLG1          ; Compare two values / strings
10F7-79             2138 (  4) CMPLG1: LD      A,C             ; Get data type
10F8-B7             2139 (  4)         OR      A
10F9-1F             2140 (  3)         RRA
10FA-C1             2141 (  9)         POP     BC              ; Get last expression to BCDE
10FB-D1             2142 (  9)         POP     DE
10FC-F5             2143 ( 11)         PUSH    AF              ; Save status
10FD-CD 77 0F       2144 ( 16)         CALL    CHKTYP          ; Check that types match
1100-21 39 11       2145 (  9)         LD      HL,CMPRES       ; Result to comparison
1103-E5             2146 ( 11)         PUSH    HL              ; Save for RETurn
1104-CA CF 19       2147 ( 6+)         JP      Z,CMPNUM        ; Compare values if numeric
1107-AF             2148 (  4)         XOR     A               ; Compare two strings
1108-32 F2 22       2149 ( 13)         LD      (TYPE),A        ; Set type to numeric
110B-D5             2150 ( 11)         PUSH    DE              ; Save string name
110C-CD 8E 15       2151 ( 16)         CALL    GSTRCU          ; Get current string
110F-7E             2152 (  6)         LD      A,(HL)          ; Get length of string
1110-23             2153 (  4)         INC     HL
1111-23             2154 (  4)         INC     HL
1112-4E             2155 (  6)         LD      C,(HL)          ; Get LSB of address
1113-23             2156 (  4)         INC     HL
1114-46             2157 (  6)         LD      B,(HL)          ; Get MSB of address
1115-D1             2158 (  9)         POP     DE              ; Restore string name
1116-C5             2159 ( 11)         PUSH    BC              ; Save address of string
1117-F5             2160 ( 11)         PUSH    AF              ; Save length of string
1118-CD 92 15       2161 ( 16)         CALL    GSTRDE          ; Get second string
111B-CD A3 19       2162 ( 16)         CALL    LOADFP          ; Get address of second string
111E-F1             2163 (  9)         POP     AF              ; Restore length of string 1
111F-57             2164 (  4)         LD      D,A             ; Length to D
1120-E1             2165 (  9)         POP     HL              ; Restore address of string 1
1121-7B             2166 (  4) CMPSTR: LD      A,E             ; Bytes of string 2 to do
1122-B2             2167 (  4)         OR      D               ; Bytes of string 1 to do
1123-C8             2168 ( 5+)         RET     Z               ; Exit if all bytes compared
1124-7A             2169 (  4)         LD      A,D             ; Get bytes of string 1 to do
1125-D6 01          2170 (  6)         SUB     1
1127-D8             2171 ( 5+)         RET     C               ; Exit if end of string 1
1128-AF             2172 (  4)         XOR     A
1129-BB             2173 (  4)         CP      E               ; Bytes of string 2 to do
112A-3C             2174 (  4)         INC     A
112B-D0             2175 ( 5+)         RET     NC              ; Exit if end of string 2
112C-15             2176 (  4)         DEC     D               ; Count bytes in string 1
112D-1D             2177 (  4)         DEC     E               ; Count bytes in string 2
112E-0A             2178 (  6)         LD      A,(BC)          ; Byte in string 2
112F-BE             2179 (  6)         CP      (HL)            ; Compare to byte in string 1
1130-23             2180 (  4)         INC     HL              ; Move up string 1
1131-03             2181 (  4)         INC     BC              ; Move up string 2
1132-CA 21 11       2182 ( 6+)         JP      Z,CMPSTR        ; Same - Try next bytes
1135-3F             2183 (  3)         CCF                     ; Flag difference (">" or "<")
1136-C3 5F 19       2184 (  9)         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
1139-               2185
1139-3C             2186 (  4) CMPRES: INC     A               ; Increment current value
113A-8F             2187 (  4)         ADC     A,A             ; Double plus carry
113B-C1             2188 (  9)         POP     BC              ; Get other value
113C-A0             2189 (  4)         AND     B               ; Combine them
113D-C6 FF          2190 (  6)         ADD     A,-1            ; Carry set if different
113F-9F             2191 (  4)         SBC     A,A             ; 00 - Equal , FF - Different
1140-C3 66 19       2192 (  9)         JP      FLGREL          ; Set current value & continue
1143-               2193
1143-16 5A          2194 (  6) EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
1145-CD 87 0F       2195 ( 16)         CALL    EVAL1           ; Eval until precedence break
1148-CD 75 0F       2196 ( 16)         CALL    TSTNUM          ; Make sure it's a number
114B-CD B7 0B       2197 ( 16)         CALL    DEINT           ; Get integer -32768 - 32767
114E-7B             2198 (  4)         LD      A,E             ; Get LSB
114F-2F             2199 (  3)         CPL                     ; Invert LSB
1150-4F             2200 (  4)         LD      C,A             ; Save "NOT" of LSB
1151-7A             2201 (  4)         LD      A,D             ; Get MSB
1152-2F             2202 (  3)         CPL                     ; Invert MSB
1153-CD 2C 13       2203 ( 16)         CALL    ACPASS          ; Save AC as current
1156-C1             2204 (  9)         POP     BC              ; Clean up stack
1157-C3 93 0F       2205 (  9)         JP      EVAL3           ; Continue evaluation
115A-               2206
115A-2B             2207 (  4) DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
115B-CD 05 0B       2208 ( 16)         CALL    GETCHR          ; Get next character
115E-C8             2209 ( 5+)         RET     Z               ; End of DIM statement
115F-CD 7B 09       2210 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1162-2C             2211               .DB      ','
1163-01 5A 11       2212 (  9) DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
1166-C5             2213 ( 11)         PUSH    BC              ; Save on stack
1167-F6             2214               .DB      0F6H            ; Flag "Create" variable
1168-AF             2215 (  4) GETVAR: XOR     A               ; Find variable address,to DE
1169-32 F1 22       2216 ( 13)         LD      (LCRFLG),A      ; Set locate / create flag
116C-46             2217 (  6)         LD      B,(HL)          ; Get First byte of name
116D-CD A3 0B       2218 ( 16) GTFNAM: CALL    CHKLTR          ; See if a letter
1170-DA AD 06       2219 ( 6+)         JP      C,SNERR         ; ?SN Error if not a letter
1173-AF             2220 (  4)         XOR     A
1174-4F             2221 (  4)         LD      C,A             ; Clear second byte of name
1175-32 F2 22       2222 ( 13)         LD      (TYPE),A        ; Set type to numeric
1178-CD 05 0B       2223 ( 16)         CALL    GETCHR          ; Get next character
117B-DA 84 11       2224 ( 6+)         JP      C,SVNAM2        ; Numeric - Save in name
117E-CD A3 0B       2225 ( 16)         CALL    CHKLTR          ; See if a letter
1181-DA 91 11       2226 ( 6+)         JP      C,CHARTY        ; Not a letter - Check type
1184-4F             2227 (  4) SVNAM2: LD      C,A             ; Save second byte of name
1185-CD 05 0B       2228 ( 16) ENDNAM: CALL    GETCHR          ; Get next character
1188-DA 85 11       2229 ( 6+)         JP      C,ENDNAM        ; Numeric - Get another
118B-CD A3 0B       2230 ( 16)         CALL    CHKLTR          ; See if a letter
118E-D2 85 11       2231 ( 6+)         JP      NC,ENDNAM       ; Letter - Get another
1191-D6 24          2232 (  6) CHARTY: SUB     '$'             ; String variable?
1193-C2 A0 11       2233 ( 6+)         JP      NZ,NOTSTR       ; No - Numeric variable
1196-3C             2234 (  4)         INC     A               ; A = 1 (string type)
1197-32 F2 22       2235 ( 13)         LD      (TYPE),A        ; Set type to string
119A-0F             2236 (  3)         RRCA                    ; A = 80H , Flag for string
119B-81             2237 (  4)         ADD     A,C             ; 2nd byte of name has bit 7 on
119C-4F             2238 (  4)         LD      C,A             ; Resave second byte on name
119D-CD 05 0B       2239 ( 16)         CALL    GETCHR          ; Get next character
11A0-3A 10 23       2240 ( 12) NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
11A3-3D             2241 (  4)         DEC     A
11A4-CA 4D 12       2242 ( 6+)         JP      Z,ARLDSV        ; Yes - Get array name
11A7-F2 B0 11       2243 ( 6+)         JP      P,NSCFOR        ; No array with "FOR" or "FN"
11AA-7E             2244 (  6)         LD      A,(HL)          ; Get byte again
11AB-D6 28          2245 (  6)         SUB     '('             ; Subscripted variable?
11AD-CA 25 12       2246 ( 6+)         JP      Z,SBSCPT        ; Yes - Sort out subscript
11B0-               2247
11B0-AF             2248 (  4) NSCFOR: XOR     A               ; Simple variable
11B1-32 10 23       2249 ( 13)         LD      (FORFLG),A      ; Clear "FOR" flag
11B4-E5             2250 ( 11)         PUSH    HL              ; Save code string address
11B5-50             2251 (  4)         LD      D,B             ; DE = Variable name to find
11B6-59             2252 (  4)         LD      E,C
11B7-2A 23 23       2253 ( 15)         LD      HL,(FNRGNM)     ; FN argument name
11BA-CD 75 09       2254 ( 16)         CALL    CPDEHL          ; Is it the FN argument?
11BD-11 25 23       2255 (  9)         LD      DE,FNARG        ; Point to argument value
11C0-CA 95 18       2256 ( 6+)         JP      Z,POPHRT        ; Yes - Return FN argument value
11C3-2A 1D 23       2257 ( 15)         LD      HL,(VAREND)     ; End of variables
11C6-EB             2258 (  3)         EX      DE,HL           ; Address of end of search
11C7-2A 1B 23       2259 ( 15)         LD      HL,(PROGND)     ; Start of variables address
11CA-CD 75 09       2260 ( 16) FNDVAR: CALL    CPDEHL          ; End of variable list table?
11CD-CA E3 11       2261 ( 6+)         JP      Z,CFEVAL        ; Yes - Called from EVAL?
11D0-79             2262 (  4)         LD      A,C             ; Get second byte of name
11D1-96             2263 (  6)         SUB     (HL)            ; Compare with name in list
11D2-23             2264 (  4)         INC     HL              ; Move on to first byte
11D3-C2 D8 11       2265 ( 6+)         JP      NZ,FNTHR        ; Different - Find another
11D6-78             2266 (  4)         LD      A,B             ; Get first byte of name
11D7-96             2267 (  6)         SUB     (HL)            ; Compare with name in list
11D8-23             2268 (  4) FNTHR:  INC     HL              ; Move on to LSB of value
11D9-CA 17 12       2269 ( 6+)         JP      Z,RETADR        ; Found - Return address
11DC-23             2270 (  4)         INC     HL              ; <- Skip
11DD-23             2271 (  4)         INC     HL              ; <- over
11DE-23             2272 (  4)         INC     HL              ; <- F.P.
11DF-23             2273 (  4)         INC     HL              ; <- value
11E0-C3 CA 11       2274 (  9)         JP      FNDVAR          ; Keep looking
11E3-               2275
11E3-E1             2276 (  9) CFEVAL: POP     HL              ; Restore code string address
11E4-E3             2277 ( 16)         EX      (SP),HL         ; Get return address
11E5-D5             2278 ( 11)         PUSH    DE              ; Save address of variable
11E6-11 65 10       2279 (  9)         LD      DE,FRMEVL       ; Return address in EVAL
11E9-CD 75 09       2280 ( 16)         CALL    CPDEHL          ; Called from EVAL ?
11EC-D1             2281 (  9)         POP     DE              ; Restore address of variable
11ED-CA 1A 12       2282 ( 6+)         JP      Z,RETNUL        ; Yes - Return null variable
11F0-E3             2283 ( 16)         EX      (SP),HL         ; Put back return
11F1-E5             2284 ( 11)         PUSH    HL              ; Save code string address
11F2-C5             2285 ( 11)         PUSH    BC              ; Save variable name
11F3-01 06 00       2286 (  9)         LD      BC,6            ; 2 byte name plus 4 byte data
11F6-2A 1F 23       2287 ( 15)         LD      HL,(ARREND)     ; End of arrays
11F9-E5             2288 ( 11)         PUSH    HL              ; Save end of arrays
11FA-09             2289 (  7)         ADD     HL,BC           ; Move up 6 bytes
11FB-C1             2290 (  9)         POP     BC              ; Source address in BC
11FC-E5             2291 ( 11)         PUSH    HL              ; Save new end address
11FD-CD 79 06       2292 ( 16)         CALL    MOVUP           ; Move arrays up
1200-E1             2293 (  9)         POP     HL              ; Restore new end address
1201-22 1F 23       2294 ( 20)         LD      (ARREND),HL     ; Set new end address
1204-60             2295 (  4)         LD      H,B             ; End of variables to HL
1205-69             2296 (  4)         LD      L,C
1206-22 1D 23       2297 ( 20)         LD      (VAREND),HL     ; Set new end address
1209-               2298
1209-2B             2299 (  4) ZEROLP: DEC     HL              ; Back through to zero variable
120A-36 00          2300 (  9)         LD      (HL),0          ; Zero byte in variable
120C-CD 75 09       2301 ( 16)         CALL    CPDEHL          ; Done them all?
120F-C2 09 12       2302 ( 6+)         JP      NZ,ZEROLP       ; No - Keep on going
1212-D1             2303 (  9)         POP     DE              ; Get variable name
1213-73             2304 (  7)         LD      (HL),E          ; Store second character
1214-23             2305 (  4)         INC     HL
1215-72             2306 (  7)         LD      (HL),D          ; Store first character
1216-23             2307 (  4)         INC     HL
1217-EB             2308 (  3) RETADR: EX      DE,HL           ; Address of variable in DE
1218-E1             2309 (  9)         POP     HL              ; Restore code string address
1219-C9             2310 (  9)         RET
121A-               2311
121A-32 2C 23       2312 ( 13) RETNUL: LD      (FPEXP),A       ; Set result to zero
121D-21 49 06       2313 (  9)         LD      HL,ZERBYT       ; Also set a null string
1220-22 29 23       2314 ( 20)         LD      (FPREG),HL      ; Save for EVAL
1223-E1             2315 (  9)         POP     HL              ; Restore code string address
1224-C9             2316 (  9)         RET
1225-               2317
1225-E5             2318 ( 11) SBSCPT: PUSH    HL              ; Save code string address
1226-2A F1 22       2319 ( 15)         LD      HL,(LCRFLG)     ; Locate/Create and Type
1229-E3             2320 ( 16)         EX      (SP),HL         ; Save and get code string
122A-57             2321 (  4)         LD      D,A             ; Zero number of dimensions
122B-D5             2322 ( 11) SCPTLP: PUSH    DE              ; Save number of dimensions
122C-C5             2323 ( 11)         PUSH    BC              ; Save array name
122D-CD AB 0B       2324 ( 16)         CALL    FPSINT          ; Get subscript (0-32767)
1230-C1             2325 (  9)         POP     BC              ; Restore array name
1231-F1             2326 (  9)         POP     AF              ; Get number of dimensions
1232-EB             2327 (  3)         EX      DE,HL
1233-E3             2328 ( 16)         EX      (SP),HL         ; Save subscript value
1234-E5             2329 ( 11)         PUSH    HL              ; Save LCRFLG and TYPE
1235-EB             2330 (  3)         EX      DE,HL
1236-3C             2331 (  4)         INC     A               ; Count dimensions
1237-57             2332 (  4)         LD      D,A             ; Save in D
1238-7E             2333 (  6)         LD      A,(HL)          ; Get next byte in code string
1239-FE 2C          2334 (  6)         CP      ','             ; Comma (more to come)?
123B-CA 2B 12       2335 ( 6+)         JP      Z,SCPTLP        ; Yes - More subscripts
123E-CD 7B 09       2336 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
1241-29             2337               .DB      ")"
1242-22 15 23       2338 ( 20)         LD      (NXTOPR),HL     ; Save code string address
1245-E1             2339 (  9)         POP     HL              ; Get LCRFLG and TYPE
1246-22 F1 22       2340 ( 20)         LD      (LCRFLG),HL     ; Restore Locate/create & type
1249-1E 00          2341 (  6)         LD      E,0             ; Flag not CSAVE* or CLOAD*
124B-D5             2342 ( 11)         PUSH    DE              ; Save number of dimensions (D)
124C-11             2343               .DB      11H             ; Skip "PUSH HL" and "PUSH AF'
124D-               2344
124D-E5             2345 ( 11) ARLDSV: PUSH    HL              ; Save code string address
124E-F5             2346 ( 11)         PUSH    AF              ; A = 00 , Flags set = Z,N
124F-2A 1D 23       2347 ( 15)         LD      HL,(VAREND)     ; Start of arrays
1252-3E             2348               .DB      3EH             ; Skip "ADD HL,DE"
1253-19             2349 (  7) FNDARY: ADD     HL,DE           ; Move to next array start
1254-EB             2350 (  3)         EX      DE,HL
1255-2A 1F 23       2351 ( 15)         LD      HL,(ARREND)     ; End of arrays
1258-EB             2352 (  3)         EX      DE,HL           ; Current array pointer
1259-CD 75 09       2353 ( 16)         CALL    CPDEHL          ; End of arrays found?
125C-CA 85 12       2354 ( 6+)         JP      Z,CREARY        ; Yes - Create array
125F-7E             2355 (  6)         LD      A,(HL)          ; Get second byte of name
1260-B9             2356 (  4)         CP      C               ; Compare with name given
1261-23             2357 (  4)         INC     HL              ; Move on
1262-C2 67 12       2358 ( 6+)         JP      NZ,NXTARY       ; Different - Find next array
1265-7E             2359 (  6)         LD      A,(HL)          ; Get first byte of name
1266-B8             2360 (  4)         CP      B               ; Compare with name given
1267-23             2361 (  4) NXTARY: INC     HL              ; Move on
1268-5E             2362 (  6)         LD      E,(HL)          ; Get LSB of next array address
1269-23             2363 (  4)         INC     HL
126A-56             2364 (  6)         LD      D,(HL)          ; Get MSB of next array address
126B-23             2365 (  4)         INC     HL
126C-C2 53 12       2366 ( 6+)         JP      NZ,FNDARY       ; Not found - Keep looking
126F-3A F1 22       2367 ( 12)         LD      A,(LCRFLG)      ; Found Locate or Create it?
1272-B7             2368 (  4)         OR      A
1273-C2 B6 06       2369 ( 6+)         JP      NZ,DDERR        ; Create - ?DD Error
1276-F1             2370 (  9)         POP     AF              ; Locate - Get number of dim'ns
1277-44             2371 (  4)         LD      B,H             ; BC Points to array dim'ns
1278-4D             2372 (  4)         LD      C,L
1279-CA 95 18       2373 ( 6+)         JP      Z,POPHRT        ; Jump if array load/save
127C-96             2374 (  6)         SUB     (HL)            ; Same number of dimensions?
127D-CA E3 12       2375 ( 6+)         JP      Z,FINDEL        ; Yes - Find element
1280-1E 10          2376 (  6) BSERR:  LD      E,BS            ; ?BS Error
1282-C3 C1 06       2377 (  9)         JP      ERROR           ; Output error
1285-               2378
1285-11 04 00       2379 (  9) CREARY: LD      DE,4            ; 4 Bytes per entry
1288-F1             2380 (  9)         POP     AF              ; Array to save or 0 dim'ns?
1289-CA CC 0B       2381 ( 6+)         JP      Z,FCERR         ; Yes - ?FC Error
128C-71             2382 (  7)         LD      (HL),C          ; Save second byte of name
128D-23             2383 (  4)         INC     HL
128E-70             2384 (  7)         LD      (HL),B          ; Save first byte of name
128F-23             2385 (  4)         INC     HL
1290-4F             2386 (  4)         LD      C,A             ; Number of dimensions to C
1291-CD 8A 06       2387 ( 16)         CALL    CHKSTK          ; Check if enough memory
1294-23             2388 (  4)         INC     HL              ; Point to number of dimensions
1295-23             2389 (  4)         INC     HL
1296-22 0A 23       2390 ( 20)         LD      (CUROPR),HL     ; Save address of pointer
1299-71             2391 (  7)         LD      (HL),C          ; Set number of dimensions
129A-23             2392 (  4)         INC     HL
129B-3A F1 22       2393 ( 12)         LD      A,(LCRFLG)      ; Locate of Create?
129E-17             2394 (  3)         RLA                     ; Carry set = Create
129F-79             2395 (  4)         LD      A,C             ; Get number of dimensions
12A0-01 0B 00       2396 (  9) CRARLP: LD      BC,10+1         ; Default dimension size 10
12A3-D2 A8 12       2397 ( 6+)         JP      NC,DEFSIZ       ; Locate - Set default size
12A6-C1             2398 (  9)         POP     BC              ; Get specified dimension size
12A7-03             2399 (  4)         INC     BC              ; Include zero element
12A8-71             2400 (  7) DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
12A9-23             2401 (  4)         INC     HL
12AA-70             2402 (  7)         LD      (HL),B          ; Save MSB of dimension size
12AB-23             2403 (  4)         INC     HL
12AC-F5             2404 ( 11)         PUSH    AF              ; Save num' of dim'ns an status
12AD-E5             2405 ( 11)         PUSH    HL              ; Save address of dim'n size
12AE-CD 40 1A       2406 ( 16)         CALL    MLDEBC          ; Multiply DE by BC to find
12B1-EB             2407 (  3)         EX      DE,HL           ; amount of mem needed (to DE)
12B2-E1             2408 (  9)         POP     HL              ; Restore address of dimension
12B3-F1             2409 (  9)         POP     AF              ; Restore number of dimensions
12B4-3D             2410 (  4)         DEC     A               ; Count them
12B5-C2 A0 12       2411 ( 6+)         JP      NZ,CRARLP       ; Do next dimension if more
12B8-F5             2412 ( 11)         PUSH    AF              ; Save locate/create flag
12B9-42             2413 (  4)         LD      B,D             ; MSB of memory needed
12BA-4B             2414 (  4)         LD      C,E             ; LSB of memory needed
12BB-EB             2415 (  3)         EX      DE,HL
12BC-19             2416 (  7)         ADD     HL,DE           ; Add bytes to array start
12BD-DA A2 06       2417 ( 6+)         JP      C,OMERR         ; Too big - Error
12C0-CD 93 06       2418 ( 16)         CALL    ENFMEM          ; See if enough memory
12C3-22 1F 23       2419 ( 20)         LD      (ARREND),HL     ; Save new end of array
12C6-               2420
12C6-2B             2421 (  4) ZERARY: DEC     HL              ; Back through array data
12C7-36 00          2422 (  9)         LD      (HL),0          ; Set array element to zero
12C9-CD 75 09       2423 ( 16)         CALL    CPDEHL          ; All elements zeroed?
12CC-C2 C6 12       2424 ( 6+)         JP      NZ,ZERARY       ; No - Keep on going
12CF-03             2425 (  4)         INC     BC              ; Number of bytes + 1
12D0-57             2426 (  4)         LD      D,A             ; A=0
12D1-2A 0A 23       2427 ( 15)         LD      HL,(CUROPR)     ; Get address of array
12D4-5E             2428 (  6)         LD      E,(HL)          ; Number of dimensions
12D5-EB             2429 (  3)         EX      DE,HL           ; To HL
12D6-29             2430 (  7)         ADD     HL,HL           ; Two bytes per dimension size
12D7-09             2431 (  7)         ADD     HL,BC           ; Add number of bytes
12D8-EB             2432 (  3)         EX      DE,HL           ; Bytes needed to DE
12D9-2B             2433 (  4)         DEC     HL
12DA-2B             2434 (  4)         DEC     HL
12DB-73             2435 (  7)         LD      (HL),E          ; Save LSB of bytes needed
12DC-23             2436 (  4)         INC     HL
12DD-72             2437 (  7)         LD      (HL),D          ; Save MSB of bytes needed
12DE-23             2438 (  4)         INC     HL
12DF-F1             2439 (  9)         POP     AF              ; Locate / Create?
12E0-DA 07 13       2440 ( 6+)         JP      C,ENDDIM        ; A is 0 , End if create
12E3-47             2441 (  4) FINDEL: LD      B,A             ; Find array element
12E4-4F             2442 (  4)         LD      C,A
12E5-7E             2443 (  6)         LD      A,(HL)          ; Number of dimensions
12E6-23             2444 (  4)         INC     HL
12E7-16             2445               .DB      16H             ; Skip "POP HL"
12E8-E1             2446 (  9) FNDELP: POP     HL              ; Address of next dim' size
12E9-5E             2447 (  6)         LD      E,(HL)          ; Get LSB of dim'n size
12EA-23             2448 (  4)         INC     HL
12EB-56             2449 (  6)         LD      D,(HL)          ; Get MSB of dim'n size
12EC-23             2450 (  4)         INC     HL
12ED-E3             2451 ( 16)         EX      (SP),HL         ; Save address - Get index
12EE-F5             2452 ( 11)         PUSH    AF              ; Save number of dim'ns
12EF-CD 75 09       2453 ( 16)         CALL    CPDEHL          ; Dimension too large?
12F2-D2 80 12       2454 ( 6+)         JP      NC,BSERR        ; Yes - ?BS Error
12F5-E5             2455 ( 11)         PUSH    HL              ; Save index
12F6-CD 40 1A       2456 ( 16)         CALL    MLDEBC          ; Multiply previous by size
12F9-D1             2457 (  9)         POP     DE              ; Index supplied to DE
12FA-19             2458 (  7)         ADD     HL,DE           ; Add index to pointer
12FB-F1             2459 (  9)         POP     AF              ; Number of dimensions
12FC-3D             2460 (  4)         DEC     A               ; Count them
12FD-44             2461 (  4)         LD      B,H             ; MSB of pointer
12FE-4D             2462 (  4)         LD      C,L             ; LSB of pointer
12FF-C2 E8 12       2463 ( 6+)         JP      NZ,FNDELP       ; More - Keep going
1302-29             2464 (  7)         ADD     HL,HL           ; 4 Bytes per element
1303-29             2465 (  7)         ADD     HL,HL
1304-C1             2466 (  9)         POP     BC              ; Start of array
1305-09             2467 (  7)         ADD     HL,BC           ; Point to element
1306-EB             2468 (  3)         EX      DE,HL           ; Address of element to DE
1307-2A 15 23       2469 ( 15) ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
130A-C9             2470 (  9)         RET
130B-               2471
130B-2A 1F 23       2472 ( 15) FRE:    LD      HL,(ARREND)     ; Start of free memory
130E-EB             2473 (  3)         EX      DE,HL           ; To DE
130F-21 00 00       2474 (  9)         LD      HL,0            ; End of free memory
1312-39             2475 (  7)         ADD     HL,SP           ; Current stack value
1313-3A F2 22       2476 ( 12)         LD      A,(TYPE)        ; Dummy argument type
1316-B7             2477 (  4)         OR      A
1317-CA 27 13       2478 ( 6+)         JP      Z,FRENUM        ; Numeric - Free variable space
131A-CD 8E 15       2479 ( 16)         CALL    GSTRCU          ; Current string to pool
131D-CD 8E 14       2480 ( 16)         CALL    GARBGE          ; Garbage collection
1320-2A 9F 22       2481 ( 15)         LD      HL,(STRSPC)     ; Bottom of string space in use
1323-EB             2482 (  3)         EX      DE,HL           ; To DE
1324-2A 08 23       2483 ( 15)         LD      HL,(STRBOT)     ; Bottom of string space
1327-7D             2484 (  4) FRENUM: LD      A,L             ; Get LSB of end
1328-93             2485 (  4)         SUB     E               ; Subtract LSB of beginning
1329-4F             2486 (  4)         LD      C,A             ; Save difference if C
132A-7C             2487 (  4)         LD      A,H             ; Get MSB of end
132B-9A             2488 (  4)         SBC     A,D             ; Subtract MSB of beginning
132C-41             2489 (  4) ACPASS: LD      B,C             ; Return integer AC
132D-50             2490 (  4) ABPASS: LD      D,B             ; Return integer AB
132E-1E 00          2491 (  6)         LD      E,0
1330-21 F2 22       2492 (  9)         LD      HL,TYPE         ; Point to type
1333-73             2493 (  7)         LD      (HL),E          ; Set type to numeric
1334-06 90          2494 (  6)         LD      B,80H+16        ; 16 bit integer
1336-C3 6B 19       2495 (  9)         JP      RETINT          ; Return the integr
1339-               2496
1339-3A F0 22       2497 ( 12) POS:    LD      A,(CURPOS)      ; Get cursor position
133C-47             2498 (  4) PASSA:  LD      B,A             ; Put A into AB
133D-AF             2499 (  4)         XOR     A               ; Zero A
133E-C3 2D 13       2500 (  9)         JP      ABPASS          ; Return integer AB
1341-               2501
1341-CD C4 13       2502 ( 16) DEF:    CALL    CHEKFN          ; Get "FN" and name
1344-CD B6 13       2503 ( 16)         CALL    IDTEST          ; Test for illegal direct
1347-01 9C 0C       2504 (  9)         LD      BC,DATA         ; To get next statement
134A-C5             2505 ( 11)         PUSH    BC              ; Save address for RETurn
134B-D5             2506 ( 11)         PUSH    DE              ; Save address of function ptr
134C-CD 7B 09       2507 ( 16)         CALL    CHKSYN          ; Make sure "(" follows
134F-28             2508               .DB      "("
1350-CD 68 11       2509 ( 16)         CALL    GETVAR          ; Get argument variable name
1353-E5             2510 ( 11)         PUSH    HL              ; Save code string address
1354-EB             2511 (  3)         EX      DE,HL           ; Argument address to HL
1355-2B             2512 (  4)         DEC     HL
1356-56             2513 (  6)         LD      D,(HL)          ; Get first byte of arg name
1357-2B             2514 (  4)         DEC     HL
1358-5E             2515 (  6)         LD      E,(HL)          ; Get second byte of arg name
1359-E1             2516 (  9)         POP     HL              ; Restore code string address
135A-CD 75 0F       2517 ( 16)         CALL    TSTNUM          ; Make sure numeric argument
135D-CD 7B 09       2518 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
1360-29             2519               .DB      ")"
1361-CD 7B 09       2520 ( 16)         CALL    CHKSYN          ; Make sure "=" follows
1364-B4             2521               .DB      ZEQUAL          ; "=" token
1365-44             2522 (  4)         LD      B,H             ; Code string address to BC
1366-4D             2523 (  4)         LD      C,L
1367-E3             2524 ( 16)         EX      (SP),HL         ; Save code str , Get FN ptr
1368-71             2525 (  7)         LD      (HL),C          ; Save LSB of FN code string
1369-23             2526 (  4)         INC     HL
136A-70             2527 (  7)         LD      (HL),B          ; Save MSB of FN code string
136B-C3 03 14       2528 (  9)         JP      SVSTAD          ; Save address and do function
136E-               2529
136E-CD C4 13       2530 ( 16) DOFN:   CALL    CHEKFN          ; Make sure FN follows
1371-D5             2531 ( 11)         PUSH    DE              ; Save function pointer address
1372-CD 49 10       2532 ( 16)         CALL    EVLPAR          ; Evaluate expression in "()"
1375-CD 75 0F       2533 ( 16)         CALL    TSTNUM          ; Make sure numeric result
1378-E3             2534 ( 16)         EX      (SP),HL         ; Save code str , Get FN ptr
1379-5E             2535 (  6)         LD      E,(HL)          ; Get LSB of FN code string
137A-23             2536 (  4)         INC     HL
137B-56             2537 (  6)         LD      D,(HL)          ; Get MSB of FN code string
137C-23             2538 (  4)         INC     HL
137D-7A             2539 (  4)         LD      A,D             ; And function DEFined?
137E-B3             2540 (  4)         OR      E
137F-CA B9 06       2541 ( 6+)         JP      Z,UFERR         ; No - ?UF Error
1382-7E             2542 (  6)         LD      A,(HL)          ; Get LSB of argument address
1383-23             2543 (  4)         INC     HL
1384-66             2544 (  6)         LD      H,(HL)          ; Get MSB of argument address
1385-6F             2545 (  4)         LD      L,A             ; HL = Arg variable address
1386-E5             2546 ( 11)         PUSH    HL              ; Save it
1387-2A 23 23       2547 ( 15)         LD      HL,(FNRGNM)     ; Get old argument name
138A-E3             2548 ( 16)         EX      (SP),HL ;       ; Save old , Get new
138B-22 23 23       2549 ( 20)         LD      (FNRGNM),HL     ; Set new argument name
138E-2A 27 23       2550 ( 15)         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
1391-E5             2551 ( 11)         PUSH    HL              ; Save it
1392-2A 25 23       2552 ( 15)         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
1395-E5             2553 ( 11)         PUSH    HL              ; Save it
1396-21 25 23       2554 (  9)         LD      HL,FNARG        ; HL = Value of argument
1399-D5             2555 ( 11)         PUSH    DE              ; Save FN code string address
139A-CD AC 19       2556 ( 16)         CALL    FPTHL           ; Move FPREG to argument
139D-E1             2557 (  9)         POP     HL              ; Get FN code string address
139E-CD 72 0F       2558 ( 16)         CALL    GETNUM          ; Get value from function
13A1-2B             2559 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
13A2-CD 05 0B       2560 ( 16)         CALL    GETCHR          ; Get next character
13A5-C2 AD 06       2561 ( 6+)         JP      NZ,SNERR        ; Bad character in FN - Error
13A8-E1             2562 (  9)         POP     HL              ; Get MSB,EXP of old arg
13A9-22 25 23       2563 ( 20)         LD      (FNARG),HL      ; Restore it
13AC-E1             2564 (  9)         POP     HL              ; Get LSB,NLSB of old arg
13AD-22 27 23       2565 ( 20)         LD      (FNARG+2),HL    ; Restore it
13B0-E1             2566 (  9)         POP     HL              ; Get name of old arg
13B1-22 23 23       2567 ( 20)         LD      (FNRGNM),HL     ; Restore it
13B4-E1             2568 (  9)         POP     HL              ; Restore code string address
13B5-C9             2569 (  9)         RET
13B6-               2570
13B6-E5             2571 ( 11) IDTEST: PUSH    HL              ; Save code string address
13B7-2A A1 22       2572 ( 15)         LD      HL,(LINEAT)     ; Get current line number
13BA-23             2573 (  4)         INC     HL              ; -1 means direct statement
13BB-7C             2574 (  4)         LD      A,H
13BC-B5             2575 (  4)         OR      L
13BD-E1             2576 (  9)         POP     HL              ; Restore code string address
13BE-C0             2577 ( 5+)         RET     NZ              ; Return if in program
13BF-1E 16          2578 (  6)         LD      E,ID            ; ?ID Error
13C1-C3 C1 06       2579 (  9)         JP      ERROR
13C4-               2580
13C4-CD 7B 09       2581 ( 16) CHEKFN: CALL    CHKSYN          ; Make sure FN follows
13C7-A7             2582               .DB      ZFN             ; "FN" token
13C8-3E 80          2583 (  6)         LD      A,80H
13CA-32 10 23       2584 ( 13)         LD      (FORFLG),A      ; Flag FN name to find
13CD-B6             2585 (  6)         OR      (HL)            ; FN name has bit 7 set
13CE-47             2586 (  4)         LD      B,A             ; in first byte of name
13CF-CD 6D 11       2587 ( 16)         CALL    GTFNAM          ; Get FN name
13D2-C3 75 0F       2588 (  9)         JP      TSTNUM          ; Make sure numeric function
13D5-               2589
13D5-CD 75 0F       2590 ( 16) STR:    CALL    TSTNUM          ; Make sure it's a number
13D8-CD F9 1A       2591 ( 16)         CALL    NUMASC          ; Turn number into text
13DB-CD 09 14       2592 ( 16) STR1:   CALL    CRTST           ; Create string entry for it
13DE-CD 8E 15       2593 ( 16)         CALL    GSTRCU          ; Current string to pool
13E1-01 E9 15       2594 (  9)         LD      BC,TOPOOL       ; Save in string pool
13E4-C5             2595 ( 11)         PUSH    BC              ; Save address on stack
13E5-               2596
13E5-7E             2597 (  6) SAVSTR: LD      A,(HL)          ; Get string length
13E6-23             2598 (  4)         INC     HL
13E7-23             2599 (  4)         INC     HL
13E8-E5             2600 ( 11)         PUSH    HL              ; Save pointer to string
13E9-CD 64 14       2601 ( 16)         CALL    TESTR           ; See if enough string space
13EC-E1             2602 (  9)         POP     HL              ; Restore pointer to string
13ED-4E             2603 (  6)         LD      C,(HL)          ; Get LSB of address
13EE-23             2604 (  4)         INC     HL
13EF-46             2605 (  6)         LD      B,(HL)          ; Get MSB of address
13F0-CD FD 13       2606 ( 16)         CALL    CRTMST          ; Create string entry
13F3-E5             2607 ( 11)         PUSH    HL              ; Save pointer to MSB of addr
13F4-6F             2608 (  4)         LD      L,A             ; Length of string
13F5-CD 81 15       2609 ( 16)         CALL    TOSTRA          ; Move to string area
13F8-D1             2610 (  9)         POP     DE              ; Restore pointer to MSB
13F9-C9             2611 (  9)         RET
13FA-               2612
13FA-CD 64 14       2613 ( 16) MKTMST: CALL    TESTR           ; See if enough string space
13FD-21 04 23       2614 (  9) CRTMST: LD      HL,TMPSTR       ; Temporary string
1400-E5             2615 ( 11)         PUSH    HL              ; Save it
1401-77             2616 (  7)         LD      (HL),A          ; Save length of string
1402-23             2617 (  4)         INC     HL
1403-23             2618 (  4) SVSTAD: INC     HL
1404-73             2619 (  7)         LD      (HL),E          ; Save LSB of address
1405-23             2620 (  4)         INC     HL
1406-72             2621 (  7)         LD      (HL),D          ; Save MSB of address
1407-E1             2622 (  9)         POP     HL              ; Restore pointer
1408-C9             2623 (  9)         RET
1409-               2624
1409-2B             2625 (  4) CRTST:  DEC     HL              ; DEC - INCed after
140A-06 22          2626 (  6) QTSTR:  LD      B,'"'           ; Terminating quote
140C-50             2627 (  4)         LD      D,B             ; Quote to D
140D-E5             2628 ( 11) DTSTR:  PUSH    HL              ; Save start
140E-0E FF          2629 (  6)         LD      C,-1            ; Set counter to -1
1410-23             2630 (  4) QTSTLP: INC     HL              ; Move on
1411-7E             2631 (  6)         LD      A,(HL)          ; Get byte
1412-0C             2632 (  4)         INC     C               ; Count bytes
1413-B7             2633 (  4)         OR      A               ; End of line?
1414-CA 1F 14       2634 ( 6+)         JP      Z,CRTSTE        ; Yes - Create string entry
1417-BA             2635 (  4)         CP      D               ; Terminator D found?
1418-CA 1F 14       2636 ( 6+)         JP      Z,CRTSTE        ; Yes - Create string entry
141B-B8             2637 (  4)         CP      B               ; Terminator B found?
141C-C2 10 14       2638 ( 6+)         JP      NZ,QTSTLP       ; No - Keep looking
141F-FE 22          2639 (  6) CRTSTE: CP      '"'             ; End with '"'?
1421-CC 05 0B       2640 ( 6+)         CALL    Z,GETCHR        ; Yes - Get next character
1424-E3             2641 ( 16)         EX      (SP),HL         ; Starting quote
1425-23             2642 (  4)         INC     HL              ; First byte of string
1426-EB             2643 (  3)         EX      DE,HL           ; To DE
1427-79             2644 (  4)         LD      A,C             ; Get length
1428-CD FD 13       2645 ( 16)         CALL    CRTMST          ; Create string entry
142B-11 04 23       2646 (  9) TSTOPL: LD      DE,TMPSTR       ; Temporary string
142E-2A F6 22       2647 ( 15)         LD      HL,(TMSTPT)     ; Temporary string pool pointer
1431-22 29 23       2648 ( 20)         LD      (FPREG),HL      ; Save address of string ptr
1434-3E 01          2649 (  6)         LD      A,1
1436-32 F2 22       2650 ( 13)         LD      (TYPE),A        ; Set type to string
1439-CD AF 19       2651 ( 16)         CALL    DETHL4          ; Move string to pool
143C-CD 75 09       2652 ( 16)         CALL    CPDEHL          ; Out of string pool?
143F-22 F6 22       2653 ( 20)         LD      (TMSTPT),HL     ; Save new pointer
1442-E1             2654 (  9)         POP     HL              ; Restore code string address
1443-7E             2655 (  6)         LD      A,(HL)          ; Get next code byte
1444-C0             2656 ( 5+)         RET     NZ              ; Return if pool OK
1445-1E 1E          2657 (  6)         LD      E,ST            ; ?ST Error
1447-C3 C1 06       2658 (  9)         JP      ERROR           ; String pool overflow
144A-               2659
144A-23             2660 (  4) PRNUMS: INC     HL              ; Skip leading space
144B-CD 09 14       2661 ( 16) PRS:    CALL    CRTST           ; Create string entry for it
144E-CD 8E 15       2662 ( 16) PRS1:   CALL    GSTRCU          ; Current string to pool
1451-CD A3 19       2663 ( 16)         CALL    LOADFP          ; Move string block to BCDE
1454-1C             2664 (  4)         INC     E               ; Length + 1
1455-1D             2665 (  4) PRSLP:  DEC     E               ; Count characters
1456-C8             2666 ( 5+)         RET     Z               ; End of string
1457-0A             2667 (  6)         LD      A,(BC)          ; Get byte to output
1458-CD 86 09       2668 ( 16)         CALL    OUTC            ; Output character in A
145B-FE 0D          2669 (  6)         CP      CR              ; Return?
145D-CC B7 0D       2670 ( 6+)         CALL    Z,DONULL        ; Yes - Do nulls
1460-03             2671 (  4)         INC     BC              ; Next byte in string
1461-C3 55 14       2672 (  9)         JP      PRSLP           ; More characters to output
1464-               2673
1464-B7             2674 (  4) TESTR:  OR      A               ; Test if enough room
1465-0E             2675               .DB      0EH             ; No garbage collection done
1466-F1             2676 (  9) GRBDON: POP     AF              ; Garbage collection done
1467-F5             2677 ( 11)         PUSH    AF              ; Save status
1468-2A 9F 22       2678 ( 15)         LD      HL,(STRSPC)     ; Bottom of string space in use
146B-EB             2679 (  3)         EX      DE,HL           ; To DE
146C-2A 08 23       2680 ( 15)         LD      HL,(STRBOT)     ; Bottom of string area
146F-2F             2681 (  3)         CPL                     ; Negate length (Top down)
1470-4F             2682 (  4)         LD      C,A             ; -Length to BC
1471-06 FF          2683 (  6)         LD      B,-1            ; BC = -ve length of string
1473-09             2684 (  7)         ADD     HL,BC           ; Add to bottom of space in use
1474-23             2685 (  4)         INC     HL              ; Plus one for 2's complement
1475-CD 75 09       2686 ( 16)         CALL    CPDEHL          ; Below string RAM area?
1478-DA 82 14       2687 ( 6+)         JP      C,TESTOS        ; Tidy up if not done else err
147B-22 08 23       2688 ( 20)         LD      (STRBOT),HL     ; Save new bottom of area
147E-23             2689 (  4)         INC     HL              ; Point to first byte of string
147F-EB             2690 (  3)         EX      DE,HL           ; Address to DE
1480-F1             2691 (  9) POPAF:  POP     AF              ; Throw away status push
1481-C9             2692 (  9)         RET
1482-               2693
1482-F1             2694 (  9) TESTOS: POP     AF              ; Garbage collect been done?
1483-1E 1A          2695 (  6)         LD      E,OS            ; ?OS Error
1485-CA C1 06       2696 ( 6+)         JP      Z,ERROR         ; Yes - Not enough string apace
1488-BF             2697 (  4)         CP      A               ; Flag garbage collect done
1489-F5             2698 ( 11)         PUSH    AF              ; Save status
148A-01 66 14       2699 (  9)         LD      BC,GRBDON       ; Garbage collection done
148D-C5             2700 ( 11)         PUSH    BC              ; Save for RETurn
148E-2A F4 22       2701 ( 15) GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
1491-22 08 23       2702 ( 20) GARBLP: LD      (STRBOT),HL     ; Reset string pointer
1494-21 00 00       2703 (  9)         LD      HL,0
1497-E5             2704 ( 11)         PUSH    HL              ; Flag no string found
1498-2A 9F 22       2705 ( 15)         LD      HL,(STRSPC)     ; Get bottom of string space
149B-E5             2706 ( 11)         PUSH    HL              ; Save bottom of string space
149C-21 F8 22       2707 (  9)         LD      HL,TMSTPL       ; Temporary string pool
149F-EB             2708 (  3) GRBLP:  EX      DE,HL
14A0-2A F6 22       2709 ( 15)         LD      HL,(TMSTPT)     ; Temporary string pool pointer
14A3-EB             2710 (  3)         EX      DE,HL
14A4-CD 75 09       2711 ( 16)         CALL    CPDEHL          ; Temporary string pool done?
14A7-01 9F 14       2712 (  9)         LD      BC,GRBLP        ; Loop until string pool done
14AA-C2 F3 14       2713 ( 6+)         JP      NZ,STPOOL       ; No - See if in string area
14AD-2A 1B 23       2714 ( 15)         LD      HL,(PROGND)     ; Start of simple variables
14B0-EB             2715 (  3) SMPVAR: EX      DE,HL
14B1-2A 1D 23       2716 ( 15)         LD      HL,(VAREND)     ; End of simple variables
14B4-EB             2717 (  3)         EX      DE,HL
14B5-CD 75 09       2718 ( 16)         CALL    CPDEHL          ; All simple strings done?
14B8-CA C6 14       2719 ( 6+)         JP      Z,ARRLP         ; Yes - Do string arrays
14BB-7E             2720 (  6)         LD      A,(HL)          ; Get type of variable
14BC-23             2721 (  4)         INC     HL
14BD-23             2722 (  4)         INC     HL
14BE-B7             2723 (  4)         OR      A               ; "S" flag set if string
14BF-CD F6 14       2724 ( 16)         CALL    STRADD          ; See if string in string area
14C2-C3 B0 14       2725 (  9)         JP      SMPVAR          ; Loop until simple ones done
14C5-               2726
14C5-C1             2727 (  9) GNXARY: POP     BC              ; Scrap address of this array
14C6-EB             2728 (  3) ARRLP:  EX      DE,HL
14C7-2A 1F 23       2729 ( 15)         LD      HL,(ARREND)     ; End of string arrays
14CA-EB             2730 (  3)         EX      DE,HL
14CB-CD 75 09       2731 ( 16)         CALL    CPDEHL          ; All string arrays done?
14CE-CA 1C 15       2732 ( 6+)         JP      Z,SCNEND        ; Yes - Move string if found
14D1-CD A3 19       2733 ( 16)         CALL    LOADFP          ; Get array name to BCDE
14D4-7B             2734 (  4)         LD      A,E             ; Get type of array
14D5-E5             2735 ( 11)         PUSH    HL              ; Save address of num of dim'ns
14D6-09             2736 (  7)         ADD     HL,BC           ; Start of next array
14D7-B7             2737 (  4)         OR      A               ; Test type of array
14D8-F2 C5 14       2738 ( 6+)         JP      P,GNXARY        ; Numeric array - Ignore it
14DB-22 0A 23       2739 ( 20)         LD      (CUROPR),HL     ; Save address of next array
14DE-E1             2740 (  9)         POP     HL              ; Get address of num of dim'ns
14DF-4E             2741 (  6)         LD      C,(HL)          ; BC = Number of dimensions
14E0-06 00          2742 (  6)         LD      B,0
14E2-09             2743 (  7)         ADD     HL,BC           ; Two bytes per dimension size
14E3-09             2744 (  7)         ADD     HL,BC
14E4-23             2745 (  4)         INC     HL              ; Plus one for number of dim'ns
14E5-EB             2746 (  3) GRBARY: EX      DE,HL
14E6-2A 0A 23       2747 ( 15)         LD      HL,(CUROPR)     ; Get address of next array
14E9-EB             2748 (  3)         EX      DE,HL
14EA-CD 75 09       2749 ( 16)         CALL    CPDEHL          ; Is this array finished?
14ED-CA C6 14       2750 ( 6+)         JP      Z,ARRLP         ; Yes - Get next one
14F0-01 E5 14       2751 (  9)         LD      BC,GRBARY       ; Loop until array all done
14F3-C5             2752 ( 11) STPOOL: PUSH    BC              ; Save return address
14F4-F6 80          2753 (  6)         OR      80H             ; Flag string type
14F6-7E             2754 (  6) STRADD: LD      A,(HL)          ; Get string length
14F7-23             2755 (  4)         INC     HL
14F8-23             2756 (  4)         INC     HL
14F9-5E             2757 (  6)         LD      E,(HL)          ; Get LSB of string address
14FA-23             2758 (  4)         INC     HL
14FB-56             2759 (  6)         LD      D,(HL)          ; Get MSB of string address
14FC-23             2760 (  4)         INC     HL
14FD-F0             2761 ( 5+)         RET     P               ; Not a string - Return
14FE-B7             2762 (  4)         OR      A               ; Set flags on string length
14FF-C8             2763 ( 5+)         RET     Z               ; Null string - Return
1500-44             2764 (  4)         LD      B,H             ; Save variable pointer
1501-4D             2765 (  4)         LD      C,L
1502-2A 08 23       2766 ( 15)         LD      HL,(STRBOT)     ; Bottom of new area
1505-CD 75 09       2767 ( 16)         CALL    CPDEHL          ; String been done?
1508-60             2768 (  4)         LD      H,B             ; Restore variable pointer
1509-69             2769 (  4)         LD      L,C
150A-D8             2770 ( 5+)         RET     C               ; String done - Ignore
150B-E1             2771 (  9)         POP     HL              ; Return address
150C-E3             2772 ( 16)         EX      (SP),HL         ; Lowest available string area
150D-CD 75 09       2773 ( 16)         CALL    CPDEHL          ; String within string area?
1510-E3             2774 ( 16)         EX      (SP),HL         ; Lowest available string area
1511-E5             2775 ( 11)         PUSH    HL              ; Re-save return address
1512-60             2776 (  4)         LD      H,B             ; Restore variable pointer
1513-69             2777 (  4)         LD      L,C
1514-D0             2778 ( 5+)         RET     NC              ; Outside string area - Ignore
1515-C1             2779 (  9)         POP     BC              ; Get return , Throw 2 away
1516-F1             2780 (  9)         POP     AF              ;
1517-F1             2781 (  9)         POP     AF              ;
1518-E5             2782 ( 11)         PUSH    HL              ; Save variable pointer
1519-D5             2783 ( 11)         PUSH    DE              ; Save address of current
151A-C5             2784 ( 11)         PUSH    BC              ; Put back return address
151B-C9             2785 (  9)         RET                     ; Go to it
151C-               2786
151C-D1             2787 (  9) SCNEND: POP     DE              ; Addresses of strings
151D-E1             2788 (  9)         POP     HL              ;
151E-7D             2789 (  4)         LD      A,L             ; HL = 0 if no more to do
151F-B4             2790 (  4)         OR      H
1520-C8             2791 ( 5+)         RET     Z               ; No more to do - Return
1521-2B             2792 (  4)         DEC     HL
1522-46             2793 (  6)         LD      B,(HL)          ; MSB of address of string
1523-2B             2794 (  4)         DEC     HL
1524-4E             2795 (  6)         LD      C,(HL)          ; LSB of address of string
1525-E5             2796 ( 11)         PUSH    HL              ; Save variable address
1526-2B             2797 (  4)         DEC     HL
1527-2B             2798 (  4)         DEC     HL
1528-6E             2799 (  6)         LD      L,(HL)          ; HL = Length of string
1529-26 00          2800 (  6)         LD      H,0
152B-09             2801 (  7)         ADD     HL,BC           ; Address of end of string+1
152C-50             2802 (  4)         LD      D,B             ; String address to DE
152D-59             2803 (  4)         LD      E,C
152E-2B             2804 (  4)         DEC     HL              ; Last byte in string
152F-44             2805 (  4)         LD      B,H             ; Address to BC
1530-4D             2806 (  4)         LD      C,L
1531-2A 08 23       2807 ( 15)         LD      HL,(STRBOT)     ; Current bottom of string area
1534-CD 7C 06       2808 ( 16)         CALL    MOVSTR          ; Move string to new address
1537-E1             2809 (  9)         POP     HL              ; Restore variable address
1538-71             2810 (  7)         LD      (HL),C          ; Save new LSB of address
1539-23             2811 (  4)         INC     HL
153A-70             2812 (  7)         LD      (HL),B          ; Save new MSB of address
153B-69             2813 (  4)         LD      L,C             ; Next string area+1 to HL
153C-60             2814 (  4)         LD      H,B
153D-2B             2815 (  4)         DEC     HL              ; Next string area address
153E-C3 91 14       2816 (  9)         JP      GARBLP          ; Look for more strings
1541-               2817
1541-C5             2818 ( 11) CONCAT: PUSH    BC              ; Save prec' opr & code string
1542-E5             2819 ( 11)         PUSH    HL              ;
1543-2A 29 23       2820 ( 15)         LD      HL,(FPREG)      ; Get first string
1546-E3             2821 ( 16)         EX      (SP),HL         ; Save first string
1547-CD FB 0F       2822 ( 16)         CALL    OPRND           ; Get second string
154A-E3             2823 ( 16)         EX      (SP),HL         ; Restore first string
154B-CD 76 0F       2824 ( 16)         CALL    TSTSTR          ; Make sure it's a string
154E-7E             2825 (  6)         LD      A,(HL)          ; Get length of second string
154F-E5             2826 ( 11)         PUSH    HL              ; Save first string
1550-2A 29 23       2827 ( 15)         LD      HL,(FPREG)      ; Get second string
1553-E5             2828 ( 11)         PUSH    HL              ; Save second string
1554-86             2829 (  6)         ADD     A,(HL)          ; Add length of second string
1555-1E 1C          2830 (  6)         LD      E,LS            ; ?LS Error
1557-DA C1 06       2831 ( 6+)         JP      C,ERROR         ; String too long - Error
155A-CD FA 13       2832 ( 16)         CALL    MKTMST          ; Make temporary string
155D-D1             2833 (  9)         POP     DE              ; Get second string to DE
155E-CD 92 15       2834 ( 16)         CALL    GSTRDE          ; Move to string pool if needed
1561-E3             2835 ( 16)         EX      (SP),HL         ; Get first string
1562-CD 91 15       2836 ( 16)         CALL    GSTRHL          ; Move to string pool if needed
1565-E5             2837 ( 11)         PUSH    HL              ; Save first string
1566-2A 06 23       2838 ( 15)         LD      HL,(TMPSTR+2)   ; Temporary string address
1569-EB             2839 (  3)         EX      DE,HL           ; To DE
156A-CD 78 15       2840 ( 16)         CALL    SSTSA           ; First string to string area
156D-CD 78 15       2841 ( 16)         CALL    SSTSA           ; Second string to string area
1570-21 90 0F       2842 (  9)         LD      HL,EVAL2        ; Return to evaluation loop
1573-E3             2843 ( 16)         EX      (SP),HL         ; Save return,get code string
1574-E5             2844 ( 11)         PUSH    HL              ; Save code string address
1575-C3 2B 14       2845 (  9)         JP      TSTOPL          ; To temporary string to pool
1578-               2846
1578-E1             2847 (  9) SSTSA:  POP     HL              ; Return address
1579-E3             2848 ( 16)         EX      (SP),HL         ; Get string block,save return
157A-7E             2849 (  6)         LD      A,(HL)          ; Get length of string
157B-23             2850 (  4)         INC     HL
157C-23             2851 (  4)         INC     HL
157D-4E             2852 (  6)         LD      C,(HL)          ; Get LSB of string address
157E-23             2853 (  4)         INC     HL
157F-46             2854 (  6)         LD      B,(HL)          ; Get MSB of string address
1580-6F             2855 (  4)         LD      L,A             ; Length to L
1581-2C             2856 (  4) TOSTRA: INC     L               ; INC - DECed after
1582-2D             2857 (  4) TSALP:  DEC     L               ; Count bytes moved
1583-C8             2858 ( 5+)         RET     Z               ; End of string - Return
1584-0A             2859 (  6)         LD      A,(BC)          ; Get source
1585-12             2860 (  7)         LD      (DE),A          ; Save destination
1586-03             2861 (  4)         INC     BC              ; Next source
1587-13             2862 (  4)         INC     DE              ; Next destination
1588-C3 82 15       2863 (  9)         JP      TSALP           ; Loop until string moved
158B-               2864
158B-CD 76 0F       2865 ( 16) GETSTR: CALL    TSTSTR          ; Make sure it's a string
158E-2A 29 23       2866 ( 15) GSTRCU: LD      HL,(FPREG)      ; Get current string
1591-EB             2867 (  3) GSTRHL: EX      DE,HL           ; Save DE
1592-CD AC 15       2868 ( 16) GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
1595-EB             2869 (  3)         EX      DE,HL           ; Restore DE
1596-C0             2870 ( 5+)         RET     NZ              ; No - Return
1597-D5             2871 ( 11)         PUSH    DE              ; Save string
1598-50             2872 (  4)         LD      D,B             ; String block address to DE
1599-59             2873 (  4)         LD      E,C
159A-1B             2874 (  4)         DEC     DE              ; Point to length
159B-4E             2875 (  6)         LD      C,(HL)          ; Get string length
159C-2A 08 23       2876 ( 15)         LD      HL,(STRBOT)     ; Current bottom of string area
159F-CD 75 09       2877 ( 16)         CALL    CPDEHL          ; Last one in string area?
15A2-C2 AA 15       2878 ( 6+)         JP      NZ,POPHL        ; No - Return
15A5-47             2879 (  4)         LD      B,A             ; Clear B (A=0)
15A6-09             2880 (  7)         ADD     HL,BC           ; Remove string from str' area
15A7-22 08 23       2881 ( 20)         LD      (STRBOT),HL     ; Save new bottom of str' area
15AA-E1             2882 (  9) POPHL:  POP     HL              ; Restore string
15AB-C9             2883 (  9)         RET
15AC-               2884
15AC-2A F6 22       2885 ( 15) BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
15AF-2B             2886 (  4)         DEC     HL              ; Back
15B0-46             2887 (  6)         LD      B,(HL)          ; Get MSB of address
15B1-2B             2888 (  4)         DEC     HL              ; Back
15B2-4E             2889 (  6)         LD      C,(HL)          ; Get LSB of address
15B3-2B             2890 (  4)         DEC     HL              ; Back
15B4-2B             2891 (  4)         DEC     HL              ; Back
15B5-CD 75 09       2892 ( 16)         CALL    CPDEHL          ; String last in string pool?
15B8-C0             2893 ( 5+)         RET     NZ              ; Yes - Leave it
15B9-22 F6 22       2894 ( 20)         LD      (TMSTPT),HL     ; Save new string pool top
15BC-C9             2895 (  9)         RET
15BD-               2896
15BD-01 3C 13       2897 (  9) LEN:    LD      BC,PASSA        ; To return integer A
15C0-C5             2898 ( 11)         PUSH    BC              ; Save address
15C1-CD 8B 15       2899 ( 16) GETLEN: CALL    GETSTR          ; Get string and its length
15C4-AF             2900 (  4)         XOR     A
15C5-57             2901 (  4)         LD      D,A             ; Clear D
15C6-32 F2 22       2902 ( 13)         LD      (TYPE),A        ; Set type to numeric
15C9-7E             2903 (  6)         LD      A,(HL)          ; Get length of string
15CA-B7             2904 (  4)         OR      A               ; Set status flags
15CB-C9             2905 (  9)         RET
15CC-               2906
15CC-01 3C 13       2907 (  9) ASC:    LD      BC,PASSA        ; To return integer A
15CF-C5             2908 ( 11)         PUSH    BC              ; Save address
15D0-CD C1 15       2909 ( 16) GTFLNM: CALL    GETLEN          ; Get length of string
15D3-CA CC 0B       2910 ( 6+)         JP      Z,FCERR         ; Null string - Error
15D6-23             2911 (  4)         INC     HL
15D7-23             2912 (  4)         INC     HL
15D8-5E             2913 (  6)         LD      E,(HL)          ; Get LSB of address
15D9-23             2914 (  4)         INC     HL
15DA-56             2915 (  6)         LD      D,(HL)          ; Get MSB of address
15DB-1A             2916 (  6)         LD      A,(DE)          ; Get first byte of string
15DC-C9             2917 (  9)         RET
15DD-               2918
15DD-3E 01          2919 (  6) CHR:    LD      A,1             ; One character string
15DF-CD FA 13       2920 ( 16)         CALL    MKTMST          ; Make a temporary string
15E2-CD D6 16       2921 ( 16)         CALL    MAKINT          ; Make it integer A
15E5-2A 06 23       2922 ( 15)         LD      HL,(TMPSTR+2)   ; Get address of string
15E8-73             2923 (  7)         LD      (HL),E          ; Save character
15E9-C1             2924 (  9) TOPOOL: POP     BC              ; Clean up stack
15EA-C3 2B 14       2925 (  9)         JP      TSTOPL          ; Temporary string to pool
15ED-               2926
15ED-CD 86 16       2927 ( 16) LEFT:   CALL    LFRGNM          ; Get number and ending ")"
15F0-AF             2928 (  4)         XOR     A               ; Start at first byte in string
15F1-E3             2929 ( 16) RIGHT1: EX      (SP),HL         ; Save code string,Get string
15F2-4F             2930 (  4)         LD      C,A             ; Starting position in string
15F3-E5             2931 ( 11) MID1:   PUSH    HL              ; Save string block address
15F4-7E             2932 (  6)         LD      A,(HL)          ; Get length of string
15F5-B8             2933 (  4)         CP      B               ; Compare with number given
15F6-DA FB 15       2934 ( 6+)         JP      C,ALLFOL        ; All following bytes required
15F9-78             2935 (  4)         LD      A,B             ; Get new length
15FA-11             2936               .DB      11H             ; Skip "LD C,0"
15FB-0E 00          2937 (  6) ALLFOL: LD      C,0             ; First byte of string
15FD-C5             2938 ( 11)         PUSH    BC              ; Save position in string
15FE-CD 64 14       2939 ( 16)         CALL    TESTR           ; See if enough string space
1601-C1             2940 (  9)         POP     BC              ; Get position in string
1602-E1             2941 (  9)         POP     HL              ; Restore string block address
1603-E5             2942 ( 11)         PUSH    HL              ; And re-save it
1604-23             2943 (  4)         INC     HL
1605-23             2944 (  4)         INC     HL
1606-46             2945 (  6)         LD      B,(HL)          ; Get LSB of address
1607-23             2946 (  4)         INC     HL
1608-66             2947 (  6)         LD      H,(HL)          ; Get MSB of address
1609-68             2948 (  4)         LD      L,B             ; HL = address of string
160A-06 00          2949 (  6)         LD      B,0             ; BC = starting address
160C-09             2950 (  7)         ADD     HL,BC           ; Point to that byte
160D-44             2951 (  4)         LD      B,H             ; BC = source string
160E-4D             2952 (  4)         LD      C,L
160F-CD FD 13       2953 ( 16)         CALL    CRTMST          ; Create a string entry
1612-6F             2954 (  4)         LD      L,A             ; Length of new string
1613-CD 81 15       2955 ( 16)         CALL    TOSTRA          ; Move string to string area
1616-D1             2956 (  9)         POP     DE              ; Clear stack
1617-CD 92 15       2957 ( 16)         CALL    GSTRDE          ; Move to string pool if needed
161A-C3 2B 14       2958 (  9)         JP      TSTOPL          ; Temporary string to pool
161D-               2959
161D-CD 86 16       2960 ( 16) RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
1620-D1             2961 (  9)         POP     DE              ; Get string length
1621-D5             2962 ( 11)         PUSH    DE              ; And re-save
1622-1A             2963 (  6)         LD      A,(DE)          ; Get length
1623-90             2964 (  4)         SUB     B               ; Move back N bytes
1624-C3 F1 15       2965 (  9)         JP      RIGHT1          ; Go and get sub-string
1627-               2966
1627-EB             2967 (  3) MID:    EX      DE,HL           ; Get code string address
1628-7E             2968 (  6)         LD      A,(HL)          ; Get next byte ',' or ")"
1629-CD 8B 16       2969 ( 16)         CALL    MIDNUM          ; Get number supplied
162C-04             2970 (  4)         INC     B               ; Is it character zero?
162D-05             2971 (  4)         DEC     B
162E-CA CC 0B       2972 ( 6+)         JP      Z,FCERR         ; Yes - Error
1631-C5             2973 ( 11)         PUSH    BC              ; Save starting position
1632-1E FF          2974 (  6)         LD      E,255           ; All of string
1634-FE 29          2975 (  6)         CP      ')'             ; Any length given?
1636-CA 40 16       2976 ( 6+)         JP      Z,RSTSTR        ; No - Rest of string
1639-CD 7B 09       2977 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
163C-2C             2978               .DB      ','
163D-CD D3 16       2979 ( 16)         CALL    GETINT          ; Get integer 0-255
1640-CD 7B 09       2980 ( 16) RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
1643-29             2981               .DB      ")"
1644-F1             2982 (  9)         POP     AF              ; Restore starting position
1645-E3             2983 ( 16)         EX      (SP),HL         ; Get string,8ave code string
1646-01 F3 15       2984 (  9)         LD      BC,MID1         ; Continuation of MID$ routine
1649-C5             2985 ( 11)         PUSH    BC              ; Save for return
164A-3D             2986 (  4)         DEC     A               ; Starting position-1
164B-BE             2987 (  6)         CP      (HL)            ; Compare with length
164C-06 00          2988 (  6)         LD      B,0             ; Zero bytes length
164E-D0             2989 ( 5+)         RET     NC              ; Null string if start past end
164F-4F             2990 (  4)         LD      C,A             ; Save starting position-1
1650-7E             2991 (  6)         LD      A,(HL)          ; Get length of string
1651-91             2992 (  4)         SUB     C               ; Subtract start
1652-BB             2993 (  4)         CP      E               ; Enough string for it?
1653-47             2994 (  4)         LD      B,A             ; Save maximum length available
1654-D8             2995 ( 5+)         RET     C               ; Truncate string if needed
1655-43             2996 (  4)         LD      B,E             ; Set specified length
1656-C9             2997 (  9)         RET                     ; Go and create string
1657-               2998
1657-CD C1 15       2999 ( 16) VAL:    CALL    GETLEN          ; Get length of string
165A-CA 74 17       3000 ( 6+)         JP      Z,RESZER        ; Result zero
165D-5F             3001 (  4)         LD      E,A             ; Save length
165E-23             3002 (  4)         INC     HL
165F-23             3003 (  4)         INC     HL
1660-7E             3004 (  6)         LD      A,(HL)          ; Get LSB of address
1661-23             3005 (  4)         INC     HL
1662-66             3006 (  6)         LD      H,(HL)          ; Get MSB of address
1663-6F             3007 (  4)         LD      L,A             ; HL = String address
1664-E5             3008 ( 11)         PUSH    HL              ; Save string address
1665-19             3009 (  7)         ADD     HL,DE
1666-46             3010 (  6)         LD      B,(HL)          ; Get end of string+1 byte
1667-72             3011 (  7)         LD      (HL),D          ; Zero it to terminate
1668-E3             3012 ( 16)         EX      (SP),HL         ; Save string end,get start
1669-C5             3013 ( 11)         PUSH    BC              ; Save end+1 byte
166A-7E             3014 (  6)         LD      A,(HL)          ; Get starting byte
166B-FE 24          3015 (  6)     CP  '$'             ; Hex number indicated? [function added]
166D-C2 75 16       3016 ( 6+)     JP  NZ,VAL1
1670-CD 9F 1E       3017 ( 16)     CALL        HEXTFP          ; Convert Hex to FPREG
1673-18 0D          3018 (  8)     JR  VAL3
1675-FE 25          3019 (  6) VAL1:   CP      '%'             ; Binary number indicated? [function added]
1677-C2 7F 16       3020 ( 6+)     JP  NZ,VAL2
167A-CD 0F 1F       3021 ( 16)     CALL        BINTFP          ; Convert Bin to FPREG
167D-18 03          3022 (  8)     JR  VAL3
167F-CD 5B 1A       3023 ( 16) VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
1682-C1             3024 (  9) VAL3:   POP     BC              ; Restore end+1 byte
1683-E1             3025 (  9)         POP     HL              ; Restore end+1 address
1684-70             3026 (  7)         LD      (HL),B          ; Put back original byte
1685-C9             3027 (  9)         RET
1686-               3028
1686-EB             3029 (  3) LFRGNM: EX      DE,HL           ; Code string address to HL
1687-CD 7B 09       3030 ( 16)         CALL    CHKSYN          ; Make sure ")" follows
168A-29             3031               .DB      ")"
168B-C1             3032 (  9) MIDNUM: POP     BC              ; Get return address
168C-D1             3033 (  9)         POP     DE              ; Get number supplied
168D-C5             3034 ( 11)         PUSH    BC              ; Re-save return address
168E-43             3035 (  4)         LD      B,E             ; Number to B
168F-C9             3036 (  9)         RET
1690-               3037
1690-CD D6 16       3038 ( 16) INP:    CALL    MAKINT          ; Make it integer A
1693-32 84 22       3039 ( 13)         LD      (INPORT),A      ; Set input port
1696-CD 83 22       3040 ( 16)         CALL    INPSUB          ; Get input from port
1699-C3 3C 13       3041 (  9)         JP      PASSA           ; Return integer A
169C-               3042
169C-CD C0 16       3043 ( 16) POUT:   CALL    SETIO           ; Set up port number
169F-C3 4B 22       3044 (  9)         JP      OUTSUB          ; Output data and return
16A2-               3045
16A2-CD C0 16       3046 ( 16) WAIT:   CALL    SETIO           ; Set up port number
16A5-F5             3047 ( 11)         PUSH    AF              ; Save AND mask
16A6-1E 00          3048 (  6)         LD      E,0             ; Assume zero if none given
16A8-2B             3049 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
16A9-CD 05 0B       3050 ( 16)         CALL    GETCHR          ; Get next character
16AC-CA B6 16       3051 ( 6+)         JP      Z,NOXOR         ; No XOR byte given
16AF-CD 7B 09       3052 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
16B2-2C             3053               .DB      ','
16B3-CD D3 16       3054 ( 16)         CALL    GETINT          ; Get integer 0-255 to XOR with
16B6-C1             3055 (  9) NOXOR:  POP     BC              ; Restore AND mask
16B7-CD 83 22       3056 ( 16) WAITLP: CALL    INPSUB          ; Get input
16BA-AB             3057 (  4)         XOR     E               ; Flip selected bits
16BB-A0             3058 (  4)         AND     B               ; Result non-zero?
16BC-CA B7 16       3059 ( 6+)         JP      Z,WAITLP        ; No = keep waiting
16BF-C9             3060 (  9)         RET
16C0-               3061
16C0-CD D3 16       3062 ( 16) SETIO:  CALL    GETINT          ; Get integer 0-255
16C3-32 84 22       3063 ( 13)         LD      (INPORT),A      ; Set input port
16C6-32 4C 22       3064 ( 13)         LD      (OTPORT),A      ; Set output port
16C9-CD 7B 09       3065 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
16CC-2C             3066               .DB      ','
16CD-C3 D3 16       3067 (  9)         JP      GETINT          ; Get integer 0-255 and return
16D0-               3068
16D0-CD 05 0B       3069 ( 16) FNDNUM: CALL    GETCHR          ; Get next character
16D3-CD 72 0F       3070 ( 16) GETINT: CALL    GETNUM          ; Get a number from 0 to 255
16D6-CD B1 0B       3071 ( 16) MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
16D9-7A             3072 (  4)         LD      A,D             ; Get MSB of number
16DA-B7             3073 (  4)         OR      A               ; Zero?
16DB-C2 CC 0B       3074 ( 6+)         JP      NZ,FCERR        ; No - Error
16DE-2B             3075 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
16DF-CD 05 0B       3076 ( 16)         CALL    GETCHR          ; Get next character
16E2-7B             3077 (  4)         LD      A,E             ; Get number to A
16E3-C9             3078 (  9)         RET
16E4-               3079
16E4-CD B7 0B       3080 ( 16) PEEK:   CALL    DEINT           ; Get memory address
16E7-1A             3081 (  6)         LD      A,(DE)          ; Get byte in memory
16E8-C3 3C 13       3082 (  9)         JP      PASSA           ; Return integer A
16EB-               3083
16EB-CD 72 0F       3084 ( 16) POKE:   CALL    GETNUM          ; Get memory address
16EE-CD B7 0B       3085 ( 16)         CALL    DEINT           ; Get integer -32768 to 3276
16F1-D5             3086 ( 11)         PUSH    DE              ; Save memory address
16F2-CD 7B 09       3087 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
16F5-2C             3088               .DB      ','
16F6-CD D3 16       3089 ( 16)         CALL    GETINT          ; Get integer 0-255
16F9-D1             3090 (  9)         POP     DE              ; Restore memory address
16FA-12             3091 (  7)         LD      (DE),A          ; Load it into memory
16FB-C9             3092 (  9)         RET
16FC-               3093
16FC-21 D2 1B       3094 (  9) ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
16FF-CD A3 19       3095 ( 16) ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
1702-C3 0E 17       3096 (  9)         JP      FPADD           ; Add BCDE to FPREG
1705-               3097
1705-CD A3 19       3098 ( 16) SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
1708-21             3099               .DB      21H             ; Skip "POP BC" and "POP DE"
1709-C1             3100 (  9) PSUB:   POP     BC              ; Get FP number from stack
170A-D1             3101 (  9)         POP     DE
170B-CD 7D 19       3102 ( 16) SUBCDE: CALL    INVSGN          ; Negate FPREG
170E-78             3103 (  4) FPADD:  LD      A,B             ; Get FP exponent
170F-B7             3104 (  4)         OR      A               ; Is number zero?
1710-C8             3105 ( 5+)         RET     Z               ; Yes - Nothing to add
1711-3A 2C 23       3106 ( 12)         LD      A,(FPEXP)       ; Get FPREG exponent
1714-B7             3107 (  4)         OR      A               ; Is this number zero?
1715-CA 95 19       3108 ( 6+)         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
1718-90             3109 (  4)         SUB     B               ; BCDE number larger?
1719-D2 28 17       3110 ( 6+)         JP      NC,NOSWAP       ; No - Don't swap them
171C-2F             3111 (  3)         CPL                     ; Two's complement
171D-3C             3112 (  4)         INC     A               ;  FP exponent
171E-EB             3113 (  3)         EX      DE,HL
171F-CD 85 19       3114 ( 16)         CALL    STAKFP          ; Put FPREG on stack
1722-EB             3115 (  3)         EX      DE,HL
1723-CD 95 19       3116 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
1726-C1             3117 (  9)         POP     BC              ; Restore number from stack
1727-D1             3118 (  9)         POP     DE
1728-FE 19          3119 (  6) NOSWAP: CP      24+1            ; Second number insignificant?
172A-D0             3120 ( 5+)         RET     NC              ; Yes - First number is result
172B-F5             3121 ( 11)         PUSH    AF              ; Save number of bits to scale
172C-CD BA 19       3122 ( 16)         CALL    SIGNS           ; Set MSBs & sign of result
172F-67             3123 (  4)         LD      H,A             ; Save sign of result
1730-F1             3124 (  9)         POP     AF              ; Restore scaling factor
1731-CD D3 17       3125 ( 16)         CALL    SCALE           ; Scale BCDE to same exponent
1734-B4             3126 (  4)         OR      H               ; Result to be positive?
1735-21 29 23       3127 (  9)         LD      HL,FPREG        ; Point to FPREG
1738-F2 4E 17       3128 ( 6+)         JP      P,MINCDE        ; No - Subtract FPREG from CDE
173B-CD B3 17       3129 ( 16)         CALL    PLUCDE          ; Add FPREG to CDE
173E-D2 94 17       3130 ( 6+)         JP      NC,RONDUP       ; No overflow - Round it up
1741-23             3131 (  4)         INC     HL              ; Point to exponent
1742-34             3132 ( 10)         INC     (HL)            ; Increment it
1743-CA BC 06       3133 ( 6+)         JP      Z,OVERR         ; Number overflowed - Error
1746-2E 01          3134 (  6)         LD      L,1             ; 1 bit to shift right
1748-CD E9 17       3135 ( 16)         CALL    SHRT1           ; Shift result right
174B-C3 94 17       3136 (  9)         JP      RONDUP          ; Round it up
174E-               3137
174E-AF             3138 (  4) MINCDE: XOR     A               ; Clear A and carry
174F-90             3139 (  4)         SUB     B               ; Negate exponent
1750-47             3140 (  4)         LD      B,A             ; Re-save exponent
1751-7E             3141 (  6)         LD      A,(HL)          ; Get LSB of FPREG
1752-9B             3142 (  4)         SBC     A, E            ; Subtract LSB of BCDE
1753-5F             3143 (  4)         LD      E,A             ; Save LSB of BCDE
1754-23             3144 (  4)         INC     HL
1755-7E             3145 (  6)         LD      A,(HL)          ; Get NMSB of FPREG
1756-9A             3146 (  4)         SBC     A,D             ; Subtract NMSB of BCDE
1757-57             3147 (  4)         LD      D,A             ; Save NMSB of BCDE
1758-23             3148 (  4)         INC     HL
1759-7E             3149 (  6)         LD      A,(HL)          ; Get MSB of FPREG
175A-99             3150 (  4)         SBC     A,C             ; Subtract MSB of BCDE
175B-4F             3151 (  4)         LD      C,A             ; Save MSB of BCDE
175C-DC BF 17       3152 ( 6+) CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
175F-               3153
175F-68             3154 (  4) BNORM:  LD      L,B             ; L = Exponent
1760-63             3155 (  4)         LD      H,E             ; H = LSB
1761-AF             3156 (  4)         XOR     A
1762-47             3157 (  4) BNRMLP: LD      B,A             ; Save bit count
1763-79             3158 (  4)         LD      A,C             ; Get MSB
1764-B7             3159 (  4)         OR      A               ; Is it zero?
1765-C2 81 17       3160 ( 6+)         JP      NZ,PNORM        ; No - Do it bit at a time
1768-4A             3161 (  4)         LD      C,D             ; MSB = NMSB
1769-54             3162 (  4)         LD      D,H             ; NMSB= LSB
176A-65             3163 (  4)         LD      H,L             ; LSB = VLSB
176B-6F             3164 (  4)         LD      L,A             ; VLSB= 0
176C-78             3165 (  4)         LD      A,B             ; Get exponent
176D-D6 08          3166 (  6)         SUB     8               ; Count 8 bits
176F-FE E0          3167 (  6)         CP      -24-8           ; Was number zero?
1771-C2 62 17       3168 ( 6+)         JP      NZ,BNRMLP       ; No - Keep normalising
1774-AF             3169 (  4) RESZER: XOR     A               ; Result is zero
1775-32 2C 23       3170 ( 13) SAVEXP: LD      (FPEXP),A       ; Save result as zero
1778-C9             3171 (  9)         RET
1779-               3172
1779-05             3173 (  4) NORMAL: DEC     B               ; Count bits
177A-29             3174 (  7)         ADD     HL,HL           ; Shift HL left
177B-7A             3175 (  4)         LD      A,D             ; Get NMSB
177C-17             3176 (  3)         RLA                     ; Shift left with last bit
177D-57             3177 (  4)         LD      D,A             ; Save NMSB
177E-79             3178 (  4)         LD      A,C             ; Get MSB
177F-8F             3179 (  4)         ADC     A,A             ; Shift left with last bit
1780-4F             3180 (  4)         LD      C,A             ; Save MSB
1781-F2 79 17       3181 ( 6+) PNORM:  JP      P,NORMAL        ; Not done - Keep going
1784-78             3182 (  4)         LD      A,B             ; Number of bits shifted
1785-5C             3183 (  4)         LD      E,H             ; Save HL in EB
1786-45             3184 (  4)         LD      B,L
1787-B7             3185 (  4)         OR      A               ; Any shifting done?
1788-CA 94 17       3186 ( 6+)         JP      Z,RONDUP        ; No - Round it up
178B-21 2C 23       3187 (  9)         LD      HL,FPEXP        ; Point to exponent
178E-86             3188 (  6)         ADD     A,(HL)          ; Add shifted bits
178F-77             3189 (  7)         LD      (HL),A          ; Re-save exponent
1790-D2 74 17       3190 ( 6+)         JP      NC,RESZER       ; Underflow - Result is zero
1793-C8             3191 ( 5+)         RET     Z               ; Result is zero
1794-78             3192 (  4) RONDUP: LD      A,B             ; Get VLSB of number
1795-21 2C 23       3193 (  9) RONDB:  LD      HL,FPEXP        ; Point to exponent
1798-B7             3194 (  4)         OR      A               ; Any rounding?
1799-FC A6 17       3195 ( 6+)         CALL    M,FPROND        ; Yes - Round number up
179C-46             3196 (  6)         LD      B,(HL)          ; B = Exponent
179D-23             3197 (  4)         INC     HL
179E-7E             3198 (  6)         LD      A,(HL)          ; Get sign of result
179F-E6 80          3199 (  6)         AND     10000000B       ; Only bit 7 needed
17A1-A9             3200 (  4)         XOR     C               ; Set correct sign
17A2-4F             3201 (  4)         LD      C,A             ; Save correct sign in number
17A3-C3 95 19       3202 (  9)         JP      FPBCDE          ; Move BCDE to FPREG
17A6-               3203
17A6-1C             3204 (  4) FPROND: INC     E               ; Round LSB
17A7-C0             3205 ( 5+)         RET     NZ              ; Return if ok
17A8-14             3206 (  4)         INC     D               ; Round NMSB
17A9-C0             3207 ( 5+)         RET     NZ              ; Return if ok
17AA-0C             3208 (  4)         INC     C               ; Round MSB
17AB-C0             3209 ( 5+)         RET     NZ              ; Return if ok
17AC-0E 80          3210 (  6)         LD      C,80H           ; Set normal value
17AE-34             3211 ( 10)         INC     (HL)            ; Increment exponent
17AF-C0             3212 ( 5+)         RET     NZ              ; Return if ok
17B0-C3 BC 06       3213 (  9)         JP      OVERR           ; Overflow error
17B3-               3214
17B3-7E             3215 (  6) PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
17B4-83             3216 (  4)         ADD     A,E             ; Add LSB of BCDE
17B5-5F             3217 (  4)         LD      E,A             ; Save LSB of BCDE
17B6-23             3218 (  4)         INC     HL
17B7-7E             3219 (  6)         LD      A,(HL)          ; Get NMSB of FPREG
17B8-8A             3220 (  4)         ADC     A,D             ; Add NMSB of BCDE
17B9-57             3221 (  4)         LD      D,A             ; Save NMSB of BCDE
17BA-23             3222 (  4)         INC     HL
17BB-7E             3223 (  6)         LD      A,(HL)          ; Get MSB of FPREG
17BC-89             3224 (  4)         ADC     A,C             ; Add MSB of BCDE
17BD-4F             3225 (  4)         LD      C,A             ; Save MSB of BCDE
17BE-C9             3226 (  9)         RET
17BF-               3227
17BF-21 2D 23       3228 (  9) COMPL:  LD      HL,SGNRES       ; Sign of result
17C2-7E             3229 (  6)         LD      A,(HL)          ; Get sign of result
17C3-2F             3230 (  3)         CPL                     ; Negate it
17C4-77             3231 (  7)         LD      (HL),A          ; Put it back
17C5-AF             3232 (  4)         XOR     A
17C6-6F             3233 (  4)         LD      L,A             ; Set L to zero
17C7-90             3234 (  4)         SUB     B               ; Negate exponent,set carry
17C8-47             3235 (  4)         LD      B,A             ; Re-save exponent
17C9-7D             3236 (  4)         LD      A,L             ; Load zero
17CA-9B             3237 (  4)         SBC     A,E             ; Negate LSB
17CB-5F             3238 (  4)         LD      E,A             ; Re-save LSB
17CC-7D             3239 (  4)         LD      A,L             ; Load zero
17CD-9A             3240 (  4)         SBC     A,D             ; Negate NMSB
17CE-57             3241 (  4)         LD      D,A             ; Re-save NMSB
17CF-7D             3242 (  4)         LD      A,L             ; Load zero
17D0-99             3243 (  4)         SBC     A,C             ; Negate MSB
17D1-4F             3244 (  4)         LD      C,A             ; Re-save MSB
17D2-C9             3245 (  9)         RET
17D3-               3246
17D3-06 00          3247 (  6) SCALE:  LD      B,0             ; Clear underflow
17D5-D6 08          3248 (  6) SCALLP: SUB     8               ; 8 bits (a whole byte)?
17D7-DA E2 17       3249 ( 6+)         JP      C,SHRITE        ; No - Shift right A bits
17DA-43             3250 (  4)         LD      B,E             ; <- Shift
17DB-5A             3251 (  4)         LD      E,D             ; <- right
17DC-51             3252 (  4)         LD      D,C             ; <- eight
17DD-0E 00          3253 (  6)         LD      C,0             ; <- bits
17DF-C3 D5 17       3254 (  9)         JP      SCALLP          ; More bits to shift
17E2-               3255
17E2-C6 09          3256 (  6) SHRITE: ADD     A,8+1           ; Adjust count
17E4-6F             3257 (  4)         LD      L,A             ; Save bits to shift
17E5-AF             3258 (  4) SHRLP:  XOR     A               ; Flag for all done
17E6-2D             3259 (  4)         DEC     L               ; All shifting done?
17E7-C8             3260 ( 5+)         RET     Z               ; Yes - Return
17E8-79             3261 (  4)         LD      A,C             ; Get MSB
17E9-1F             3262 (  3) SHRT1:  RRA                     ; Shift it right
17EA-4F             3263 (  4)         LD      C,A             ; Re-save
17EB-7A             3264 (  4)         LD      A,D             ; Get NMSB
17EC-1F             3265 (  3)         RRA                     ; Shift right with last bit
17ED-57             3266 (  4)         LD      D,A             ; Re-save it
17EE-7B             3267 (  4)         LD      A,E             ; Get LSB
17EF-1F             3268 (  3)         RRA                     ; Shift right with last bit
17F0-5F             3269 (  4)         LD      E,A             ; Re-save it
17F1-78             3270 (  4)         LD      A,B             ; Get underflow
17F2-1F             3271 (  3)         RRA                     ; Shift right with last bit
17F3-47             3272 (  4)         LD      B,A             ; Re-save underflow
17F4-C3 E5 17       3273 (  9)         JP      SHRLP           ; More bits to do
17F7-               3274
17F7-00 00 00 81    3275       UNITY:  .DB       000H,000H,000H,081H    ; 1.00000
17FB-               3276
17FB-03             3277       LOGTAB: .DB      3                       ; Table used by LOG
17FC-AA 56 19 80    3278               .DB      0AAH,056H,019H,080H     ; 0.59898
1800-F1 22 76 80    3279               .DB      0F1H,022H,076H,080H     ; 0.96147
1804-45 AA 38 82    3280               .DB      045H,0AAH,038H,082H     ; 2.88539
1808-               3281
1808-CD 54 19       3282 ( 16) LOG:    CALL    TSTSGN          ; Test sign of value
180B-B7             3283 (  4)         OR      A
180C-EA CC 0B       3284 ( 6+)         JP      PE,FCERR        ; ?FC Error if <= zero
180F-21 2C 23       3285 (  9)         LD      HL,FPEXP        ; Point to exponent
1812-7E             3286 (  6)         LD      A,(HL)          ; Get exponent
1813-01 35 80       3287 (  9)         LD      BC,8035H        ; BCDE = SQR(1/2)
1816-11 F3 04       3288 (  9)         LD      DE,04F3H
1819-90             3289 (  4)         SUB     B               ; Scale value to be < 1
181A-F5             3290 ( 11)         PUSH    AF              ; Save scale factor
181B-70             3291 (  7)         LD      (HL),B          ; Save new exponent
181C-D5             3292 ( 11)         PUSH    DE              ; Save SQR(1/2)
181D-C5             3293 ( 11)         PUSH    BC
181E-CD 0E 17       3294 ( 16)         CALL    FPADD           ; Add SQR(1/2) to value
1821-C1             3295 (  9)         POP     BC              ; Restore SQR(1/2)
1822-D1             3296 (  9)         POP     DE
1823-04             3297 (  4)         INC     B               ; Make it SQR(2)
1824-CD AA 18       3298 ( 16)         CALL    DVBCDE          ; Divide by SQR(2)
1827-21 F7 17       3299 (  9)         LD      HL,UNITY        ; Point to 1.
182A-CD 05 17       3300 ( 16)         CALL    SUBPHL          ; Subtract FPREG from 1
182D-21 FB 17       3301 (  9)         LD      HL,LOGTAB       ; Coefficient table
1830-CD 9C 1C       3302 ( 16)         CALL    SUMSER          ; Evaluate sum of series
1833-01 80 80       3303 (  9)         LD      BC,8080H        ; BCDE = -0.5
1836-11 00 00       3304 (  9)         LD      DE,0000H
1839-CD 0E 17       3305 ( 16)         CALL    FPADD           ; Subtract 0.5 from FPREG
183C-F1             3306 (  9)         POP     AF              ; Restore scale factor
183D-CD CF 1A       3307 ( 16)         CALL    RSCALE          ; Re-scale number
1840-01 31 80       3308 (  9) MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
1843-11 18 72       3309 (  9)         LD      DE,7218H
1846-21             3310               .DB      21H             ; Skip "POP BC" and "POP DE"
1847-               3311
1847-C1             3312 (  9) MULT:   POP     BC              ; Get number from stack
1848-D1             3313 (  9)         POP     DE
1849-CD 54 19       3314 ( 16) FPMULT: CALL    TSTSGN          ; Test sign of FPREG
184C-C8             3315 ( 5+)         RET     Z               ; Return zero if zero
184D-2E 00          3316 (  6)         LD      L,0             ; Flag add exponents
184F-CD 12 19       3317 ( 16)         CALL    ADDEXP          ; Add exponents
1852-79             3318 (  4)         LD      A,C             ; Get MSB of multiplier
1853-32 3B 23       3319 ( 13)         LD      (MULVAL),A      ; Save MSB of multiplier
1856-EB             3320 (  3)         EX      DE,HL
1857-22 3C 23       3321 ( 20)         LD      (MULVAL+1),HL   ; Save rest of multiplier
185A-01 00 00       3322 (  9)         LD      BC,0            ; Partial product (BCDE) = zero
185D-50             3323 (  4)         LD      D,B
185E-58             3324 (  4)         LD      E,B
185F-21 5F 17       3325 (  9)         LD      HL,BNORM        ; Address of normalise
1862-E5             3326 ( 11)         PUSH    HL              ; Save for return
1863-21 6B 18       3327 (  9)         LD      HL,MULT8        ; Address of 8 bit multiply
1866-E5             3328 ( 11)         PUSH    HL              ; Save for NMSB,MSB
1867-E5             3329 ( 11)         PUSH    HL              ;
1868-21 29 23       3330 (  9)         LD      HL,FPREG        ; Point to number
186B-7E             3331 (  6) MULT8:  LD      A,(HL)          ; Get LSB of number
186C-23             3332 (  4)         INC     HL              ; Point to NMSB
186D-B7             3333 (  4)         OR      A               ; Test LSB
186E-CA 97 18       3334 ( 6+)         JP      Z,BYTSFT        ; Zero - shift to next byte
1871-E5             3335 ( 11)         PUSH    HL              ; Save address of number
1872-2E 08          3336 (  6)         LD      L,8             ; 8 bits to multiply by
1874-1F             3337 (  3) MUL8LP: RRA                     ; Shift LSB right
1875-67             3338 (  4)         LD      H,A             ; Save LSB
1876-79             3339 (  4)         LD      A,C             ; Get MSB
1877-D2 85 18       3340 ( 6+)         JP      NC,NOMADD       ; Bit was zero - Don't add
187A-E5             3341 ( 11)         PUSH    HL              ; Save LSB and count
187B-2A 3C 23       3342 ( 15)         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
187E-19             3343 (  7)         ADD     HL,DE           ; Add NMSB and LSB
187F-EB             3344 (  3)         EX      DE,HL           ; Leave sum in DE
1880-E1             3345 (  9)         POP     HL              ; Restore MSB and count
1881-3A 3B 23       3346 ( 12)         LD      A,(MULVAL)      ; Get MSB of multiplier
1884-89             3347 (  4)         ADC     A,C             ; Add MSB
1885-1F             3348 (  3) NOMADD: RRA                     ; Shift MSB right
1886-4F             3349 (  4)         LD      C,A             ; Re-save MSB
1887-7A             3350 (  4)         LD      A,D             ; Get NMSB
1888-1F             3351 (  3)         RRA                     ; Shift NMSB right
1889-57             3352 (  4)         LD      D,A             ; Re-save NMSB
188A-7B             3353 (  4)         LD      A,E             ; Get LSB
188B-1F             3354 (  3)         RRA                     ; Shift LSB right
188C-5F             3355 (  4)         LD      E,A             ; Re-save LSB
188D-78             3356 (  4)         LD      A,B             ; Get VLSB
188E-1F             3357 (  3)         RRA                     ; Shift VLSB right
188F-47             3358 (  4)         LD      B,A             ; Re-save VLSB
1890-2D             3359 (  4)         DEC     L               ; Count bits multiplied
1891-7C             3360 (  4)         LD      A,H             ; Get LSB of multiplier
1892-C2 74 18       3361 ( 6+)         JP      NZ,MUL8LP       ; More - Do it
1895-E1             3362 (  9) POPHRT: POP     HL              ; Restore address of number
1896-C9             3363 (  9)         RET
1897-               3364
1897-43             3365 (  4) BYTSFT: LD      B,E             ; Shift partial product left
1898-5A             3366 (  4)         LD      E,D
1899-51             3367 (  4)         LD      D,C
189A-4F             3368 (  4)         LD      C,A
189B-C9             3369 (  9)         RET
189C-               3370
189C-CD 85 19       3371 ( 16) DIV10:  CALL    STAKFP          ; Save FPREG on stack
189F-01 20 84       3372 (  9)         LD      BC,8420H        ; BCDE = 10.
18A2-11 00 00       3373 (  9)         LD      DE,0000H
18A5-CD 95 19       3374 ( 16)         CALL    FPBCDE          ; Move 10 to FPREG
18A8-               3375
18A8-C1             3376 (  9) DIV:    POP     BC              ; Get number from stack
18A9-D1             3377 (  9)         POP     DE
18AA-CD 54 19       3378 ( 16) DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
18AD-CA B0 06       3379 ( 6+)         JP      Z,DZERR         ; Error if division by zero
18B0-2E FF          3380 (  6)         LD      L,-1            ; Flag subtract exponents
18B2-CD 12 19       3381 ( 16)         CALL    ADDEXP          ; Subtract exponents
18B5-34             3382 ( 10)         INC     (HL)            ; Add 2 to exponent to adjust
18B6-34             3383 ( 10)         INC     (HL)
18B7-2B             3384 (  4)         DEC     HL              ; Point to MSB
18B8-7E             3385 (  6)         LD      A,(HL)          ; Get MSB of dividend
18B9-32 57 22       3386 ( 13)         LD      (DIV3),A        ; Save for subtraction
18BC-2B             3387 (  4)         DEC     HL
18BD-7E             3388 (  6)         LD      A,(HL)          ; Get NMSB of dividend
18BE-32 53 22       3389 ( 13)         LD      (DIV2),A        ; Save for subtraction
18C1-2B             3390 (  4)         DEC     HL
18C2-7E             3391 (  6)         LD      A,(HL)          ; Get MSB of dividend
18C3-32 4F 22       3392 ( 13)         LD      (DIV1),A        ; Save for subtraction
18C6-41             3393 (  4)         LD      B,C             ; Get MSB
18C7-EB             3394 (  3)         EX      DE,HL           ; NMSB,LSB to HL
18C8-AF             3395 (  4)         XOR     A
18C9-4F             3396 (  4)         LD      C,A             ; Clear MSB of quotient
18CA-57             3397 (  4)         LD      D,A             ; Clear NMSB of quotient
18CB-5F             3398 (  4)         LD      E,A             ; Clear LSB of quotient
18CC-32 5A 22       3399 ( 13)         LD      (DIV4),A        ; Clear overflow count
18CF-E5             3400 ( 11) DIVLP:  PUSH    HL              ; Save divisor
18D0-C5             3401 ( 11)         PUSH    BC
18D1-7D             3402 (  4)         LD      A,L             ; Get LSB of number
18D2-CD 4E 22       3403 ( 16)         CALL    DIVSUP          ; Subt' divisor from dividend
18D5-DE 00          3404 (  6)         SBC     A,0             ; Count for overflows
18D7-3F             3405 (  3)         CCF
18D8-D2 E2 18       3406 ( 6+)         JP      NC,RESDIV       ; Restore divisor if borrow
18DB-32 5A 22       3407 ( 13)         LD      (DIV4),A        ; Re-save overflow count
18DE-F1             3408 (  9)         POP     AF              ; Scrap divisor
18DF-F1             3409 (  9)         POP     AF
18E0-37             3410 (  3)         SCF                     ; Set carry to
18E1-D2             3411               .DB      0D2H            ; Skip "POP BC" and "POP HL"
18E2-               3412
18E2-C1             3413 (  9) RESDIV: POP     BC              ; Restore divisor
18E3-E1             3414 (  9)         POP     HL
18E4-79             3415 (  4)         LD      A,C             ; Get MSB of quotient
18E5-3C             3416 (  4)         INC     A
18E6-3D             3417 (  4)         DEC     A
18E7-1F             3418 (  3)         RRA                     ; Bit 0 to bit 7
18E8-FA 95 17       3419 ( 6+)         JP      M,RONDB         ; Done - Normalise result
18EB-17             3420 (  3)         RLA                     ; Restore carry
18EC-7B             3421 (  4)         LD      A,E             ; Get LSB of quotient
18ED-17             3422 (  3)         RLA                     ; Double it
18EE-5F             3423 (  4)         LD      E,A             ; Put it back
18EF-7A             3424 (  4)         LD      A,D             ; Get NMSB of quotient
18F0-17             3425 (  3)         RLA                     ; Double it
18F1-57             3426 (  4)         LD      D,A             ; Put it back
18F2-79             3427 (  4)         LD      A,C             ; Get MSB of quotient
18F3-17             3428 (  3)         RLA                     ; Double it
18F4-4F             3429 (  4)         LD      C,A             ; Put it back
18F5-29             3430 (  7)         ADD     HL,HL           ; Double NMSB,LSB of divisor
18F6-78             3431 (  4)         LD      A,B             ; Get MSB of divisor
18F7-17             3432 (  3)         RLA                     ; Double it
18F8-47             3433 (  4)         LD      B,A             ; Put it back
18F9-3A 5A 22       3434 ( 12)         LD      A,(DIV4)        ; Get VLSB of quotient
18FC-17             3435 (  3)         RLA                     ; Double it
18FD-32 5A 22       3436 ( 13)         LD      (DIV4),A        ; Put it back
1900-79             3437 (  4)         LD      A,C             ; Get MSB of quotient
1901-B2             3438 (  4)         OR      D               ; Merge NMSB
1902-B3             3439 (  4)         OR      E               ; Merge LSB
1903-C2 CF 18       3440 ( 6+)         JP      NZ,DIVLP        ; Not done - Keep dividing
1906-E5             3441 ( 11)         PUSH    HL              ; Save divisor
1907-21 2C 23       3442 (  9)         LD      HL,FPEXP        ; Point to exponent
190A-35             3443 ( 10)         DEC     (HL)            ; Divide by 2
190B-E1             3444 (  9)         POP     HL              ; Restore divisor
190C-C2 CF 18       3445 ( 6+)         JP      NZ,DIVLP        ; Ok - Keep going
190F-C3 BC 06       3446 (  9)         JP      OVERR           ; Overflow error
1912-               3447
1912-78             3448 (  4) ADDEXP: LD      A,B             ; Get exponent of dividend
1913-B7             3449 (  4)         OR      A               ; Test it
1914-CA 36 19       3450 ( 6+)         JP      Z,OVTST3        ; Zero - Result zero
1917-7D             3451 (  4)         LD      A,L             ; Get add/subtract flag
1918-21 2C 23       3452 (  9)         LD      HL,FPEXP        ; Point to exponent
191B-AE             3453 (  6)         XOR     (HL)            ; Add or subtract it
191C-80             3454 (  4)         ADD     A,B             ; Add the other exponent
191D-47             3455 (  4)         LD      B,A             ; Save new exponent
191E-1F             3456 (  3)         RRA                     ; Test exponent for overflow
191F-A8             3457 (  4)         XOR     B
1920-78             3458 (  4)         LD      A,B             ; Get exponent
1921-F2 35 19       3459 ( 6+)         JP      P,OVTST2        ; Positive - Test for overflow
1924-C6 80          3460 (  6)         ADD     A,80H           ; Add excess 128
1926-77             3461 (  7)         LD      (HL),A          ; Save new exponent
1927-CA 95 18       3462 ( 6+)         JP      Z,POPHRT        ; Zero - Result zero
192A-CD BA 19       3463 ( 16)         CALL    SIGNS           ; Set MSBs and sign of result
192D-77             3464 (  7)         LD      (HL),A          ; Save new exponent
192E-2B             3465 (  4)         DEC     HL              ; Point to MSB
192F-C9             3466 (  9)         RET
1930-               3467
1930-CD 54 19       3468 ( 16) OVTST1: CALL    TSTSGN          ; Test sign of FPREG
1933-2F             3469 (  3)         CPL                     ; Invert sign
1934-E1             3470 (  9)         POP     HL              ; Clean up stack
1935-B7             3471 (  4) OVTST2: OR      A               ; Test if new exponent zero
1936-E1             3472 (  9) OVTST3: POP     HL              ; Clear off return address
1937-F2 74 17       3473 ( 6+)         JP      P,RESZER        ; Result zero
193A-C3 BC 06       3474 (  9)         JP      OVERR           ; Overflow error
193D-               3475
193D-CD A0 19       3476 ( 16) MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
1940-78             3477 (  4)         LD      A,B             ; Get exponent
1941-B7             3478 (  4)         OR      A               ; Is it zero?
1942-C8             3479 ( 5+)         RET     Z               ; Yes - Result is zero
1943-C6 02          3480 (  6)         ADD     A,2             ; Multiply by 4
1945-DA BC 06       3481 ( 6+)         JP      C,OVERR         ; Overflow - ?OV Error
1948-47             3482 (  4)         LD      B,A             ; Re-save exponent
1949-CD 0E 17       3483 ( 16)         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
194C-21 2C 23       3484 (  9)         LD      HL,FPEXP        ; Point to exponent
194F-34             3485 ( 10)         INC     (HL)            ; Double number (Times 10)
1950-C0             3486 ( 5+)         RET     NZ              ; Ok - Return
1951-C3 BC 06       3487 (  9)         JP      OVERR           ; Overflow error
1954-               3488
1954-3A 2C 23       3489 ( 12) TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
1957-B7             3490 (  4)         OR      A
1958-C8             3491 ( 5+)         RET     Z               ; RETurn if number is zero
1959-3A 2B 23       3492 ( 12)         LD      A,(FPREG+2)     ; Get MSB of FPREG
195C-FE             3493               .DB      0FEH            ; Test sign
195D-2F             3494 (  3) RETREL: CPL                     ; Invert sign
195E-17             3495 (  3)         RLA                     ; Sign bit to carry
195F-9F             3496 (  4) FLGDIF: SBC     A,A             ; Carry to all bits of A
1960-C0             3497 ( 5+)         RET     NZ              ; Return -1 if negative
1961-3C             3498 (  4)         INC     A               ; Bump to +1
1962-C9             3499 (  9)         RET                     ; Positive - Return +1
1963-               3500
1963-CD 54 19       3501 ( 16) SGN:    CALL    TSTSGN          ; Test sign of FPREG
1966-06 88          3502 (  6) FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
1968-11 00 00       3503 (  9)         LD      DE,0            ; Zero NMSB and LSB
196B-21 2C 23       3504 (  9) RETINT: LD      HL,FPEXP        ; Point to exponent
196E-4F             3505 (  4)         LD      C,A             ; CDE = MSB,NMSB and LSB
196F-70             3506 (  7)         LD      (HL),B          ; Save exponent
1970-06 00          3507 (  6)         LD      B,0             ; CDE = integer to normalise
1972-23             3508 (  4)         INC     HL              ; Point to sign of result
1973-36 80          3509 (  9)         LD      (HL),80H        ; Set sign of result
1975-17             3510 (  3)         RLA                     ; Carry = sign of integer
1976-C3 5C 17       3511 (  9)         JP      CONPOS          ; Set sign of result
1979-               3512
1979-CD 54 19       3513 ( 16) ABS:    CALL    TSTSGN          ; Test sign of FPREG
197C-F0             3514 ( 5+)         RET     P               ; Return if positive
197D-21 2B 23       3515 (  9) INVSGN: LD      HL,FPREG+2      ; Point to MSB
1980-7E             3516 (  6)         LD      A,(HL)          ; Get sign of mantissa
1981-EE 80          3517 (  6)         XOR     80H             ; Invert sign of mantissa
1983-77             3518 (  7)         LD      (HL),A          ; Re-save sign of mantissa
1984-C9             3519 (  9)         RET
1985-               3520
1985-EB             3521 (  3) STAKFP: EX      DE,HL           ; Save code string address
1986-2A 29 23       3522 ( 15)         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
1989-E3             3523 ( 16)         EX      (SP),HL         ; Stack them,get return
198A-E5             3524 ( 11)         PUSH    HL              ; Re-save return
198B-2A 2B 23       3525 ( 15)         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
198E-E3             3526 ( 16)         EX      (SP),HL         ; Stack them,get return
198F-E5             3527 ( 11)         PUSH    HL              ; Re-save return
1990-EB             3528 (  3)         EX      DE,HL           ; Restore code string address
1991-C9             3529 (  9)         RET
1992-               3530
1992-CD A3 19       3531 ( 16) PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
1995-EB             3532 (  3) FPBCDE: EX      DE,HL           ; Save code string address
1996-22 29 23       3533 ( 20)         LD      (FPREG),HL      ; Save LSB,NLSB of number
1999-60             3534 (  4)         LD      H,B             ; Exponent of number
199A-69             3535 (  4)         LD      L,C             ; MSB of number
199B-22 2B 23       3536 ( 20)         LD      (FPREG+2),HL    ; Save MSB and exponent
199E-EB             3537 (  3)         EX      DE,HL           ; Restore code string address
199F-C9             3538 (  9)         RET
19A0-               3539
19A0-21 29 23       3540 (  9) BCDEFP: LD      HL,FPREG        ; Point to FPREG
19A3-5E             3541 (  6) LOADFP: LD      E,(HL)          ; Get LSB of number
19A4-23             3542 (  4)         INC     HL
19A5-56             3543 (  6)         LD      D,(HL)          ; Get NMSB of number
19A6-23             3544 (  4)         INC     HL
19A7-4E             3545 (  6)         LD      C,(HL)          ; Get MSB of number
19A8-23             3546 (  4)         INC     HL
19A9-46             3547 (  6)         LD      B,(HL)          ; Get exponent of number
19AA-23             3548 (  4) INCHL:  INC     HL              ; Used for conditional "INC HL"
19AB-C9             3549 (  9)         RET
19AC-               3550
19AC-11 29 23       3551 (  9) FPTHL:  LD      DE,FPREG        ; Point to FPREG
19AF-06 04          3552 (  6) DETHL4: LD      B,4             ; 4 bytes to move
19B1-1A             3553 (  6) DETHLB: LD      A,(DE)          ; Get source
19B2-77             3554 (  7)         LD      (HL),A          ; Save destination
19B3-13             3555 (  4)         INC     DE              ; Next source
19B4-23             3556 (  4)         INC     HL              ; Next destination
19B5-05             3557 (  4)         DEC     B               ; Count bytes
19B6-C2 B1 19       3558 ( 6+)         JP      NZ,DETHLB       ; Loop if more
19B9-C9             3559 (  9)         RET
19BA-               3560
19BA-21 2B 23       3561 (  9) SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
19BD-7E             3562 (  6)         LD      A,(HL)          ; Get MSB
19BE-07             3563 (  3)         RLCA                    ; Old sign to carry
19BF-37             3564 (  3)         SCF                     ; Set MSBit
19C0-1F             3565 (  3)         RRA                     ; Set MSBit of MSB
19C1-77             3566 (  7)         LD      (HL),A          ; Save new MSB
19C2-3F             3567 (  3)         CCF                     ; Complement sign
19C3-1F             3568 (  3)         RRA                     ; Old sign to carry
19C4-23             3569 (  4)         INC     HL
19C5-23             3570 (  4)         INC     HL
19C6-77             3571 (  7)         LD      (HL),A          ; Set sign of result
19C7-79             3572 (  4)         LD      A,C             ; Get MSB
19C8-07             3573 (  3)         RLCA                    ; Old sign to carry
19C9-37             3574 (  3)         SCF                     ; Set MSBit
19CA-1F             3575 (  3)         RRA                     ; Set MSBit of MSB
19CB-4F             3576 (  4)         LD      C,A             ; Save MSB
19CC-1F             3577 (  3)         RRA
19CD-AE             3578 (  6)         XOR     (HL)            ; New sign of result
19CE-C9             3579 (  9)         RET
19CF-               3580
19CF-78             3581 (  4) CMPNUM: LD      A,B             ; Get exponent of number
19D0-B7             3582 (  4)         OR      A
19D1-CA 54 19       3583 ( 6+)         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
19D4-21 5D 19       3584 (  9)         LD      HL,RETREL       ; Return relation routine
19D7-E5             3585 ( 11)         PUSH    HL              ; Save for return
19D8-CD 54 19       3586 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
19DB-79             3587 (  4)         LD      A,C             ; Get MSB of number
19DC-C8             3588 ( 5+)         RET     Z               ; FPREG zero - Number's MSB
19DD-21 2B 23       3589 (  9)         LD      HL,FPREG+2      ; MSB of FPREG
19E0-AE             3590 (  6)         XOR     (HL)            ; Combine signs
19E1-79             3591 (  4)         LD      A,C             ; Get MSB of number
19E2-F8             3592 ( 5+)         RET     M               ; Exit if signs different
19E3-CD E9 19       3593 ( 16)         CALL    CMPFP           ; Compare FP numbers
19E6-1F             3594 (  3)         RRA                     ; Get carry to sign
19E7-A9             3595 (  4)         XOR     C               ; Combine with MSB of number
19E8-C9             3596 (  9)         RET
19E9-               3597
19E9-23             3598 (  4) CMPFP:  INC     HL              ; Point to exponent
19EA-78             3599 (  4)         LD      A,B             ; Get exponent
19EB-BE             3600 (  6)         CP      (HL)            ; Compare exponents
19EC-C0             3601 ( 5+)         RET     NZ              ; Different
19ED-2B             3602 (  4)         DEC     HL              ; Point to MBS
19EE-79             3603 (  4)         LD      A,C             ; Get MSB
19EF-BE             3604 (  6)         CP      (HL)            ; Compare MSBs
19F0-C0             3605 ( 5+)         RET     NZ              ; Different
19F1-2B             3606 (  4)         DEC     HL              ; Point to NMSB
19F2-7A             3607 (  4)         LD      A,D             ; Get NMSB
19F3-BE             3608 (  6)         CP      (HL)            ; Compare NMSBs
19F4-C0             3609 ( 5+)         RET     NZ              ; Different
19F5-2B             3610 (  4)         DEC     HL              ; Point to LSB
19F6-7B             3611 (  4)         LD      A,E             ; Get LSB
19F7-96             3612 (  6)         SUB     (HL)            ; Compare LSBs
19F8-C0             3613 ( 5+)         RET     NZ              ; Different
19F9-E1             3614 (  9)         POP     HL              ; Drop RETurn
19FA-E1             3615 (  9)         POP     HL              ; Drop another RETurn
19FB-C9             3616 (  9)         RET
19FC-               3617
19FC-47             3618 (  4) FPINT:  LD      B,A             ; <- Move
19FD-4F             3619 (  4)         LD      C,A             ; <- exponent
19FE-57             3620 (  4)         LD      D,A             ; <- to all
19FF-5F             3621 (  4)         LD      E,A             ; <- bits
1A00-B7             3622 (  4)         OR      A               ; Test exponent
1A01-C8             3623 ( 5+)         RET     Z               ; Zero - Return zero
1A02-E5             3624 ( 11)         PUSH    HL              ; Save pointer to number
1A03-CD A0 19       3625 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1A06-CD BA 19       3626 ( 16)         CALL    SIGNS           ; Set MSBs & sign of result
1A09-AE             3627 (  6)         XOR     (HL)            ; Combine with sign of FPREG
1A0A-67             3628 (  4)         LD      H,A             ; Save combined signs
1A0B-FC 20 1A       3629 ( 6+)         CALL    M,DCBCDE        ; Negative - Decrement BCDE
1A0E-3E 98          3630 (  6)         LD      A,80H+24        ; 24 bits
1A10-90             3631 (  4)         SUB     B               ; Bits to shift
1A11-CD D3 17       3632 ( 16)         CALL    SCALE           ; Shift BCDE
1A14-7C             3633 (  4)         LD      A,H             ; Get combined sign
1A15-17             3634 (  3)         RLA                     ; Sign to carry
1A16-DC A6 17       3635 ( 6+)         CALL    C,FPROND        ; Negative - Round number up
1A19-06 00          3636 (  6)         LD      B,0             ; Zero exponent
1A1B-DC BF 17       3637 ( 6+)         CALL    C,COMPL         ; If negative make positive
1A1E-E1             3638 (  9)         POP     HL              ; Restore pointer to number
1A1F-C9             3639 (  9)         RET
1A20-               3640
1A20-1B             3641 (  4) DCBCDE: DEC     DE              ; Decrement BCDE
1A21-7A             3642 (  4)         LD      A,D             ; Test LSBs
1A22-A3             3643 (  4)         AND     E
1A23-3C             3644 (  4)         INC     A
1A24-C0             3645 ( 5+)         RET     NZ              ; Exit if LSBs not FFFF
1A25-0B             3646 (  4)         DEC     BC              ; Decrement MSBs
1A26-C9             3647 (  9)         RET
1A27-               3648
1A27-21 2C 23       3649 (  9) INT:    LD      HL,FPEXP        ; Point to exponent
1A2A-7E             3650 (  6)         LD      A,(HL)          ; Get exponent
1A2B-FE 98          3651 (  6)         CP      80H+24          ; Integer accuracy only?
1A2D-3A 29 23       3652 ( 12)         LD      A,(FPREG)       ; Get LSB
1A30-D0             3653 ( 5+)         RET     NC              ; Yes - Already integer
1A31-7E             3654 (  6)         LD      A,(HL)          ; Get exponent
1A32-CD FC 19       3655 ( 16)         CALL    FPINT           ; F.P to integer
1A35-36 98          3656 (  9)         LD      (HL),80H+24     ; Save 24 bit integer
1A37-7B             3657 (  4)         LD      A,E             ; Get LSB of number
1A38-F5             3658 ( 11)         PUSH    AF              ; Save LSB
1A39-79             3659 (  4)         LD      A,C             ; Get MSB of number
1A3A-17             3660 (  3)         RLA                     ; Sign to carry
1A3B-CD 5C 17       3661 ( 16)         CALL    CONPOS          ; Set sign of result
1A3E-F1             3662 (  9)         POP     AF              ; Restore LSB of number
1A3F-C9             3663 (  9)         RET
1A40-               3664
1A40-21 00 00       3665 (  9) MLDEBC: LD      HL,0            ; Clear partial product
1A43-78             3666 (  4)         LD      A,B             ; Test multiplier
1A44-B1             3667 (  4)         OR      C
1A45-C8             3668 ( 5+)         RET     Z               ; Return zero if zero
1A46-3E 10          3669 (  6)         LD      A,16            ; 16 bits
1A48-29             3670 (  7) MLDBLP: ADD     HL,HL           ; Shift P.P left
1A49-DA 80 12       3671 ( 6+)         JP      C,BSERR         ; ?BS Error if overflow
1A4C-EB             3672 (  3)         EX      DE,HL
1A4D-29             3673 (  7)         ADD     HL,HL           ; Shift multiplier left
1A4E-EB             3674 (  3)         EX      DE,HL
1A4F-D2 56 1A       3675 ( 6+)         JP      NC,NOMLAD       ; Bit was zero - No add
1A52-09             3676 (  7)         ADD     HL,BC           ; Add multiplicand
1A53-DA 80 12       3677 ( 6+)         JP      C,BSERR         ; ?BS Error if overflow
1A56-3D             3678 (  4) NOMLAD: DEC     A               ; Count bits
1A57-C2 48 1A       3679 ( 6+)         JP      NZ,MLDBLP       ; More
1A5A-C9             3680 (  9)         RET
1A5B-               3681
1A5B-FE 2D          3682 (  6) ASCTFP: CP      '-'             ; Negative?
1A5D-F5             3683 ( 11)         PUSH    AF              ; Save it and flags
1A5E-CA 67 1A       3684 ( 6+)         JP      Z,CNVNUM        ; Yes - Convert number
1A61-FE 2B          3685 (  6)         CP      '+'             ; Positive?
1A63-CA 67 1A       3686 ( 6+)         JP      Z,CNVNUM        ; Yes - Convert number
1A66-2B             3687 (  4)         DEC     HL              ; DEC 'cos GETCHR INCs
1A67-CD 74 17       3688 ( 16) CNVNUM: CALL    RESZER          ; Set result to zero
1A6A-47             3689 (  4)         LD      B,A             ; Digits after point counter
1A6B-57             3690 (  4)         LD      D,A             ; Sign of exponent
1A6C-5F             3691 (  4)         LD      E,A             ; Exponent of ten
1A6D-2F             3692 (  3)         CPL
1A6E-4F             3693 (  4)         LD      C,A             ; Before or after point flag
1A6F-CD 05 0B       3694 ( 16) MANLP:  CALL    GETCHR          ; Get next character
1A72-DA B8 1A       3695 ( 6+)         JP      C,ADDIG         ; Digit - Add to number
1A75-FE 2E          3696 (  6)         CP      '.'
1A77-CA 93 1A       3697 ( 6+)         JP      Z,DPOINT        ; '.' - Flag point
1A7A-FE 45          3698 (  6)         CP      'E'
1A7C-C2 97 1A       3699 ( 6+)         JP      NZ,CONEXP       ; Not 'E' - Scale number
1A7F-CD 05 0B       3700 ( 16)         CALL    GETCHR          ; Get next character
1A82-CD AB 10       3701 ( 16)         CALL    SGNEXP          ; Get sign of exponent
1A85-CD 05 0B       3702 ( 16) EXPLP:  CALL    GETCHR          ; Get next character
1A88-DA DA 1A       3703 ( 6+)         JP      C,EDIGIT        ; Digit - Add to exponent
1A8B-14             3704 (  4)         INC     D               ; Is sign negative?
1A8C-C2 97 1A       3705 ( 6+)         JP      NZ,CONEXP       ; No - Scale number
1A8F-AF             3706 (  4)         XOR     A
1A90-93             3707 (  4)         SUB     E               ; Negate exponent
1A91-5F             3708 (  4)         LD      E,A             ; And re-save it
1A92-0C             3709 (  4)         INC     C               ; Flag end of number
1A93-0C             3710 (  4) DPOINT: INC     C               ; Flag point passed
1A94-CA 6F 1A       3711 ( 6+)         JP      Z,MANLP         ; Zero - Get another digit
1A97-E5             3712 ( 11) CONEXP: PUSH    HL              ; Save code string address
1A98-7B             3713 (  4)         LD      A,E             ; Get exponent
1A99-90             3714 (  4)         SUB     B               ; Subtract digits after point
1A9A-F4 B0 1A       3715 ( 6+) SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
1A9D-F2 A6 1A       3716 ( 6+)         JP      P,ENDCON        ; Positive - All done
1AA0-F5             3717 ( 11)         PUSH    AF              ; Save number of times to /10
1AA1-CD 9C 18       3718 ( 16)         CALL    DIV10           ; Divide by 10
1AA4-F1             3719 (  9)         POP     AF              ; Restore count
1AA5-3C             3720 (  4)         INC     A               ; Count divides
1AA6-               3721
1AA6-C2 9A 1A       3722 ( 6+) ENDCON: JP      NZ,SCALMI       ; More to do
1AA9-D1             3723 (  9)         POP     DE              ; Restore code string address
1AAA-F1             3724 (  9)         POP     AF              ; Restore sign of number
1AAB-CC 7D 19       3725 ( 6+)         CALL    Z,INVSGN        ; Negative - Negate number
1AAE-EB             3726 (  3)         EX      DE,HL           ; Code string address to HL
1AAF-C9             3727 (  9)         RET
1AB0-               3728
1AB0-C8             3729 ( 5+) SCALPL: RET     Z               ; Exit if no scaling needed
1AB1-F5             3730 ( 11) MULTEN: PUSH    AF              ; Save count
1AB2-CD 3D 19       3731 ( 16)         CALL    MLSP10          ; Multiply number by 10
1AB5-F1             3732 (  9)         POP     AF              ; Restore count
1AB6-3D             3733 (  4)         DEC     A               ; Count multiplies
1AB7-C9             3734 (  9)         RET
1AB8-               3735
1AB8-D5             3736 ( 11) ADDIG:  PUSH    DE              ; Save sign of exponent
1AB9-57             3737 (  4)         LD      D,A             ; Save digit
1ABA-78             3738 (  4)         LD      A,B             ; Get digits after point
1ABB-89             3739 (  4)         ADC     A,C             ; Add one if after point
1ABC-47             3740 (  4)         LD      B,A             ; Re-save counter
1ABD-C5             3741 ( 11)         PUSH    BC              ; Save point flags
1ABE-E5             3742 ( 11)         PUSH    HL              ; Save code string address
1ABF-D5             3743 ( 11)         PUSH    DE              ; Save digit
1AC0-CD 3D 19       3744 ( 16)         CALL    MLSP10          ; Multiply number by 10
1AC3-F1             3745 (  9)         POP     AF              ; Restore digit
1AC4-D6 30          3746 (  6)         SUB     '0'             ; Make it absolute
1AC6-CD CF 1A       3747 ( 16)         CALL    RSCALE          ; Re-scale number
1AC9-E1             3748 (  9)         POP     HL              ; Restore code string address
1ACA-C1             3749 (  9)         POP     BC              ; Restore point flags
1ACB-D1             3750 (  9)         POP     DE              ; Restore sign of exponent
1ACC-C3 6F 1A       3751 (  9)         JP      MANLP           ; Get another digit
1ACF-               3752
1ACF-CD 85 19       3753 ( 16) RSCALE: CALL    STAKFP          ; Put number on stack
1AD2-CD 66 19       3754 ( 16)         CALL    FLGREL          ; Digit to add to FPREG
1AD5-C1             3755 (  9) PADD:   POP     BC              ; Restore number
1AD6-D1             3756 (  9)         POP     DE
1AD7-C3 0E 17       3757 (  9)         JP      FPADD           ; Add BCDE to FPREG and return
1ADA-               3758
1ADA-7B             3759 (  4) EDIGIT: LD      A,E             ; Get digit
1ADB-07             3760 (  3)         RLCA                    ; Times 2
1ADC-07             3761 (  3)         RLCA                    ; Times 4
1ADD-83             3762 (  4)         ADD     A,E             ; Times 5
1ADE-07             3763 (  3)         RLCA                    ; Times 10
1ADF-86             3764 (  6)         ADD     A,(HL)          ; Add next digit
1AE0-D6 30          3765 (  6)         SUB     '0'             ; Make it absolute
1AE2-5F             3766 (  4)         LD      E,A             ; Save new digit
1AE3-C3 85 1A       3767 (  9)         JP      EXPLP           ; Look for another digit
1AE6-               3768
1AE6-E5             3769 ( 11) LINEIN: PUSH    HL              ; Save code string address
1AE7-21 45 06       3770 (  9)         LD      HL,INMSG        ; Output " in "
1AEA-CD 4B 14       3771 ( 16)         CALL    PRS             ; Output string at HL
1AED-E1             3772 (  9)         POP     HL              ; Restore code string address
1AEE-EB             3773 (  3) PRNTHL: EX      DE,HL           ; Code string address to DE
1AEF-AF             3774 (  4)         XOR     A
1AF0-06 98          3775 (  6)         LD      B,80H+24        ; 24 bits
1AF2-CD 6B 19       3776 ( 16)         CALL    RETINT          ; Return the integer
1AF5-21 4A 14       3777 (  9)         LD      HL,PRNUMS       ; Print number string
1AF8-E5             3778 ( 11)         PUSH    HL              ; Save for return
1AF9-21 2E 23       3779 (  9) NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
1AFC-E5             3780 ( 11)         PUSH    HL              ; Save for return
1AFD-CD 54 19       3781 ( 16)         CALL    TSTSGN          ; Test sign of FPREG
1B00-36 20          3782 (  9)         LD      (HL),' '        ; Space at start
1B02-F2 07 1B       3783 ( 6+)         JP      P,SPCFST        ; Positive - Space to start
1B05-36 2D          3784 (  9)         LD      (HL),'-'        ; '-' sign at start
1B07-23             3785 (  4) SPCFST: INC     HL              ; First byte of number
1B08-36 30          3786 (  9)         LD      (HL),'0'        ; '0' if zero
1B0A-CA BD 1B       3787 ( 6+)         JP      Z,JSTZER        ; Return '0' if zero
1B0D-E5             3788 ( 11)         PUSH    HL              ; Save buffer address
1B0E-FC 7D 19       3789 ( 6+)         CALL    M,INVSGN        ; Negate FPREG if negative
1B11-AF             3790 (  4)         XOR     A               ; Zero A
1B12-F5             3791 ( 11)         PUSH    AF              ; Save it
1B13-CD C3 1B       3792 ( 16)         CALL    RNGTST          ; Test number is in range
1B16-01 43 91       3793 (  9) SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
1B19-11 F8 4F       3794 (  9)         LD      DE,4FF8H
1B1C-CD CF 19       3795 ( 16)         CALL    CMPNUM          ; Compare numbers
1B1F-B7             3796 (  4)         OR      A
1B20-E2 34 1B       3797 ( 6+)         JP      PO,INRNG        ; > 99999.9 - Sort it out
1B23-F1             3798 (  9)         POP     AF              ; Restore count
1B24-CD B1 1A       3799 ( 16)         CALL    MULTEN          ; Multiply by ten
1B27-F5             3800 ( 11)         PUSH    AF              ; Re-save count
1B28-C3 16 1B       3801 (  9)         JP      SIXDIG          ; Test it again
1B2B-               3802
1B2B-CD 9C 18       3803 ( 16) GTSIXD: CALL    DIV10           ; Divide by 10
1B2E-F1             3804 (  9)         POP     AF              ; Get count
1B2F-3C             3805 (  4)         INC     A               ; Count divides
1B30-F5             3806 ( 11)         PUSH    AF              ; Re-save count
1B31-CD C3 1B       3807 ( 16)         CALL    RNGTST          ; Test number is in range
1B34-CD FC 16       3808 ( 16) INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
1B37-3C             3809 (  4)         INC     A
1B38-CD FC 19       3810 ( 16)         CALL    FPINT           ; F.P to integer
1B3B-CD 95 19       3811 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
1B3E-01 06 03       3812 (  9)         LD      BC,0306H        ; 1E+06 to 1E-03 range
1B41-F1             3813 (  9)         POP     AF              ; Restore count
1B42-81             3814 (  4)         ADD     A,C             ; 6 digits before point
1B43-3C             3815 (  4)         INC     A               ; Add one
1B44-FA 50 1B       3816 ( 6+)         JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
1B47-FE 08          3817 (  6)         CP      6+1+1           ; More than 999999 ?
1B49-D2 50 1B       3818 ( 6+)         JP      NC,MAKNUM       ; Yes - Do it in 'E' form
1B4C-3C             3819 (  4)         INC     A               ; Adjust for exponent
1B4D-47             3820 (  4)         LD      B,A             ; Exponent of number
1B4E-3E 02          3821 (  6)         LD      A,2             ; Make it zero after
1B50-               3822
1B50-3D             3823 (  4) MAKNUM: DEC     A               ; Adjust for digits to do
1B51-3D             3824 (  4)         DEC     A
1B52-E1             3825 (  9)         POP     HL              ; Restore buffer address
1B53-F5             3826 ( 11)         PUSH    AF              ; Save count
1B54-11 D6 1B       3827 (  9)         LD      DE,POWERS       ; Powers of ten
1B57-05             3828 (  4)         DEC     B               ; Count digits before point
1B58-C2 61 1B       3829 ( 6+)         JP      NZ,DIGTXT       ; Not zero - Do number
1B5B-36 2E          3830 (  9)         LD      (HL),'.'        ; Save point
1B5D-23             3831 (  4)         INC     HL              ; Move on
1B5E-36 30          3832 (  9)         LD      (HL),'0'        ; Save zero
1B60-23             3833 (  4)         INC     HL              ; Move on
1B61-05             3834 (  4) DIGTXT: DEC     B               ; Count digits before point
1B62-36 2E          3835 (  9)         LD      (HL),'.'        ; Save point in case
1B64-CC AA 19       3836 ( 6+)         CALL    Z,INCHL         ; Last digit - move on
1B67-C5             3837 ( 11)         PUSH    BC              ; Save digits before point
1B68-E5             3838 ( 11)         PUSH    HL              ; Save buffer address
1B69-D5             3839 ( 11)         PUSH    DE              ; Save powers of ten
1B6A-CD A0 19       3840 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1B6D-E1             3841 (  9)         POP     HL              ; Powers of ten table
1B6E-06 2F          3842 (  6)         LD      B, '0'-1        ; ASCII '0' - 1
1B70-04             3843 (  4) TRYAGN: INC     B               ; Count subtractions
1B71-7B             3844 (  4)         LD      A,E             ; Get LSB
1B72-96             3845 (  6)         SUB     (HL)            ; Subtract LSB
1B73-5F             3846 (  4)         LD      E,A             ; Save LSB
1B74-23             3847 (  4)         INC     HL
1B75-7A             3848 (  4)         LD      A,D             ; Get NMSB
1B76-9E             3849 (  6)         SBC     A,(HL)          ; Subtract NMSB
1B77-57             3850 (  4)         LD      D,A             ; Save NMSB
1B78-23             3851 (  4)         INC     HL
1B79-79             3852 (  4)         LD      A,C             ; Get MSB
1B7A-9E             3853 (  6)         SBC     A,(HL)          ; Subtract MSB
1B7B-4F             3854 (  4)         LD      C,A             ; Save MSB
1B7C-2B             3855 (  4)         DEC     HL              ; Point back to start
1B7D-2B             3856 (  4)         DEC     HL
1B7E-D2 70 1B       3857 ( 6+)         JP      NC,TRYAGN       ; No overflow - Try again
1B81-CD B3 17       3858 ( 16)         CALL    PLUCDE          ; Restore number
1B84-23             3859 (  4)         INC     HL              ; Start of next number
1B85-CD 95 19       3860 ( 16)         CALL    FPBCDE          ; Move BCDE to FPREG
1B88-EB             3861 (  3)         EX      DE,HL           ; Save point in table
1B89-E1             3862 (  9)         POP     HL              ; Restore buffer address
1B8A-70             3863 (  7)         LD      (HL),B          ; Save digit in buffer
1B8B-23             3864 (  4)         INC     HL              ; And move on
1B8C-C1             3865 (  9)         POP     BC              ; Restore digit count
1B8D-0D             3866 (  4)         DEC     C               ; Count digits
1B8E-C2 61 1B       3867 ( 6+)         JP      NZ,DIGTXT       ; More - Do them
1B91-05             3868 (  4)         DEC     B               ; Any decimal part?
1B92-CA A1 1B       3869 ( 6+)         JP      Z,DOEBIT        ; No - Do 'E' bit
1B95-2B             3870 (  4) SUPTLZ: DEC     HL              ; Move back through buffer
1B96-7E             3871 (  6)         LD      A,(HL)          ; Get character
1B97-FE 30          3872 (  6)         CP      '0'             ; '0' character?
1B99-CA 95 1B       3873 ( 6+)         JP      Z,SUPTLZ        ; Yes - Look back for more
1B9C-FE 2E          3874 (  6)         CP      '.'             ; A decimal point?
1B9E-C4 AA 19       3875 ( 6+)         CALL    NZ,INCHL        ; Move back over digit
1BA1-               3876
1BA1-F1             3877 (  9) DOEBIT: POP     AF              ; Get 'E' flag
1BA2-CA C0 1B       3878 ( 6+)         JP      Z,NOENED        ; No 'E' needed - End buffer
1BA5-36 45          3879 (  9)         LD      (HL),'E'        ; Put 'E' in buffer
1BA7-23             3880 (  4)         INC     HL              ; And move on
1BA8-36 2B          3881 (  9)         LD      (HL),'+'        ; Put '+' in buffer
1BAA-F2 B1 1B       3882 ( 6+)         JP      P,OUTEXP        ; Positive - Output exponent
1BAD-36 2D          3883 (  9)         LD      (HL),'-'        ; Put '-' in buffer
1BAF-2F             3884 (  3)         CPL                     ; Negate exponent
1BB0-3C             3885 (  4)         INC     A
1BB1-06 2F          3886 (  6) OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
1BB3-04             3887 (  4) EXPTEN: INC     B               ; Count subtractions
1BB4-D6 0A          3888 (  6)         SUB     10              ; Tens digit
1BB6-D2 B3 1B       3889 ( 6+)         JP      NC,EXPTEN       ; More to do
1BB9-C6 3A          3890 (  6)         ADD     A,'0'+10        ; Restore and make ASCII
1BBB-23             3891 (  4)         INC     HL              ; Move on
1BBC-70             3892 (  7)         LD      (HL),B          ; Save MSB of exponent
1BBD-23             3893 (  4) JSTZER: INC     HL              ;
1BBE-77             3894 (  7)         LD      (HL),A          ; Save LSB of exponent
1BBF-23             3895 (  4)         INC     HL
1BC0-71             3896 (  7) NOENED: LD      (HL),C          ; Mark end of buffer
1BC1-E1             3897 (  9)         POP     HL              ; Restore code string address
1BC2-C9             3898 (  9)         RET
1BC3-               3899
1BC3-01 74 94       3900 (  9) RNGTST: LD      BC,9474H        ; BCDE = 999999.
1BC6-11 F7 23       3901 (  9)         LD      DE,23F7H
1BC9-CD CF 19       3902 ( 16)         CALL    CMPNUM          ; Compare numbers
1BCC-B7             3903 (  4)         OR      A
1BCD-E1             3904 (  9)         POP     HL              ; Return address to HL
1BCE-E2 2B 1B       3905 ( 6+)         JP      PO,GTSIXD       ; Too big - Divide by ten
1BD1-E9             3906 (  3)         JP      (HL)            ; Otherwise return to caller
1BD2-               3907
1BD2-00 00 00 80    3908       HALF:   .DB      00H,00H,00H,80H ; 0.5
1BD6-               3909
1BD6-A0 86 01       3910       POWERS: .DB      0A0H,086H,001H  ; 100000
1BD9-10 27 00       3911               .DB      010H,027H,000H  ;  10000
1BDC-E8 03 00       3912               .DB      0E8H,003H,000H  ;   1000
1BDF-64 00 00       3913               .DB      064H,000H,000H  ;    100
1BE2-0A 00 00       3914               .DB      00AH,000H,000H  ;     10
1BE5-01 00 00       3915               .DB      001H,000H,000H  ;      1
1BE8-               3916
1BE8-21 7D 19       3917 (  9) NEGAFT: LD  HL,INVSGN           ; Negate result
1BEB-E3             3918 ( 16)         EX      (SP),HL         ; To be done after caller
1BEC-E9             3919 (  3)         JP      (HL)            ; Return to caller
1BED-               3920
1BED-CD 85 19       3921 ( 16) SQR:    CALL    STAKFP          ; Put value on stack
1BF0-21 D2 1B       3922 (  9)         LD      HL,HALF         ; Set power to 1/2
1BF3-CD 92 19       3923 ( 16)         CALL    PHLTFP          ; Move 1/2 to FPREG
1BF6-               3924
1BF6-C1             3925 (  9) POWER:  POP     BC              ; Get base
1BF7-D1             3926 (  9)         POP     DE
1BF8-CD 54 19       3927 ( 16)         CALL    TSTSGN          ; Test sign of power
1BFB-78             3928 (  4)         LD      A,B             ; Get exponent of base
1BFC-CA 3B 1C       3929 ( 6+)         JP      Z,EXP           ; Make result 1 if zero
1BFF-F2 06 1C       3930 ( 6+)         JP      P,POWER1        ; Positive base - Ok
1C02-B7             3931 (  4)         OR      A               ; Zero to negative power?
1C03-CA B0 06       3932 ( 6+)         JP      Z,DZERR         ; Yes - ?/0 Error
1C06-B7             3933 (  4) POWER1: OR      A               ; Base zero?
1C07-CA 75 17       3934 ( 6+)         JP      Z,SAVEXP        ; Yes - Return zero
1C0A-D5             3935 ( 11)         PUSH    DE              ; Save base
1C0B-C5             3936 ( 11)         PUSH    BC
1C0C-79             3937 (  4)         LD      A,C             ; Get MSB of base
1C0D-F6 7F          3938 (  6)         OR      01111111B       ; Get sign status
1C0F-CD A0 19       3939 ( 16)         CALL    BCDEFP          ; Move power to BCDE
1C12-F2 23 1C       3940 ( 6+)         JP      P,POWER2        ; Positive base - Ok
1C15-D5             3941 ( 11)         PUSH    DE              ; Save power
1C16-C5             3942 ( 11)         PUSH    BC
1C17-CD 27 1A       3943 ( 16)         CALL    INT             ; Get integer of power
1C1A-C1             3944 (  9)         POP     BC              ; Restore power
1C1B-D1             3945 (  9)         POP     DE
1C1C-F5             3946 ( 11)         PUSH    AF              ; MSB of base
1C1D-CD CF 19       3947 ( 16)         CALL    CMPNUM          ; Power an integer?
1C20-E1             3948 (  9)         POP     HL              ; Restore MSB of base
1C21-7C             3949 (  4)         LD      A,H             ; but don't affect flags
1C22-1F             3950 (  3)         RRA                     ; Exponent odd or even?
1C23-E1             3951 (  9) POWER2: POP     HL              ; Restore MSB and exponent
1C24-22 2B 23       3952 ( 20)         LD      (FPREG+2),HL    ; Save base in FPREG
1C27-E1             3953 (  9)         POP     HL              ; LSBs of base
1C28-22 29 23       3954 ( 20)         LD      (FPREG),HL      ; Save in FPREG
1C2B-DC E8 1B       3955 ( 6+)         CALL    C,NEGAFT        ; Odd power - Negate result
1C2E-CC 7D 19       3956 ( 6+)         CALL    Z,INVSGN        ; Negative base - Negate it
1C31-D5             3957 ( 11)         PUSH    DE              ; Save power
1C32-C5             3958 ( 11)         PUSH    BC
1C33-CD 08 18       3959 ( 16)         CALL    LOG             ; Get LOG of base
1C36-C1             3960 (  9)         POP     BC              ; Restore power
1C37-D1             3961 (  9)         POP     DE
1C38-CD 49 18       3962 ( 16)         CALL    FPMULT          ; Multiply LOG by power
1C3B-               3963
1C3B-CD 85 19       3964 ( 16) EXP:    CALL    STAKFP          ; Put value on stack
1C3E-01 38 81       3965 (  9)         LD      BC,08138H       ; BCDE = 1/Ln(2)
1C41-11 3B AA       3966 (  9)         LD      DE,0AA3BH
1C44-CD 49 18       3967 ( 16)         CALL    FPMULT          ; Multiply value by 1/LN(2)
1C47-3A 2C 23       3968 ( 12)         LD      A,(FPEXP)       ; Get exponent
1C4A-FE 88          3969 (  6)         CP      80H+8           ; Is it in range?
1C4C-D2 30 19       3970 ( 6+)         JP      NC,OVTST1       ; No - Test for overflow
1C4F-CD 27 1A       3971 ( 16)         CALL    INT             ; Get INT of FPREG
1C52-C6 80          3972 (  6)         ADD     A,80H           ; For excess 128
1C54-C6 02          3973 (  6)         ADD     A,2             ; Exponent > 126?
1C56-DA 30 19       3974 ( 6+)         JP      C,OVTST1        ; Yes - Test for overflow
1C59-F5             3975 ( 11)         PUSH    AF              ; Save scaling factor
1C5A-21 F7 17       3976 (  9)         LD      HL,UNITY        ; Point to 1.
1C5D-CD FF 16       3977 ( 16)         CALL    ADDPHL          ; Add 1 to FPREG
1C60-CD 40 18       3978 ( 16)         CALL    MULLN2          ; Multiply by LN(2)
1C63-F1             3979 (  9)         POP     AF              ; Restore scaling factor
1C64-C1             3980 (  9)         POP     BC              ; Restore exponent
1C65-D1             3981 (  9)         POP     DE
1C66-F5             3982 ( 11)         PUSH    AF              ; Save scaling factor
1C67-CD 0B 17       3983 ( 16)         CALL    SUBCDE          ; Subtract exponent from FPREG
1C6A-CD 7D 19       3984 ( 16)         CALL    INVSGN          ; Negate result
1C6D-21 7B 1C       3985 (  9)         LD      HL,EXPTAB       ; Coefficient table
1C70-CD AB 1C       3986 ( 16)         CALL    SMSER1          ; Sum the series
1C73-11 00 00       3987 (  9)         LD      DE,0            ; Zero LSBs
1C76-C1             3988 (  9)         POP     BC              ; Scaling factor
1C77-4A             3989 (  4)         LD      C,D             ; Zero MSB
1C78-C3 49 18       3990 (  9)         JP      FPMULT          ; Scale result to correct value
1C7B-               3991
1C7B-08             3992       EXPTAB: .DB      8                       ; Table used by EXP
1C7C-40 2E 94 74    3993               .DB      040H,02EH,094H,074H     ; -1/7! (-1/5040)
1C80-70 4F 2E 77    3994               .DB      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
1C84-6E 02 88 7A    3995               .DB      06EH,002H,088H,07AH     ; -1/5! (-1/120)
1C88-E6 A0 2A 7C    3996               .DB      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
1C8C-50 AA AA 7E    3997               .DB      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
1C90-FF FF 7F 7F    3998               .DB      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
1C94-00 00 80 81    3999               .DB      000H,000H,080H,081H     ; -1/1! (-1/1)
1C98-00 00 00 81    4000               .DB      000H,000H,000H,081H     ;  1/0! ( 1/1)
1C9C-               4001
1C9C-CD 85 19       4002 ( 16) SUMSER: CALL    STAKFP          ; Put FPREG on stack
1C9F-11 47 18       4003 (  9)         LD      DE,MULT         ; Multiply by "X"
1CA2-D5             4004 ( 11)         PUSH    DE              ; To be done after
1CA3-E5             4005 ( 11)         PUSH    HL              ; Save address of table
1CA4-CD A0 19       4006 ( 16)         CALL    BCDEFP          ; Move FPREG to BCDE
1CA7-CD 49 18       4007 ( 16)         CALL    FPMULT          ; Square the value
1CAA-E1             4008 (  9)         POP     HL              ; Restore address of table
1CAB-CD 85 19       4009 ( 16) SMSER1: CALL    STAKFP          ; Put value on stack
1CAE-7E             4010 (  6)         LD      A,(HL)          ; Get number of coefficients
1CAF-23             4011 (  4)         INC     HL              ; Point to start of table
1CB0-CD 92 19       4012 ( 16)         CALL    PHLTFP          ; Move coefficient to FPREG
1CB3-06             4013               .DB      06H             ; Skip "POP AF"
1CB4-F1             4014 (  9) SUMLP:  POP     AF              ; Restore count
1CB5-C1             4015 (  9)         POP     BC              ; Restore number
1CB6-D1             4016 (  9)         POP     DE
1CB7-3D             4017 (  4)         DEC     A               ; Cont coefficients
1CB8-C8             4018 ( 5+)         RET     Z               ; All done
1CB9-D5             4019 ( 11)         PUSH    DE              ; Save number
1CBA-C5             4020 ( 11)         PUSH    BC
1CBB-F5             4021 ( 11)         PUSH    AF              ; Save count
1CBC-E5             4022 ( 11)         PUSH    HL              ; Save address in table
1CBD-CD 49 18       4023 ( 16)         CALL    FPMULT          ; Multiply FPREG by BCDE
1CC0-E1             4024 (  9)         POP     HL              ; Restore address in table
1CC1-CD A3 19       4025 ( 16)         CALL    LOADFP          ; Number at HL to BCDE
1CC4-E5             4026 ( 11)         PUSH    HL              ; Save address in table
1CC5-CD 0E 17       4027 ( 16)         CALL    FPADD           ; Add coefficient to FPREG
1CC8-E1             4028 (  9)         POP     HL              ; Restore address in table
1CC9-C3 B4 1C       4029 (  9)         JP      SUMLP           ; More coefficients
1CCC-               4030
1CCC-CD 54 19       4031 ( 16) RND:    CALL    TSTSGN          ; Test sign of FPREG
1CCF-21 5E 22       4032 (  9)         LD      HL,SEED+2       ; Random number seed
1CD2-FA 2D 1D       4033 ( 6+)         JP      M,RESEED        ; Negative - Re-seed
1CD5-21 7F 22       4034 (  9)         LD      HL,LSTRND       ; Last random number
1CD8-CD 92 19       4035 ( 16)         CALL    PHLTFP          ; Move last RND to FPREG
1CDB-21 5E 22       4036 (  9)         LD      HL,SEED+2       ; Random number seed
1CDE-C8             4037 ( 5+)         RET     Z               ; Return if RND(0)
1CDF-86             4038 (  6)         ADD     A,(HL)          ; Add (SEED)+2)
1CE0-E6 07          4039 (  6)         AND     00000111B       ; 0 to 7
1CE2-06 00          4040 (  6)         LD      B,0
1CE4-77             4041 (  7)         LD      (HL),A          ; Re-save seed
1CE5-23             4042 (  4)         INC     HL              ; Move to coefficient table
1CE6-87             4043 (  4)         ADD     A,A             ; 4 bytes
1CE7-87             4044 (  4)         ADD     A,A             ; per entry
1CE8-4F             4045 (  4)         LD      C,A             ; BC = Offset into table
1CE9-09             4046 (  7)         ADD     HL,BC           ; Point to coefficient
1CEA-CD A3 19       4047 ( 16)         CALL    LOADFP          ; Coefficient to BCDE
1CED-CD 49 18       4048 ( 16)         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
1CF0-3A 5D 22       4049 ( 12)         LD      A,(SEED+1)      ; Get (SEED+1)
1CF3-3C             4050 (  4)         INC     A               ; Add 1
1CF4-E6 03          4051 (  6)         AND     00000011B       ; 0 to 3
1CF6-06 00          4052 (  6)         LD      B,0
1CF8-FE 01          4053 (  6)         CP      1               ; Is it zero?
1CFA-88             4054 (  4)         ADC     A,B             ; Yes - Make it 1
1CFB-32 5D 22       4055 ( 13)         LD      (SEED+1),A      ; Re-save seed
1CFE-21 31 1D       4056 (  9)         LD      HL,RNDTAB-4     ; Addition table
1D01-87             4057 (  4)         ADD     A,A             ; 4 bytes
1D02-87             4058 (  4)         ADD     A,A             ; per entry
1D03-4F             4059 (  4)         LD      C,A             ; BC = Offset into table
1D04-09             4060 (  7)         ADD     HL,BC           ; Point to value
1D05-CD FF 16       4061 ( 16)         CALL    ADDPHL          ; Add value to FPREG
1D08-CD A0 19       4062 ( 16) RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
1D0B-7B             4063 (  4)         LD      A,E             ; Get LSB
1D0C-59             4064 (  4)         LD      E,C             ; LSB = MSB
1D0D-EE 4F          4065 (  6)         XOR     01001111B       ; Fiddle around
1D0F-4F             4066 (  4)         LD      C,A             ; New MSB
1D10-36 80          4067 (  9)         LD      (HL),80H        ; Set exponent
1D12-2B             4068 (  4)         DEC     HL              ; Point to MSB
1D13-46             4069 (  6)         LD      B,(HL)          ; Get MSB
1D14-36 80          4070 (  9)         LD      (HL),80H        ; Make value -0.5
1D16-21 5C 22       4071 (  9)         LD      HL,SEED         ; Random number seed
1D19-34             4072 ( 10)         INC     (HL)            ; Count seed
1D1A-7E             4073 (  6)         LD      A,(HL)          ; Get seed
1D1B-D6 AB          4074 (  6)         SUB     171             ; Do it modulo 171
1D1D-C2 24 1D       4075 ( 6+)         JP      NZ,RND2         ; Non-zero - Ok
1D20-77             4076 (  7)         LD      (HL),A          ; Zero seed
1D21-0C             4077 (  4)         INC     C               ; Fillde about
1D22-15             4078 (  4)         DEC     D               ; with the
1D23-1C             4079 (  4)         INC     E               ; number
1D24-CD 5F 17       4080 ( 16) RND2:   CALL    BNORM           ; Normalise number
1D27-21 7F 22       4081 (  9)         LD      HL,LSTRND       ; Save random number
1D2A-C3 AC 19       4082 (  9)         JP      FPTHL           ; Move FPREG to last and return
1D2D-               4083
1D2D-77             4084 (  7) RESEED: LD      (HL),A          ; Re-seed random numbers
1D2E-2B             4085 (  4)         DEC     HL
1D2F-77             4086 (  7)         LD      (HL),A
1D30-2B             4087 (  4)         DEC     HL
1D31-77             4088 (  7)         LD      (HL),A
1D32-C3 08 1D       4089 (  9)         JP      RND1            ; Return RND seed
1D35-               4090
1D35-68 B1 46 68    4091       RNDTAB: .DB   068H,0B1H,046H,068H     ; Table used by RND
1D39-99 E9 92 69    4092               .DB   099H,0E9H,092H,069H
1D3D-10 D1 75 68    4093               .DB   010H,0D1H,075H,068H
1D41-               4094
1D41-21 8B 1D       4095 (  9) COS:    LD      HL,HALFPI       ; Point to PI/2
1D44-CD FF 16       4096 ( 16)         CALL    ADDPHL          ; Add it to PPREG
1D47-CD 85 19       4097 ( 16) SIN:    CALL    STAKFP          ; Put angle on stack
1D4A-01 49 83       4098 (  9)         LD      BC,8349H        ; BCDE = 2 PI
1D4D-11 DB 0F       4099 (  9)         LD      DE,0FDBH
1D50-CD 95 19       4100 ( 16)         CALL    FPBCDE          ; Move 2 PI to FPREG
1D53-C1             4101 (  9)         POP     BC              ; Restore angle
1D54-D1             4102 (  9)         POP     DE
1D55-CD AA 18       4103 ( 16)         CALL    DVBCDE          ; Divide angle by 2 PI
1D58-CD 85 19       4104 ( 16)         CALL    STAKFP          ; Put it on stack
1D5B-CD 27 1A       4105 ( 16)         CALL    INT             ; Get INT of result
1D5E-C1             4106 (  9)         POP     BC              ; Restore number
1D5F-D1             4107 (  9)         POP     DE
1D60-CD 0B 17       4108 ( 16)         CALL    SUBCDE          ; Make it 0 <= value < 1
1D63-21 8F 1D       4109 (  9)         LD      HL,QUARTR       ; Point to 0.25
1D66-CD 05 17       4110 ( 16)         CALL    SUBPHL          ; Subtract value from 0.25
1D69-CD 54 19       4111 ( 16)         CALL    TSTSGN          ; Test sign of value
1D6C-37             4112 (  3)         SCF                     ; Flag positive
1D6D-F2 77 1D       4113 ( 6+)         JP      P,SIN1          ; Positive - Ok
1D70-CD FC 16       4114 ( 16)         CALL    ROUND           ; Add 0.5 to value
1D73-CD 54 19       4115 ( 16)         CALL    TSTSGN          ; Test sign of value
1D76-B7             4116 (  4)         OR      A               ; Flag negative
1D77-F5             4117 ( 11) SIN1:   PUSH    AF              ; Save sign
1D78-F4 7D 19       4118 ( 6+)         CALL    P,INVSGN        ; Negate value if positive
1D7B-21 8F 1D       4119 (  9)         LD      HL,QUARTR       ; Point to 0.25
1D7E-CD FF 16       4120 ( 16)         CALL    ADDPHL          ; Add 0.25 to value
1D81-F1             4121 (  9)         POP     AF              ; Restore sign
1D82-D4 7D 19       4122 ( 6+)         CALL    NC,INVSGN       ; Negative - Make positive
1D85-21 93 1D       4123 (  9)         LD      HL,SINTAB       ; Coefficient table
1D88-C3 9C 1C       4124 (  9)         JP      SUMSER          ; Evaluate sum of series
1D8B-               4125
1D8B-DB 0F 49 81    4126       HALFPI: .DB   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
1D8F-               4127
1D8F-00 00 00 7F    4128       QUARTR: .DB   000H,000H,000H,07FH     ; 0.25
1D93-               4129
1D93-05             4130       SINTAB: .DB   5                       ; Table used by SIN
1D94-BA D7 1E 86    4131               .DB   0BAH,0D7H,01EH,086H     ; 39.711
1D98-64 26 99 87    4132               .DB   064H,026H,099H,087H     ;-76.575
1D9C-58 34 23 87    4133               .DB   058H,034H,023H,087H     ; 81.602
1DA0-E0 5D A5 86    4134               .DB   0E0H,05DH,0A5H,086H     ;-41.342
1DA4-DA 0F 49 83    4135               .DB   0DAH,00FH,049H,083H     ;  6.2832
1DA8-               4136
1DA8-CD 85 19       4137 ( 16) TAN:    CALL    STAKFP          ; Put angle on stack
1DAB-CD 47 1D       4138 ( 16)         CALL    SIN             ; Get SIN of angle
1DAE-C1             4139 (  9)         POP     BC              ; Restore angle
1DAF-E1             4140 (  9)         POP     HL
1DB0-CD 85 19       4141 ( 16)         CALL    STAKFP          ; Save SIN of angle
1DB3-EB             4142 (  3)         EX      DE,HL           ; BCDE = Angle
1DB4-CD 95 19       4143 ( 16)         CALL    FPBCDE          ; Angle to FPREG
1DB7-CD 41 1D       4144 ( 16)         CALL    COS             ; Get COS of angle
1DBA-C3 A8 18       4145 (  9)         JP      DIV             ; TAN = SIN / COS
1DBD-               4146
1DBD-CD 54 19       4147 ( 16) ATN:    CALL    TSTSGN          ; Test sign of value
1DC0-FC E8 1B       4148 ( 6+)         CALL    M,NEGAFT        ; Negate result after if -ve
1DC3-FC 7D 19       4149 ( 6+)         CALL    M,INVSGN        ; Negate value if -ve
1DC6-3A 2C 23       4150 ( 12)         LD      A,(FPEXP)       ; Get exponent
1DC9-FE 81          4151 (  6)         CP      81H             ; Number less than 1?
1DCB-DA DA 1D       4152 ( 6+)         JP      C,ATN1          ; Yes - Get arc tangnt
1DCE-01 00 81       4153 (  9)         LD      BC,8100H        ; BCDE = 1
1DD1-51             4154 (  4)         LD      D,C
1DD2-59             4155 (  4)         LD      E,C
1DD3-CD AA 18       4156 ( 16)         CALL    DVBCDE          ; Get reciprocal of number
1DD6-21 05 17       4157 (  9)         LD      HL,SUBPHL       ; Sub angle from PI/2
1DD9-E5             4158 ( 11)         PUSH    HL              ; Save for angle > 1
1DDA-21 E4 1D       4159 (  9) ATN1:   LD      HL,ATNTAB       ; Coefficient table
1DDD-CD 9C 1C       4160 ( 16)         CALL    SUMSER          ; Evaluate sum of series
1DE0-21 8B 1D       4161 (  9)         LD      HL,HALFPI       ; PI/2 - angle in case > 1
1DE3-C9             4162 (  9)         RET                     ; Number > 1 - Sub from PI/2
1DE4-               4163
1DE4-09             4164       ATNTAB: .DB   9                       ; Table used by ATN
1DE5-4A D7 3B 78    4165               .DB   04AH,0D7H,03BH,078H     ; 1/17
1DE9-02 6E 84 7B    4166               .DB   002H,06EH,084H,07BH     ;-1/15
1DED-FE C1 2F 7C    4167               .DB   0FEH,0C1H,02FH,07CH     ; 1/13
1DF1-74 31 9A 7D    4168               .DB   074H,031H,09AH,07DH     ;-1/11
1DF5-84 3D 5A 7D    4169               .DB   084H,03DH,05AH,07DH     ; 1/9
1DF9-C8 7F 91 7E    4170               .DB   0C8H,07FH,091H,07EH     ;-1/7
1DFD-E4 BB 4C 7E    4171               .DB   0E4H,0BBH,04CH,07EH     ; 1/5
1E01-6C AA AA 7F    4172               .DB   06CH,0AAH,0AAH,07FH     ;-1/3
1E05-00 00 00 81    4173               .DB   000H,000H,000H,081H     ; 1/1
1E09-               4174
1E09-               4175
1E09-C9             4176 (  9) ARET:   RET                     ; A RETurn instruction
1E0A-               4177
1E0A-D7             4178 ( 11) GETINP: RST         10H             ;input a character
1E0B-C9             4179 (  9)         RET
1E0C-               4180
1E0C-               4181       CLS:
1E0C-3E 0C          4182 (  6)         LD      A,CS            ; ASCII Clear screen
1E0E-C3 46 1F       4183 (  9)         JP      MONOUT          ; Output character
1E11-               4184
1E11-CD D3 16       4185 ( 16) WIDTH:  CALL    GETINT          ; Get integer 0-255
1E14-7B             4186 (  4)         LD      A,E             ; Width to A
1E15-32 87 22       4187 ( 13)         LD      (LWIDTH),A      ; Set width
1E18-C9             4188 (  9)         RET
1E19-               4189
1E19-CD 72 0F       4190 ( 16) LINES:  CALL    GETNUM          ; Get a number
1E1C-CD B7 0B       4191 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1E1F-ED 53 8B 22    4192 ( 20)         LD      (LINESC),DE     ; Set lines counter
1E23-ED 53 8D 22    4193 ( 20)         LD      (LINESN),DE     ; Set lines number
1E27-C9             4194 (  9)         RET
1E28-               4195
1E28-CD B7 0B       4196 ( 16) DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
1E2B-D5             4197 ( 11)         PUSH    DE              ; Save number
1E2C-E1             4198 (  9)         POP     HL              ; Number to HL
1E2D-46             4199 (  6)         LD      B,(HL)          ; Get LSB of contents
1E2E-23             4200 (  4)         INC     HL
1E2F-7E             4201 (  6)         LD      A,(HL)          ; Get MSB of contents
1E30-C3 2D 13       4202 (  9)         JP      ABPASS          ; Return integer AB
1E33-               4203
1E33-CD 72 0F       4204 ( 16) DOKE:   CALL    GETNUM          ; Get a number
1E36-CD B7 0B       4205 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1E39-D5             4206 ( 11)         PUSH    DE              ; Save address
1E3A-CD 7B 09       4207 ( 16)         CALL    CHKSYN          ; Make sure ',' follows
1E3D-2C             4208               .DB      ','
1E3E-CD 72 0F       4209 ( 16)         CALL    GETNUM          ; Get a number
1E41-CD B7 0B       4210 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1E44-E3             4211 ( 16)         EX      (SP),HL         ; Save value,get address
1E45-73             4212 (  7)         LD      (HL),E          ; Save LSB of value
1E46-23             4213 (  4)         INC     HL
1E47-72             4214 (  7)         LD      (HL),D          ; Save MSB of value
1E48-E1             4215 (  9)         POP     HL              ; Restore code string address
1E49-C9             4216 (  9)         RET
1E4A-               4217
1E4A-               4218
1E4A-               4219       ; HEX$(nn) Convert 16 bit number to Hexadecimal string
1E4A-               4220
1E4A-CD 75 0F       4221 ( 16) HEX:    CALL    TSTNUM          ; Verify it's a number
1E4D-CD B7 0B       4222 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1E50-C5             4223 ( 11)         PUSH    BC              ; Save contents of BC
1E51-21 2E 23       4224 (  9)         LD          HL,PBUFF
1E54-7A             4225 (  4)         LD          A,D             ; Get high order into A
1E55-FE 00          4226 (  6)         CP      $0
1E57-28 0C          4227 ( 6+)                 JR      Z,HEX2          ; Skip output if both high digits are zero
1E59-CD 82 1E       4228 ( 16)         CALL    BYT2ASC         ; Convert D to ASCII
1E5C-78             4229 (  4)                 LD      A,B
1E5D-FE 30          4230 (  6)                 CP      '0'
1E5F-28 02          4231 ( 6+)                 JR      Z,HEX1          ; Don't store high digit if zero
1E61-70             4232 (  7)         LD          (HL),B          ; Store it to PBUFF
1E62-23             4233 (  4)         INC         HL              ; Next location
1E63-71             4234 (  7) HEX1:   LD          (HL),C          ; Store C to PBUFF+1
1E64-23             4235 (  4)         INC     HL              ; Next location
1E65-7B             4236 (  4) HEX2:   LD          A,E             ; Get lower byte
1E66-CD 82 1E       4237 ( 16)         CALL    BYT2ASC         ; Convert E to ASCII
1E69-7A             4238 (  4)                 LD      A,D
1E6A-FE 00          4239 (  6)         CP      $0
1E6C-20 05          4240 ( 6+)                 JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
1E6E-78             4241 (  4)                 LD      A,B
1E6F-FE 30          4242 (  6)                 CP      '0'             ; If high digit of lower byte is zero then don't print
1E71-28 02          4243 ( 6+)                 JR      Z,HEX4
1E73-70             4244 (  7) HEX3:   LD      (HL),B          ; to PBUFF+2
1E74-23             4245 (  4)         INC     HL              ; Next location
1E75-71             4246 (  7) HEX4:   LD      (HL),C          ; to PBUFF+3
1E76-23             4247 (  4)         INC     HL              ; PBUFF+4 to zero
1E77-AF             4248 (  4)         XOR     A               ; Terminating character
1E78-77             4249 (  7)         LD      (HL),A          ; Store zero to terminate
1E79-23             4250 (  4)         INC     HL              ; Make sure PBUFF is terminated
1E7A-77             4251 (  7)         LD      (HL),A          ; Store the double zero there
1E7B-C1             4252 (  9)         POP     BC              ; Get BC back
1E7C-21 2E 23       4253 (  9)         LD      HL,PBUFF        ; Reset to start of PBUFF
1E7F-C3 DB 13       4254 (  9)         JP      STR1            ; Convert the PBUFF to a string and return it
1E82-               4255
1E82-47             4256 (  4) BYT2ASC LD      B,A             ; Save original value
1E83-E6 0F          4257 (  6)         AND     $0F             ; Strip off upper nybble
1E85-FE 0A          4258 (  6)         CP      $0A             ; 0-9?
1E87-38 02          4259 ( 6+)         JR      C,ADD30         ; If A-F, add 7 more
1E89-C6 07          4260 (  6)         ADD     A,$07           ; Bring value up to ASCII A-F
1E8B-C6 30          4261 (  6) ADD30   ADD     A,$30           ; And make ASCII
1E8D-4F             4262 (  4)         LD      C,A             ; Save converted char to C
1E8E-78             4263 (  4)         LD      A,B             ; Retrieve original value
1E8F-0F             4264 (  3)         RRCA                    ; and Rotate it right
1E90-0F             4265 (  3)         RRCA
1E91-0F             4266 (  3)         RRCA
1E92-0F             4267 (  3)         RRCA
1E93-E6 0F          4268 (  6)         AND     $0F             ; Mask off upper nybble
1E95-FE 0A          4269 (  6)         CP      $0A             ; 0-9? < A hex?
1E97-38 02          4270 ( 6+)         JR      C,ADD301        ; Skip Add 7
1E99-C6 07          4271 (  6)         ADD     A,$07           ; Bring it up to ASCII A-F
1E9B-C6 30          4272 (  6) ADD301  ADD     A,$30           ; And make it full ASCII
1E9D-47             4273 (  4)         LD      B,A             ; Store high order byte
1E9E-C9             4274 (  9)         RET
1E9F-               4275
1E9F-               4276       ; Convert "&Hnnnn" to FPREG
1E9F-               4277       ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
1E9F-               4278       ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
1E9F-EB             4279 (  3) HEXTFP  EX      DE,HL           ; Move code string pointer to DE
1EA0-21 00 00       4280 (  9)         LD      HL,$0000        ; Zero out the value
1EA3-CD B8 1E       4281 ( 16)         CALL    GETHEX          ; Check the number for valid hex
1EA6-DA D8 1E       4282 ( 6+)         JP      C,HXERR         ; First value wasn't hex, HX error
1EA9-18 05          4283 (  8)         JR      HEXLP1          ; Convert first character
1EAB-CD B8 1E       4284 ( 16) HEXLP   CALL    GETHEX          ; Get second and addtional characters
1EAE-38 1F          4285 ( 6+)         JR      C,HEXIT         ; Exit if not a hex character
1EB0-29             4286 (  7) HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
1EB1-29             4287 (  7)         ADD     HL,HL
1EB2-29             4288 (  7)         ADD     HL,HL
1EB3-29             4289 (  7)         ADD     HL,HL
1EB4-B5             4290 (  4)         OR      L               ; Add in D0-D3 into L
1EB5-6F             4291 (  4)         LD      L,A             ; Save new value
1EB6-18 F3          4292 (  8)         JR      HEXLP           ; And continue until all hex characters are in
1EB8-               4293
1EB8-13             4294 (  4) GETHEX  INC     DE              ; Next location
1EB9-1A             4295 (  6)         LD      A,(DE)          ; Load character at pointer
1EBA-FE 20          4296 (  6)         CP      ' '
1EBC-CA B8 1E       4297 ( 6+)         JP      Z,GETHEX        ; Skip spaces
1EBF-D6 30          4298 (  6)         SUB     $30             ; Get absolute value
1EC1-D8             4299 ( 5+)         RET     C               ; < "0", error
1EC2-FE 0A          4300 (  6)         CP      $0A
1EC4-38 05          4301 ( 6+)         JR      C,NOSUB7        ; Is already in the range 0-9
1EC6-D6 07          4302 (  6)         SUB     $07             ; Reduce to A-F
1EC8-FE 0A          4303 (  6)         CP      $0A             ; Value should be $0A-$0F at this point
1ECA-D8             4304 ( 5+)         RET     C               ; CY set if was :            ; < = > ? @
1ECB-FE 10          4305 (  6) NOSUB7  CP      $10             ; > Greater than "F"?
1ECD-3F             4306 (  3)         CCF
1ECE-C9             4307 (  9)         RET                     ; CY set if it wasn't valid hex
1ECF-               4308
1ECF-EB             4309 (  3) HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
1ED0-7A             4310 (  4)         LD      A,D             ; Load DE into AC
1ED1-4B             4311 (  4)         LD      C,E             ; For prep to
1ED2-E5             4312 ( 11)         PUSH    HL
1ED3-CD 2C 13       4313 ( 16)         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1ED6-E1             4314 (  9)         POP     HL
1ED7-C9             4315 (  9)         RET
1ED8-               4316
1ED8-1E 26          4317 (  6) HXERR:  LD      E,HX            ; ?HEX Error
1EDA-C3 C1 06       4318 (  9)         JP      ERROR
1EDD-               4319
1EDD-               4320       ; BIN$(NN) Convert integer to a 1-16 char binary string
1EDD-CD 75 0F       4321 ( 16) BIN:    CALL    TSTNUM          ; Verify it's a number
1EE0-CD B7 0B       4322 ( 16)         CALL    DEINT           ; Get integer -32768 to 32767
1EE3-C5             4323 ( 11) BIN2:   PUSH    BC              ; Save contents of BC
1EE4-21 2E 23       4324 (  9)         LD      HL,PBUFF
1EE7-06 11          4325 (  6)         LD      B,17            ; One higher than max char count
1EE9-               4326       ZEROSUP:                        ; Suppress leading zeros
1EE9-05             4327 (  4)         DEC     B               ; Max 16 chars
1EEA-78             4328 (  4)         LD      A,B
1EEB-FE 01          4329 (  6)         CP      $01
1EED-28 08          4330 ( 6+)         JR      Z,BITOUT        ; Always output at least one character
1EEF-CB 13          4331 (  7)         RL      E
1EF1-CB 12          4332 (  7)         RL      D
1EF3-30 F4          4333 ( 6+)         JR      NC,ZEROSUP
1EF5-18 04          4334 (  8)         JR      BITOUT2
1EF7-               4335       BITOUT:
1EF7-CB 13          4336 (  7)         RL      E
1EF9-CB 12          4337 (  7)         RL      D               ; Top bit now in carry
1EFB-               4338       BITOUT2:
1EFB-3E 30          4339 (  6)         LD      A,'0'           ; Char for '0'
1EFD-CE 00          4340 (  6)         ADC     A,0             ; If carry set then '0' --> '1'
1EFF-77             4341 (  7)         LD      (HL),A
1F00-23             4342 (  4)         INC     HL
1F01-05             4343 (  4)         DEC     B
1F02-20 F3          4344 ( 6+)         JR      NZ,BITOUT
1F04-AF             4345 (  4)         XOR     A               ; Terminating character
1F05-77             4346 (  7)         LD      (HL),A          ; Store zero to terminate
1F06-23             4347 (  4)         INC     HL              ; Make sure PBUFF is terminated
1F07-77             4348 (  7)         LD      (HL),A          ; Store the double zero there
1F08-C1             4349 (  9)         POP     BC
1F09-21 2E 23       4350 (  9)         LD      HL,PBUFF
1F0C-C3 DB 13       4351 (  9)         JP      STR1
1F0F-               4352
1F0F-               4353       ; Convert "&Bnnnn" to FPREG
1F0F-               4354       ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1F0F-EB             4355 (  3) BINTFP: EX      DE,HL           ; Move code string pointer to DE
1F10-21 00 00       4356 (  9)         LD      HL,$0000        ; Zero out the value
1F13-CD 2C 1F       4357 ( 16)         CALL    CHKBIN          ; Check the number for valid bin
1F16-DA 3A 1F       4358 ( 6+)         JP      C,BINERR        ; First value wasn't bin, HX error
1F19-D6 30          4359 (  6) BINIT:  SUB     '0'
1F1B-29             4360 (  7)         ADD     HL,HL           ; Rotate HL left
1F1C-B5             4361 (  4)         OR      L
1F1D-6F             4362 (  4)         LD      L,A
1F1E-CD 2C 1F       4363 ( 16)         CALL    CHKBIN          ; Get second and addtional characters
1F21-30 F6          4364 ( 6+)         JR      NC,BINIT        ; Process if a bin character
1F23-EB             4365 (  3)         EX      DE,HL           ; Value into DE, Code string into HL
1F24-7A             4366 (  4)         LD      A,D             ; Load DE into AC
1F25-4B             4367 (  4)         LD      C,E             ; For prep to
1F26-E5             4368 ( 11)         PUSH    HL
1F27-CD 2C 13       4369 ( 16)         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1F2A-E1             4370 (  9)         POP     HL
1F2B-C9             4371 (  9)         RET
1F2C-               4372
1F2C-               4373       ; Char is in A, NC if char is 0 or 1
1F2C-13             4374 (  4) CHKBIN: INC     DE
1F2D-1A             4375 (  6)         LD      A,(DE)
1F2E-FE 20          4376 (  6)         CP      ' '
1F30-CA 2C 1F       4377 ( 6+)         JP      Z,CHKBIN        ; Skip spaces
1F33-FE 30          4378 (  6)         CP      '0'             ; Set C if < '0'
1F35-D8             4379 ( 5+)         RET     C
1F36-FE 32          4380 (  6)         CP      '2'
1F38-3F             4381 (  3)         CCF                     ; Set C if > '1'
1F39-C9             4382 (  9)         RET
1F3A-               4383
1F3A-1E 28          4384 (  6) BINERR: LD      E,BN            ; ?BIN Error
1F3C-C3 C1 06       4385 (  9)         JP      ERROR
1F3F-               4386
1F3F-               4387
1F3F-               4388       JJUMP1:
1F3F-DD 21 FF FF    4389 ( 12)         LD      IX,-1           ; Flag cold start
1F43-C3 11 03       4390 (  9)         JP      CSTART          ; Go and initialise
1F46-               4391
1F46-               4392       MONOUT:
1F46-C3 08 00       4393 (  9)         JP      $0008           ; output a char
1F49-               4394
1F49-               4395
1F49-               4396       MONITR:
1F49-C3 00 00       4397 (  9)         JP      $0000           ; Restart (Normally Monitor Start)
1F4C-               4398
1F4C-               4399
1F4C-3E 00          4400 (  6) INITST: LD      A,0             ; Clear break flag
1F4E-32 92 22       4401 ( 13)         LD      (BRKFLG),A
1F51-C3 18 03       4402 (  9)         JP      INIT
1F54-               4403
1F54-ED 45          4404 ( 12) ARETN:  RETN                    ; Return from NMI
1F56-               4405
1F56-               4406
1F56-F5             4407 ( 11) TSTBIT: PUSH    AF              ; Save bit mask
1F57-A0             4408 (  4)         AND     B               ; Get common bits
1F58-C1             4409 (  9)         POP     BC              ; Restore bit mask
1F59-B8             4410 (  4)         CP      B               ; Same bit set?
1F5A-3E 00          4411 (  6)         LD      A,0             ; Return 0 in A
1F5C-C9             4412 (  9)         RET
1F5D-               4413
1F5D-CD 86 09       4414 ( 16) OUTNCR: CALL    OUTC            ; Output character in A
1F60-C3 AD 0D       4415 (  9)         JP      PRNTCRLF        ; Output CRLF
1F63-               4416
1F63-               4417       .end
1F63-               4418
