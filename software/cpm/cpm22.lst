0000-                  4
0000-                  5       ;**************************************************************
0000-                  6       ;*
0000-                  7       ;*             C P / M   version   2 . 2
0000-                  8       ;*
0000-                  9       ;*   Reconstructed from memory image on February 27, 1981
0000-                 10       ;*
0000-                 11       ;*                by Clark A. Calkins
0000-                 12       ;*
0000-                 13       ;**************************************************************
0000-                 14       ;
0000-                 15       ;   Set memory limit here. This is the amount of contigeous
0000-                 16       ; ram starting from 0000. CP/M will reside at the end of this space.
0000-                 17       ;
0000-                 18
0003-                 19       IOBYTE  .EQU    3               ;i/o definition byte.
0004-                 20       TDRIVE  .EQU    4               ;current drive name and user number.
0005-                 21       ENTRY   .EQU    5               ;entry point for the cp/m bdos.
005C-                 22       TFCB    .EQU    5CH             ;default file control block.
0080-                 23       TBUFF   .EQU    80H             ;i/o buffer and command line storage.
0100-                 24       TBASE   .EQU    100H            ;transiant program storage area.
0000-                 25       ;
0000-                 26       ;   Set control character equates.
0000-                 27       ;
0003-                 28       CNTRLC  .EQU    3               ;control-c
0005-                 29       CNTRLE  .EQU    05H             ;control-e
0008-                 30       BS      .EQU    08H             ;backspace
0009-                 31       TAB     .EQU    09H             ;tab
000A-                 32       LF      .EQU    0AH             ;line feed
000C-                 33       FF      .EQU    0CH             ;form feed
000D-                 34       CR      .EQU    0DH             ;carriage return
0010-                 35       CNTRLP  .EQU    10H             ;control-p
0012-                 36       CNTRLR  .EQU    12H             ;control-r
0013-                 37       CNTRLS  .EQU    13H             ;control-s
0015-                 38       CNTRLU  .EQU    15H             ;control-u
0018-                 39       CNTRLX  .EQU    18H             ;control-x
001A-                 40       CNTRLZ  .EQU    1AH             ;control-z (end-of-file mark)
007F-                 41       DEL     .EQU    7FH             ;rubout
0000-                 42       ;
0000-                 43       ;   Set origin for CP/M
0000-                 44       ;
C900-                 45               .ORG    0C900H
C900-                 46       ;
C900-C3 5C CC         47 (  9) CBASE:  JP      COMMAND         ;execute command processor (ccp).
C903-C3 58 CC         48 (  9)         JP      CLEARBUF        ;entry to empty input buffer before starting ccp.
C906-                 49
C906-                 50       ;
C906-                 51       ;   Standard cp/m ccp input buffer. Format is (max length),
C906-                 52       ; (actual length), (char #1), (char #2), (char #3), etc.
C906-                 53       ;
C906-7F               54       INBUFF:         .DB     127             ;length of input buffer.
C907-00               55               .DB     0               ;current length of contents.
C908-43 6F 70 79 
     72 69 67 68 
     74               56               .DB     "Copyright"
C911-20 31 39 37 
     39 20 28 63 
     29 20 62 79 
     20 44 69 67 
     69 74 61 6C 
     20 52 65 73 
     65 61 72 63 
     68 20 20 20 
     20 20 20         57               .DB     " 1979 (c) by Digital Research      "
C934-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00         58               .DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
C94B-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00         59               .DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
C962-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00         60               .DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
C979-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00         61               .DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
C988-08 C9            62       INPOINT: .DW    INBUFF+2        ;input line pointer
C98A-00 00            63       NAMEPNT: .DW    0               ;input line pointer used for error message. Points to
C98C-                 64       ;                       ;start of name in error.
C98C-                 65       ;
C98C-                 66       ;   Routine to print (A) on the console. All registers used.
C98C-                 67       ;
C98C-5F               68 (  4) PRINT:  LD      E,A             ;setup bdos call.
C98D-0E 02            69 (  6)         LD      C,2
C98F-C3 05 00         70 (  9)         JP      ENTRY
C992-                 71       ;
C992-                 72       ;   Routine to print (A) on the console and to save (BC).
C992-                 73       ;
C992-C5               74 ( 11) PRINTB:         PUSH    BC
C993-CD 8C C9         75 ( 16)         CALL    PRINT
C996-C1               76 (  9)         POP     BC
C997-C9               77 (  9)         RET
C998-                 78       ;
C998-                 79       ;   Routine to send a carriage return, line feed combination
C998-                 80       ; to the console.
C998-                 81       ;
C998-3E 0D            82 (  6) CRLF:   LD      A,CR
C99A-CD 92 C9         83 ( 16)         CALL    PRINTB
C99D-3E 0A            84 (  6)         LD      A,LF
C99F-C3 92 C9         85 (  9)         JP      PRINTB
C9A2-                 86       ;
C9A2-                 87       ;   Routine to send one space to the console and save (BC).
C9A2-                 88       ;
C9A2-3E 20            89 (  6) SPACE:  LD      A,' '
C9A4-C3 92 C9         90 (  9)         JP      PRINTB
C9A7-                 91       ;
C9A7-                 92       ;   Routine to print character string pointed to be (BC) on the
C9A7-                 93       ; console. It must terminate with a null byte.
C9A7-                 94       ;
C9A7-C5               95 ( 11) PLINE:  PUSH    BC
C9A8-CD 98 C9         96 ( 16)         CALL    CRLF
C9AB-E1               97 (  9)         POP     HL
C9AC-7E               98 (  6) PLINE2:         LD      A,(HL)
C9AD-B7               99 (  4)         OR      A
C9AE-C8              100 ( 5+)         RET     Z
C9AF-23              101 (  4)         INC     HL
C9B0-E5              102 ( 11)         PUSH    HL
C9B1-CD 8C C9        103 ( 16)         CALL    PRINT
C9B4-E1              104 (  9)         POP     HL
C9B5-C3 AC C9        105 (  9)         JP      PLINE2
C9B8-                106       ;
C9B8-                107       ;   Routine to reset the disk system.
C9B8-                108       ;
C9B8-0E 0D           109 (  6) RESDSK:         LD      C,13
C9BA-C3 05 00        110 (  9)         JP      ENTRY
C9BD-                111       ;
C9BD-                112       ;   Routine to select disk (A).
C9BD-                113       ;
C9BD-5F              114 (  4) DSKSEL:         LD      E,A
C9BE-0E 0E           115 (  6)         LD      C,14
C9C0-C3 05 00        116 (  9)         JP      ENTRY
C9C3-                117       ;
C9C3-                118       ;   Routine to call bdos and save the return code. The zero
C9C3-                119       ; flag is set on a return of 0ffh.
C9C3-                120       ;
C9C3-CD 05 00        121 ( 16) ENTRY1:         CALL    ENTRY
C9C6-32 EE D0        122 ( 13)         LD      (RTNCODE),A     ;save return code.
C9C9-3C              123 (  4)         INC     A               ;set zero if 0ffh returned.
C9CA-C9              124 (  9)         RET
C9CB-                125       ;
C9CB-                126       ;   Routine to open a file. (DE) must point to the FCB.
C9CB-                127       ;
C9CB-0E 0F           128 (  6) OPEN:   LD      C,15
C9CD-C3 C3 C9        129 (  9)         JP      ENTRY1
C9D0-                130       ;
C9D0-                131       ;   Routine to open file at (FCB).
C9D0-                132       ;
C9D0-AF              133 (  4) OPENFCB: XOR    A               ;clear the record number byte at fcb+32
C9D1-32 ED D0        134 ( 13)         LD      (FCB+32),A
C9D4-11 CD D0        135 (  9)         LD      DE,FCB
C9D7-C3 CB C9        136 (  9)         JP      OPEN
C9DA-                137       ;
C9DA-                138       ;   Routine to close a file. (DE) points to FCB.
C9DA-                139       ;
C9DA-0E 10           140 (  6) CLOSE:  LD      C,16
C9DC-C3 C3 C9        141 (  9)         JP      ENTRY1
C9DF-                142       ;
C9DF-                143       ;   Routine to search for the first file with ambigueous name
C9DF-                144       ; (DE).
C9DF-                145       ;
C9DF-0E 11           146 (  6) SRCHFST: LD     C,17
C9E1-C3 C3 C9        147 (  9)         JP      ENTRY1
C9E4-                148       ;
C9E4-                149       ;   Search for the next ambigeous file name.
C9E4-                150       ;
C9E4-0E 12           151 (  6) SRCHNXT: LD     C,18
C9E6-C3 C3 C9        152 (  9)         JP      ENTRY1
C9E9-                153       ;
C9E9-                154       ;   Search for file at (FCB).
C9E9-                155       ;
C9E9-11 CD D0        156 (  9) SRCHFCB: LD     DE,FCB
C9EC-C3 DF C9        157 (  9)         JP      SRCHFST
C9EF-                158       ;
C9EF-                159       ;   Routine to delete a file pointed to by (DE).
C9EF-                160       ;
C9EF-0E 13           161 (  6) DELETE:         LD      C,19
C9F1-C3 05 00        162 (  9)         JP      ENTRY
C9F4-                163       ;
C9F4-                164       ;   Routine to call the bdos and set the zero flag if a zero
C9F4-                165       ; status is returned.
C9F4-                166       ;
C9F4-CD 05 00        167 ( 16) ENTRY2:         CALL    ENTRY
C9F7-B7              168 (  4)         OR      A               ;set zero flag if appropriate.
C9F8-C9              169 (  9)         RET
C9F9-                170       ;
C9F9-                171       ;   Routine to read the next record from a sequential file.
C9F9-                172       ; (DE) points to the FCB.
C9F9-                173       ;
C9F9-0E 14           174 (  6) RDREC:  LD      C,20
C9FB-C3 F4 C9        175 (  9)         JP      ENTRY2
C9FE-                176       ;
C9FE-                177       ;   Routine to read file at (FCB).
C9FE-                178       ;
C9FE-11 CD D0        179 (  9) READFCB: LD     DE,FCB
CA01-C3 F9 C9        180 (  9)         JP      RDREC
CA04-                181       ;
CA04-                182       ;   Routine to write the next record of a sequential file.
CA04-                183       ; (DE) points to the FCB.
CA04-                184       ;
CA04-0E 15           185 (  6) WRTREC:         LD      C,21
CA06-C3 F4 C9        186 (  9)         JP      ENTRY2
CA09-                187       ;
CA09-                188       ;   Routine to create the file pointed to by (DE).
CA09-                189       ;
CA09-0E 16           190 (  6) CREATE:         LD      C,22
CA0B-C3 C3 C9        191 (  9)         JP      ENTRY1
CA0E-                192       ;
CA0E-                193       ;   Routine to rename the file pointed to by (DE). Note that
CA0E-                194       ; the new name starts at (DE+16).
CA0E-                195       ;
CA0E-0E 17           196 (  6) RENAM:  LD      C,23
CA10-C3 05 00        197 (  9)         JP      ENTRY
CA13-                198       ;
CA13-                199       ;   Get the current user code.
CA13-                200       ;
CA13-1E FF           201 (  6) GETUSR:         LD      E,0FFH
CA15-                202       ;
CA15-                203       ;   Routne to get or set the current user code.
CA15-                204       ; If (E) is FF then this is a GET, else it is a SET.
CA15-                205       ;
CA15-0E 20           206 (  6) GETSETUC:  LD   C,32
CA17-C3 05 00        207 (  9)         JP      ENTRY
CA1A-                208       ;
CA1A-                209       ;   Routine to set the current drive byte at (TDRIVE).
CA1A-                210       ;
CA1A-CD 13 CA        211 ( 16) SETCDRV: CALL   GETUSR          ;get user number
CA1D-87              212 (  4)         ADD     A,A             ;and shift into the upper 4 bits.
CA1E-87              213 (  4)         ADD     A,A
CA1F-87              214 (  4)         ADD     A,A
CA20-87              215 (  4)         ADD     A,A
CA21-21 EF D0        216 (  9)         LD      HL,CDRIVE       ;now add in the current drive number.
CA24-B6              217 (  6)         OR      (HL)
CA25-32 04 00        218 ( 13)         LD      (TDRIVE),A      ;and save.
CA28-C9              219 (  9)         RET
CA29-                220       ;
CA29-                221       ;   Move currently active drive down to (TDRIVE).
CA29-                222       ;
CA29-3A EF D0        223 ( 12) MOVECD:         LD      A,(CDRIVE)
CA2C-32 04 00        224 ( 13)         LD      (TDRIVE),A
CA2F-C9              225 (  9)         RET
CA30-                226       ;
CA30-                227       ;   Routine to convert (A) into upper case ascii. Only letters
CA30-                228       ; are affected.
CA30-                229       ;
CA30-FE 61           230 (  6) UPPER:  CP      'a'             ;check for letters in the range of 'a' to 'z'.
CA32-D8              231 ( 5+)         RET     C
CA33-FE 7B           232 (  6)         CP      '{'
CA35-D0              233 ( 5+)         RET     NC
CA36-E6 5F           234 (  6)         AND     5FH             ;convert it if found.
CA38-C9              235 (  9)         RET
CA39-                236       ;
CA39-                237       ;   Routine to get a line of input. We must check to see if the
CA39-                238       ; user is in (BATCH) mode. If so, then read the input from file
CA39-                239       ; ($$$.SUB). At the end, reset to console input.
CA39-                240       ;
CA39-3A AB D0        241 ( 12) GETINP:         LD      A,(BATCH)       ;if =0, then use console input.
CA3C-B7              242 (  4)         OR      A
CA3D-CA 96 CA        243 ( 6+)         JP      Z,GETINP1
CA40-                244       ;
CA40-                245       ;   Use the submit file ($$$.sub) which is prepared by a
CA40-                246       ; SUBMIT run. It must be on drive (A) and it will be deleted
CA40-                247       ; if and error occures (like eof).
CA40-                248       ;
CA40-3A EF D0        249 ( 12)         LD      A,(CDRIVE)      ;select drive 0 if need be.
CA43-B7              250 (  4)         OR      A
CA44-3E 00           251 (  6)         LD      A,0             ;always use drive A for submit.
CA46-C4 BD C9        252 ( 6+)         CALL    NZ,DSKSEL       ;select it if required.
CA49-11 AC D0        253 (  9)         LD      DE,BATCHFCB
CA4C-CD CB C9        254 ( 16)         CALL    OPEN            ;look for it.
CA4F-CA 96 CA        255 ( 6+)         JP      Z,GETINP1       ;if not there, use normal input.
CA52-3A BB D0        256 ( 12)         LD      A,(BATCHFCB+15) ;get last record number+1.
CA55-3D              257 (  4)         DEC     A
CA56-32 CC D0        258 ( 13)         LD      (BATCHFCB+32),A
CA59-11 AC D0        259 (  9)         LD      DE,BATCHFCB
CA5C-CD F9 C9        260 ( 16)         CALL    RDREC           ;read last record.
CA5F-C2 96 CA        261 ( 6+)         JP      NZ,GETINP1      ;quit on end of file.
CA62-                262       ;
CA62-                263       ;   Move this record into input buffer.
CA62-                264       ;
CA62-11 07 C9        265 (  9)         LD      DE,INBUFF+1
CA65-21 80 00        266 (  9)         LD      HL,TBUFF        ;data was read into buffer here.
CA68-06 80           267 (  6)         LD      B,128           ;all 128 characters may be used.
CA6A-CD 42 CD        268 ( 16)         CALL    HL2DE           ;(HL) to (DE), (B) bytes.
CA6D-21 BA D0        269 (  9)         LD      HL,BATCHFCB+14
CA70-36 00           270 (  9)         LD      (HL),0          ;zero out the 's2' byte.
CA72-23              271 (  4)         INC     HL              ;and decrement the record count.
CA73-35              272 ( 10)         DEC     (HL)
CA74-11 AC D0        273 (  9)         LD      DE,BATCHFCB     ;close the batch file now.
CA77-CD DA C9        274 ( 16)         CALL    CLOSE
CA7A-CA 96 CA        275 ( 6+)         JP      Z,GETINP1       ;quit on an error.
CA7D-3A EF D0        276 ( 12)         LD      A,(CDRIVE)      ;re-select previous drive if need be.
CA80-B7              277 (  4)         OR      A
CA81-C4 BD C9        278 ( 6+)         CALL    NZ,DSKSEL       ;don't do needless selects.
CA84-                279       ;
CA84-                280       ;   Print line just read on console.
CA84-                281       ;
CA84-21 08 C9        282 (  9)         LD      HL,INBUFF+2
CA87-CD AC C9        283 ( 16)         CALL    PLINE2
CA8A-CD C2 CA        284 ( 16)         CALL    CHKCON          ;check console, quit on a key.
CA8D-CA A7 CA        285 ( 6+)         JP      Z,GETINP2       ;jump if no key is pressed.
CA90-                286       ;
CA90-                287       ;   Terminate the submit job on any keyboard input. Delete this
CA90-                288       ; file such that it is not re-started and jump to normal keyboard
CA90-                289       ; input section.
CA90-                290       ;
CA90-CD DD CA        291 ( 16)         CALL    DELBATCH        ;delete the batch file.
CA93-C3 82 CC        292 (  9)         JP      CMMND1          ;and restart command input.
CA96-                293       ;
CA96-                294       ;   Get here for normal keyboard input. Delete the submit file
CA96-                295       ; incase there was one.
CA96-                296       ;
CA96-CD DD CA        297 ( 16) GETINP1: CALL   DELBATCH        ;delete file ($$$.sub).
CA99-CD 1A CA        298 ( 16)         CALL    SETCDRV         ;reset active disk.
CA9C-0E 0A           299 (  6)         LD      C,10            ;get line from console device.
CA9E-11 06 C9        300 (  9)         LD      DE,INBUFF
CAA1-CD 05 00        301 ( 16)         CALL    ENTRY
CAA4-CD 29 CA        302 ( 16)         CALL    MOVECD          ;reset current drive (again).
CAA7-                303       ;
CAA7-                304       ;   Convert input line to upper case.
CAA7-                305       ;
CAA7-21 07 C9        306 (  9) GETINP2: LD     HL,INBUFF+1
CAAA-46              307 (  6)         LD      B,(HL)          ;(B)=character counter.
CAAB-23              308 (  4) GETINP3: INC    HL
CAAC-78              309 (  4)         LD      A,B             ;end of the line?
CAAD-B7              310 (  4)         OR      A
CAAE-CA BA CA        311 ( 6+)         JP      Z,GETINP4
CAB1-7E              312 (  6)         LD      A,(HL)          ;convert to upper case.
CAB2-CD 30 CA        313 ( 16)         CALL    UPPER
CAB5-77              314 (  7)         LD      (HL),A
CAB6-05              315 (  4)         DEC     B               ;adjust character count.
CAB7-C3 AB CA        316 (  9)         JP      GETINP3
CABA-77              317 (  7) GETINP4: LD     (HL),A          ;add trailing null.
CABB-21 08 C9        318 (  9)         LD      HL,INBUFF+2
CABE-22 88 C9        319 ( 20)         LD      (INPOINT),HL    ;reset input line pointer.
CAC1-C9              320 (  9)         RET
CAC2-                321       ;
CAC2-                322       ;   Routine to check the console for a key pressed. The zero
CAC2-                323       ; flag is set is none, else the character is returned in (A).
CAC2-                324       ;
CAC2-0E 0B           325 (  6) CHKCON:         LD      C,11            ;check console.
CAC4-CD 05 00        326 ( 16)         CALL    ENTRY
CAC7-B7              327 (  4)         OR      A
CAC8-C8              328 ( 5+)         RET     Z               ;return if nothing.
CAC9-0E 01           329 (  6)         LD      C,1             ;else get character.
CACB-CD 05 00        330 ( 16)         CALL    ENTRY
CACE-B7              331 (  4)         OR      A               ;clear zero flag and return.
CACF-C9              332 (  9)         RET
CAD0-                333       ;
CAD0-                334       ;   Routine to get the currently active drive number.
CAD0-                335       ;
CAD0-0E 19           336 (  6) GETDSK:         LD      C,25
CAD2-C3 05 00        337 (  9)         JP      ENTRY
CAD5-                338       ;
CAD5-                339       ;   Set the stabdard dma address.
CAD5-                340       ;
CAD5-11 80 00        341 (  9) STDDMA:         LD      DE,TBUFF
CAD8-                342       ;
CAD8-                343       ;   Routine to set the dma address to (DE).
CAD8-                344       ;
CAD8-0E 1A           345 (  6) DMASET:         LD      C,26
CADA-C3 05 00        346 (  9)         JP      ENTRY
CADD-                347       ;
CADD-                348       ;  Delete the batch file created by SUBMIT.
CADD-                349       ;
CADD-21 AB D0        350 (  9) DELBATCH:  LD   HL,BATCH        ;is batch active?
CAE0-7E              351 (  6)         LD      A,(HL)
CAE1-B7              352 (  4)         OR      A
CAE2-C8              353 ( 5+)         RET     Z
CAE3-36 00           354 (  9)         LD      (HL),0          ;yes, de-activate it.
CAE5-AF              355 (  4)         XOR     A
CAE6-CD BD C9        356 ( 16)         CALL    DSKSEL          ;select drive 0 for sure.
CAE9-11 AC D0        357 (  9)         LD      DE,BATCHFCB     ;and delete this file.
CAEC-CD EF C9        358 ( 16)         CALL    DELETE
CAEF-3A EF D0        359 ( 12)         LD      A,(CDRIVE)      ;reset current drive.
CAF2-C3 BD C9        360 (  9)         JP      DSKSEL
CAF5-                361       ;
CAF5-                362       ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
CAF5-                363       ; the same or we halt....
CAF5-                364       ;
CAF5-11 28 CC        365 (  9) VERIFY:         LD      DE,PATTRN1      ;these are the serial number bytes.
CAF8-21 00 D1        366 (  9)         LD      HL,PATTRN2      ;ditto, but how could they be different?
CAFB-06 06           367 (  6)         LD      B,6             ;6 bytes each.
CAFD-1A              368 (  6) VERIFY1: LD     A,(DE)
CAFE-BE              369 (  6)         CP      (HL)
CAFF-C2 CF CC        370 ( 6+)         JP      NZ,HALT         ;jump to halt routine.
CB02-13              371 (  4)         INC     DE
CB03-23              372 (  4)         INC     HL
CB04-05              373 (  4)         DEC     B
CB05-C2 FD CA        374 ( 6+)         JP      NZ,VERIFY1
CB08-C9              375 (  9)         RET
CB09-                376       ;
CB09-                377       ;   Print back file name with a '?' to indicate a syntax error.
CB09-                378       ;
CB09-CD 98 C9        379 ( 16) SYNERR:         CALL    CRLF            ;end current line.
CB0C-2A 8A C9        380 ( 15)         LD      HL,(NAMEPNT)    ;this points to name in error.
CB0F-7E              381 (  6) SYNERR1: LD     A,(HL)          ;print it until a space or null is found.
CB10-FE 20           382 (  6)         CP      ' '
CB12-CA 22 CB        383 ( 6+)         JP      Z,SYNERR2
CB15-B7              384 (  4)         OR      A
CB16-CA 22 CB        385 ( 6+)         JP      Z,SYNERR2
CB19-E5              386 ( 11)         PUSH    HL
CB1A-CD 8C C9        387 ( 16)         CALL    PRINT
CB1D-E1              388 (  9)         POP     HL
CB1E-23              389 (  4)         INC     HL
CB1F-C3 0F CB        390 (  9)         JP      SYNERR1
CB22-3E 3F           391 (  6) SYNERR2: LD     A,'?'           ;add trailing '?'.
CB24-CD 8C C9        392 ( 16)         CALL    PRINT
CB27-CD 98 C9        393 ( 16)         CALL    CRLF
CB2A-CD DD CA        394 ( 16)         CALL    DELBATCH        ;delete any batch file.
CB2D-C3 82 CC        395 (  9)         JP      CMMND1          ;and restart from console input.
CB30-                396       ;
CB30-                397       ;   Check character at (DE) for legal command input. Note that the
CB30-                398       ; zero flag is set if the character is a delimiter.
CB30-                399       ;
CB30-1A              400 (  6) CHECK:  LD      A,(DE)
CB31-B7              401 (  4)         OR      A
CB32-C8              402 ( 5+)         RET     Z
CB33-FE 20           403 (  6)         CP      ' '             ;control characters are not legal here.
CB35-DA 09 CB        404 ( 6+)         JP      C,SYNERR
CB38-C8              405 ( 5+)         RET     Z               ;check for valid delimiter.
CB39-FE 3D           406 (  6)         CP      '='
CB3B-C8              407 ( 5+)         RET     Z
CB3C-FE 5F           408 (  6)         CP      '_'
CB3E-C8              409 ( 5+)         RET     Z
CB3F-FE 2E           410 (  6)         CP      '.'
CB41-C8              411 ( 5+)         RET     Z
CB42-FE 3A           412 (  6)         CP      ': '
CB44-C8              413 ( 5+)         RET     Z
CB45-FE 3B           414 (  6)         CP      03BH ; ';'
CB47-C8              415 ( 5+)         RET     Z
CB48-FE 3C           416 (  6)         CP      '<'
CB4A-C8              417 ( 5+)         RET     Z
CB4B-FE 3E           418 (  6)         CP      '>'
CB4D-C8              419 ( 5+)         RET     Z
CB4E-C9              420 (  9)         RET
CB4F-                421       ;
CB4F-                422       ;   Get the next non-blank character from (DE).
CB4F-                423       ;
CB4F-1A              424 (  6) NONBLANK:  LD   A,(DE)
CB50-B7              425 (  4)         OR      A               ;string ends with a null.
CB51-C8              426 ( 5+)         RET     Z
CB52-FE 20           427 (  6)         CP      ' '
CB54-C0              428 ( 5+)         RET     NZ
CB55-13              429 (  4)         INC     DE
CB56-C3 4F CB        430 (  9)         JP      NONBLANK
CB59-                431       ;
CB59-                432       ;   Add (HL)=(HL)+(A)
CB59-                433       ;
CB59-85              434 (  4) ADDHL:  ADD     A,L
CB5A-6F              435 (  4)         LD      L,A
CB5B-D0              436 ( 5+)         RET     NC              ;take care of any carry.
CB5C-24              437 (  4)         INC     H
CB5D-C9              438 (  9)         RET
CB5E-                439       ;
CB5E-                440       ;   Convert the first name in (FCB).
CB5E-                441       ;
CB5E-3E 00           442 (  6) CONVFST: LD     A,0
CB60-                443       ;
CB60-                444       ;   Format a file name (convert * to '?', etc.). On return,
CB60-                445       ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
CB60-                446       ; the position within the fcb for the name (either 0 or 16).
CB60-                447       ;
CB60-21 CD D0        448 (  9) CONVERT: LD     HL,FCB
CB63-CD 59 CB        449 ( 16)         CALL    ADDHL
CB66-E5              450 ( 11)         PUSH    HL
CB67-E5              451 ( 11)         PUSH    HL
CB68-AF              452 (  4)         XOR     A
CB69-32 F0 D0        453 ( 13)         LD      (CHGDRV),A      ;initialize drive change flag.
CB6C-2A 88 C9        454 ( 15)         LD      HL,(INPOINT)    ;set (HL) as pointer into input line.
CB6F-EB              455 (  3)         EX      DE,HL
CB70-CD 4F CB        456 ( 16)         CALL    NONBLANK        ;get next non-blank character.
CB73-EB              457 (  3)         EX      DE,HL
CB74-22 8A C9        458 ( 20)         LD      (NAMEPNT),HL    ;save pointer here for any error message.
CB77-EB              459 (  3)         EX      DE,HL
CB78-E1              460 (  9)         POP     HL
CB79-1A              461 (  6)         LD      A,(DE)          ;get first character.
CB7A-B7              462 (  4)         OR      A
CB7B-CA 89 CB        463 ( 6+)         JP      Z,CONVRT1
CB7E-DE 40           464 (  6)         SBC     A,'A'-1         ;might be a drive name, convert to binary.
CB80-47              465 (  4)         LD      B,A             ;and save.
CB81-13              466 (  4)         INC     DE              ;check next character for a ': '.
CB82-1A              467 (  6)         LD      A,(DE)
CB83-FE 3A           468 (  6)         CP      ': '
CB85-CA 90 CB        469 ( 6+)         JP      Z,CONVRT2
CB88-1B              470 (  4)         DEC     DE              ;nope, move pointer back to the start of the line.
CB89-3A EF D0        471 ( 12) CONVRT1: LD     A,(CDRIVE)
CB8C-77              472 (  7)         LD      (HL),A
CB8D-C3 96 CB        473 (  9)         JP      CONVRT3
CB90-78              474 (  4) CONVRT2: LD     A,B
CB91-32 F0 D0        475 ( 13)         LD      (CHGDRV),A      ;set change in drives flag.
CB94-70              476 (  7)         LD      (HL),B
CB95-13              477 (  4)         INC     DE
CB96-                478       ;
CB96-                479       ;   Convert the basic file name.
CB96-                480       ;
CB96-06 08           481 (  6) CONVRT3: LD     B,08H
CB98-CD 30 CB        482 ( 16) CONVRT4: CALL   CHECK
CB9B-CA B9 CB        483 ( 6+)         JP      Z,CONVRT8
CB9E-23              484 (  4)         INC     HL
CB9F-FE 2A           485 (  6)         CP      '*'             ;note that an '*' will fill the remaining
CBA1-C2 A9 CB        486 ( 6+)         JP      NZ,CONVRT5      ;field with '?'.
CBA4-36 3F           487 (  9)         LD      (HL),'?'
CBA6-C3 AB CB        488 (  9)         JP      CONVRT6
CBA9-77              489 (  7) CONVRT5: LD     (HL),A
CBAA-13              490 (  4)         INC     DE
CBAB-05              491 (  4) CONVRT6: DEC    B
CBAC-C2 98 CB        492 ( 6+)         JP      NZ,CONVRT4
CBAF-CD 30 CB        493 ( 16) CONVRT7: CALL   CHECK           ;get next delimiter.
CBB2-CA C0 CB        494 ( 6+)         JP      Z,GETEXT
CBB5-13              495 (  4)         INC     DE
CBB6-C3 AF CB        496 (  9)         JP      CONVRT7
CBB9-23              497 (  4) CONVRT8: INC    HL              ;blank fill the file name.
CBBA-36 20           498 (  9)         LD      (HL),' '
CBBC-05              499 (  4)         DEC     B
CBBD-C2 B9 CB        500 ( 6+)         JP      NZ,CONVRT8
CBC0-                501       ;
CBC0-                502       ;   Get the extension and convert it.
CBC0-                503       ;
CBC0-06 03           504 (  6) GETEXT:         LD      B,03H
CBC2-FE 2E           505 (  6)         CP      '.'
CBC4-C2 E9 CB        506 ( 6+)         JP      NZ,GETEXT5
CBC7-13              507 (  4)         INC     DE
CBC8-CD 30 CB        508 ( 16) GETEXT1: CALL   CHECK
CBCB-CA E9 CB        509 ( 6+)         JP      Z,GETEXT5
CBCE-23              510 (  4)         INC     HL
CBCF-FE 2A           511 (  6)         CP      '*'
CBD1-C2 D9 CB        512 ( 6+)         JP      NZ,GETEXT2
CBD4-36 3F           513 (  9)         LD      (HL),'?'
CBD6-C3 DB CB        514 (  9)         JP      GETEXT3
CBD9-77              515 (  7) GETEXT2: LD     (HL),A
CBDA-13              516 (  4)         INC     DE
CBDB-05              517 (  4) GETEXT3: DEC    B
CBDC-C2 C8 CB        518 ( 6+)         JP      NZ,GETEXT1
CBDF-CD 30 CB        519 ( 16) GETEXT4: CALL   CHECK
CBE2-CA F0 CB        520 ( 6+)         JP      Z,GETEXT6
CBE5-13              521 (  4)         INC     DE
CBE6-C3 DF CB        522 (  9)         JP      GETEXT4
CBE9-23              523 (  4) GETEXT5: INC    HL
CBEA-36 20           524 (  9)         LD      (HL),' '
CBEC-05              525 (  4)         DEC     B
CBED-C2 E9 CB        526 ( 6+)         JP      NZ,GETEXT5
CBF0-06 03           527 (  6) GETEXT6: LD     B,3
CBF2-23              528 (  4) GETEXT7: INC    HL
CBF3-36 00           529 (  9)         LD      (HL),0
CBF5-05              530 (  4)         DEC     B
CBF6-C2 F2 CB        531 ( 6+)         JP      NZ,GETEXT7
CBF9-EB              532 (  3)         EX      DE,HL
CBFA-22 88 C9        533 ( 20)         LD      (INPOINT),HL    ;save input line pointer.
CBFD-E1              534 (  9)         POP     HL
CBFE-                535       ;
CBFE-                536       ;   Check to see if this is an ambigeous file name specification.
CBFE-                537       ; Set the (A) register to non zero if it is.
CBFE-                538       ;
CBFE-01 0B 00        539 (  9)         LD      BC,11           ;set name length.
CC01-23              540 (  4) GETEXT8: INC    HL
CC02-7E              541 (  6)         LD      A,(HL)
CC03-FE 3F           542 (  6)         CP      '?'             ;any question marks?
CC05-C2 09 CC        543 ( 6+)         JP      NZ,GETEXT9
CC08-04              544 (  4)         INC     B               ;count them.
CC09-0D              545 (  4) GETEXT9: DEC    C
CC0A-C2 01 CC        546 ( 6+)         JP      NZ,GETEXT8
CC0D-78              547 (  4)         LD      A,B
CC0E-B7              548 (  4)         OR      A
CC0F-C9              549 (  9)         RET
CC10-                550       ;
CC10-                551       ;   CP/M command table. Note commands can be either 3 or 4 characters long.
CC10-                552       ;
0006-                553       NUMCMDS .EQU    6               ;number of commands
CC10-44 49 52 20     554       CMDTBL:         .DB     "DIR "
CC14-45 52 41 20     555               .DB     "ERA "
CC18-54 59 50 45     556               .DB     "TYPE"
CC1C-53 41 56 45     557               .DB     "SAVE"
CC20-52 45 4E 20     558               .DB     "REN "
CC24-55 53 45 52     559               .DB     "USER"
CC28-                560       ;
CC28-                561       ;   The following six bytes must agree with those at (PATTRN2)
CC28-                562       ; or cp/m will HALT. Why?
CC28-                563       ;
CC28-00 16 00 00 
     00 00           564       PATTRN1: .DB    0,22,0,0,0,0    ;(* serial number bytes *).
CC2E-                565       ;
CC2E-                566       ;   Search the command table for a match with what has just
CC2E-                567       ; been entered. If a match is found, then we jump to the
CC2E-                568       ; proper section. Else jump to (UNKNOWN).
CC2E-                569       ; On return, the (C) register is set to the command number
CC2E-                570       ; that matched (or NUMCMDS+1 if no match).
CC2E-                571       ;
CC2E-21 10 CC        572 (  9) SEARCH:         LD      HL,CMDTBL
CC31-0E 00           573 (  6)         LD      C,0
CC33-79              574 (  4) SEARCH1: LD     A,C
CC34-FE 06           575 (  6)         CP      NUMCMDS         ;this commands exists.
CC36-D0              576 ( 5+)         RET     NC
CC37-11 CE D0        577 (  9)         LD      DE,FCB+1        ;check this one.
CC3A-06 04           578 (  6)         LD      B,4             ;max command length.
CC3C-1A              579 (  6) SEARCH2: LD     A,(DE)
CC3D-BE              580 (  6)         CP      (HL)
CC3E-C2 4F CC        581 ( 6+)         JP      NZ,SEARCH3      ;not a match.
CC41-13              582 (  4)         INC     DE
CC42-23              583 (  4)         INC     HL
CC43-05              584 (  4)         DEC     B
CC44-C2 3C CC        585 ( 6+)         JP      NZ,SEARCH2
CC47-1A              586 (  6)         LD      A,(DE)          ;allow a 3 character command to match.
CC48-FE 20           587 (  6)         CP      ' '
CC4A-C2 54 CC        588 ( 6+)         JP      NZ,SEARCH4
CC4D-79              589 (  4)         LD      A,C             ;set return register for this command.
CC4E-C9              590 (  9)         RET
CC4F-23              591 (  4) SEARCH3: INC    HL
CC50-05              592 (  4)         DEC     B
CC51-C2 4F CC        593 ( 6+)         JP      NZ,SEARCH3
CC54-0C              594 (  4) SEARCH4: INC    C
CC55-C3 33 CC        595 (  9)         JP      SEARCH1
CC58-                596       ;
CC58-                597       ;   Set the input buffer to empty and then start the command
CC58-                598       ; processor (ccp).
CC58-                599       ;
CC58-AF              600 (  4) CLEARBUF:  XOR  A
CC59-32 07 C9        601 ( 13)         LD      (INBUFF+1),A    ;second byte is actual length.
CC5C-                602       ;
CC5C-                603       ;**************************************************************
CC5C-                604       ;*
CC5C-                605       ;*
CC5C-                606       ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
CC5C-                607       ;*
CC5C-                608       ;**************************************************************
CC5C-                609       ;*
CC5C-31 AB D0        610 (  9) COMMAND: LD     SP,CCPSTACK     ;setup stack area.
CC5F-C5              611 ( 11)         PUSH    BC              ;note that (C) should be equal to:
CC60-79              612 (  4)         LD      A,C             ;(uuuudddd) where 'uuuu' is the user number
CC61-1F              613 (  3)         RRA                     ;and 'dddd' is the drive number.
CC62-1F              614 (  3)         RRA
CC63-1F              615 (  3)         RRA
CC64-1F              616 (  3)         RRA
CC65-E6 0F           617 (  6)         AND     0FH             ;isolate the user number.
CC67-5F              618 (  4)         LD      E,A
CC68-CD 15 CA        619 ( 16)         CALL    GETSETUC        ;and set it.
CC6B-CD B8 C9        620 ( 16)         CALL    RESDSK          ;reset the disk system.
CC6E-32 AB D0        621 ( 13)         LD      (BATCH),A       ;clear batch mode flag.
CC71-C1              622 (  9)         POP     BC
CC72-79              623 (  4)         LD      A,C
CC73-E6 0F           624 (  6)         AND     0FH             ;isolate the drive number.
CC75-32 EF D0        625 ( 13)         LD      (CDRIVE),A      ;and save.
CC78-CD BD C9        626 ( 16)         CALL    DSKSEL          ;...and select.
CC7B-3A 07 C9        627 ( 12)         LD      A,(INBUFF+1)
CC7E-B7              628 (  4)         OR      A               ;anything in input buffer already?
CC7F-C2 98 CC        629 ( 6+)         JP      NZ,CMMND2       ;yes, we just process it.
CC82-                630       ;
CC82-                631       ;   Entry point to get a command line from the console.
CC82-                632       ;
CC82-31 AB D0        633 (  9) CMMND1:         LD      SP,CCPSTACK     ;set stack straight.
CC85-CD 98 C9        634 ( 16)         CALL    CRLF            ;start a new line on the screen.
CC88-CD D0 CA        635 ( 16)         CALL    GETDSK          ;get current drive.
CC8B-C6 41           636 (  6)         ADD     A,'A'
CC8D-CD 8C C9        637 ( 16)         CALL    PRINT           ;print current drive.
CC90-3E 3E           638 (  6)         LD      A,'>'
CC92-CD 8C C9        639 ( 16)         CALL    PRINT           ;and add prompt.
CC95-CD 39 CA        640 ( 16)         CALL    GETINP          ;get line from user.
CC98-                641       ;
CC98-                642       ;   Process command line here.
CC98-                643       ;
CC98-11 80 00        644 (  9) CMMND2:         LD      DE,TBUFF
CC9B-CD D8 CA        645 ( 16)         CALL    DMASET          ;set standard dma address.
CC9E-CD D0 CA        646 ( 16)         CALL    GETDSK
CCA1-32 EF D0        647 ( 13)         LD      (CDRIVE),A      ;set current drive.
CCA4-CD 5E CB        648 ( 16)         CALL    CONVFST         ;convert name typed in.
CCA7-C4 09 CB        649 ( 6+)         CALL    NZ,SYNERR       ;wild cards are not allowed.
CCAA-3A F0 D0        650 ( 12)         LD      A,(CHGDRV)      ;if a change in drives was indicated,
CCAD-B7              651 (  4)         OR      A               ;then treat this as an unknown command
CCAE-C2 A5 CF        652 ( 6+)         JP      NZ,UNKNOWN      ;which gets executed.
CCB1-CD 2E CC        653 ( 16)         CALL    SEARCH          ;else search command table for a match.
CCB4-                654       ;
CCB4-                655       ;   Note that an unknown command returns
CCB4-                656       ; with (A) pointing to the last address
CCB4-                657       ; in our table which is (UNKNOWN).
CCB4-                658       ;
CCB4-21 C1 CC        659 (  9)         LD      HL,CMDADR       ;now, look thru our address table for command (A).
CCB7-5F              660 (  4)         LD      E,A             ;set (DE) to command number.
CCB8-16 00           661 (  6)         LD      D,0
CCBA-19              662 (  7)         ADD     HL,DE
CCBB-19              663 (  7)         ADD     HL,DE           ;(HL)=(CMDADR)+2*(command number).
CCBC-7E              664 (  6)         LD      A,(HL)          ;now pick out this address.
CCBD-23              665 (  4)         INC     HL
CCBE-66              666 (  6)         LD      H,(HL)
CCBF-6F              667 (  4)         LD      L,A
CCC0-E9              668 (  3)         JP      (HL)            ;now execute it.
CCC1-                669       ;
CCC1-                670       ;   CP/M command address table.
CCC1-                671       ;
CCC1-77 CD 1F CE 
     5D CE AD CE     672       CMDADR:         .DW     DIRECT,ERASE,TYPE,SAVE
CCC9-10 CF 8E CF 
     A5 CF           673               .DW     RENAME,USER,UNKNOWN
CCCF-                674       ;
CCCF-                675       ;   Halt the system. Reason for this is unknown at present.
CCCF-                676       ;
CCCF-21 F3 76        677 (  9) HALT:   LD      HL,76F3H        ;'DI HLT' instructions.
CCD2-22 00 C9        678 ( 20)         LD      (CBASE),HL
CCD5-21 00 C9        679 (  9)         LD      HL,CBASE
CCD8-E9              680 (  3)         JP      (HL)
CCD9-                681       ;
CCD9-                682       ;   Read error while TYPEing a file.
CCD9-                683       ;
CCD9-01 DF CC        684 (  9) RDERROR: LD     BC,RDERR
CCDC-C3 A7 C9        685 (  9)         JP      PLINE
CCDF-52 65 61 64 
     20 65 72 72 
     6F 72           686       RDERR:  .DB     "Read error"
CCE9-00              687               .DB     0
CCEA-                688       ;
CCEA-                689       ;   Required file was not located.
CCEA-                690       ;
CCEA-01 F0 CC        691 (  9) NONE:   LD      BC,NOFILE
CCED-C3 A7 C9        692 (  9)         JP      PLINE
CCF0-4E 6F 20 66 
     69 6C 65        693       NOFILE:         .DB     "No file"
CCF7-00              694               .DB     0
CCF8-                695       ;
CCF8-                696       ;   Decode a command of the form 'A>filename number{ filename}.
CCF8-                697       ; Note that a drive specifier is not allowed on the first file
CCF8-                698       ; name. On return, the number is in register (A). Any error
CCF8-                699       ; causes 'filename?' to be printed and the command is aborted.
CCF8-                700       ;
CCF8-CD 5E CB        701 ( 16) DECODE:         CALL    CONVFST         ;convert filename.
CCFB-3A F0 D0        702 ( 12)         LD      A,(CHGDRV)      ;do not allow a drive to be specified.
CCFE-B7              703 (  4)         OR      A
CCFF-C2 09 CB        704 ( 6+)         JP      NZ,SYNERR
CD02-21 CE D0        705 (  9)         LD      HL,FCB+1        ;convert number now.
CD05-01 0B 00        706 (  9)         LD      BC,11           ;(B)=sum register, (C)=max digit count.
CD08-7E              707 (  6) DECODE1: LD     A,(HL)
CD09-FE 20           708 (  6)         CP      ' '             ;a space terminates the numeral.
CD0B-CA 33 CD        709 ( 6+)         JP      Z,DECODE3
CD0E-23              710 (  4)         INC     HL
CD0F-D6 30           711 (  6)         SUB     '0'             ;make binary from ascii.
CD11-FE 0A           712 (  6)         CP      10              ;legal digit?
CD13-D2 09 CB        713 ( 6+)         JP      NC,SYNERR
CD16-57              714 (  4)         LD      D,A             ;yes, save it in (D).
CD17-78              715 (  4)         LD      A,B             ;compute (B)=(B)*10 and check for overflow.
CD18-E6 E0           716 (  6)         AND     0E0H
CD1A-C2 09 CB        717 ( 6+)         JP      NZ,SYNERR
CD1D-78              718 (  4)         LD      A,B
CD1E-07              719 (  3)         RLCA
CD1F-07              720 (  3)         RLCA
CD20-07              721 (  3)         RLCA                    ;(A)=(B)*8
CD21-80              722 (  4)         ADD     A,B             ;.......*9
CD22-DA 09 CB        723 ( 6+)         JP      C,SYNERR
CD25-80              724 (  4)         ADD     A,B             ;.......*10
CD26-DA 09 CB        725 ( 6+)         JP      C,SYNERR
CD29-82              726 (  4)         ADD     A,D             ;add in new digit now.
CD2A-DA 09 CB        727 ( 6+) DECODE2: JP     C,SYNERR
CD2D-47              728 (  4)         LD      B,A             ;and save result.
CD2E-0D              729 (  4)         DEC     C               ;only look at 11 digits.
CD2F-C2 08 CD        730 ( 6+)         JP      NZ,DECODE1
CD32-C9              731 (  9)         RET
CD33-7E              732 (  6) DECODE3: LD     A,(HL)          ;spaces must follow (why?).
CD34-FE 20           733 (  6)         CP      ' '
CD36-C2 09 CB        734 ( 6+)         JP      NZ,SYNERR
CD39-23              735 (  4)         INC     HL
CD3A-0D              736 (  4) DECODE4: DEC    C
CD3B-C2 33 CD        737 ( 6+)         JP      NZ,DECODE3
CD3E-78              738 (  4)         LD      A,B             ;set (A)=the numeric value entered.
CD3F-C9              739 (  9)         RET
CD40-                740       ;
CD40-                741       ;   Move 3 bytes from (HL) to (DE). Note that there is only
CD40-                742       ; one reference to this at (A2D5h).
CD40-                743       ;
CD40-06 03           744 (  6) MOVE3:  LD      B,3
CD42-                745       ;
CD42-                746       ;   Move (B) bytes from (HL) to (DE).
CD42-                747       ;
CD42-7E              748 (  6) HL2DE:  LD      A,(HL)
CD43-12              749 (  7)         LD      (DE),A
CD44-23              750 (  4)         INC     HL
CD45-13              751 (  4)         INC     DE
CD46-05              752 (  4)         DEC     B
CD47-C2 42 CD        753 ( 6+)         JP      NZ,HL2DE
CD4A-C9              754 (  9)         RET
CD4B-                755       ;
CD4B-                756       ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
CD4B-                757       ;
CD4B-21 80 00        758 (  9) EXTRACT: LD     HL,TBUFF
CD4E-81              759 (  4)         ADD     A,C
CD4F-CD 59 CB        760 ( 16)         CALL    ADDHL
CD52-7E              761 (  6)         LD      A,(HL)
CD53-C9              762 (  9)         RET
CD54-                763       ;
CD54-                764       ;  Check drive specified. If it means a change, then the new
CD54-                765       ; drive will be selected. In any case, the drive byte of the
CD54-                766       ; fcb will be set to null (means use current drive).
CD54-                767       ;
CD54-AF              768 (  4) DSELECT: XOR    A               ;null out first byte of fcb.
CD55-32 CD D0        769 ( 13)         LD      (FCB),A
CD58-3A F0 D0        770 ( 12)         LD      A,(CHGDRV)      ;a drive change indicated?
CD5B-B7              771 (  4)         OR      A
CD5C-C8              772 ( 5+)         RET     Z
CD5D-3D              773 (  4)         DEC     A               ;yes, is it the same as the current drive?
CD5E-21 EF D0        774 (  9)         LD      HL,CDRIVE
CD61-BE              775 (  6)         CP      (HL)
CD62-C8              776 ( 5+)         RET     Z
CD63-C3 BD C9        777 (  9)         JP      DSKSEL          ;no. Select it then.
CD66-                778       ;
CD66-                779       ;   Check the drive selection and reset it to the previous
CD66-                780       ; drive if it was changed for the preceeding command.
CD66-                781       ;
CD66-3A F0 D0        782 ( 12) RESETDR: LD     A,(CHGDRV)      ;drive change indicated?
CD69-B7              783 (  4)         OR      A
CD6A-C8              784 ( 5+)         RET     Z
CD6B-3D              785 (  4)         DEC     A               ;yes, was it a different drive?
CD6C-21 EF D0        786 (  9)         LD      HL,CDRIVE
CD6F-BE              787 (  6)         CP      (HL)
CD70-C8              788 ( 5+)         RET     Z
CD71-3A EF D0        789 ( 12)         LD      A,(CDRIVE)      ;yes, re-select our old drive.
CD74-C3 BD C9        790 (  9)         JP      DSKSEL
CD77-                791       ;
CD77-                792       ;**************************************************************
CD77-                793       ;*
CD77-                794       ;*           D I R E C T O R Y   C O M M A N D
CD77-                795       ;*
CD77-                796       ;**************************************************************
CD77-                797       ;
CD77-CD 5E CB        798 ( 16) DIRECT:         CALL    CONVFST         ;convert file name.
CD7A-CD 54 CD        799 ( 16)         CALL    DSELECT         ;select indicated drive.
CD7D-21 CE D0        800 (  9)         LD      HL,FCB+1        ;was any file indicated?
CD80-7E              801 (  6)         LD      A,(HL)
CD81-FE 20           802 (  6)         CP      ' '
CD83-C2 8F CD        803 ( 6+)         JP      NZ,DIRECT2
CD86-06 0B           804 (  6)         LD      B,11            ;no. Fill field with '?' - same as *.*.
CD88-36 3F           805 (  9) DIRECT1: LD     (HL),'?'
CD8A-23              806 (  4)         INC     HL
CD8B-05              807 (  4)         DEC     B
CD8C-C2 88 CD        808 ( 6+)         JP      NZ,DIRECT1
CD8F-1E 00           809 (  6) DIRECT2: LD     E,0             ;set initial cursor position.
CD91-D5              810 ( 11)         PUSH    DE
CD92-CD E9 C9        811 ( 16)         CALL    SRCHFCB         ;get first file name.
CD95-CC EA CC        812 ( 6+)         CALL    Z,NONE          ;none found at all?
CD98-CA 1B CE        813 ( 6+) DIRECT3: JP     Z,DIRECT9       ;terminate if no more names.
CD9B-3A EE D0        814 ( 12)         LD      A,(RTNCODE)     ;get file's position in segment (0-3).
CD9E-0F              815 (  3)         RRCA
CD9F-0F              816 (  3)         RRCA
CDA0-0F              817 (  3)         RRCA
CDA1-E6 60           818 (  6)         AND     60H             ;(A)=position*32
CDA3-4F              819 (  4)         LD      C,A
CDA4-3E 0A           820 (  6)         LD      A,10
CDA6-CD 4B CD        821 ( 16)         CALL    EXTRACT         ;extract the tenth entry in fcb.
CDA9-17              822 (  3)         RLA                     ;check system file status bit.
CDAA-DA 0F CE        823 ( 6+)         JP      C,DIRECT8       ;we don't list them.
CDAD-D1              824 (  9)         POP     DE
CDAE-7B              825 (  4)         LD      A,E             ;bump name count.
CDAF-1C              826 (  4)         INC     E
CDB0-D5              827 ( 11)         PUSH    DE
CDB1-E6 03           828 (  6)         AND     03H             ;at end of line?
CDB3-F5              829 ( 11)         PUSH    AF
CDB4-C2 CC CD        830 ( 6+)         JP      NZ,DIRECT4
CDB7-CD 98 C9        831 ( 16)         CALL    CRLF            ;yes, end this line and start another.
CDBA-C5              832 ( 11)         PUSH    BC
CDBB-CD D0 CA        833 ( 16)         CALL    GETDSK          ;start line with ('A: ').
CDBE-C1              834 (  9)         POP     BC
CDBF-C6 41           835 (  6)         ADD     A,'A'
CDC1-CD 92 C9        836 ( 16)         CALL    PRINTB
CDC4-3E 3A           837 (  6)         LD      A,': '
CDC6-CD 92 C9        838 ( 16)         CALL    PRINTB
CDC9-C3 D4 CD        839 (  9)         JP      DIRECT5
CDCC-CD A2 C9        840 ( 16) DIRECT4: CALL   SPACE           ;add seperator between file names.
CDCF-3E 3A           841 (  6)         LD      A,': '
CDD1-CD 92 C9        842 ( 16)         CALL    PRINTB
CDD4-CD A2 C9        843 ( 16) DIRECT5: CALL   SPACE
CDD7-06 01           844 (  6)         LD      B,1             ;'extract' each file name character at a time.
CDD9-78              845 (  4) DIRECT6: LD     A,B
CDDA-CD 4B CD        846 ( 16)         CALL    EXTRACT
CDDD-E6 7F           847 (  6)         AND     7FH             ;strip bit 7 (status bit).
CDDF-FE 20           848 (  6)         CP      ' '             ;are we at the end of the name?
CDE1-C2 F9 CD        849 ( 6+)         JP      NZ,DRECT65
CDE4-F1              850 (  9)         POP     AF              ;yes, don't print spaces at the end of a line.
CDE5-F5              851 ( 11)         PUSH    AF
CDE6-FE 03           852 (  6)         CP      3
CDE8-C2 F7 CD        853 ( 6+)         JP      NZ,DRECT63
CDEB-3E 09           854 (  6)         LD      A,9             ;first check for no extension.
CDED-CD 4B CD        855 ( 16)         CALL    EXTRACT
CDF0-E6 7F           856 (  6)         AND     7FH
CDF2-FE 20           857 (  6)         CP      ' '
CDF4-CA 0E CE        858 ( 6+)         JP      Z,DIRECT7       ;don't print spaces.
CDF7-3E 20           859 (  6) DRECT63: LD     A,' '           ;else print them.
CDF9-CD 92 C9        860 ( 16) DRECT65: CALL   PRINTB
CDFC-04              861 (  4)         INC     B               ;bump to next character psoition.
CDFD-78              862 (  4)         LD      A,B
CDFE-FE 0C           863 (  6)         CP      12              ;end of the name?
CE00-D2 0E CE        864 ( 6+)         JP      NC,DIRECT7
CE03-FE 09           865 (  6)         CP      9               ;nope, starting extension?
CE05-C2 D9 CD        866 ( 6+)         JP      NZ,DIRECT6
CE08-CD A2 C9        867 ( 16)         CALL    SPACE           ;yes, add seperating space.
CE0B-C3 D9 CD        868 (  9)         JP      DIRECT6
CE0E-F1              869 (  9) DIRECT7: POP    AF              ;get the next file name.
CE0F-CD C2 CA        870 ( 16) DIRECT8: CALL   CHKCON          ;first check console, quit on anything.
CE12-C2 1B CE        871 ( 6+)         JP      NZ,DIRECT9
CE15-CD E4 C9        872 ( 16)         CALL    SRCHNXT         ;get next name.
CE18-C3 98 CD        873 (  9)         JP      DIRECT3         ;and continue with our list.
CE1B-D1              874 (  9) DIRECT9: POP    DE              ;restore the stack and return to command level.
CE1C-C3 86 D0        875 (  9)         JP      GETBACK
CE1F-                876       ;
CE1F-                877       ;**************************************************************
CE1F-                878       ;*
CE1F-                879       ;*                E R A S E   C O M M A N D
CE1F-                880       ;*
CE1F-                881       ;**************************************************************
CE1F-                882       ;
CE1F-CD 5E CB        883 ( 16) ERASE:  CALL    CONVFST         ;convert file name.
CE22-FE 0B           884 (  6)         CP      11              ;was '*.*' entered?
CE24-C2 42 CE        885 ( 6+)         JP      NZ,ERASE1
CE27-01 52 CE        886 (  9)         LD      BC,YESNO        ;yes, ask for confirmation.
CE2A-CD A7 C9        887 ( 16)         CALL    PLINE
CE2D-CD 39 CA        888 ( 16)         CALL    GETINP
CE30-21 07 C9        889 (  9)         LD      HL,INBUFF+1
CE33-35              890 ( 10)         DEC     (HL)            ;must be exactly 'y'.
CE34-C2 82 CC        891 ( 6+)         JP      NZ,CMMND1
CE37-23              892 (  4)         INC     HL
CE38-7E              893 (  6)         LD      A,(HL)
CE39-FE 59           894 (  6)         CP      'Y'
CE3B-C2 82 CC        895 ( 6+)         JP      NZ,CMMND1
CE3E-23              896 (  4)         INC     HL
CE3F-22 88 C9        897 ( 20)         LD      (INPOINT),HL    ;save input line pointer.
CE42-CD 54 CD        898 ( 16) ERASE1:         CALL    DSELECT         ;select desired disk.
CE45-11 CD D0        899 (  9)         LD      DE,FCB
CE48-CD EF C9        900 ( 16)         CALL    DELETE          ;delete the file.
CE4B-3C              901 (  4)         INC     A
CE4C-CC EA CC        902 ( 6+)         CALL    Z,NONE          ;not there?
CE4F-C3 86 D0        903 (  9)         JP      GETBACK         ;return to command level now.
CE52-41 6C 6C 20 
     28 79 2F 6E 
     29 3F           904       YESNO:  .DB     "All (y/n)?"
CE5C-00              905               .DB     0
CE5D-                906       ;
CE5D-                907       ;**************************************************************
CE5D-                908       ;*
CE5D-                909       ;*            T Y P E   C O M M A N D
CE5D-                910       ;*
CE5D-                911       ;**************************************************************
CE5D-                912       ;
CE5D-CD 5E CB        913 ( 16) TYPE:   CALL    CONVFST         ;convert file name.
CE60-C2 09 CB        914 ( 6+)         JP      NZ,SYNERR       ;wild cards not allowed.
CE63-CD 54 CD        915 ( 16)         CALL    DSELECT         ;select indicated drive.
CE66-CD D0 C9        916 ( 16)         CALL    OPENFCB         ;open the file.
CE69-CA A7 CE        917 ( 6+)         JP      Z,TYPE5         ;not there?
CE6C-CD 98 C9        918 ( 16)         CALL    CRLF            ;ok, start a new line on the screen.
CE6F-21 F1 D0        919 (  9)         LD      HL,NBYTES       ;initialize byte counter.
CE72-36 FF           920 (  9)         LD      (HL),0FFH       ;set to read first sector.
CE74-21 F1 D0        921 (  9) TYPE1:  LD      HL,NBYTES
CE77-7E              922 (  6) TYPE2:  LD      A,(HL)          ;have we written the entire sector?
CE78-FE 80           923 (  6)         CP      128
CE7A-DA 87 CE        924 ( 6+)         JP      C,TYPE3
CE7D-E5              925 ( 11)         PUSH    HL              ;yes, read in the next one.
CE7E-CD FE C9        926 ( 16)         CALL    READFCB
CE81-E1              927 (  9)         POP     HL
CE82-C2 A0 CE        928 ( 6+)         JP      NZ,TYPE4        ;end or error?
CE85-AF              929 (  4)         XOR     A               ;ok, clear byte counter.
CE86-77              930 (  7)         LD      (HL),A
CE87-34              931 ( 10) TYPE3:  INC     (HL)            ;count this byte.
CE88-21 80 00        932 (  9)         LD      HL,TBUFF        ;and get the (A)th one from the buffer (TBUFF).
CE8B-CD 59 CB        933 ( 16)         CALL    ADDHL
CE8E-7E              934 (  6)         LD      A,(HL)
CE8F-FE 1A           935 (  6)         CP      CNTRLZ          ;end of file mark?
CE91-CA 86 D0        936 ( 6+)         JP      Z,GETBACK
CE94-CD 8C C9        937 ( 16)         CALL    PRINT           ;no, print it.
CE97-CD C2 CA        938 ( 16)         CALL    CHKCON          ;check console, quit if anything ready.
CE9A-C2 86 D0        939 ( 6+)         JP      NZ,GETBACK
CE9D-C3 74 CE        940 (  9)         JP      TYPE1
CEA0-                941       ;
CEA0-                942       ;   Get here on an end of file or read error.
CEA0-                943       ;
CEA0-3D              944 (  4) TYPE4:  DEC     A               ;read error?
CEA1-CA 86 D0        945 ( 6+)         JP      Z,GETBACK
CEA4-CD D9 CC        946 ( 16)         CALL    RDERROR         ;yes, print message.
CEA7-CD 66 CD        947 ( 16) TYPE5:  CALL    RESETDR         ;and reset proper drive
CEAA-C3 09 CB        948 (  9)         JP      SYNERR          ;now print file name with problem.
CEAD-                949       ;
CEAD-                950       ;**************************************************************
CEAD-                951       ;*
CEAD-                952       ;*            S A V E   C O M M A N D
CEAD-                953       ;*
CEAD-                954       ;**************************************************************
CEAD-                955       ;
CEAD-CD F8 CC        956 ( 16) SAVE:   CALL    DECODE          ;get numeric number that follows SAVE.
CEB0-F5              957 ( 11)         PUSH    AF              ;save number of pages to write.
CEB1-CD 5E CB        958 ( 16)         CALL    CONVFST         ;convert file name.
CEB4-C2 09 CB        959 ( 6+)         JP      NZ,SYNERR       ;wild cards not allowed.
CEB7-CD 54 CD        960 ( 16)         CALL    DSELECT         ;select specified drive.
CEBA-11 CD D0        961 (  9)         LD      DE,FCB          ;now delete this file.
CEBD-D5              962 ( 11)         PUSH    DE
CEBE-CD EF C9        963 ( 16)         CALL    DELETE
CEC1-D1              964 (  9)         POP     DE
CEC2-CD 09 CA        965 ( 16)         CALL    CREATE          ;and create it again.
CEC5-CA FB CE        966 ( 6+)         JP      Z,SAVE3         ;can't create?
CEC8-AF              967 (  4)         XOR     A               ;clear record number byte.
CEC9-32 ED D0        968 ( 13)         LD      (FCB+32),A
CECC-F1              969 (  9)         POP     AF              ;convert pages to sectors.
CECD-6F              970 (  4)         LD      L,A
CECE-26 00           971 (  6)         LD      H,0
CED0-29              972 (  7)         ADD     HL,HL           ;(HL)=number of sectors to write.
CED1-11 00 01        973 (  9)         LD      DE,TBASE        ;and we start from here.
CED4-7C              974 (  4) SAVE1:  LD      A,H             ;done yet?
CED5-B5              975 (  4)         OR      L
CED6-CA F1 CE        976 ( 6+)         JP      Z,SAVE2
CED9-2B              977 (  4)         DEC     HL              ;nope, count this and compute the start
CEDA-E5              978 ( 11)         PUSH    HL              ;of the next 128 byte sector.
CEDB-21 80 00        979 (  9)         LD      HL,128
CEDE-19              980 (  7)         ADD     HL,DE
CEDF-E5              981 ( 11)         PUSH    HL              ;save it and set the transfer address.
CEE0-CD D8 CA        982 ( 16)         CALL    DMASET
CEE3-11 CD D0        983 (  9)         LD      DE,FCB          ;write out this sector now.
CEE6-CD 04 CA        984 ( 16)         CALL    WRTREC
CEE9-D1              985 (  9)         POP     DE              ;reset (DE) to the start of the last sector.
CEEA-E1              986 (  9)         POP     HL              ;restore sector count.
CEEB-C2 FB CE        987 ( 6+)         JP      NZ,SAVE3        ;write error?
CEEE-C3 D4 CE        988 (  9)         JP      SAVE1
CEF1-                989       ;
CEF1-                990       ;   Get here after writing all of the file.
CEF1-                991       ;
CEF1-11 CD D0        992 (  9) SAVE2:  LD      DE,FCB          ;now close the file.
CEF4-CD DA C9        993 ( 16)         CALL    CLOSE
CEF7-3C              994 (  4)         INC     A               ;did it close ok?
CEF8-C2 01 CF        995 ( 6+)         JP      NZ,SAVE4
CEFB-                996       ;
CEFB-                997       ;   Print out error message (no space).
CEFB-                998       ;
CEFB-01 07 CF        999 (  9) SAVE3:  LD      BC,NOSPACE
CEFE-CD A7 C9       1000 ( 16)         CALL    PLINE
CF01-CD D5 CA       1001 ( 16) SAVE4:  CALL    STDDMA          ;reset the standard dma address.
CF04-C3 86 D0       1002 (  9)         JP      GETBACK
CF07-4E 6F 20 73 
     70 61 63 65    1003       NOSPACE: .DB    "No space"
CF0F-00             1004               .DB     0
CF10-               1005       ;
CF10-               1006       ;**************************************************************
CF10-               1007       ;*
CF10-               1008       ;*           R E N A M E   C O M M A N D
CF10-               1009       ;*
CF10-               1010       ;**************************************************************
CF10-               1011       ;
CF10-CD 5E CB       1012 ( 16) RENAME:         CALL    CONVFST         ;convert first file name.
CF13-C2 09 CB       1013 ( 6+)         JP      NZ,SYNERR       ;wild cards not allowed.
CF16-3A F0 D0       1014 ( 12)         LD      A,(CHGDRV)      ;remember any change in drives specified.
CF19-F5             1015 ( 11)         PUSH    AF
CF1A-CD 54 CD       1016 ( 16)         CALL    DSELECT         ;and select this drive.
CF1D-CD E9 C9       1017 ( 16)         CALL    SRCHFCB         ;is this file present?
CF20-C2 79 CF       1018 ( 6+)         JP      NZ,RENAME6      ;yes, print error message.
CF23-21 CD D0       1019 (  9)         LD      HL,FCB          ;yes, move this name into second slot.
CF26-11 DD D0       1020 (  9)         LD      DE,FCB+16
CF29-06 10          1021 (  6)         LD      B,16
CF2B-CD 42 CD       1022 ( 16)         CALL    HL2DE
CF2E-2A 88 C9       1023 ( 15)         LD      HL,(INPOINT)    ;get input pointer.
CF31-EB             1024 (  3)         EX      DE,HL
CF32-CD 4F CB       1025 ( 16)         CALL    NONBLANK        ;get next non blank character.
CF35-FE 3D          1026 (  6)         CP      '='             ;only allow an '=' or '_' seperator.
CF37-CA 3F CF       1027 ( 6+)         JP      Z,RENAME1
CF3A-FE 5F          1028 (  6)         CP      '_'
CF3C-C2 73 CF       1029 ( 6+)         JP      NZ,RENAME5
CF3F-EB             1030 (  3) RENAME1: EX     DE,HL
CF40-23             1031 (  4)         INC     HL              ;ok, skip seperator.
CF41-22 88 C9       1032 ( 20)         LD      (INPOINT),HL    ;save input line pointer.
CF44-CD 5E CB       1033 ( 16)         CALL    CONVFST         ;convert this second file name now.
CF47-C2 73 CF       1034 ( 6+)         JP      NZ,RENAME5      ;again, no wild cards.
CF4A-F1             1035 (  9)         POP     AF              ;if a drive was specified, then it
CF4B-47             1036 (  4)         LD      B,A             ;must be the same as before.
CF4C-21 F0 D0       1037 (  9)         LD      HL,CHGDRV
CF4F-7E             1038 (  6)         LD      A,(HL)
CF50-B7             1039 (  4)         OR      A
CF51-CA 59 CF       1040 ( 6+)         JP      Z,RENAME2
CF54-B8             1041 (  4)         CP      B
CF55-70             1042 (  7)         LD      (HL),B
CF56-C2 73 CF       1043 ( 6+)         JP      NZ,RENAME5      ;they were different, error.
CF59-70             1044 (  7) RENAME2: LD     (HL),B          ;       reset as per the first file specification.
CF5A-AF             1045 (  4)         XOR     A
CF5B-32 CD D0       1046 ( 13)         LD      (FCB),A         ;clear the drive byte of the fcb.
CF5E-CD E9 C9       1047 ( 16) RENAME3: CALL   SRCHFCB         ;and go look for second file.
CF61-CA 6D CF       1048 ( 6+)         JP      Z,RENAME4       ;doesn't exist?
CF64-11 CD D0       1049 (  9)         LD      DE,FCB
CF67-CD 0E CA       1050 ( 16)         CALL    RENAM           ;ok, rename the file.
CF6A-C3 86 D0       1051 (  9)         JP      GETBACK
CF6D-               1052       ;
CF6D-               1053       ;   Process rename errors here.
CF6D-               1054       ;
CF6D-CD EA CC       1055 ( 16) RENAME4: CALL   NONE            ;file not there.
CF70-C3 86 D0       1056 (  9)         JP      GETBACK
CF73-CD 66 CD       1057 ( 16) RENAME5: CALL   RESETDR         ;bad command format.
CF76-C3 09 CB       1058 (  9)         JP      SYNERR
CF79-01 82 CF       1059 (  9) RENAME6: LD     BC,EXISTS       ;destination file already exists.
CF7C-CD A7 C9       1060 ( 16)         CALL    PLINE
CF7F-C3 86 D0       1061 (  9)         JP      GETBACK
CF82-46 69 6C 65 
     20 65 78 69 
     73 74 73       1062       EXISTS:         .DB     "File exists"
CF8D-00             1063               .DB     0
CF8E-               1064       ;
CF8E-               1065       ;**************************************************************
CF8E-               1066       ;*
CF8E-               1067       ;*             U S E R   C O M M A N D
CF8E-               1068       ;*
CF8E-               1069       ;**************************************************************
CF8E-               1070       ;
CF8E-CD F8 CC       1071 ( 16) USER:   CALL    DECODE          ;get numeric value following command.
CF91-FE 10          1072 (  6)         CP      16              ;legal user number?
CF93-D2 09 CB       1073 ( 6+)         JP      NC,SYNERR
CF96-5F             1074 (  4)         LD      E,A             ;yes but is there anything else?
CF97-3A CE D0       1075 ( 12)         LD      A,(FCB+1)
CF9A-FE 20          1076 (  6)         CP      ' '
CF9C-CA 09 CB       1077 ( 6+)         JP      Z,SYNERR        ;yes, that is not allowed.
CF9F-CD 15 CA       1078 ( 16)         CALL    GETSETUC        ;ok, set user code.
CFA2-C3 89 D0       1079 (  9)         JP      GETBACK1
CFA5-               1080       ;
CFA5-               1081       ;**************************************************************
CFA5-               1082       ;*
CFA5-               1083       ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
CFA5-               1084       ;*
CFA5-               1085       ;**************************************************************
CFA5-               1086       ;
CFA5-CD F5 CA       1087 ( 16) UNKNOWN: CALL   VERIFY          ;check for valid system (why?).
CFA8-3A CE D0       1088 ( 12)         LD      A,(FCB+1)       ;anything to execute?
CFAB-FE 20          1089 (  6)         CP      ' '
CFAD-C2 C4 CF       1090 ( 6+)         JP      NZ,UNKWN1
CFB0-3A F0 D0       1091 ( 12)         LD      A,(CHGDRV)      ;nope, only a drive change?
CFB3-B7             1092 (  4)         OR      A
CFB4-CA 89 D0       1093 ( 6+)         JP      Z,GETBACK1      ;neither???
CFB7-3D             1094 (  4)         DEC     A
CFB8-32 EF D0       1095 ( 13)         LD      (CDRIVE),A      ;ok, store new drive.
CFBB-CD 29 CA       1096 ( 16)         CALL    MOVECD          ;set (TDRIVE) also.
CFBE-CD BD C9       1097 ( 16)         CALL    DSKSEL          ;and select this drive.
CFC1-C3 89 D0       1098 (  9)         JP      GETBACK1        ;then return.
CFC4-               1099       ;
CFC4-               1100       ;   Here a file name was typed. Prepare to execute it.
CFC4-               1101       ;
CFC4-11 D6 D0       1102 (  9) UNKWN1:         LD      DE,FCB+9        ;an extension specified?
CFC7-1A             1103 (  6)         LD      A,(DE)
CFC8-FE 20          1104 (  6)         CP      ' '
CFCA-C2 09 CB       1105 ( 6+)         JP      NZ,SYNERR       ;yes, not allowed.
CFCD-D5             1106 ( 11) UNKWN2:         PUSH    DE
CFCE-CD 54 CD       1107 ( 16)         CALL    DSELECT         ;select specified drive.
CFD1-D1             1108 (  9)         POP     DE
CFD2-21 83 D0       1109 (  9)         LD      HL,COMFILE      ;set the extension to 'COM'.
CFD5-CD 40 CD       1110 ( 16)         CALL    MOVE3
CFD8-CD D0 C9       1111 ( 16)         CALL    OPENFCB         ;and open this file.
CFDB-CA 6B D0       1112 ( 6+)         JP      Z,UNKWN9        ;not present?
CFDE-               1113       ;
CFDE-               1114       ;   Load in the program.
CFDE-               1115       ;
CFDE-21 00 01       1116 (  9)         LD      HL,TBASE        ;store the program starting here.
CFE1-E5             1117 ( 11) UNKWN3:         PUSH    HL
CFE2-EB             1118 (  3)         EX      DE,HL
CFE3-CD D8 CA       1119 ( 16)         CALL    DMASET          ;set transfer address.
CFE6-11 CD D0       1120 (  9)         LD      DE,FCB          ;and read the next record.
CFE9-CD F9 C9       1121 ( 16)         CALL    RDREC
CFEC-C2 01 D0       1122 ( 6+)         JP      NZ,UNKWN4       ;end of file or read error?
CFEF-E1             1123 (  9)         POP     HL              ;nope, bump pointer for next sector.
CFF0-11 80 00       1124 (  9)         LD      DE,128
CFF3-19             1125 (  7)         ADD     HL,DE
CFF4-11 00 C9       1126 (  9)         LD      DE,CBASE        ;enough room for the whole file?
CFF7-7D             1127 (  4)         LD      A,L
CFF8-93             1128 (  4)         SUB     E
CFF9-7C             1129 (  4)         LD      A,H
CFFA-9A             1130 (  4)         SBC     A,D
CFFB-D2 71 D0       1131 ( 6+)         JP      NC,UNKWN0       ;no, it can't fit.
CFFE-C3 E1 CF       1132 (  9)         JP      UNKWN3
D001-               1133       ;
D001-               1134       ;   Get here after finished reading.
D001-               1135       ;
D001-E1             1136 (  9) UNKWN4:         POP     HL
D002-3D             1137 (  4)         DEC     A               ;normal end of file?
D003-C2 71 D0       1138 ( 6+)         JP      NZ,UNKWN0
D006-CD 66 CD       1139 ( 16)         CALL    RESETDR         ;yes, reset previous drive.
D009-CD 5E CB       1140 ( 16)         CALL    CONVFST         ;convert the first file name that follows
D00C-21 F0 D0       1141 (  9)         LD      HL,CHGDRV       ;command name.
D00F-E5             1142 ( 11)         PUSH    HL
D010-7E             1143 (  6)         LD      A,(HL)          ;set drive code in default fcb.
D011-32 CD D0       1144 ( 13)         LD      (FCB),A
D014-3E 10          1145 (  6)         LD      A,16            ;put second name 16 bytes later.
D016-CD 60 CB       1146 ( 16)         CALL    CONVERT         ;convert second file name.
D019-E1             1147 (  9)         POP     HL
D01A-7E             1148 (  6)         LD      A,(HL)          ;and set the drive for this second file.
D01B-32 DD D0       1149 ( 13)         LD      (FCB+16),A
D01E-AF             1150 (  4)         XOR     A               ;clear record byte in fcb.
D01F-32 ED D0       1151 ( 13)         LD      (FCB+32),A
D022-11 5C 00       1152 (  9)         LD      DE,TFCB         ;move it into place at(005Ch).
D025-21 CD D0       1153 (  9)         LD      HL,FCB
D028-06 21          1154 (  6)         LD      B,33
D02A-CD 42 CD       1155 ( 16)         CALL    HL2DE
D02D-21 08 C9       1156 (  9)         LD      HL,INBUFF+2     ;now move the remainder of the input
D030-7E             1157 (  6) UNKWN5:         LD      A,(HL)          ;line down to (0080h). Look for a non blank.
D031-B7             1158 (  4)         OR      A               ;or a null.
D032-CA 3E D0       1159 ( 6+)         JP      Z,UNKWN6
D035-FE 20          1160 (  6)         CP      ' '
D037-CA 3E D0       1161 ( 6+)         JP      Z,UNKWN6
D03A-23             1162 (  4)         INC     HL
D03B-C3 30 D0       1163 (  9)         JP      UNKWN5
D03E-               1164       ;
D03E-               1165       ;   Do the line move now. It ends in a null byte.
D03E-               1166       ;
D03E-06 00          1167 (  6) UNKWN6:         LD      B,0             ;keep a character count.
D040-11 81 00       1168 (  9)         LD      DE,TBUFF+1      ;data gets put here.
D043-7E             1169 (  6) UNKWN7:         LD      A,(HL)          ;move it now.
D044-12             1170 (  7)         LD      (DE),A
D045-B7             1171 (  4)         OR      A
D046-CA 4F D0       1172 ( 6+)         JP      Z,UNKWN8
D049-04             1173 (  4)         INC     B
D04A-23             1174 (  4)         INC     HL
D04B-13             1175 (  4)         INC     DE
D04C-C3 43 D0       1176 (  9)         JP      UNKWN7
D04F-78             1177 (  4) UNKWN8:         LD      A,B             ;now store the character count.
D050-32 80 00       1178 ( 13)         LD      (TBUFF),A
D053-CD 98 C9       1179 ( 16)         CALL    CRLF            ;clean up the screen.
D056-CD D5 CA       1180 ( 16)         CALL    STDDMA          ;set standard transfer address.
D059-CD 1A CA       1181 ( 16)         CALL    SETCDRV         ;reset current drive.
D05C-CD 00 01       1182 ( 16)         CALL    TBASE           ;and execute the program.
D05F-               1183       ;
D05F-               1184       ;   Transiant programs return here (or reboot).
D05F-               1185       ;
D05F-31 AB D0       1186 (  9)         LD      SP,BATCH        ;set stack first off.
D062-CD 29 CA       1187 ( 16)         CALL    MOVECD          ;move current drive into place (TDRIVE).
D065-CD BD C9       1188 ( 16)         CALL    DSKSEL          ;and reselect it.
D068-C3 82 CC       1189 (  9)         JP      CMMND1          ;back to comand mode.
D06B-               1190       ;
D06B-               1191       ;   Get here if some error occured.
D06B-               1192       ;
D06B-CD 66 CD       1193 ( 16) UNKWN9:         CALL    RESETDR         ;inproper format.
D06E-C3 09 CB       1194 (  9)         JP      SYNERR
D071-01 7A D0       1195 (  9) UNKWN0:         LD      BC,BADLOAD      ;read error or won't fit.
D074-CD A7 C9       1196 ( 16)         CALL    PLINE
D077-C3 86 D0       1197 (  9)         JP      GETBACK
D07A-42 61 64 20 
     6C 6F 61 64    1198       BADLOAD: .DB    "Bad load"
D082-00             1199               .DB     0
D083-43 4F 4D       1200       COMFILE: .DB    "COM"           ;command file extension.
D086-               1201       ;
D086-               1202       ;   Get here to return to command level. We will reset the
D086-               1203       ; previous active drive and then either return to command
D086-               1204       ; level directly or print error message and then return.
D086-               1205       ;
D086-CD 66 CD       1206 ( 16) GETBACK: CALL   RESETDR         ;reset previous drive.
D089-CD 5E CB       1207 ( 16) GETBACK1:  CALL CONVFST         ;convert first name in (FCB).
D08C-3A CE D0       1208 ( 12)         LD      A,(FCB+1)       ;if this was just a drive change request,
D08F-D6 20          1209 (  6)         SUB     ' '             ;make sure it was valid.
D091-21 F0 D0       1210 (  9)         LD      HL,CHGDRV
D094-B6             1211 (  6)         OR      (HL)
D095-C2 09 CB       1212 ( 6+)         JP      NZ,SYNERR
D098-C3 82 CC       1213 (  9)         JP      CMMND1          ;ok, return to command level.
D09B-               1214       ;
D09B-               1215       ;   ccp stack area.
D09B-               1216       ;
D09B-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00    1217               .DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D0AB-               1218       CCPSTACK .EQU   $       ;end of ccp stack area.
D0AB-               1219       ;
D0AB-               1220       ;   Batch (or SUBMIT) processing information storage.
D0AB-               1221       ;
D0AB-00             1222       BATCH:  .DB     0               ;batch mode flag (0=not active).
D0AC-00             1223       BATCHFCB:  .DB  0
D0AD-24 24 24 20 
     20 20 20 20 
     53 55 42       1224               .DB "$$$     SUB"
D0B8-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00             1225               .DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D0CD-               1226       ;
D0CD-               1227       ;   File control block setup by the CCP.
D0CD-               1228       ;
D0CD-00             1229       FCB:    .DB     0
D0CE-20 20 20 20 
     20 20 20 20 
     20 20 20       1230               .DB     "           "
D0D9-00 00 00 00 
     00             1231               .DB     0,0,0,0,0
D0DE-20 20 20 20 
     20 20 20 20 
     20 20 20       1232               .DB     "           "
D0E9-00 00 00 00 
     00             1233               .DB     0,0,0,0,0
D0EE-00             1234       RTNCODE: .DB    0               ;status returned from bdos call.
D0EF-00             1235       CDRIVE:         .DB     0               ;currently active drive.
D0F0-00             1236       CHGDRV:         .DB     0               ;change in drives flag (0=no change).
D0F1-00 00          1237       NBYTES:         .DW     0               ;byte counter used by TYPE.
D0F3-               1238       ;
D0F3-               1239       ;   Room for expansion?
D0F3-               1240       ;
D0F3-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00             1241               .DB     0,0,0,0,0,0,0,0,0,0,0,0,0
D100-               1242       ;
D100-               1243       ;   Note that the following six bytes must match those at
D100-               1244       ; (PATTRN1) or cp/m will HALT. Why?
D100-               1245       ;
D100-00 16 00 00 
     00 00          1246       PATTRN2: .DB    0,22,0,0,0,0    ;(* serial number bytes *).
D106-               1247       ;
D106-               1248       ;**************************************************************
D106-               1249       ;*
D106-               1250       ;*                    B D O S   E N T R Y
D106-               1251       ;*
D106-               1252       ;**************************************************************
D106-               1253       ;
D106-C3 11 D1       1254 (  9) FBASE:  JP      FBASE1
D109-               1255       ;
D109-               1256       ;   Bdos error table.
D109-               1257       ;
D109-99 D1          1258       BADSCTR: .DW    ERROR1          ;bad sector on read or write.
D10B-A5 D1          1259       BADSLCT: .DW    ERROR2          ;bad disk select.
D10D-AB D1          1260       RODISK:         .DW     ERROR3          ;disk is read only.
D10F-B1 D1          1261       ROFILE:         .DW     ERROR4          ;file is read only.
D111-               1262       ;
D111-               1263       ;   Entry into bdos. (DE) or (E) are the parameters passed. The
D111-               1264       ; function number desired is in register (C).
D111-               1265       ;
D111-EB             1266 (  3) FBASE1:         EX      DE,HL           ;save the (DE) parameters.
D112-22 44 D4       1267 ( 20)         LD      (PARAMS),HL
D115-EB             1268 (  3)         EX      DE,HL
D116-7B             1269 (  4)         LD      A,E             ;and save register (E) in particular.
D117-32 D7 DE       1270 ( 13)         LD      (EPARAM),A
D11A-21 00 00       1271 (  9)         LD      HL,0
D11D-22 46 D4       1272 ( 20)         LD      (STATUS),HL     ;clear return status.
D120-39             1273 (  7)         ADD     HL,SP
D121-22 10 D4       1274 ( 20)         LD      (USRSTACK),HL   ;save users stack pointer.
D124-31 42 D4       1275 (  9)         LD      SP,STKAREA      ;and set our own.
D127-AF             1276 (  4)         XOR     A               ;clear auto select storage space.
D128-32 E1 DE       1277 ( 13)         LD      (AUTOFLAG),A
D12B-32 DF DE       1278 ( 13)         LD      (AUTO),A
D12E-21 75 DE       1279 (  9)         LD      HL,GOBACK       ;set return address.
D131-E5             1280 ( 11)         PUSH    HL
D132-79             1281 (  4)         LD      A,C             ;get function number.
D133-FE 29          1282 (  6)         CP      NFUNCTS         ;valid function number?
D135-D0             1283 ( 5+)         RET     NC
D136-4B             1284 (  4)         LD      C,E             ;keep single register function here.
D137-21 47 D1       1285 (  9)         LD      HL,FUNCTNS      ;now look thru the function table.
D13A-5F             1286 (  4)         LD      E,A
D13B-16 00          1287 (  6)         LD      D,0             ;(DE)=function number.
D13D-19             1288 (  7)         ADD     HL,DE
D13E-19             1289 (  7)         ADD     HL,DE           ;(HL)=(start of table)+2*(function number).
D13F-5E             1290 (  6)         LD      E,(HL)
D140-23             1291 (  4)         INC     HL
D141-56             1292 (  6)         LD      D,(HL)          ;now (DE)=address for this function.
D142-2A 44 D4       1293 ( 15)         LD      HL,(PARAMS)     ;retrieve parameters.
D145-EB             1294 (  3)         EX      DE,HL           ;now (DE) has the original parameters.
D146-E9             1295 (  3)         JP      (HL)            ;execute desired function.
D147-               1296       ;
D147-               1297       ;   BDOS function jump table.
D147-               1298       ;
0029-               1299       NFUNCTS .EQU    41              ;number of functions in followin table.
D147-               1300       ;
D147-04 DF C9 D3 
     91 D2 CF D3 
     13 DF 10 DF 
     D5 D3 EE D3    1301       FUNCTNS: .DW    WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
D157-F4 D3 F9 D3 
     E2 D2 FF D3 
     7F DD 84 DD 
     46 DD 9D DD    1302               .DW     SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
D167-A6 DD AC DD 
     C9 DD D8 DD 
     E1 DD E7 DD 
     ED DD          1303               .DW     CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
D175-F6 DD FF DD 
     05 DE 0B DE 
     12 DE 2D D6 
     18 DE 1E DE    1304               .DW     RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
D185-27 DE 2E DE 
     42 DE 48 DE 
     4E DE 0F DD 
     54 DE 05 D4    1305               .DW     GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
D195-05 D4 9C DE    1306               .DW     RTN,WTSPECL
D199-               1307       ;
D199-               1308       ;   Bdos error message section.
D199-               1309       ;
D199-21 CB D1       1310 (  9) ERROR1:         LD      HL,BADSEC       ;bad sector message.
D19C-CD E6 D1       1311 ( 16)         CALL    PRTERR          ;print it and get a 1 char responce.
D19F-FE 03          1312 (  6)         CP      CNTRLC          ;re-boot request (control-c)?
D1A1-CA 00 00       1313 ( 6+)         JP      Z,0             ;yes.
D1A4-C9             1314 (  9)         RET                     ;no, return to retry i/o function.
D1A5-               1315       ;
D1A5-21 D6 D1       1316 (  9) ERROR2:         LD      HL,BADSEL       ;bad drive selected.
D1A8-C3 B4 D1       1317 (  9)         JP      ERROR5
D1AB-               1318       ;
D1AB-21 E2 D1       1319 (  9) ERROR3:         LD      HL,DISKRO       ;disk is read only.
D1AE-C3 B4 D1       1320 (  9)         JP      ERROR5
D1B1-               1321       ;
D1B1-21 DD D1       1322 (  9) ERROR4:         LD      HL,FILERO       ;file is read only.
D1B4-               1323       ;
D1B4-CD E6 D1       1324 ( 16) ERROR5:         CALL    PRTERR
D1B7-C3 00 00       1325 (  9)         JP      0               ;always reboot on these errors.
D1BA-               1326       ;
D1BA-42 64 6F 73 
     20 45 72 72 
     20 4F 6E 20    1327       BDOSERR: .DB    "Bdos Err On "
D1C6-20 3A 20 20 
     24             1328       BDOSDRV: .DB    " :  $"
D1CB-42 61 64 20 
     53 65 63 74 
     6F 72 24       1329       BADSEC:         .DB     "Bad Sector$"
D1D6-53 65 6C 65 
     63 74 24       1330       BADSEL:         .DB     "Select$"
D1DD-46 69 6C 65 
     20             1331       FILERO:         .DB     "File "
D1E2-52 2F 4F 24    1332       DISKRO:         .DB     "R/O$"
D1E6-               1333       ;
D1E6-               1334       ;   Print bdos error message.
D1E6-               1335       ;
D1E6-E5             1336 ( 11) PRTERR:         PUSH    HL              ;save second message pointer.
D1E7-CD CA D2       1337 ( 16)         CALL    OUTCRLF         ;send (cr)(lf).
D1EA-3A 43 D4       1338 ( 12)         LD      A,(ACTIVE)      ;get active drive.
D1ED-C6 41          1339 (  6)         ADD     A,'A'           ;make ascii.
D1EF-32 C6 D1       1340 ( 13)         LD      (BDOSDRV),A     ;and put in message.
D1F2-01 BA D1       1341 (  9)         LD      BC,BDOSERR      ;and print it.
D1F5-CD D4 D2       1342 ( 16)         CALL    PRTMESG
D1F8-C1             1343 (  9)         POP     BC              ;print second message line now.
D1F9-CD D4 D2       1344 ( 16)         CALL    PRTMESG
D1FC-               1345       ;
D1FC-               1346       ;   Get an input character. We will check our 1 character
D1FC-               1347       ; buffer first. This may be set by the console status routine.
D1FC-               1348       ;
D1FC-21 0F D4       1349 (  9) GETCHAR: LD     HL,CHARBUF      ;check character buffer.
D1FF-7E             1350 (  6)         LD      A,(HL)          ;anything present already?
D200-36 00          1351 (  9)         LD      (HL),0          ;...either case clear it.
D202-B7             1352 (  4)         OR      A
D203-C0             1353 ( 5+)         RET     NZ              ;yes, use it.
D204-C3 0A DF       1354 (  9)         JP      CONIN           ;nope, go get a character responce.
D207-               1355       ;
D207-               1356       ;   Input and echo a character.
D207-               1357       ;
D207-CD FC D1       1358 ( 16) GETECHO: CALL   GETCHAR         ;input a character.
D20A-CD 15 D2       1359 ( 16)         CALL    CHKCHAR         ;carriage control?
D20D-D8             1360 ( 5+)         RET     C               ;no, a regular control char so don't echo.
D20E-F5             1361 ( 11)         PUSH    AF              ;ok, save character now.
D20F-4F             1362 (  4)         LD      C,A
D210-CD 91 D2       1363 ( 16)         CALL    OUTCON          ;and echo it.
D213-F1             1364 (  9)         POP     AF              ;get character and return.
D214-C9             1365 (  9)         RET
D215-               1366       ;
D215-               1367       ;   Check character in (A). Set the zero flag on a carriage
D215-               1368       ; control character and the carry flag on any other control
D215-               1369       ; character.
D215-               1370       ;
D215-FE 0D          1371 (  6) CHKCHAR: CP     CR              ;check for carriage return, line feed, backspace,
D217-C8             1372 ( 5+)         RET     Z               ;or a tab.
D218-FE 0A          1373 (  6)         CP      LF
D21A-C8             1374 ( 5+)         RET     Z
D21B-FE 09          1375 (  6)         CP      TAB
D21D-C8             1376 ( 5+)         RET     Z
D21E-FE 08          1377 (  6)         CP      BS
D220-C8             1378 ( 5+)         RET     Z
D221-FE 20          1379 (  6)         CP      ' '             ;other control char? Set carry flag.
D223-C9             1380 (  9)         RET
D224-               1381       ;
D224-               1382       ;   Check the console during output. Halt on a control-s, then
D224-               1383       ; reboot on a control-c. If anything else is ready, clear the
D224-               1384       ; zero flag and return (the calling routine may want to do
D224-               1385       ; something).
D224-               1386       ;
D224-3A 0F D4       1387 ( 12) CKCONSOL:  LD   A,(CHARBUF)     ;check buffer.
D227-B7             1388 (  4)         OR      A               ;if anything, just return without checking.
D228-C2 46 D2       1389 ( 6+)         JP      NZ,CKCON2
D22B-CD 07 DF       1390 ( 16)         CALL    CONST           ;nothing in buffer. Check console.
D22E-E6 01          1391 (  6)         AND     01H             ;look at bit 0.
D230-C8             1392 ( 5+)         RET     Z               ;return if nothing.
D231-CD 0A DF       1393 ( 16)         CALL    CONIN           ;ok, get it.
D234-FE 13          1394 (  6)         CP      CNTRLS          ;if not control-s, return with zero cleared.
D236-C2 43 D2       1395 ( 6+)         JP      NZ,CKCON1
D239-CD 0A DF       1396 ( 16)         CALL    CONIN           ;halt processing until another char
D23C-FE 03          1397 (  6)         CP      CNTRLC          ;is typed. Control-c?
D23E-CA 00 00       1398 ( 6+)         JP      Z,0             ;yes, reboot now.
D241-AF             1399 (  4)         XOR     A               ;no, just pretend nothing was ever ready.
D242-C9             1400 (  9)         RET
D243-32 0F D4       1401 ( 13) CKCON1:         LD      (CHARBUF),A     ;save character in buffer for later processing.
D246-3E 01          1402 (  6) CKCON2:         LD      A,1             ;set (A) to non zero to mean something is ready.
D248-C9             1403 (  9)         RET
D249-               1404       ;
D249-               1405       ;   Output (C) to the screen. If the printer flip-flop flag
D249-               1406       ; is set, we will send character to printer also. The console
D249-               1407       ; will be checked in the process.
D249-               1408       ;
D249-3A 0B D4       1409 ( 12) OUTCHAR: LD     A,(OUTFLAG)     ;check output flag.
D24C-B7             1410 (  4)         OR      A               ;anything and we won't generate output.
D24D-C2 63 D2       1411 ( 6+)         JP      NZ,OUTCHR1
D250-C5             1412 ( 11)         PUSH    BC
D251-CD 24 D2       1413 ( 16)         CALL    CKCONSOL        ;check console (we don't care whats there).
D254-C1             1414 (  9)         POP     BC
D255-C5             1415 ( 11)         PUSH    BC
D256-CD 0D DF       1416 ( 16)         CALL    CONOUT          ;output (C) to the screen.
D259-C1             1417 (  9)         POP     BC
D25A-C5             1418 ( 11)         PUSH    BC
D25B-3A 0E D4       1419 ( 12)         LD      A,(PRTFLAG)     ;check printer flip-flop flag.
D25E-B7             1420 (  4)         OR      A
D25F-C4 10 DF       1421 ( 6+)         CALL    NZ,LIST         ;print it also if non-zero.
D262-C1             1422 (  9)         POP     BC
D263-79             1423 (  4) OUTCHR1: LD     A,C             ;update cursors position.
D264-21 0D D4       1424 (  9)         LD      HL,CURPOS
D267-FE 7F          1425 (  6)         CP      DEL             ;rubouts don't do anything here.
D269-C8             1426 ( 5+)         RET     Z
D26A-34             1427 ( 10)         INC     (HL)            ;bump line pointer.
D26B-FE 20          1428 (  6)         CP      ' '             ;and return if a normal character.
D26D-D0             1429 ( 5+)         RET     NC
D26E-35             1430 ( 10)         DEC     (HL)            ;restore and check for the start of the line.
D26F-7E             1431 (  6)         LD      A,(HL)
D270-B7             1432 (  4)         OR      A
D271-C8             1433 ( 5+)         RET     Z               ;ingnore control characters at the start of the line.
D272-79             1434 (  4)         LD      A,C
D273-FE 08          1435 (  6)         CP      BS              ;is it a backspace?
D275-C2 7A D2       1436 ( 6+)         JP      NZ,OUTCHR2
D278-35             1437 ( 10)         DEC     (HL)            ;yes, backup pointer.
D279-C9             1438 (  9)         RET
D27A-FE 0A          1439 (  6) OUTCHR2: CP     LF              ;is it a line feed?
D27C-C0             1440 ( 5+)         RET     NZ              ;ignore anything else.
D27D-36 00          1441 (  9)         LD      (HL),0          ;reset pointer to start of line.
D27F-C9             1442 (  9)         RET
D280-               1443       ;
D280-               1444       ;   Output (A) to the screen. If it is a control character
D280-               1445       ; (other than carriage control), use ^x format.
D280-               1446       ;
D280-79             1447 (  4) SHOWIT:         LD      A,C
D281-CD 15 D2       1448 ( 16)         CALL    CHKCHAR         ;check character.
D284-D2 91 D2       1449 ( 6+)         JP      NC,OUTCON       ;not a control, use normal output.
D287-F5             1450 ( 11)         PUSH    AF
D288-0E 5E          1451 (  6)         LD      C,'^'           ;for a control character, preceed it with '^'.
D28A-CD 49 D2       1452 ( 16)         CALL    OUTCHAR
D28D-F1             1453 (  9)         POP     AF
D28E-F6 40          1454 (  6)         OR      '@'             ;and then use the letter equivelant.
D290-4F             1455 (  4)         LD      C,A
D291-               1456       ;
D291-               1457       ;   Function to output (C) to the console device and expand tabs
D291-               1458       ; if necessary.
D291-               1459       ;
D291-79             1460 (  4) OUTCON:         LD      A,C
D292-FE 09          1461 (  6)         CP      TAB             ;is it a tab?
D294-C2 49 D2       1462 ( 6+)         JP      NZ,OUTCHAR      ;use regular output.
D297-0E 20          1463 (  6) OUTCON1: LD     C,' '           ;yes it is, use spaces instead.
D299-CD 49 D2       1464 ( 16)         CALL    OUTCHAR
D29C-3A 0D D4       1465 ( 12)         LD      A,(CURPOS)      ;go until the cursor is at a multiple of 8
D29F-               1466
D29F-E6 07          1467 (  6)         AND     07H             ;position.
D2A1-C2 97 D2       1468 ( 6+)         JP      NZ,OUTCON1
D2A4-C9             1469 (  9)         RET
D2A5-               1470       ;
D2A5-               1471       ;   Echo a backspace character. Erase the prevoius character
D2A5-               1472       ; on the screen.
D2A5-               1473       ;
D2A5-CD AD D2       1474 ( 16) BACKUP:         CALL    BACKUP1         ;backup the screen 1 place.
D2A8-0E 20          1475 (  6)         LD      C,' '           ;then blank that character.
D2AA-CD 0D DF       1476 ( 16)         CALL    CONOUT
D2AD-0E 08          1477 (  6) BACKUP1: LD     C,BS            ;then back space once more.
D2AF-C3 0D DF       1478 (  9)         JP      CONOUT
D2B2-               1479       ;
D2B2-               1480       ;   Signal a deleted line. Print a '#' at the end and start
D2B2-               1481       ; over.
D2B2-               1482       ;
D2B2-0E 23          1483 (  6) NEWLINE: LD     C,'#'
D2B4-CD 49 D2       1484 ( 16)         CALL    OUTCHAR         ;print this.
D2B7-CD CA D2       1485 ( 16)         CALL    OUTCRLF         ;start new line.
D2BA-3A 0D D4       1486 ( 12) NEWLN1:         LD      A,(CURPOS)      ;move the cursor to the starting position.
D2BD-21 0C D4       1487 (  9)         LD      HL,STARTING
D2C0-BE             1488 (  6)         CP      (HL)
D2C1-D0             1489 ( 5+)         RET     NC              ;there yet?
D2C2-0E 20          1490 (  6)         LD      C,' '
D2C4-CD 49 D2       1491 ( 16)         CALL    OUTCHAR         ;nope, keep going.
D2C7-C3 BA D2       1492 (  9)         JP      NEWLN1
D2CA-               1493       ;
D2CA-               1494       ;   Output a (cr) (lf) to the console device (screen).
D2CA-               1495       ;
D2CA-0E 0D          1496 (  6) OUTCRLF: LD     C,CR
D2CC-CD 49 D2       1497 ( 16)         CALL    OUTCHAR
D2CF-0E 0A          1498 (  6)         LD      C,LF
D2D1-C3 49 D2       1499 (  9)         JP      OUTCHAR
D2D4-               1500       ;
D2D4-               1501       ;   Print message pointed to by (BC). It will end with a '$'.
D2D4-               1502       ;
D2D4-0A             1503 (  6) PRTMESG: LD     A,(BC)          ;check for terminating character.
D2D5-FE 24          1504 (  6)         CP      '$'
D2D7-C8             1505 ( 5+)         RET     Z
D2D8-03             1506 (  4)         INC     BC
D2D9-C5             1507 ( 11)         PUSH    BC              ;otherwise, bump pointer and print it.
D2DA-4F             1508 (  4)         LD      C,A
D2DB-CD 91 D2       1509 ( 16)         CALL    OUTCON
D2DE-C1             1510 (  9)         POP     BC
D2DF-C3 D4 D2       1511 (  9)         JP      PRTMESG
D2E2-               1512       ;
D2E2-               1513       ;   Function to execute a buffered read.
D2E2-               1514       ;
D2E2-3A 0D D4       1515 ( 12) RDBUFF:         LD      A,(CURPOS)      ;use present location as starting one.
D2E5-32 0C D4       1516 ( 13)         LD      (STARTING),A
D2E8-2A 44 D4       1517 ( 15)         LD      HL,(PARAMS)     ;get the maximum buffer space.
D2EB-4E             1518 (  6)         LD      C,(HL)
D2EC-23             1519 (  4)         INC     HL              ;point to first available space.
D2ED-E5             1520 ( 11)         PUSH    HL              ;and save.
D2EE-06 00          1521 (  6)         LD      B,0             ;keep a character count.
D2F0-C5             1522 ( 11) RDBUF1:         PUSH    BC
D2F1-E5             1523 ( 11)         PUSH    HL
D2F2-CD FC D1       1524 ( 16) RDBUF2:         CALL    GETCHAR         ;get the next input character.
D2F5-E6 7F          1525 (  6)         AND     7FH             ;strip bit 7.
D2F7-E1             1526 (  9)         POP     HL              ;reset registers.
D2F8-C1             1527 (  9)         POP     BC
D2F9-FE 0D          1528 (  6)         CP      CR              ;en of the line?
D2FB-CA C2 D3       1529 ( 6+)         JP      Z,RDBUF17
D2FE-FE 0A          1530 (  6)         CP      LF
D300-CA C2 D3       1531 ( 6+)         JP      Z,RDBUF17
D303-FE 08          1532 (  6)         CP      BS              ;how about a backspace?
D305-C2 17 D3       1533 ( 6+)         JP      NZ,RDBUF3
D308-78             1534 (  4)         LD      A,B             ;yes, but ignore at the beginning of the line.
D309-B7             1535 (  4)         OR      A
D30A-CA F0 D2       1536 ( 6+)         JP      Z,RDBUF1
D30D-05             1537 (  4)         DEC     B               ;ok, update counter.
D30E-3A 0D D4       1538 ( 12)         LD      A,(CURPOS)      ;if we backspace to the start of the line,
D311-32 0B D4       1539 ( 13)         LD      (OUTFLAG),A     ;treat as a cancel (control-x).
D314-C3 71 D3       1540 (  9)         JP      RDBUF10
D317-FE 7F          1541 (  6) RDBUF3:         CP      DEL             ;user typed a rubout?
D319-C2 27 D3       1542 ( 6+)         JP      NZ,RDBUF4
D31C-78             1543 (  4)         LD      A,B             ;ignore at the start of the line.
D31D-B7             1544 (  4)         OR      A
D31E-CA F0 D2       1545 ( 6+)         JP      Z,RDBUF1
D321-7E             1546 (  6)         LD      A,(HL)          ;ok, echo the prevoius character.
D322-05             1547 (  4)         DEC     B               ;and reset pointers (counters).
D323-2B             1548 (  4)         DEC     HL
D324-C3 AA D3       1549 (  9)         JP      RDBUF15
D327-FE 05          1550 (  6) RDBUF4:         CP      CNTRLE          ;physical end of line?
D329-C2 38 D3       1551 ( 6+)         JP      NZ,RDBUF5
D32C-C5             1552 ( 11)         PUSH    BC              ;yes, do it.
D32D-E5             1553 ( 11)         PUSH    HL
D32E-CD CA D2       1554 ( 16)         CALL    OUTCRLF
D331-AF             1555 (  4)         XOR     A               ;and update starting position.
D332-32 0C D4       1556 ( 13)         LD      (STARTING),A
D335-C3 F2 D2       1557 (  9)         JP      RDBUF2
D338-FE 10          1558 (  6) RDBUF5:         CP      CNTRLP          ;control-p?
D33A-C2 49 D3       1559 ( 6+)         JP      NZ,RDBUF6
D33D-E5             1560 ( 11)         PUSH    HL              ;yes, flip the print flag filp-flop byte.
D33E-21 0E D4       1561 (  9)         LD      HL,PRTFLAG
D341-3E 01          1562 (  6)         LD      A,1             ;PRTFLAG=1-PRTFLAG
D343-96             1563 (  6)         SUB     (HL)
D344-77             1564 (  7)         LD      (HL),A
D345-E1             1565 (  9)         POP     HL
D346-C3 F0 D2       1566 (  9)         JP      RDBUF1
D349-FE 18          1567 (  6) RDBUF6:         CP      CNTRLX          ;control-x (cancel)?
D34B-C2 60 D3       1568 ( 6+)         JP      NZ,RDBUF8
D34E-E1             1569 (  9)         POP     HL
D34F-3A 0C D4       1570 ( 12) RDBUF7:         LD      A,(STARTING)    ;yes, backup the cursor to here.
D352-21 0D D4       1571 (  9)         LD      HL,CURPOS
D355-BE             1572 (  6)         CP      (HL)
D356-D2 E2 D2       1573 ( 6+)         JP      NC,RDBUFF       ;done yet?
D359-35             1574 ( 10)         DEC     (HL)            ;no, decrement pointer and output back up one space.
D35A-CD A5 D2       1575 ( 16)         CALL    BACKUP
D35D-C3 4F D3       1576 (  9)         JP      RDBUF7
D360-FE 15          1577 (  6) RDBUF8:         CP      CNTRLU          ;cntrol-u (cancel line)?
D362-C2 6C D3       1578 ( 6+)         JP      NZ,RDBUF9
D365-CD B2 D2       1579 ( 16)         CALL    NEWLINE         ;start a new line.
D368-E1             1580 (  9)         POP     HL
D369-C3 E2 D2       1581 (  9)         JP      RDBUFF
D36C-FE 12          1582 (  6) RDBUF9:         CP      CNTRLR          ;control-r?
D36E-C2 A7 D3       1583 ( 6+)         JP      NZ,RDBUF14
D371-C5             1584 ( 11) RDBUF10: PUSH   BC              ;yes, start a new line and retype the old one.
D372-CD B2 D2       1585 ( 16)         CALL    NEWLINE
D375-C1             1586 (  9)         POP     BC
D376-E1             1587 (  9)         POP     HL
D377-E5             1588 ( 11)         PUSH    HL
D378-C5             1589 ( 11)         PUSH    BC
D379-78             1590 (  4) RDBUF11: LD     A,B             ;done whole line yet?
D37A-B7             1591 (  4)         OR      A
D37B-CA 8B D3       1592 ( 6+)         JP      Z,RDBUF12
D37E-23             1593 (  4)         INC     HL              ;nope, get next character.
D37F-4E             1594 (  6)         LD      C,(HL)
D380-05             1595 (  4)         DEC     B               ;count it.
D381-C5             1596 ( 11)         PUSH    BC
D382-E5             1597 ( 11)         PUSH    HL
D383-CD 80 D2       1598 ( 16)         CALL    SHOWIT          ;and display it.
D386-E1             1599 (  9)         POP     HL
D387-C1             1600 (  9)         POP     BC
D388-C3 79 D3       1601 (  9)         JP      RDBUF11
D38B-E5             1602 ( 11) RDBUF12: PUSH   HL              ;done with line. If we were displaying
D38C-3A 0B D4       1603 ( 12)         LD      A,(OUTFLAG)     ;then update cursor position.
D38F-B7             1604 (  4)         OR      A
D390-CA F2 D2       1605 ( 6+)         JP      Z,RDBUF2
D393-21 0D D4       1606 (  9)         LD      HL,CURPOS       ;because this line is shorter, we must
D396-96             1607 (  6)         SUB     (HL)            ;back up the cursor (not the screen however)
D397-32 0B D4       1608 ( 13)         LD      (OUTFLAG),A     ;some number of positions.
D39A-CD A5 D2       1609 ( 16) RDBUF13: CALL   BACKUP          ;note that as long as (OUTFLAG) is non
D39D-21 0B D4       1610 (  9)         LD      HL,OUTFLAG      ;zero, the screen will not be changed.
D3A0-35             1611 ( 10)         DEC     (HL)
D3A1-C2 9A D3       1612 ( 6+)         JP      NZ,RDBUF13
D3A4-C3 F2 D2       1613 (  9)         JP      RDBUF2          ;now just get the next character.
D3A7-               1614       ;
D3A7-               1615       ;   Just a normal character, put this in our buffer and echo.
D3A7-               1616       ;
D3A7-23             1617 (  4) RDBUF14: INC    HL
D3A8-77             1618 (  7)         LD      (HL),A          ;store character.
D3A9-04             1619 (  4)         INC     B               ;and count it.
D3AA-C5             1620 ( 11) RDBUF15: PUSH   BC
D3AB-E5             1621 ( 11)         PUSH    HL
D3AC-4F             1622 (  4)         LD      C,A             ;echo it now.
D3AD-CD 80 D2       1623 ( 16)         CALL    SHOWIT
D3B0-E1             1624 (  9)         POP     HL
D3B1-C1             1625 (  9)         POP     BC
D3B2-7E             1626 (  6)         LD      A,(HL)          ;was it an abort request?
D3B3-FE 03          1627 (  6)         CP      CNTRLC          ;control-c abort?
D3B5-78             1628 (  4)         LD      A,B
D3B6-C2 BE D3       1629 ( 6+)         JP      NZ,RDBUF16
D3B9-FE 01          1630 (  6)         CP      1               ;only if at start of line.
D3BB-CA 00 00       1631 ( 6+)         JP      Z,0
D3BE-B9             1632 (  4) RDBUF16: CP     C               ;nope, have we filled the buffer?
D3BF-DA F0 D2       1633 ( 6+)         JP      C,RDBUF1
D3C2-E1             1634 (  9) RDBUF17: POP    HL              ;yes end the line and return.
D3C3-70             1635 (  7)         LD      (HL),B
D3C4-0E 0D          1636 (  6)         LD      C,CR
D3C6-C3 49 D2       1637 (  9)         JP      OUTCHAR         ;output (cr) and return.
D3C9-               1638       ;
D3C9-               1639       ;   Function to get a character from the console device.
D3C9-               1640       ;
D3C9-CD 07 D2       1641 ( 16) GETCON:         CALL    GETECHO         ;get and echo.
D3CC-C3 02 D4       1642 (  9)         JP      SETSTAT         ;save status and return.
D3CF-               1643       ;
D3CF-               1644       ;   Function to get a character from the tape reader device.
D3CF-               1645       ;
D3CF-CD 16 DF       1646 ( 16) GETRDR:         CALL    READER          ;get a character from reader, set status and return.
D3D2-C3 02 D4       1647 (  9)         JP      SETSTAT
D3D5-               1648       ;
D3D5-               1649       ;  Function to perform direct console i/o. If (C) contains (FF)
D3D5-               1650       ; then this is an input request. If (C) contains (FE) then
D3D5-               1651       ; this is a status request. Otherwise we are to output (C).
D3D5-               1652       ;
D3D5-79             1653 (  4) DIRCIO:         LD      A,C             ;test for (FF).
D3D6-3C             1654 (  4)         INC     A
D3D7-CA E1 D3       1655 ( 6+)         JP      Z,DIRC1
D3DA-3C             1656 (  4)         INC     A               ;test for (FE).
D3DB-CA 07 DF       1657 ( 6+)         JP      Z,CONST
D3DE-C3 0D DF       1658 (  9)         JP      CONOUT          ;just output (C).
D3E1-CD 07 DF       1659 ( 16) DIRC1:  CALL    CONST           ;this is an input request.
D3E4-B7             1660 (  4)         OR      A
D3E5-CA 92 DE       1661 ( 6+)         JP      Z,GOBACK1       ;not ready? Just return (directly).
D3E8-CD 0A DF       1662 ( 16)         CALL    CONIN           ;yes, get character.
D3EB-C3 02 D4       1663 (  9)         JP      SETSTAT         ;set status and return.
D3EE-               1664       ;
D3EE-               1665       ;   Function to return the i/o byte.
D3EE-               1666       ;
D3EE-3A 03 00       1667 ( 12) GETIOB:         LD      A,(IOBYTE)
D3F1-C3 02 D4       1668 (  9)         JP      SETSTAT
D3F4-               1669       ;
D3F4-               1670       ;   Function to set the i/o byte.
D3F4-               1671       ;
D3F4-21 03 00       1672 (  9) SETIOB:         LD      HL,IOBYTE
D3F7-71             1673 (  7)         LD      (HL),C
D3F8-C9             1674 (  9)         RET
D3F9-               1675       ;
D3F9-               1676       ;   Function to print the character string pointed to by (DE)
D3F9-               1677       ; on the console device. The string ends with a '$'.
D3F9-               1678       ;
D3F9-EB             1679 (  3) PRTSTR:         EX      DE,HL
D3FA-4D             1680 (  4)         LD      C,L
D3FB-44             1681 (  4)         LD      B,H             ;now (BC) points to it.
D3FC-C3 D4 D2       1682 (  9)         JP      PRTMESG
D3FF-               1683       ;
D3FF-               1684       ;   Function to interigate the console device.
D3FF-               1685       ;
D3FF-CD 24 D2       1686 ( 16) GETCSTS: CALL   CKCONSOL
D402-               1687       ;
D402-               1688       ;   Get here to set the status and return to the cleanup
D402-               1689       ; section. Then back to the user.
D402-               1690       ;
D402-32 46 D4       1691 ( 13) SETSTAT: LD     (STATUS),A
D405-C9             1692 (  9) RTN:    RET
D406-               1693       ;
D406-               1694       ;   Set the status to 1 (read or write error code).
D406-               1695       ;
D406-3E 01          1696 (  6) IOERR1:         LD      A,1
D408-C3 02 D4       1697 (  9)         JP      SETSTAT
D40B-               1698       ;
D40B-00             1699       OUTFLAG: .DB    0               ;output flag (non zero means no output).
D40C-02             1700       STARTING:  .DB  2               ;starting position for cursor.
D40D-00             1701       CURPOS:         .DB     0               ;cursor position (0=start of line).
D40E-00             1702       PRTFLAG: .DB    0               ;printer flag (control-p toggle). List if non zero.
D40F-00             1703       CHARBUF: .DB    0               ;single input character buffer.
D410-               1704       ;
D410-               1705       ;   Stack area for BDOS calls.
D410-               1706       ;
D410-00 00          1707       USRSTACK:  .DW  0               ;save users stack pointer here.
D412-               1708       ;
D412-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00    1709               .DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D42A-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00    1710               .DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D442-               1711       STKAREA .EQU    $               ;end of stack area.
D442-               1712       ;
D442-00             1713       USERNO:         .DB     0               ;current user number.
D443-00             1714       ACTIVE:         .DB     0               ;currently active drive.
D444-00 00          1715       PARAMS:         .DW     0               ;save (DE) parameters here on entry.
D446-00 00          1716       STATUS:         .DW     0               ;status returned from bdos function.
D448-               1717       ;
D448-               1718       ;   Select error occured, jump to error routine.
D448-               1719       ;
D448-21 0B D1       1720 (  9) SLCTERR: LD     HL,BADSLCT
D44B-               1721       ;
D44B-               1722       ;   Jump to (HL) indirectly.
D44B-               1723       ;
D44B-5E             1724 (  6) JUMPHL:         LD      E,(HL)
D44C-23             1725 (  4)         INC     HL
D44D-56             1726 (  6)         LD      D,(HL)          ;now (DE) contain the desired address.
D44E-EB             1727 (  3)         EX      DE,HL
D44F-E9             1728 (  3)         JP      (HL)
D450-               1729       ;
D450-               1730       ;   Block move. (DE) to (HL), (C) bytes total.
D450-               1731       ;
D450-0C             1732 (  4) DE2HL:  INC     C               ;is count down to zero?
D451-0D             1733 (  4) DE2HL1:         DEC     C
D452-C8             1734 ( 5+)         RET     Z               ;yes, we are done.
D453-1A             1735 (  6)         LD      A,(DE)          ;no, move one more byte.
D454-77             1736 (  7)         LD      (HL),A
D455-13             1737 (  4)         INC     DE
D456-23             1738 (  4)         INC     HL
D457-C3 51 D4       1739 (  9)         JP      DE2HL1          ;and repeat.
D45A-               1740       ;
D45A-               1741       ;   Select the desired drive.
D45A-               1742       ;
D45A-3A 43 D4       1743 ( 12) SELECT:         LD      A,(ACTIVE)      ;get active disk.
D45D-4F             1744 (  4)         LD      C,A
D45E-CD 1C DF       1745 ( 16)         CALL    SELDSK          ;select it.
D461-7C             1746 (  4)         LD      A,H             ;valid drive?
D462-B5             1747 (  4)         OR      L               ;valid drive?
D463-C8             1748 ( 5+)         RET     Z               ;return if not.
D464-               1749       ;
D464-               1750       ;   Here, the BIOS returned the address of the parameter block
D464-               1751       ; in (HL). We will extract the necessary pointers and save them.
D464-               1752       ;
D464-5E             1753 (  6)         LD      E,(HL)          ;yes, get address of translation table into (DE).
D465-23             1754 (  4)         INC     HL
D466-56             1755 (  6)         LD      D,(HL)
D467-23             1756 (  4)         INC     HL
D468-22 B4 DE       1757 ( 20)         LD      (SCRATCH1),HL   ;save pointers to scratch areas.
D46B-23             1758 (  4)         INC     HL
D46C-23             1759 (  4)         INC     HL
D46D-22 B6 DE       1760 ( 20)         LD      (SCRATCH2),HL   ;ditto.
D470-23             1761 (  4)         INC     HL
D471-23             1762 (  4)         INC     HL
D472-22 B8 DE       1763 ( 20)         LD      (SCRATCH3),HL   ;ditto.
D475-23             1764 (  4)         INC     HL
D476-23             1765 (  4)         INC     HL
D477-EB             1766 (  3)         EX      DE,HL           ;now save the translation table address.
D478-22 D1 DE       1767 ( 20)         LD      (XLATE),HL
D47B-21 BA DE       1768 (  9)         LD      HL,DIRBUF       ;put the next 8 bytes here.
D47E-0E 08          1769 (  6)         LD      C,8             ;they consist of the directory buffer
D480-CD 50 D4       1770 ( 16)         CALL    DE2HL           ;pointer, parameter block pointer,
D483-2A BC DE       1771 ( 15)         LD      HL,(DISKPB)     ;check and allocation vectors.
D486-EB             1772 (  3)         EX      DE,HL
D487-21 C2 DE       1773 (  9)         LD      HL,SECTORS      ;move parameter block into our ram.
D48A-0E 0F          1774 (  6)         LD      C,15            ;it is 15 bytes long.
D48C-CD 50 D4       1775 ( 16)         CALL    DE2HL
D48F-2A C7 DE       1776 ( 15)         LD      HL,(DSKSIZE)    ;check disk size.
D492-7C             1777 (  4)         LD      A,H             ;more than 256 blocks on this?
D493-21 DE DE       1778 (  9)         LD      HL,BIGDISK
D496-36 FF          1779 (  9)         LD      (HL),0FFH       ;set to samll.
D498-B7             1780 (  4)         OR      A
D499-CA 9E D4       1781 ( 6+)         JP      Z,SELECT1
D49C-36 00          1782 (  9)         LD      (HL),0          ;wrong, set to large.
D49E-3E FF          1783 (  6) SELECT1: LD     A,0FFH          ;clear the zero flag.
D4A0-B7             1784 (  4)         OR      A
D4A1-C9             1785 (  9)         RET
D4A2-               1786       ;
D4A2-               1787       ;   Routine to home the disk track head and clear pointers.
D4A2-               1788       ;
D4A2-CD 19 DF       1789 ( 16) HOMEDRV: CALL   HOME            ;home the head.
D4A5-AF             1790 (  4)         XOR     A
D4A6-2A B6 DE       1791 ( 15)         LD      HL,(SCRATCH2)   ;set our track pointer also.
D4A9-77             1792 (  7)         LD      (HL),A
D4AA-23             1793 (  4)         INC     HL
D4AB-77             1794 (  7)         LD      (HL),A
D4AC-2A B8 DE       1795 ( 15)         LD      HL,(SCRATCH3)   ;and our sector pointer.
D4AF-77             1796 (  7)         LD      (HL),A
D4B0-23             1797 (  4)         INC     HL
D4B1-77             1798 (  7)         LD      (HL),A
D4B2-C9             1799 (  9)         RET
D4B3-               1800       ;
D4B3-               1801       ;   Do the actual disk read and check the error return status.
D4B3-               1802       ;
D4B3-CD 28 DF       1803 ( 16) DOREAD:         CALL    READ
D4B6-C3 BC D4       1804 (  9)         JP      IORET
D4B9-               1805       ;
D4B9-               1806       ;   Do the actual disk write and handle any bios error.
D4B9-               1807       ;
D4B9-CD 2B DF       1808 ( 16) DOWRITE: CALL   WRITE
D4BC-B7             1809 (  4) IORET:  OR      A
D4BD-C8             1810 ( 5+)         RET     Z               ;return unless an error occured.
D4BE-21 09 D1       1811 (  9)         LD      HL,BADSCTR      ;bad read/write on this sector.
D4C1-C3 4B D4       1812 (  9)         JP      JUMPHL
D4C4-               1813       ;
D4C4-               1814       ;   Routine to select the track and sector that the desired
D4C4-               1815       ; block number falls in.
D4C4-               1816       ;
D4C4-2A EB DE       1817 ( 15) TRKSEC:         LD      HL,(FILEPOS)    ;get position of last accessed file
D4C7-0E 02          1818 (  6)         LD      C,2             ;in directory and compute sector #.
D4C9-CD EB D5       1819 ( 16)         CALL    SHIFTR          ;sector #=file-position/4.
D4CC-22 E6 DE       1820 ( 20)         LD      (BLKNMBR),HL    ;save this as the block number of interest.
D4CF-22 ED DE       1821 ( 20)         LD      (CKSUMTBL),HL   ;what's it doing here too?
D4D2-               1822       ;
D4D2-               1823       ;   if the sector number has already been set (BLKNMBR), enter
D4D2-               1824       ; at this point.
D4D2-               1825       ;
D4D2-21 E6 DE       1826 (  9) TRKSEC1: LD     HL,BLKNMBR
D4D5-4E             1827 (  6)         LD      C,(HL)          ;move sector number into (BC).
D4D6-23             1828 (  4)         INC     HL
D4D7-46             1829 (  6)         LD      B,(HL)
D4D8-2A B8 DE       1830 ( 15)         LD      HL,(SCRATCH3)   ;get current sector number and
D4DB-5E             1831 (  6)         LD      E,(HL)          ;move this into (DE).
D4DC-23             1832 (  4)         INC     HL
D4DD-56             1833 (  6)         LD      D,(HL)
D4DE-2A B6 DE       1834 ( 15)         LD      HL,(SCRATCH2)   ;get current track number.
D4E1-7E             1835 (  6)         LD      A,(HL)          ;and this into (HL).
D4E2-23             1836 (  4)         INC     HL
D4E3-66             1837 (  6)         LD      H,(HL)
D4E4-6F             1838 (  4)         LD      L,A
D4E5-79             1839 (  4) TRKSEC2: LD     A,C             ;is desired sector before current one?
D4E6-93             1840 (  4)         SUB     E
D4E7-78             1841 (  4)         LD      A,B
D4E8-9A             1842 (  4)         SBC     A,D
D4E9-D2 FB D4       1843 ( 6+)         JP      NC,TRKSEC3
D4EC-E5             1844 ( 11)         PUSH    HL              ;yes, decrement sectors by one track.
D4ED-2A C2 DE       1845 ( 15)         LD      HL,(SECTORS)    ;get sectors per track.
D4F0-7B             1846 (  4)         LD      A,E
D4F1-95             1847 (  4)         SUB     L
D4F2-5F             1848 (  4)         LD      E,A
D4F3-7A             1849 (  4)         LD      A,D
D4F4-9C             1850 (  4)         SBC     A,H
D4F5-57             1851 (  4)         LD      D,A             ;now we have backed up one full track.
D4F6-E1             1852 (  9)         POP     HL
D4F7-2B             1853 (  4)         DEC     HL              ;adjust track counter.
D4F8-C3 E5 D4       1854 (  9)         JP      TRKSEC2
D4FB-E5             1855 ( 11) TRKSEC3: PUSH   HL              ;desired sector is after current one.
D4FC-2A C2 DE       1856 ( 15)         LD      HL,(SECTORS)    ;get sectors per track.
D4FF-19             1857 (  7)         ADD     HL,DE           ;bump sector pointer to next track.
D500-DA 10 D5       1858 ( 6+)         JP      C,TRKSEC4
D503-79             1859 (  4)         LD      A,C             ;is desired sector now before current one?
D504-95             1860 (  4)         SUB     L
D505-78             1861 (  4)         LD      A,B
D506-9C             1862 (  4)         SBC     A,H
D507-DA 10 D5       1863 ( 6+)         JP      C,TRKSEC4
D50A-EB             1864 (  3)         EX      DE,HL           ;not yes, increment track counter
D50B-E1             1865 (  9)         POP     HL              ;and continue until it is.
D50C-23             1866 (  4)         INC     HL
D50D-C3 FB D4       1867 (  9)         JP      TRKSEC3
D510-               1868       ;
D510-               1869       ;   here we have determined the track number that contains the
D510-               1870       ; desired sector.
D510-               1871       ;
D510-E1             1872 (  9) TRKSEC4: POP    HL              ;get track number (HL).
D511-C5             1873 ( 11)         PUSH    BC
D512-D5             1874 ( 11)         PUSH    DE
D513-E5             1875 ( 11)         PUSH    HL
D514-EB             1876 (  3)         EX      DE,HL
D515-2A CF DE       1877 ( 15)         LD      HL,(OFFSET)     ;adjust for first track offset.
D518-19             1878 (  7)         ADD     HL,DE
D519-44             1879 (  4)         LD      B,H
D51A-4D             1880 (  4)         LD      C,L
D51B-CD 1F DF       1881 ( 16)         CALL    SETTRK          ;select this track.
D51E-D1             1882 (  9)         POP     DE              ;reset current track pointer.
D51F-2A B6 DE       1883 ( 15)         LD      HL,(SCRATCH2)
D522-73             1884 (  7)         LD      (HL),E
D523-23             1885 (  4)         INC     HL
D524-72             1886 (  7)         LD      (HL),D
D525-D1             1887 (  9)         POP     DE
D526-2A B8 DE       1888 ( 15)         LD      HL,(SCRATCH3)   ;reset the first sector on this track.
D529-73             1889 (  7)         LD      (HL),E
D52A-23             1890 (  4)         INC     HL
D52B-72             1891 (  7)         LD      (HL),D
D52C-C1             1892 (  9)         POP     BC
D52D-79             1893 (  4)         LD      A,C             ;now subtract the desired one.
D52E-93             1894 (  4)         SUB     E               ;to make it relative (1-# sectors/track).
D52F-4F             1895 (  4)         LD      C,A
D530-78             1896 (  4)         LD      A,B
D531-9A             1897 (  4)         SBC     A,D
D532-47             1898 (  4)         LD      B,A
D533-2A D1 DE       1899 ( 15)         LD      HL,(XLATE)      ;translate this sector according to this table.
D536-EB             1900 (  3)         EX      DE,HL
D537-CD 31 DF       1901 ( 16)         CALL    SECTRN          ;let the bios translate it.
D53A-4D             1902 (  4)         LD      C,L
D53B-44             1903 (  4)         LD      B,H
D53C-C3 22 DF       1904 (  9)         JP      SETSEC          ;and select it.
D53F-               1905       ;
D53F-               1906       ;   Compute block number from record number (SAVNREC) and
D53F-               1907       ; extent number (SAVEXT).
D53F-               1908       ;
D53F-21 C4 DE       1909 (  9) GETBLOCK:  LD   HL,BLKSHFT      ;get logical to physical conversion.
D542-4E             1910 (  6)         LD      C,(HL)          ;note that this is base 2 log of ratio.
D543-3A E4 DE       1911 ( 12)         LD      A,(SAVNREC)     ;get record number.
D546-B7             1912 (  4) GETBLK1: OR     A               ;compute (A)=(A)/2^BLKSHFT.
D547-1F             1913 (  3)         RRA
D548-0D             1914 (  4)         DEC     C
D549-C2 46 D5       1915 ( 6+)         JP      NZ,GETBLK1
D54C-47             1916 (  4)         LD      B,A             ;save result in (B).
D54D-3E 08          1917 (  6)         LD      A,8
D54F-96             1918 (  6)         SUB     (HL)
D550-4F             1919 (  4)         LD      C,A             ;compute (C)=8-BLKSHFT.
D551-3A E3 DE       1920 ( 12)         LD      A,(SAVEXT)
D554-0D             1921 (  4) GETBLK2: DEC    C               ;compute (A)=SAVEXT*2^(8-BLKSHFT).
D555-CA 5D D5       1922 ( 6+)         JP      Z,GETBLK3
D558-B7             1923 (  4)         OR      A
D559-17             1924 (  3)         RLA
D55A-C3 54 D5       1925 (  9)         JP      GETBLK2
D55D-80             1926 (  4) GETBLK3: ADD    A,B
D55E-C9             1927 (  9)         RET
D55F-               1928       ;
D55F-               1929       ;   Routine to extract the (BC) block byte from the fcb pointed
D55F-               1930       ; to by (PARAMS). If this is a big-disk, then these are 16 bit
D55F-               1931       ; block numbers, else they are 8 bit numbers.
D55F-               1932       ; Number is returned in (HL).
D55F-               1933       ;
D55F-2A 44 D4       1934 ( 15) EXTBLK:         LD      HL,(PARAMS)     ;get fcb address.
D562-11 10 00       1935 (  9)         LD      DE,16           ;block numbers start 16 bytes into fcb.
D565-19             1936 (  7)         ADD     HL,DE
D566-09             1937 (  7)         ADD     HL,BC
D567-3A DE DE       1938 ( 12)         LD      A,(BIGDISK)     ;are we using a big-disk?
D56A-B7             1939 (  4)         OR      A
D56B-CA 72 D5       1940 ( 6+)         JP      Z,EXTBLK1
D56E-6E             1941 (  6)         LD      L,(HL)          ;no, extract an 8 bit number from the fcb.
D56F-26 00          1942 (  6)         LD      H,0
D571-C9             1943 (  9)         RET
D572-09             1944 (  7) EXTBLK1: ADD    HL,BC           ;yes, extract a 16 bit number.
D573-5E             1945 (  6)         LD      E,(HL)
D574-23             1946 (  4)         INC     HL
D575-56             1947 (  6)         LD      D,(HL)
D576-EB             1948 (  3)         EX      DE,HL           ;return in (HL).
D577-C9             1949 (  9)         RET
D578-               1950       ;
D578-               1951       ;   Compute block number.
D578-               1952       ;
D578-CD 3F D5       1953 ( 16) COMBLK:         CALL    GETBLOCK
D57B-4F             1954 (  4)         LD      C,A
D57C-06 00          1955 (  6)         LD      B,0
D57E-CD 5F D5       1956 ( 16)         CALL    EXTBLK
D581-22 E6 DE       1957 ( 20)         LD      (BLKNMBR),HL
D584-C9             1958 (  9)         RET
D585-               1959       ;
D585-               1960       ;   Check for a zero block number (unused).
D585-               1961       ;
D585-2A E6 DE       1962 ( 15) CHKBLK:         LD      HL,(BLKNMBR)
D588-7D             1963 (  4)         LD      A,L             ;is it zero?
D589-B4             1964 (  4)         OR      H
D58A-C9             1965 (  9)         RET
D58B-               1966       ;
D58B-               1967       ;   Adjust physical block (BLKNMBR) and convert to logical
D58B-               1968       ; sector (LOGSECT). This is the starting sector of this block.
D58B-               1969       ; The actual sector of interest is then added to this and the
D58B-               1970       ; resulting sector number is stored back in (BLKNMBR). This
D58B-               1971       ; will still have to be adjusted for the track number.
D58B-               1972       ;
D58B-3A C4 DE       1973 ( 12) LOGICAL: LD     A,(BLKSHFT)     ;get log2(physical/logical sectors).
D58E-2A E6 DE       1974 ( 15)         LD      HL,(BLKNMBR)    ;get physical sector desired.
D591-29             1975 (  7) LOGICL1: ADD    HL,HL           ;compute logical sector number.
D592-3D             1976 (  4)         DEC     A               ;note logical sectors are 128 bytes long.
D593-C2 91 D5       1977 ( 6+)         JP      NZ,LOGICL1
D596-22 E8 DE       1978 ( 20)         LD      (LOGSECT),HL    ;save logical sector.
D599-3A C5 DE       1979 ( 12)         LD      A,(BLKMASK)     ;get block mask.
D59C-4F             1980 (  4)         LD      C,A
D59D-3A E4 DE       1981 ( 12)         LD      A,(SAVNREC)     ;get next sector to access.
D5A0-A1             1982 (  4)         AND     C               ;extract the relative position within physical block.
D5A1-B5             1983 (  4)         OR      L               ;and add it too logical sector.
D5A2-6F             1984 (  4)         LD      L,A
D5A3-22 E6 DE       1985 ( 20)         LD      (BLKNMBR),HL    ;and store.
D5A6-C9             1986 (  9)         RET
D5A7-               1987       ;
D5A7-               1988       ;   Set (HL) to point to extent byte in fcb.
D5A7-               1989       ;
D5A7-2A 44 D4       1990 ( 15) SETEXT:         LD      HL,(PARAMS)
D5AA-11 0C 00       1991 (  9)         LD      DE,12           ;it is the twelth byte.
D5AD-19             1992 (  7)         ADD     HL,DE
D5AE-C9             1993 (  9)         RET
D5AF-               1994       ;
D5AF-               1995       ;   Set (HL) to point to record count byte in fcb and (DE) to
D5AF-               1996       ; next record number byte.
D5AF-               1997       ;
D5AF-2A 44 D4       1998 ( 15) SETHLDE: LD     HL,(PARAMS)
D5B2-11 0F 00       1999 (  9)         LD      DE,15           ;record count byte (#15).
D5B5-19             2000 (  7)         ADD     HL,DE
D5B6-EB             2001 (  3)         EX      DE,HL
D5B7-21 11 00       2002 (  9)         LD      HL,17           ;next record number (#32).
D5BA-19             2003 (  7)         ADD     HL,DE
D5BB-C9             2004 (  9)         RET
D5BC-               2005       ;
D5BC-               2006       ;   Save current file data from fcb.
D5BC-               2007       ;
D5BC-CD AF D5       2008 ( 16) STRDATA: CALL   SETHLDE
D5BF-7E             2009 (  6)         LD      A,(HL)          ;get and store record count byte.
D5C0-32 E4 DE       2010 ( 13)         LD      (SAVNREC),A
D5C3-EB             2011 (  3)         EX      DE,HL
D5C4-7E             2012 (  6)         LD      A,(HL)          ;get and store next record number byte.
D5C5-32 E2 DE       2013 ( 13)         LD      (SAVNXT),A
D5C8-CD A7 D5       2014 ( 16)         CALL    SETEXT          ;point to extent byte.
D5CB-3A C6 DE       2015 ( 12)         LD      A,(EXTMASK)     ;get extent mask.
D5CE-A6             2016 (  6)         AND     (HL)
D5CF-32 E3 DE       2017 ( 13)         LD      (SAVEXT),A      ;and save extent here.
D5D2-C9             2018 (  9)         RET
D5D3-               2019       ;
D5D3-               2020       ;   Set the next record to access. If (MODE) is set to 2, then
D5D3-               2021       ; the last record byte (SAVNREC) has the correct number to access.
D5D3-               2022       ; For sequential access, (MODE) will be equal to 1.
D5D3-               2023       ;
D5D3-CD AF D5       2024 ( 16) SETNREC: CALL   SETHLDE
D5D6-3A D6 DE       2025 ( 12)         LD      A,(MODE)        ;get sequential flag (=1).
D5D9-FE 02          2026 (  6)         CP      2               ;a 2 indicates that no adder is needed.
D5DB-C2 DF D5       2027 ( 6+)         JP      NZ,STNREC1
D5DE-AF             2028 (  4)         XOR     A               ;clear adder (random access?).
D5DF-4F             2029 (  4) STNREC1: LD     C,A
D5E0-3A E4 DE       2030 ( 12)         LD      A,(SAVNREC)     ;get last record number.
D5E3-81             2031 (  4)         ADD     A,C             ;increment record count.
D5E4-77             2032 (  7)         LD      (HL),A          ;and set fcb's next record byte.
D5E5-EB             2033 (  3)         EX      DE,HL
D5E6-3A E2 DE       2034 ( 12)         LD      A,(SAVNXT)      ;get next record byte from storage.
D5E9-77             2035 (  7)         LD      (HL),A          ;and put this into fcb as number of records used.
D5EA-C9             2036 (  9)         RET
D5EB-               2037       ;
D5EB-               2038       ;   Shift (HL) right (C) bits.
D5EB-               2039       ;
D5EB-0C             2040 (  4) SHIFTR:         INC     C
D5EC-0D             2041 (  4) SHIFTR1: DEC    C
D5ED-C8             2042 ( 5+)         RET     Z
D5EE-7C             2043 (  4)         LD      A,H
D5EF-B7             2044 (  4)         OR      A
D5F0-1F             2045 (  3)         RRA
D5F1-67             2046 (  4)         LD      H,A
D5F2-7D             2047 (  4)         LD      A,L
D5F3-1F             2048 (  3)         RRA
D5F4-6F             2049 (  4)         LD      L,A
D5F5-C3 EC D5       2050 (  9)         JP      SHIFTR1
D5F8-               2051       ;
D5F8-               2052       ;   Compute the check-sum for the directory buffer. Return
D5F8-               2053       ; integer sum in (A).
D5F8-               2054       ;
D5F8-0E 80          2055 (  6) CHECKSUM:  LD   C,128           ;length of buffer.
D5FA-2A BA DE       2056 ( 15)         LD      HL,(DIRBUF)     ;get its location.
D5FD-AF             2057 (  4)         XOR     A               ;clear summation byte.
D5FE-86             2058 (  6) CHKSUM1: ADD    A,(HL)          ;and compute sum ignoring carries.
D5FF-23             2059 (  4)         INC     HL
D600-0D             2060 (  4)         DEC     C
D601-C2 FE D5       2061 ( 6+)         JP      NZ,CHKSUM1
D604-C9             2062 (  9)         RET
D605-               2063       ;
D605-               2064       ;   Shift (HL) left (C) bits.
D605-               2065       ;
D605-0C             2066 (  4) SHIFTL:         INC     C
D606-0D             2067 (  4) SHIFTL1: DEC    C
D607-C8             2068 ( 5+)         RET     Z
D608-29             2069 (  7)         ADD     HL,HL           ;shift left 1 bit.
D609-C3 06 D6       2070 (  9)         JP      SHIFTL1
D60C-               2071       ;
D60C-               2072       ;   Routine to set a bit in a 16 bit value contained in (BC).
D60C-               2073       ; The bit set depends on the current drive selection.
D60C-               2074       ;
D60C-C5             2075 ( 11) SETBIT:         PUSH    BC              ;save 16 bit word.
D60D-3A 43 D4       2076 ( 12)         LD      A,(ACTIVE)      ;get active drive.
D610-4F             2077 (  4)         LD      C,A
D611-21 01 00       2078 (  9)         LD      HL,1
D614-CD 05 D6       2079 ( 16)         CALL    SHIFTL          ;shift bit 0 into place.
D617-C1             2080 (  9)         POP     BC              ;now 'or' this with the original word.
D618-79             2081 (  4)         LD      A,C
D619-B5             2082 (  4)         OR      L
D61A-6F             2083 (  4)         LD      L,A             ;low byte done, do high byte.
D61B-78             2084 (  4)         LD      A,B
D61C-B4             2085 (  4)         OR      H
D61D-67             2086 (  4)         LD      H,A
D61E-C9             2087 (  9)         RET
D61F-               2088       ;
D61F-               2089       ;   Extract the write protect status bit for the current drive.
D61F-               2090       ; The result is returned in (A), bit 0.
D61F-               2091       ;
D61F-2A AE DE       2092 ( 15) GETWPRT: LD     HL,(WRTPRT)     ;get status bytes.
D622-3A 43 D4       2093 ( 12)         LD      A,(ACTIVE)      ;which drive is current?
D625-4F             2094 (  4)         LD      C,A
D626-CD EB D5       2095 ( 16)         CALL    SHIFTR          ;shift status such that bit 0 is the
D629-7D             2096 (  4)         LD      A,L             ;one of interest for this drive.
D62A-E6 01          2097 (  6)         AND     01H             ;and isolate it.
D62C-C9             2098 (  9)         RET
D62D-               2099       ;
D62D-               2100       ;   Function to write protect the current disk.
D62D-               2101       ;
D62D-21 AE DE       2102 (  9) WRTPRTD: LD     HL,WRTPRT       ;point to status word.
D630-4E             2103 (  6)         LD      C,(HL)          ;set (BC) equal to the status.
D631-23             2104 (  4)         INC     HL
D632-46             2105 (  6)         LD      B,(HL)
D633-CD 0C D6       2106 ( 16)         CALL    SETBIT          ;and set this bit according to current drive.
D636-22 AE DE       2107 ( 20)         LD      (WRTPRT),HL     ;then save.
D639-2A C9 DE       2108 ( 15)         LD      HL,(DIRSIZE)    ;now save directory size limit.
D63C-23             2109 (  4)         INC     HL              ;remember the last one.
D63D-EB             2110 (  3)         EX      DE,HL
D63E-2A B4 DE       2111 ( 15)         LD      HL,(SCRATCH1)   ;and store it here.
D641-73             2112 (  7)         LD      (HL),E          ;put low byte.
D642-23             2113 (  4)         INC     HL
D643-72             2114 (  7)         LD      (HL),D          ;then high byte.
D644-C9             2115 (  9)         RET
D645-               2116       ;
D645-               2117       ;   Check for a read only file.
D645-               2118       ;
D645-CD 5F D6       2119 ( 16) CHKROFL: CALL   FCB2HL          ;set (HL) to file entry in directory buffer.
D648-11 09 00       2120 (  9) CKROF1:         LD      DE,9            ;look at bit 7 of the ninth byte.
D64B-19             2121 (  7)         ADD     HL,DE
D64C-7E             2122 (  6)         LD      A,(HL)
D64D-17             2123 (  3)         RLA
D64E-D0             2124 ( 5+)         RET     NC              ;return if ok.
D64F-21 0F D1       2125 (  9)         LD      HL,ROFILE       ;else, print error message and terminate.
D652-C3 4B D4       2126 (  9)         JP      JUMPHL
D655-               2127       ;
D655-               2128       ;   Check the write protect status of the active disk.
D655-               2129       ;
D655-CD 1F D6       2130 ( 16) CHKWPRT: CALL   GETWPRT
D658-C8             2131 ( 5+)         RET     Z               ;return if ok.
D659-21 0D D1       2132 (  9)         LD      HL,RODISK       ;else print message and terminate.
D65C-C3 4B D4       2133 (  9)         JP      JUMPHL
D65F-               2134       ;
D65F-               2135       ;   Routine to set (HL) pointing to the proper entry in the
D65F-               2136       ; directory buffer.
D65F-               2137       ;
D65F-2A BA DE       2138 ( 15) FCB2HL:         LD      HL,(DIRBUF)     ;get address of buffer.
D662-3A EA DE       2139 ( 12)         LD      A,(FCBPOS)      ;relative position of file.
D665-               2140       ;
D665-               2141       ;   Routine to add (A) to (HL).
D665-               2142       ;
D665-85             2143 (  4) ADDA2HL: ADD    A,L
D666-6F             2144 (  4)         LD      L,A
D667-D0             2145 ( 5+)         RET     NC
D668-24             2146 (  4)         INC     H               ;take care of any carry.
D669-C9             2147 (  9)         RET
D66A-               2148       ;
D66A-               2149       ;   Routine to get the 's2' byte from the fcb supplied in
D66A-               2150       ; the initial parameter specification.
D66A-               2151       ;
D66A-2A 44 D4       2152 ( 15) GETS2:  LD      HL,(PARAMS)     ;get address of fcb.
D66D-11 0E 00       2153 (  9)         LD      DE,14           ;relative position of 's2'.
D670-19             2154 (  7)         ADD     HL,DE
D671-7E             2155 (  6)         LD      A,(HL)          ;extract this byte.
D672-C9             2156 (  9)         RET
D673-               2157       ;
D673-               2158       ;   Clear the 's2' byte in the fcb.
D673-               2159       ;
D673-CD 6A D6       2160 ( 16) CLEARS2: CALL   GETS2           ;this sets (HL) pointing to it.
D676-36 00          2161 (  9)         LD      (HL),0          ;now clear it.
D678-C9             2162 (  9)         RET
D679-               2163       ;
D679-               2164       ;   Set bit 7 in the 's2' byte of the fcb.
D679-               2165       ;
D679-CD 6A D6       2166 ( 16) SETS2B7: CALL   GETS2           ;get the byte.
D67C-F6 80          2167 (  6)         OR      80H             ;and set bit 7.
D67E-77             2168 (  7)         LD      (HL),A          ;then store.
D67F-C9             2169 (  9)         RET
D680-               2170       ;
D680-               2171       ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
D680-               2172       ; the difference. This checks to see if there are more file
D680-               2173       ; names in the directory. We are at (FILEPOS) and there are
D680-               2174       ; (SCRATCH1) of them to check.
D680-               2175       ;
D680-2A EB DE       2176 ( 15) MOREFLS: LD     HL,(FILEPOS)    ;we are here.
D683-EB             2177 (  3)         EX      DE,HL
D684-2A B4 DE       2178 ( 15)         LD      HL,(SCRATCH1)   ;and don't go past here.
D687-7B             2179 (  4)         LD      A,E             ;compute difference but don't keep.
D688-96             2180 (  6)         SUB     (HL)
D689-23             2181 (  4)         INC     HL
D68A-7A             2182 (  4)         LD      A,D
D68B-9E             2183 (  6)         SBC     A,(HL)          ;set carry if no more names.
D68C-C9             2184 (  9)         RET
D68D-               2185       ;
D68D-               2186       ;   Call this routine to prevent (SCRATCH1) from being greater
D68D-               2187       ; than (FILEPOS).
D68D-               2188       ;
D68D-CD 80 D6       2189 ( 16) CHKNMBR: CALL   MOREFLS         ;SCRATCH1 too big?
D690-D8             2190 ( 5+)         RET     C
D691-13             2191 (  4)         INC     DE              ;yes, reset it to (FILEPOS).
D692-72             2192 (  7)         LD      (HL),D
D693-2B             2193 (  4)         DEC     HL
D694-73             2194 (  7)         LD      (HL),E
D695-C9             2195 (  9)         RET
D696-               2196       ;
D696-               2197       ;   Compute (HL)=(DE)-(HL)
D696-               2198       ;
D696-7B             2199 (  4) SUBHL:  LD      A,E             ;compute difference.
D697-95             2200 (  4)         SUB     L
D698-6F             2201 (  4)         LD      L,A             ;store low byte.
D699-7A             2202 (  4)         LD      A,D
D69A-9C             2203 (  4)         SBC     A,H
D69B-67             2204 (  4)         LD      H,A             ;and then high byte.
D69C-C9             2205 (  9)         RET
D69D-               2206       ;
D69D-               2207       ;   Set the directory checksum byte.
D69D-               2208       ;
D69D-0E FF          2209 (  6) SETDIR:         LD      C,0FFH
D69F-               2210       ;
D69F-               2211       ;   Routine to set or compare the directory checksum byte. If
D69F-               2212       ; (C)=0ffh, then this will set the checksum byte. Else the byte
D69F-               2213       ; will be checked. If the check fails (the disk has been changed),
D69F-               2214       ; then this disk will be write protected.
D69F-               2215       ;
D69F-2A ED DE       2216 ( 15) CHECKDIR:  LD   HL,(CKSUMTBL)
D6A2-EB             2217 (  3)         EX      DE,HL
D6A3-2A CD DE       2218 ( 15)         LD      HL,(ALLOC1)
D6A6-CD 96 D6       2219 ( 16)         CALL    SUBHL
D6A9-D0             2220 ( 5+)         RET     NC              ;ok if (CKSUMTBL) > (ALLOC1), so return.
D6AA-C5             2221 ( 11)         PUSH    BC
D6AB-CD F8 D5       2222 ( 16)         CALL    CHECKSUM        ;else compute checksum.
D6AE-2A BE DE       2223 ( 15)         LD      HL,(CHKVECT)    ;get address of checksum table.
D6B1-EB             2224 (  3)         EX      DE,HL
D6B2-2A ED DE       2225 ( 15)         LD      HL,(CKSUMTBL)
D6B5-19             2226 (  7)         ADD     HL,DE           ;set (HL) to point to byte for this drive.
D6B6-C1             2227 (  9)         POP     BC
D6B7-0C             2228 (  4)         INC     C               ;set or check ?
D6B8-CA C5 D6       2229 ( 6+)         JP      Z,CHKDIR1
D6BB-BE             2230 (  6)         CP      (HL)            ;check them.
D6BC-C8             2231 ( 5+)         RET     Z               ;return if they are the same.
D6BD-CD 80 D6       2232 ( 16)         CALL    MOREFLS         ;not the same, do we care?
D6C0-D0             2233 ( 5+)         RET     NC
D6C1-CD 2D D6       2234 ( 16)         CALL    WRTPRTD         ;yes, mark this as write protected.
D6C4-C9             2235 (  9)         RET
D6C5-77             2236 (  7) CHKDIR1: LD     (HL),A          ;just set the byte.
D6C6-C9             2237 (  9)         RET
D6C7-               2238       ;
D6C7-               2239       ;   Do a write to the directory of the current disk.
D6C7-               2240       ;
D6C7-CD 9D D6       2241 ( 16) DIRWRITE:  CALL SETDIR          ;set checksum byte.
D6CA-CD E1 D6       2242 ( 16)         CALL    DIRDMA          ;set directory dma address.
D6CD-0E 01          2243 (  6)         LD      C,1             ;tell the bios to actually write.
D6CF-CD B9 D4       2244 ( 16)         CALL    DOWRITE         ;then do the write.
D6D2-C3 DB D6       2245 (  9)         JP      DEFDMA
D6D5-               2246       ;
D6D5-               2247       ;   Read from the directory.
D6D5-               2248       ;
D6D5-CD E1 D6       2249 ( 16) DIRREAD: CALL   DIRDMA          ;set the directory dma address.
D6D8-CD B3 D4       2250 ( 16)         CALL    DOREAD          ;and read it.
D6DB-               2251       ;
D6DB-               2252       ;   Routine to set the dma address to the users choice.
D6DB-               2253       ;
D6DB-21 B2 DE       2254 (  9) DEFDMA:         LD      HL,USERDMA      ;reset the default dma address and return.
D6DE-C3 E4 D6       2255 (  9)         JP      DIRDMA1
D6E1-               2256       ;
D6E1-               2257       ;   Routine to set the dma address for directory work.
D6E1-               2258       ;
D6E1-21 BA DE       2259 (  9) DIRDMA:         LD      HL,DIRBUF
D6E4-               2260       ;
D6E4-               2261       ;   Set the dma address. On entry, (HL) points to
D6E4-               2262       ; word containing the desired dma address.
D6E4-               2263       ;
D6E4-4E             2264 (  6) DIRDMA1: LD     C,(HL)
D6E5-23             2265 (  4)         INC     HL
D6E6-46             2266 (  6)         LD      B,(HL)          ;setup (BC) and go to the bios to set it.
D6E7-C3 25 DF       2267 (  9)         JP      SETDMA
D6EA-               2268       ;
D6EA-               2269       ;   Move the directory buffer into user's dma space.
D6EA-               2270       ;
D6EA-2A BA DE       2271 ( 15) MOVEDIR: LD     HL,(DIRBUF)     ;buffer is located here, and
D6ED-EB             2272 (  3)         EX      DE,HL
D6EE-2A B2 DE       2273 ( 15)         LD      HL,(USERDMA)    ; put it here.
D6F1-0E 80          2274 (  6)         LD      C,128           ;this is its length.
D6F3-C3 50 D4       2275 (  9)         JP      DE2HL           ;move it now and return.
D6F6-               2276       ;
D6F6-               2277       ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
D6F6-               2278       ;
D6F6-21 EB DE       2279 (  9) CKFILPOS:  LD   HL,FILEPOS
D6F9-7E             2280 (  6)         LD      A,(HL)
D6FA-23             2281 (  4)         INC     HL
D6FB-BE             2282 (  6)         CP      (HL)            ;are both bytes the same?
D6FC-C0             2283 ( 5+)         RET     NZ
D6FD-3C             2284 (  4)         INC     A               ;yes, but are they each 0ffh?
D6FE-C9             2285 (  9)         RET
D6FF-               2286       ;
D6FF-               2287       ;   Set location (FILEPOS) to 0ffffh.
D6FF-               2288       ;
D6FF-21 FF FF       2289 (  9) STFILPOS:  LD   HL,0FFFFH
D702-22 EB DE       2290 ( 20)         LD      (FILEPOS),HL
D705-C9             2291 (  9)         RET
D706-               2292       ;
D706-               2293       ;   Move on to the next file position within the current
D706-               2294       ; directory buffer. If no more exist, set pointer to 0ffffh
D706-               2295       ; and the calling routine will check for this. Enter with (C)
D706-               2296       ; equal to 0ffh to cause the checksum byte to be set, else we
D706-               2297       ; will check this disk and set write protect if checksums are
D706-               2298       ; not the same (applies only if another directory sector must
D706-               2299       ; be read).
D706-               2300       ;
D706-2A C9 DE       2301 ( 15) NXENTRY: LD     HL,(DIRSIZE)    ;get directory entry size limit.
D709-EB             2302 (  3)         EX      DE,HL
D70A-2A EB DE       2303 ( 15)         LD      HL,(FILEPOS)    ;get current count.
D70D-23             2304 (  4)         INC     HL              ;go on to the next one.
D70E-22 EB DE       2305 ( 20)         LD      (FILEPOS),HL
D711-CD 96 D6       2306 ( 16)         CALL    SUBHL           ;(HL)=(DIRSIZE)-(FILEPOS)
D714-D2 1A D7       2307 ( 6+)         JP      NC,NXENT1       ;is there more room left?
D717-C3 FF D6       2308 (  9)         JP      STFILPOS        ;no. Set this flag and return.
D71A-3A EB DE       2309 ( 12) NXENT1:         LD      A,(FILEPOS)     ;get file position within directory.
D71D-E6 03          2310 (  6)         AND     03H             ;only look within this sector (only 4 entries fit).
D71F-06 05          2311 (  6)         LD      B,5             ;convert to relative position (32 bytes each).
D721-87             2312 (  4) NXENT2:         ADD     A,A             ;note that this is not efficient code.
D722-05             2313 (  4)         DEC     B               ;5 'ADD A's would be better.
D723-C2 21 D7       2314 ( 6+)         JP      NZ,NXENT2
D726-32 EA DE       2315 ( 13)         LD      (FCBPOS),A      ;save it as position of fcb.
D729-B7             2316 (  4)         OR      A
D72A-C0             2317 ( 5+)         RET     NZ              ;return if we are within buffer.
D72B-C5             2318 ( 11)         PUSH    BC
D72C-CD C4 D4       2319 ( 16)         CALL    TRKSEC          ;we need the next directory sector.
D72F-CD D5 D6       2320 ( 16)         CALL    DIRREAD
D732-C1             2321 (  9)         POP     BC
D733-C3 9F D6       2322 (  9)         JP      CHECKDIR
D736-               2323       ;
D736-               2324       ;   Routine to to get a bit from the disk space allocation
D736-               2325       ; map. It is returned in (A), bit position 0. On entry to here,
D736-               2326       ; set (BC) to the block number on the disk to check.
D736-               2327       ; On return, (D) will contain the original bit position for
D736-               2328       ; this block number and (HL) will point to the address for it.
D736-               2329       ;
D736-79             2330 (  4) CKBITMAP:  LD   A,C             ;determine bit number of interest.
D737-E6 07          2331 (  6)         AND     07H             ;compute (D)=(E)=(C and 7)+1.
D739-3C             2332 (  4)         INC     A
D73A-5F             2333 (  4)         LD      E,A             ;save particular bit number.
D73B-57             2334 (  4)         LD      D,A
D73C-               2335       ;
D73C-               2336       ;   compute (BC)=(BC)/8.
D73C-               2337       ;
D73C-79             2338 (  4)         LD      A,C
D73D-0F             2339 (  3)         RRCA                    ;now shift right 3 bits.
D73E-0F             2340 (  3)         RRCA
D73F-0F             2341 (  3)         RRCA
D740-E6 1F          2342 (  6)         AND     1FH             ;and clear bits 7,6,5.
D742-4F             2343 (  4)         LD      C,A
D743-78             2344 (  4)         LD      A,B
D744-87             2345 (  4)         ADD     A,A             ;now shift (B) into bits 7,6,5.
D745-87             2346 (  4)         ADD     A,A
D746-87             2347 (  4)         ADD     A,A
D747-87             2348 (  4)         ADD     A,A
D748-87             2349 (  4)         ADD     A,A
D749-B1             2350 (  4)         OR      C               ;and add in (C).
D74A-4F             2351 (  4)         LD      C,A             ;ok, (C) ha been completed.
D74B-78             2352 (  4)         LD      A,B             ;is there a better way of doing this?
D74C-0F             2353 (  3)         RRCA
D74D-0F             2354 (  3)         RRCA
D74E-0F             2355 (  3)         RRCA
D74F-E6 1F          2356 (  6)         AND     1FH
D751-47             2357 (  4)         LD      B,A             ;and now (B) is completed.
D752-               2358       ;
D752-               2359       ;   use this as an offset into the disk space allocation
D752-               2360       ; table.
D752-               2361       ;
D752-2A C0 DE       2362 ( 15)         LD      HL,(ALOCVECT)
D755-09             2363 (  7)         ADD     HL,BC
D756-7E             2364 (  6)         LD      A,(HL)          ;now get correct byte.
D757-07             2365 (  3) CKBMAP1: RLCA                   ;get correct bit into position 0.
D758-1D             2366 (  4)         DEC     E
D759-C2 57 D7       2367 ( 6+)         JP      NZ,CKBMAP1
D75C-C9             2368 (  9)         RET
D75D-               2369       ;
D75D-               2370       ;   Set or clear the bit map such that block number (BC) will be marked
D75D-               2371       ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
D75D-               2372       ; 1 then it will be set (don't use anyother values).
D75D-               2373       ;
D75D-D5             2374 ( 11) STBITMAP:  PUSH DE
D75E-CD 36 D7       2375 ( 16)         CALL    CKBITMAP        ;get the byte of interest.
D761-E6 FE          2376 (  6)         AND     0FEH            ;clear the affected bit.
D763-C1             2377 (  9)         POP     BC
D764-B1             2378 (  4)         OR      C               ;and now set it acording to (C).
D765-               2379       ;
D765-               2380       ;  entry to restore the original bit position and then store
D765-               2381       ; in table. (A) contains the value, (D) contains the bit
D765-               2382       ; position (1-8), and (HL) points to the address within the
D765-               2383       ; space allocation table for this byte.
D765-               2384       ;
D765-0F             2385 (  3) STBMAP1: RRCA                   ;restore original bit position.
D766-15             2386 (  4)         DEC     D
D767-C2 65 D7       2387 ( 6+)         JP      NZ,STBMAP1
D76A-77             2388 (  7)         LD      (HL),A          ;and stor byte in table.
D76B-C9             2389 (  9)         RET
D76C-               2390       ;
D76C-               2391       ;   Set/clear space used bits in allocation map for this file.
D76C-               2392       ; On entry, (C)=1 to set the map and (C)=0 to clear it.
D76C-               2393       ;
D76C-CD 5F D6       2394 ( 16) SETFILE: CALL   FCB2HL          ;get address of fcb
D76F-11 10 00       2395 (  9)         LD      DE,16
D772-19             2396 (  7)         ADD     HL,DE           ;get to block number bytes.
D773-C5             2397 ( 11)         PUSH    BC
D774-0E 11          2398 (  6)         LD      C,17            ;check all 17 bytes (max) of table.
D776-D1             2399 (  9) SETFL1:         POP     DE
D777-0D             2400 (  4)         DEC     C               ;done all bytes yet?
D778-C8             2401 ( 5+)         RET     Z
D779-D5             2402 ( 11)         PUSH    DE
D77A-3A DE DE       2403 ( 12)         LD      A,(BIGDISK)     ;check disk size for 16 bit block numbers.
D77D-B7             2404 (  4)         OR      A
D77E-CA 89 D7       2405 ( 6+)         JP      Z,SETFL2
D781-C5             2406 ( 11)         PUSH    BC              ;only 8 bit numbers. set (BC) to this one.
D782-E5             2407 ( 11)         PUSH    HL
D783-4E             2408 (  6)         LD      C,(HL)          ;get low byte from table, always
D784-06 00          2409 (  6)         LD      B,0             ;set high byte to zero.
D786-C3 8F D7       2410 (  9)         JP      SETFL3
D789-0D             2411 (  4) SETFL2:         DEC     C               ;for 16 bit block numbers, adjust counter.
D78A-C5             2412 ( 11)         PUSH    BC
D78B-4E             2413 (  6)         LD      C,(HL)          ;now get both the low and high bytes.
D78C-23             2414 (  4)         INC     HL
D78D-46             2415 (  6)         LD      B,(HL)
D78E-E5             2416 ( 11)         PUSH    HL
D78F-79             2417 (  4) SETFL3:         LD      A,C             ;block used?
D790-B0             2418 (  4)         OR      B
D791-CA 9E D7       2419 ( 6+)         JP      Z,SETFL4
D794-2A C7 DE       2420 ( 15)         LD      HL,(DSKSIZE)    ;is this block number within the
D797-7D             2421 (  4)         LD      A,L             ;space on the disk?
D798-91             2422 (  4)         SUB     C
D799-7C             2423 (  4)         LD      A,H
D79A-98             2424 (  4)         SBC     A,B
D79B-D4 5D D7       2425 ( 6+)         CALL    NC,STBITMAP     ;yes, set the proper bit.
D79E-E1             2426 (  9) SETFL4:         POP     HL              ;point to next block number in fcb.
D79F-23             2427 (  4)         INC     HL
D7A0-C1             2428 (  9)         POP     BC
D7A1-C3 76 D7       2429 (  9)         JP      SETFL1
D7A4-               2430       ;
D7A4-               2431       ;   Construct the space used allocation bit map for the active
D7A4-               2432       ; drive. If a file name starts with '$' and it is under the
D7A4-               2433       ; current user number, then (STATUS) is set to minus 1. Otherwise
D7A4-               2434       ; it is not set at all.
D7A4-               2435       ;
D7A4-2A C7 DE       2436 ( 15) BITMAP:         LD      HL,(DSKSIZE)    ;compute size of allocation table.
D7A7-0E 03          2437 (  6)         LD      C,3
D7A9-CD EB D5       2438 ( 16)         CALL    SHIFTR          ;(HL)=(HL)/8.
D7AC-23             2439 (  4)         INC     HL              ;at lease 1 byte.
D7AD-44             2440 (  4)         LD      B,H
D7AE-4D             2441 (  4)         LD      C,L             ;set (BC) to the allocation table length.
D7AF-               2442       ;
D7AF-               2443       ;   Initialize the bitmap for this drive. Right now, the first
D7AF-               2444       ; two bytes are specified by the disk parameter block. However
D7AF-               2445       ; a patch could be entered here if it were necessary to setup
D7AF-               2446       ; this table in a special mannor. For example, the bios could
D7AF-               2447       ; determine locations of 'bad blocks' and set them as already
D7AF-               2448       ; 'used' in the map.
D7AF-               2449       ;
D7AF-2A C0 DE       2450 ( 15)         LD      HL,(ALOCVECT)   ;now zero out the table now.
D7B2-36 00          2451 (  9) BITMAP1: LD     (HL),0
D7B4-23             2452 (  4)         INC     HL
D7B5-0B             2453 (  4)         DEC     BC
D7B6-78             2454 (  4)         LD      A,B
D7B7-B1             2455 (  4)         OR      C
D7B8-C2 B2 D7       2456 ( 6+)         JP      NZ,BITMAP1
D7BB-2A CB DE       2457 ( 15)         LD      HL,(ALLOC0)     ;get initial space used by directory.
D7BE-EB             2458 (  3)         EX      DE,HL
D7BF-2A C0 DE       2459 ( 15)         LD      HL,(ALOCVECT)   ;and put this into map.
D7C2-73             2460 (  7)         LD      (HL),E
D7C3-23             2461 (  4)         INC     HL
D7C4-72             2462 (  7)         LD      (HL),D
D7C5-               2463       ;
D7C5-               2464       ;   End of initialization portion.
D7C5-               2465       ;
D7C5-CD A2 D4       2466 ( 16)         CALL    HOMEDRV         ;now home the drive.
D7C8-2A B4 DE       2467 ( 15)         LD      HL,(SCRATCH1)
D7CB-36 03          2468 (  9)         LD      (HL),3          ;force next directory request to read
D7CD-23             2469 (  4)         INC     HL              ;in a sector.
D7CE-36 00          2470 (  9)         LD      (HL),0
D7D0-CD FF D6       2471 ( 16)         CALL    STFILPOS        ;clear initial file position also.
D7D3-0E FF          2472 (  6) BITMAP2: LD     C,0FFH          ;read next file name in directory
D7D5-CD 06 D7       2473 ( 16)         CALL    NXENTRY         ;and set checksum byte.
D7D8-CD F6 D6       2474 ( 16)         CALL    CKFILPOS        ;is there another file?
D7DB-C8             2475 ( 5+)         RET     Z
D7DC-CD 5F D6       2476 ( 16)         CALL    FCB2HL          ;yes, get its address.
D7DF-3E E5          2477 (  6)         LD      A,0E5H
D7E1-BE             2478 (  6)         CP      (HL)            ;empty file entry?
D7E2-CA D3 D7       2479 ( 6+)         JP      Z,BITMAP2
D7E5-3A 42 D4       2480 ( 12)         LD      A,(USERNO)      ;no, correct user number?
D7E8-BE             2481 (  6)         CP      (HL)
D7E9-C2 F7 D7       2482 ( 6+)         JP      NZ,BITMAP3
D7EC-23             2483 (  4)         INC     HL
D7ED-7E             2484 (  6)         LD      A,(HL)          ;yes, does name start with a '$'?
D7EE-D6 24          2485 (  6)         SUB     '$'
D7F0-C2 F7 D7       2486 ( 6+)         JP      NZ,BITMAP3
D7F3-3D             2487 (  4)         DEC     A               ;yes, set atatus to minus one.
D7F4-32 46 D4       2488 ( 13)         LD      (STATUS),A
D7F7-0E 01          2489 (  6) BITMAP3: LD     C,1             ;now set this file's space as used in bit map.
D7F9-CD 6C D7       2490 ( 16)         CALL    SETFILE
D7FC-CD 8D D6       2491 ( 16)         CALL    CHKNMBR         ;keep (SCRATCH1) in bounds.
D7FF-C3 D3 D7       2492 (  9)         JP      BITMAP2
D802-               2493       ;
D802-               2494       ;   Set the status (STATUS) and return.
D802-               2495       ;
D802-3A D5 DE       2496 ( 12) STSTATUS:  LD   A,(FNDSTAT)
D805-C3 02 D4       2497 (  9)         JP      SETSTAT
D808-               2498       ;
D808-               2499       ;   Check extents in (A) and (C). Set the zero flag if they
D808-               2500       ; are the same. The number of 16k chunks of disk space that
D808-               2501       ; the directory extent covers is expressad is (EXTMASK+1).
D808-               2502       ; No registers are modified.
D808-               2503       ;
D808-C5             2504 ( 11) SAMEXT:         PUSH    BC
D809-F5             2505 ( 11)         PUSH    AF
D80A-3A C6 DE       2506 ( 12)         LD      A,(EXTMASK)     ;get extent mask and use it to
D80D-2F             2507 (  3)         CPL                     ;to compare both extent numbers.
D80E-47             2508 (  4)         LD      B,A             ;save resulting mask here.
D80F-79             2509 (  4)         LD      A,C             ;mask first extent and save in (C).
D810-A0             2510 (  4)         AND     B
D811-4F             2511 (  4)         LD      C,A
D812-F1             2512 (  9)         POP     AF              ;now mask second extent and compare
D813-A0             2513 (  4)         AND     B               ;with the first one.
D814-91             2514 (  4)         SUB     C
D815-E6 1F          2515 (  6)         AND     1FH             ;(* only check buts 0-4 *)
D817-C1             2516 (  9)         POP     BC              ;the zero flag is set if they are the same.
D818-C9             2517 (  9)         RET                     ;restore (BC) and return.
D819-               2518       ;
D819-               2519       ;   Search for the first occurence of a file name. On entry,
D819-               2520       ; register (C) should contain the number of bytes of the fcb
D819-               2521       ; that must match.
D819-               2522       ;
D819-3E FF          2523 (  6) FINDFST: LD     A,0FFH
D81B-32 D5 DE       2524 ( 13)         LD      (FNDSTAT),A
D81E-21 D9 DE       2525 (  9)         LD      HL,COUNTER      ;save character count.
D821-71             2526 (  7)         LD      (HL),C
D822-2A 44 D4       2527 ( 15)         LD      HL,(PARAMS)     ;get filename to match.
D825-22 DA DE       2528 ( 20)         LD      (SAVEFCB),HL    ;and save.
D828-CD FF D6       2529 ( 16)         CALL    STFILPOS        ;clear initial file position (set to 0ffffh).
D82B-CD A2 D4       2530 ( 16)         CALL    HOMEDRV         ;home the drive.
D82E-               2531       ;
D82E-               2532       ;   Entry to locate the next occurence of a filename within the
D82E-               2533       ; directory. The disk is not expected to have been changed. If
D82E-               2534       ; it was, then it will be write protected.
D82E-               2535       ;
D82E-0E 00          2536 (  6) FINDNXT: LD     C,0             ;write protect the disk if changed.
D830-CD 06 D7       2537 ( 16)         CALL    NXENTRY         ;get next filename entry in directory.
D833-CD F6 D6       2538 ( 16)         CALL    CKFILPOS        ;is file position = 0ffffh?
D836-CA 95 D8       2539 ( 6+)         JP      Z,FNDNXT6       ;yes, exit now then.
D839-2A DA DE       2540 ( 15)         LD      HL,(SAVEFCB)    ;set (DE) pointing to filename to match.
D83C-EB             2541 (  3)         EX      DE,HL
D83D-1A             2542 (  6)         LD      A,(DE)
D83E-FE E5          2543 (  6)         CP      0E5H            ;empty directory entry?
D840-CA 4B D8       2544 ( 6+)         JP      Z,FNDNXT1       ;(* are we trying to reserect erased entries? *)
D843-D5             2545 ( 11)         PUSH    DE
D844-CD 80 D6       2546 ( 16)         CALL    MOREFLS         ;more files in directory?
D847-D1             2547 (  9)         POP     DE
D848-D2 95 D8       2548 ( 6+)         JP      NC,FNDNXT6      ;no more. Exit now.
D84B-CD 5F D6       2549 ( 16) FNDNXT1: CALL   FCB2HL          ;get address of this fcb in directory.
D84E-3A D9 DE       2550 ( 12)         LD      A,(COUNTER)     ;get number of bytes (characters) to check.
D851-4F             2551 (  4)         LD      C,A
D852-06 00          2552 (  6)         LD      B,0             ;initialize byte position counter.
D854-79             2553 (  4) FNDNXT2: LD     A,C             ;are we done with the compare?
D855-B7             2554 (  4)         OR      A
D856-CA 84 D8       2555 ( 6+)         JP      Z,FNDNXT5
D859-1A             2556 (  6)         LD      A,(DE)          ;no, check next byte.
D85A-FE 3F          2557 (  6)         CP      '?'             ;don't care about this character?
D85C-CA 7D D8       2558 ( 6+)         JP      Z,FNDNXT4
D85F-78             2559 (  4)         LD      A,B             ;get bytes position in fcb.
D860-FE 0D          2560 (  6)         CP      13              ;don't care about the thirteenth byte either.
D862-CA 7D D8       2561 ( 6+)         JP      Z,FNDNXT4
D865-FE 0C          2562 (  6)         CP      12              ;extent byte?
D867-1A             2563 (  6)         LD      A,(DE)
D868-CA 74 D8       2564 ( 6+)         JP      Z,FNDNXT3
D86B-96             2565 (  6)         SUB     (HL)            ;otherwise compare characters.
D86C-E6 7F          2566 (  6)         AND     7FH
D86E-C2 2E D8       2567 ( 6+)         JP      NZ,FINDNXT      ;not the same, check next entry.
D871-C3 7D D8       2568 (  9)         JP      FNDNXT4         ;so far so good, keep checking.
D874-C5             2569 ( 11) FNDNXT3: PUSH   BC              ;check the extent byte here.
D875-4E             2570 (  6)         LD      C,(HL)
D876-CD 08 D8       2571 ( 16)         CALL    SAMEXT
D879-C1             2572 (  9)         POP     BC
D87A-C2 2E D8       2573 ( 6+)         JP      NZ,FINDNXT      ;not the same, look some more.
D87D-               2574       ;
D87D-               2575       ;   So far the names compare. Bump pointers to the next byte
D87D-               2576       ; and continue until all (C) characters have been checked.
D87D-               2577       ;
D87D-13             2578 (  4) FNDNXT4: INC    DE              ;bump pointers.
D87E-23             2579 (  4)         INC     HL
D87F-04             2580 (  4)         INC     B
D880-0D             2581 (  4)         DEC     C               ;adjust character counter.
D881-C3 54 D8       2582 (  9)         JP      FNDNXT2
D884-3A EB DE       2583 ( 12) FNDNXT5: LD     A,(FILEPOS)     ;return the position of this entry.
D887-E6 03          2584 (  6)         AND     03H
D889-32 46 D4       2585 ( 13)         LD      (STATUS),A
D88C-21 D5 DE       2586 (  9)         LD      HL,FNDSTAT
D88F-7E             2587 (  6)         LD      A,(HL)
D890-17             2588 (  3)         RLA
D891-D0             2589 ( 5+)         RET     NC
D892-AF             2590 (  4)         XOR     A
D893-77             2591 (  7)         LD      (HL),A
D894-C9             2592 (  9)         RET
D895-               2593       ;
D895-               2594       ;   Filename was not found. Set appropriate status.
D895-               2595       ;
D895-CD FF D6       2596 ( 16) FNDNXT6: CALL   STFILPOS        ;set (FILEPOS) to 0ffffh.
D898-3E FF          2597 (  6)         LD      A,0FFH          ;say not located.
D89A-C3 02 D4       2598 (  9)         JP      SETSTAT
D89D-               2599       ;
D89D-               2600       ;   Erase files from the directory. Only the first byte of the
D89D-               2601       ; fcb will be affected. It is set to (E5).
D89D-               2602       ;
D89D-CD 55 D6       2603 ( 16) ERAFILE: CALL   CHKWPRT         ;is disk write protected?
D8A0-0E 0C          2604 (  6)         LD      C,12            ;only compare file names.
D8A2-CD 19 D8       2605 ( 16)         CALL    FINDFST         ;get first file name.
D8A5-CD F6 D6       2606 ( 16) ERAFIL1: CALL   CKFILPOS        ;any found?
D8A8-C8             2607 ( 5+)         RET     Z               ;nope, we must be done.
D8A9-CD 45 D6       2608 ( 16)         CALL    CHKROFL         ;is file read only?
D8AC-CD 5F D6       2609 ( 16)         CALL    FCB2HL          ;nope, get address of fcb and
D8AF-36 E5          2610 (  9)         LD      (HL),0E5H       ;set first byte to 'empty'.
D8B1-0E 00          2611 (  6)         LD      C,0             ;clear the space from the bit map.
D8B3-CD 6C D7       2612 ( 16)         CALL    SETFILE
D8B6-CD C7 D6       2613 ( 16)         CALL    DIRWRITE        ;now write the directory sector back out.
D8B9-CD 2E D8       2614 ( 16)         CALL    FINDNXT         ;find the next file name.
D8BC-C3 A5 D8       2615 (  9)         JP      ERAFIL1         ;and repeat process.
D8BF-               2616       ;
D8BF-               2617       ;   Look through the space allocation map (bit map) for the
D8BF-               2618       ; next available block. Start searching at block number (BC-1).
D8BF-               2619       ; The search procedure is to look for an empty block that is
D8BF-               2620       ; before the starting block. If not empty, look at a later
D8BF-               2621       ; block number. In this way, we return the closest empty block
D8BF-               2622       ; on either side of the 'target' block number. This will speed
D8BF-               2623       ; access on random devices. For serial devices, this should be
D8BF-               2624       ; changed to look in the forward direction first and then start
D8BF-               2625       ; at the front and search some more.
D8BF-               2626       ;
D8BF-               2627       ;   On return, (DE)= block number that is empty and (HL) =0
D8BF-               2628       ; if no empry block was found.
D8BF-               2629       ;
D8BF-50             2630 (  4) FNDSPACE:  LD   D,B             ;set (DE) as the block that is checked.
D8C0-59             2631 (  4)         LD      E,C
D8C1-               2632       ;
D8C1-               2633       ;   Look before target block. Registers (BC) are used as the lower
D8C1-               2634       ; pointer and (DE) as the upper pointer.
D8C1-               2635       ;
D8C1-79             2636 (  4) FNDSPA1: LD     A,C             ;is block 0 specified?
D8C2-B0             2637 (  4)         OR      B
D8C3-CA D2 D8       2638 ( 6+)         JP      Z,FNDSPA2
D8C6-0B             2639 (  4)         DEC     BC              ;nope, check previous block.
D8C7-D5             2640 ( 11)         PUSH    DE
D8C8-C5             2641 ( 11)         PUSH    BC
D8C9-CD 36 D7       2642 ( 16)         CALL    CKBITMAP
D8CC-1F             2643 (  3)         RRA                     ;is this block empty?
D8CD-D2 ED D8       2644 ( 6+)         JP      NC,FNDSPA3      ;yes. use this.
D8D0-               2645       ;
D8D0-               2646       ;   Note that the above logic gets the first block that it finds
D8D0-               2647       ; that is empty. Thus a file could be written 'backward' making
D8D0-               2648       ; it very slow to access. This could be changed to look for the
D8D0-               2649       ; first empty block and then continue until the start of this
D8D0-               2650       ; empty space is located and then used that starting block.
D8D0-               2651       ; This should help speed up access to some files especially on
D8D0-               2652       ; a well used disk with lots of fairly small 'holes'.
D8D0-               2653       ;
D8D0-C1             2654 (  9)         POP     BC              ;nope, check some more.
D8D1-D1             2655 (  9)         POP     DE
D8D2-               2656       ;
D8D2-               2657       ;   Now look after target block.
D8D2-               2658       ;
D8D2-2A C7 DE       2659 ( 15) FNDSPA2: LD     HL,(DSKSIZE)    ;is block (DE) within disk limits?
D8D5-7B             2660 (  4)         LD      A,E
D8D6-95             2661 (  4)         SUB     L
D8D7-7A             2662 (  4)         LD      A,D
D8D8-9C             2663 (  4)         SBC     A,H
D8D9-D2 F5 D8       2664 ( 6+)         JP      NC,FNDSPA4
D8DC-13             2665 (  4)         INC     DE              ;yes, move on to next one.
D8DD-C5             2666 ( 11)         PUSH    BC
D8DE-D5             2667 ( 11)         PUSH    DE
D8DF-42             2668 (  4)         LD      B,D
D8E0-4B             2669 (  4)         LD      C,E
D8E1-CD 36 D7       2670 ( 16)         CALL    CKBITMAP        ;check it.
D8E4-1F             2671 (  3)         RRA                     ;empty?
D8E5-D2 ED D8       2672 ( 6+)         JP      NC,FNDSPA3
D8E8-D1             2673 (  9)         POP     DE              ;nope, continue searching.
D8E9-C1             2674 (  9)         POP     BC
D8EA-C3 C1 D8       2675 (  9)         JP      FNDSPA1
D8ED-               2676       ;
D8ED-               2677       ;   Empty block found. Set it as used and return with (HL)
D8ED-               2678       ; pointing to it (true?).
D8ED-               2679       ;
D8ED-17             2680 (  3) FNDSPA3: RLA                    ;reset byte.
D8EE-3C             2681 (  4)         INC     A               ;and set bit 0.
D8EF-CD 65 D7       2682 ( 16)         CALL    STBMAP1         ;update bit map.
D8F2-E1             2683 (  9)         POP     HL              ;set return registers.
D8F3-D1             2684 (  9)         POP     DE
D8F4-C9             2685 (  9)         RET
D8F5-               2686       ;
D8F5-               2687       ;   Free block was not found. If (BC) is not zero, then we have
D8F5-               2688       ; not checked all of the disk space.
D8F5-               2689       ;
D8F5-79             2690 (  4) FNDSPA4: LD     A,C
D8F6-B0             2691 (  4)         OR      B
D8F7-C2 C1 D8       2692 ( 6+)         JP      NZ,FNDSPA1
D8FA-21 00 00       2693 (  9)         LD      HL,0            ;set 'not found' status.
D8FD-C9             2694 (  9)         RET
D8FE-               2695       ;
D8FE-               2696       ;   Move a complete fcb entry into the directory and write it.
D8FE-               2697       ;
D8FE-0E 00          2698 (  6) FCBSET:         LD      C,0
D900-1E 20          2699 (  6)         LD      E,32            ;length of each entry.
D902-               2700       ;
D902-               2701       ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
D902-               2702       ; fcb in directory starting at relative byte (C). This updated
D902-               2703       ; directory buffer is then written to the disk.
D902-               2704       ;
D902-D5             2705 ( 11) UPDATE:         PUSH    DE
D903-06 00          2706 (  6)         LD      B,0             ;set (BC) to relative byte position.
D905-2A 44 D4       2707 ( 15)         LD      HL,(PARAMS)     ;get address of fcb.
D908-09             2708 (  7)         ADD     HL,BC           ;compute starting byte.
D909-EB             2709 (  3)         EX      DE,HL
D90A-CD 5F D6       2710 ( 16)         CALL    FCB2HL          ;get address of fcb to update in directory.
D90D-C1             2711 (  9)         POP     BC              ;set (C) to number of bytes to change.
D90E-CD 50 D4       2712 ( 16)         CALL    DE2HL
D911-CD C4 D4       2713 ( 16) UPDATE1: CALL   TRKSEC          ;determine the track and sector affected.
D914-C3 C7 D6       2714 (  9)         JP      DIRWRITE        ;then write this sector out.
D917-               2715       ;
D917-               2716       ;   Routine to change the name of all files on the disk with a
D917-               2717       ; specified name. The fcb contains the current name as the
D917-               2718       ; first 12 characters and the new name 16 bytes into the fcb.
D917-               2719       ;
D917-CD 55 D6       2720 ( 16) CHGNAMES:  CALL CHKWPRT         ;check for a write protected disk.
D91A-0E 0C          2721 (  6)         LD      C,12            ;match first 12 bytes of fcb only.
D91C-CD 19 D8       2722 ( 16)         CALL    FINDFST         ;get first name.
D91F-2A 44 D4       2723 ( 15)         LD      HL,(PARAMS)     ;get address of fcb.
D922-7E             2724 (  6)         LD      A,(HL)          ;get user number.
D923-11 10 00       2725 (  9)         LD      DE,16           ;move over to desired name.
D926-19             2726 (  7)         ADD     HL,DE
D927-77             2727 (  7)         LD      (HL),A          ;keep same user number.
D928-CD F6 D6       2728 ( 16) CHGNAM1: CALL   CKFILPOS        ;any matching file found?
D92B-C8             2729 ( 5+)         RET     Z               ;no, we must be done.
D92C-CD 45 D6       2730 ( 16)         CALL    CHKROFL         ;check for read only file.
D92F-0E 10          2731 (  6)         LD      C,16            ;start 16 bytes into fcb.
D931-1E 0C          2732 (  6)         LD      E,12            ;and update the first 12 bytes of directory.
D933-CD 02 D9       2733 ( 16)         CALL    UPDATE
D936-CD 2E D8       2734 ( 16)         CALL    FINDNXT         ;get te next file name.
D939-C3 28 D9       2735 (  9)         JP      CHGNAM1         ;and continue.
D93C-               2736       ;
D93C-               2737       ;   Update a files attributes. The procedure is to search for
D93C-               2738       ; every file with the same name as shown in fcb (ignoring bit 7)
D93C-               2739       ; and then to update it (which includes bit 7). No other changes
D93C-               2740       ; are made.
D93C-               2741       ;
D93C-0E 0C          2742 (  6) SAVEATTR:  LD   C,12            ;match first 12 bytes.
D93E-CD 19 D8       2743 ( 16)         CALL    FINDFST         ;look for first filename.
D941-CD F6 D6       2744 ( 16) SAVATR1: CALL   CKFILPOS        ;was one found?
D944-C8             2745 ( 5+)         RET     Z               ;nope, we must be done.
D945-0E 00          2746 (  6)         LD      C,0             ;yes, update the first 12 bytes now.
D947-1E 0C          2747 (  6)         LD      E,12
D949-CD 02 D9       2748 ( 16)         CALL    UPDATE          ;update filename and write directory.
D94C-CD 2E D8       2749 ( 16)         CALL    FINDNXT         ;and get the next file.
D94F-C3 41 D9       2750 (  9)         JP      SAVATR1         ;then continue until done.
D952-               2751       ;
D952-               2752       ;  Open a file (name specified in fcb).
D952-               2753       ;
D952-0E 0F          2754 (  6) OPENIT:         LD      C,15            ;compare the first 15 bytes.
D954-CD 19 D8       2755 ( 16)         CALL    FINDFST         ;get the first one in directory.
D957-CD F6 D6       2756 ( 16)         CALL    CKFILPOS        ;any at all?
D95A-C8             2757 ( 5+)         RET     Z
D95B-CD A7 D5       2758 ( 16) OPENIT1: CALL   SETEXT          ;point to extent byte within users fcb.
D95E-7E             2759 (  6)         LD      A,(HL)          ;and get it.
D95F-F5             2760 ( 11)         PUSH    AF              ;save it and address.
D960-E5             2761 ( 11)         PUSH    HL
D961-CD 5F D6       2762 ( 16)         CALL    FCB2HL          ;point to fcb in directory.
D964-EB             2763 (  3)         EX      DE,HL
D965-2A 44 D4       2764 ( 15)         LD      HL,(PARAMS)     ;this is the users copy.
D968-0E 20          2765 (  6)         LD      C,32            ;move it into users space.
D96A-D5             2766 ( 11)         PUSH    DE
D96B-CD 50 D4       2767 ( 16)         CALL    DE2HL
D96E-CD 79 D6       2768 ( 16)         CALL    SETS2B7         ;set bit 7 in 's2' byte (unmodified).
D971-D1             2769 (  9)         POP     DE              ;now get the extent byte from this fcb.
D972-21 0C 00       2770 (  9)         LD      HL,12
D975-19             2771 (  7)         ADD     HL,DE
D976-4E             2772 (  6)         LD      C,(HL)          ;into (C).
D977-21 0F 00       2773 (  9)         LD      HL,15           ;now get the record count byte into (B).
D97A-19             2774 (  7)         ADD     HL,DE
D97B-46             2775 (  6)         LD      B,(HL)
D97C-E1             2776 (  9)         POP     HL              ;keep the same extent as the user had originally.
D97D-F1             2777 (  9)         POP     AF
D97E-77             2778 (  7)         LD      (HL),A
D97F-79             2779 (  4)         LD      A,C             ;is it the same as in the directory fcb?
D980-BE             2780 (  6)         CP      (HL)
D981-78             2781 (  4)         LD      A,B             ;if yes, then use the same record count.
D982-CA 8C D9       2782 ( 6+)         JP      Z,OPENIT2
D985-3E 00          2783 (  6)         LD      A,0             ;if the user specified an extent greater than
D987-DA 8C D9       2784 ( 6+)         JP      C,OPENIT2       ;the one in the directory, then set record count to 0.
D98A-3E 80          2785 (  6)         LD      A,128           ;otherwise set to maximum.
D98C-2A 44 D4       2786 ( 15) OPENIT2: LD     HL,(PARAMS)     ;set record count in users fcb to (A).
D98F-11 0F 00       2787 (  9)         LD      DE,15
D992-19             2788 (  7)         ADD     HL,DE           ;compute relative position.
D993-77             2789 (  7)         LD      (HL),A          ;and set the record count.
D994-C9             2790 (  9)         RET
D995-               2791       ;
D995-               2792       ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
D995-               2793       ; point to a zero value (16 bit).
D995-               2794       ;   Return with zero flag set it (DE) was moved. Registers (DE)
D995-               2795       ; and (HL) are not changed. However (A) is.
D995-               2796       ;
D995-7E             2797 (  6) MOVEWORD:  LD   A,(HL)          ;check for a zero word.
D996-23             2798 (  4)         INC     HL
D997-B6             2799 (  6)         OR      (HL)            ;both bytes zero?
D998-2B             2800 (  4)         DEC     HL
D999-C0             2801 ( 5+)         RET     NZ              ;nope, just return.
D99A-1A             2802 (  6)         LD      A,(DE)          ;yes, move two bytes from (DE) into
D99B-77             2803 (  7)         LD      (HL),A          ;this zero space.
D99C-13             2804 (  4)         INC     DE
D99D-23             2805 (  4)         INC     HL
D99E-1A             2806 (  6)         LD      A,(DE)
D99F-77             2807 (  7)         LD      (HL),A
D9A0-1B             2808 (  4)         DEC     DE              ;don't disturb these registers.
D9A1-2B             2809 (  4)         DEC     HL
D9A2-C9             2810 (  9)         RET
D9A3-               2811       ;
D9A3-               2812       ;   Get here to close a file specified by (fcb).
D9A3-               2813       ;
D9A3-AF             2814 (  4) CLOSEIT: XOR    A               ;clear status and file position bytes.
D9A4-32 46 D4       2815 ( 13)         LD      (STATUS),A
D9A7-32 EB DE       2816 ( 13)         LD      (FILEPOS),A
D9AA-32 EC DE       2817 ( 13)         LD      (FILEPOS+1),A
D9AD-CD 1F D6       2818 ( 16)         CALL    GETWPRT         ;get write protect bit for this drive.
D9B0-C0             2819 ( 5+)         RET     NZ              ;just return if it is set.
D9B1-CD 6A D6       2820 ( 16)         CALL    GETS2           ;else get the 's2' byte.
D9B4-E6 80          2821 (  6)         AND     80H             ;and look at bit 7 (file unmodified?).
D9B6-C0             2822 ( 5+)         RET     NZ              ;just return if set.
D9B7-0E 0F          2823 (  6)         LD      C,15            ;else look up this file in directory.
D9B9-CD 19 D8       2824 ( 16)         CALL    FINDFST
D9BC-CD F6 D6       2825 ( 16)         CALL    CKFILPOS        ;was it found?
D9BF-C8             2826 ( 5+)         RET     Z               ;just return if not.
D9C0-01 10 00       2827 (  9)         LD      BC,16           ;set (HL) pointing to records used section.
D9C3-CD 5F D6       2828 ( 16)         CALL    FCB2HL
D9C6-09             2829 (  7)         ADD     HL,BC
D9C7-EB             2830 (  3)         EX      DE,HL
D9C8-2A 44 D4       2831 ( 15)         LD      HL,(PARAMS)     ;do the same for users specified fcb.
D9CB-09             2832 (  7)         ADD     HL,BC
D9CC-0E 10          2833 (  6)         LD      C,16            ;this many bytes are present in this extent.
D9CE-3A DE DE       2834 ( 12) CLOSEIT1:  LD   A,(BIGDISK)     ;8 or 16 bit record numbers?
D9D1-B7             2835 (  4)         OR      A
D9D2-CA E9 D9       2836 ( 6+)         JP      Z,CLOSEIT4
D9D5-7E             2837 (  6)         LD      A,(HL)          ;just 8 bit. Get one from users fcb.
D9D6-B7             2838 (  4)         OR      A
D9D7-1A             2839 (  6)         LD      A,(DE)          ;now get one from directory fcb.
D9D8-C2 DC D9       2840 ( 6+)         JP      NZ,CLOSEIT2
D9DB-77             2841 (  7)         LD      (HL),A          ;users byte was zero. Update from directory.
D9DC-B7             2842 (  4) CLOSEIT2:  OR   A
D9DD-C2 E2 D9       2843 ( 6+)         JP      NZ,CLOSEIT3
D9E0-7E             2844 (  6)         LD      A,(HL)          ;directories byte was zero, update from users fcb.
D9E1-12             2845 (  7)         LD      (DE),A
D9E2-BE             2846 (  6) CLOSEIT3:  CP   (HL)            ;if neither one of these bytes were zero,
D9E3-C2 20 DA       2847 ( 6+)         JP      NZ,CLOSEIT7     ;then close error if they are not the same.
D9E6-C3 FE D9       2848 (  9)         JP      CLOSEIT5        ;ok so far, get to next byte in fcbs.
D9E9-CD 95 D9       2849 ( 16) CLOSEIT4:  CALL MOVEWORD        ;update users fcb if it is zero.
D9EC-EB             2850 (  3)         EX      DE,HL
D9ED-CD 95 D9       2851 ( 16)         CALL    MOVEWORD        ;update directories fcb if it is zero.
D9F0-EB             2852 (  3)         EX      DE,HL
D9F1-1A             2853 (  6)         LD      A,(DE)          ;if these two values are no different,
D9F2-BE             2854 (  6)         CP      (HL)            ;then a close error occured.
D9F3-C2 20 DA       2855 ( 6+)         JP      NZ,CLOSEIT7
D9F6-13             2856 (  4)         INC     DE              ;check second byte.
D9F7-23             2857 (  4)         INC     HL
D9F8-1A             2858 (  6)         LD      A,(DE)
D9F9-BE             2859 (  6)         CP      (HL)
D9FA-C2 20 DA       2860 ( 6+)         JP      NZ,CLOSEIT7
D9FD-0D             2861 (  4)         DEC     C               ;remember 16 bit values.
D9FE-13             2862 (  4) CLOSEIT5:  INC  DE              ;bump to next item in table.
D9FF-23             2863 (  4)         INC     HL
DA00-0D             2864 (  4)         DEC     C               ;there are 16 entries only.
DA01-C2 CE D9       2865 ( 6+)         JP      NZ,CLOSEIT1     ;continue if more to do.
DA04-01 EC FF       2866 (  9)         LD      BC,0FFECH       ;backup 20 places (extent byte).
DA07-09             2867 (  7)         ADD     HL,BC
DA08-EB             2868 (  3)         EX      DE,HL
DA09-09             2869 (  7)         ADD     HL,BC
DA0A-1A             2870 (  6)         LD      A,(DE)
DA0B-BE             2871 (  6)         CP      (HL)            ;directory's extent already greater than the
DA0C-DA 18 DA       2872 ( 6+)         JP      C,CLOSEIT6      ;users extent?
DA0F-77             2873 (  7)         LD      (HL),A          ;no, update directory extent.
DA10-01 03 00       2874 (  9)         LD      BC,3            ;and update the record count byte in
DA13-09             2875 (  7)         ADD     HL,BC           ;directories fcb.
DA14-EB             2876 (  3)         EX      DE,HL
DA15-09             2877 (  7)         ADD     HL,BC
DA16-7E             2878 (  6)         LD      A,(HL)          ;get from user.
DA17-12             2879 (  7)         LD      (DE),A          ;and put in directory.
DA18-3E FF          2880 (  6) CLOSEIT6:  LD   A,0FFH          ;set 'was open and is now closed' byte.
DA1A-32 D3 DE       2881 ( 13)         LD      (CLOSEFLG),A
DA1D-C3 11 D9       2882 (  9)         JP      UPDATE1         ;update the directory now.
DA20-21 46 D4       2883 (  9) CLOSEIT7:  LD   HL,STATUS       ;set return status and then return.
DA23-35             2884 ( 10)         DEC     (HL)
DA24-C9             2885 (  9)         RET
DA25-               2886       ;
DA25-               2887       ;   Routine to get the next empty space in the directory. It
DA25-               2888       ; will then be cleared for use.
DA25-               2889       ;
DA25-CD 55 D6       2890 ( 16) GETEMPTY:  CALL CHKWPRT         ;make sure disk is not write protected.
DA28-2A 44 D4       2891 ( 15)         LD      HL,(PARAMS)     ;save current parameters (fcb).
DA2B-E5             2892 ( 11)         PUSH    HL
DA2C-21 AD DE       2893 (  9)         LD      HL,EMPTYFCB     ;use special one for empty space.
DA2F-22 44 D4       2894 ( 20)         LD      (PARAMS),HL
DA32-0E 01          2895 (  6)         LD      C,1             ;search for first empty spot in directory.
DA34-CD 19 D8       2896 ( 16)         CALL    FINDFST         ;(* only check first byte *)
DA37-CD F6 D6       2897 ( 16)         CALL    CKFILPOS        ;none?
DA3A-E1             2898 (  9)         POP     HL
DA3B-22 44 D4       2899 ( 20)         LD      (PARAMS),HL     ;restore original fcb address.
DA3E-C8             2900 ( 5+)         RET     Z               ;return if no more space.
DA3F-EB             2901 (  3)         EX      DE,HL
DA40-21 0F 00       2902 (  9)         LD      HL,15           ;point to number of records for this file.
DA43-19             2903 (  7)         ADD     HL,DE
DA44-0E 11          2904 (  6)         LD      C,17            ;and clear all of this space.
DA46-AF             2905 (  4)         XOR     A
DA47-77             2906 (  7) GETMT1:         LD      (HL),A
DA48-23             2907 (  4)         INC     HL
DA49-0D             2908 (  4)         DEC     C
DA4A-C2 47 DA       2909 ( 6+)         JP      NZ,GETMT1
DA4D-21 0D 00       2910 (  9)         LD      HL,13           ;clear the 's1' byte also.
DA50-19             2911 (  7)         ADD     HL,DE
DA51-77             2912 (  7)         LD      (HL),A
DA52-CD 8D D6       2913 ( 16)         CALL    CHKNMBR         ;keep (SCRATCH1) within bounds.
DA55-CD FE D8       2914 ( 16)         CALL    FCBSET          ;write out this fcb entry to directory.
DA58-C3 79 D6       2915 (  9)         JP      SETS2B7         ;set 's2' byte bit 7 (unmodified at present).
DA5B-               2916       ;
DA5B-               2917       ;   Routine to close the current extent and open the next one
DA5B-               2918       ; for reading.
DA5B-               2919       ;
DA5B-AF             2920 (  4) GETNEXT: XOR    A
DA5C-32 D3 DE       2921 ( 13)         LD      (CLOSEFLG),A    ;clear close flag.
DA5F-CD A3 D9       2922 ( 16)         CALL    CLOSEIT         ;close this extent.
DA62-CD F6 D6       2923 ( 16)         CALL    CKFILPOS
DA65-C8             2924 ( 5+)         RET     Z               ;not there???
DA66-2A 44 D4       2925 ( 15)         LD      HL,(PARAMS)     ;get extent byte.
DA69-01 0C 00       2926 (  9)         LD      BC,12
DA6C-09             2927 (  7)         ADD     HL,BC
DA6D-7E             2928 (  6)         LD      A,(HL)          ;and increment it.
DA6E-3C             2929 (  4)         INC     A
DA6F-E6 1F          2930 (  6)         AND     1FH             ;keep within range 0-31.
DA71-77             2931 (  7)         LD      (HL),A
DA72-CA 84 DA       2932 ( 6+)         JP      Z,GTNEXT1       ;overflow?
DA75-47             2933 (  4)         LD      B,A             ;mask extent byte.
DA76-3A C6 DE       2934 ( 12)         LD      A,(EXTMASK)
DA79-A0             2935 (  4)         AND     B
DA7A-21 D3 DE       2936 (  9)         LD      HL,CLOSEFLG     ;check close flag (0ffh is ok).
DA7D-A6             2937 (  6)         AND     (HL)
DA7E-CA 8F DA       2938 ( 6+)         JP      Z,GTNEXT2       ;if zero, we must read in next extent.
DA81-C3 AD DA       2939 (  9)         JP      GTNEXT3         ;else, it is already in memory.
DA84-01 02 00       2940 (  9) GTNEXT1: LD     BC,2            ;Point to the 's2' byte.
DA87-09             2941 (  7)         ADD     HL,BC
DA88-34             2942 ( 10)         INC     (HL)            ;and bump it.
DA89-7E             2943 (  6)         LD      A,(HL)          ;too many extents?
DA8A-E6 0F          2944 (  6)         AND     0FH
DA8C-CA B7 DA       2945 ( 6+)         JP      Z,GTNEXT5       ;yes, set error code.
DA8F-               2946       ;
DA8F-               2947       ;   Get here to open the next extent.
DA8F-               2948       ;
DA8F-0E 0F          2949 (  6) GTNEXT2: LD     C,15            ;set to check first 15 bytes of fcb.
DA91-CD 19 D8       2950 ( 16)         CALL    FINDFST         ;find the first one.
DA94-CD F6 D6       2951 ( 16)         CALL    CKFILPOS        ;none available?
DA97-C2 AD DA       2952 ( 6+)         JP      NZ,GTNEXT3
DA9A-3A D4 DE       2953 ( 12)         LD      A,(RDWRTFLG)    ;no extent present. Can we open an empty one?
DA9D-3C             2954 (  4)         INC     A               ;0ffh means reading (so not possible).
DA9E-CA B7 DA       2955 ( 6+)         JP      Z,GTNEXT5       ;or an error.
DAA1-CD 25 DA       2956 ( 16)         CALL    GETEMPTY        ;we are writing, get an empty entry.
DAA4-CD F6 D6       2957 ( 16)         CALL    CKFILPOS        ;none?
DAA7-CA B7 DA       2958 ( 6+)         JP      Z,GTNEXT5       ;error if true.
DAAA-C3 B0 DA       2959 (  9)         JP      GTNEXT4         ;else we are almost done.
DAAD-CD 5B D9       2960 ( 16) GTNEXT3: CALL   OPENIT1         ;open this extent.
DAB0-CD BC D5       2961 ( 16) GTNEXT4: CALL   STRDATA         ;move in updated data (rec #, extent #, etc.)
DAB3-AF             2962 (  4)         XOR     A               ;clear status and return.
DAB4-C3 02 D4       2963 (  9)         JP      SETSTAT
DAB7-               2964       ;
DAB7-               2965       ;   Error in extending the file. Too many extents were needed
DAB7-               2966       ; or not enough space on the disk.
DAB7-               2967       ;
DAB7-CD 06 D4       2968 ( 16) GTNEXT5: CALL   IOERR1          ;set error code, clear bit 7 of 's2'
DABA-C3 79 D6       2969 (  9)         JP      SETS2B7         ;so this is not written on a close.
DABD-               2970       ;
DABD-               2971       ;   Read a sequential file.
DABD-               2972       ;
DABD-3E 01          2973 (  6) RDSEQ:  LD      A,1             ;set sequential access mode.
DABF-32 D6 DE       2974 ( 13)         LD      (MODE),A
DAC2-3E FF          2975 (  6) RDSEQ1:         LD      A,0FFH          ;don't allow reading unwritten space.
DAC4-32 D4 DE       2976 ( 13)         LD      (RDWRTFLG),A
DAC7-CD BC D5       2977 ( 16)         CALL    STRDATA         ;put rec# and ext# into fcb.
DACA-3A E4 DE       2978 ( 12)         LD      A,(SAVNREC)     ;get next record to read.
DACD-21 E2 DE       2979 (  9)         LD      HL,SAVNXT       ;get number of records in extent.
DAD0-BE             2980 (  6)         CP      (HL)            ;within this extent?
DAD1-DA E7 DA       2981 ( 6+)         JP      C,RDSEQ2
DAD4-FE 80          2982 (  6)         CP      128             ;no. Is this extent fully used?
DAD6-C2 FC DA       2983 ( 6+)         JP      NZ,RDSEQ3       ;no. End-of-file.
DAD9-CD 5B DA       2984 ( 16)         CALL    GETNEXT         ;yes, open the next one.
DADC-AF             2985 (  4)         XOR     A               ;reset next record to read.
DADD-32 E4 DE       2986 ( 13)         LD      (SAVNREC),A
DAE0-3A 46 D4       2987 ( 12)         LD      A,(STATUS)      ;check on open, successful?
DAE3-B7             2988 (  4)         OR      A
DAE4-C2 FC DA       2989 ( 6+)         JP      NZ,RDSEQ3       ;no, error.
DAE7-CD 78 D5       2990 ( 16) RDSEQ2:         CALL    COMBLK          ;ok. compute block number to read.
DAEA-CD 85 D5       2991 ( 16)         CALL    CHKBLK          ;check it. Within bounds?
DAED-CA FC DA       2992 ( 6+)         JP      Z,RDSEQ3        ;no, error.
DAF0-CD 8B D5       2993 ( 16)         CALL    LOGICAL         ;convert (BLKNMBR) to logical sector (128 byte).
DAF3-CD D2 D4       2994 ( 16)         CALL    TRKSEC1         ;set the track and sector for this block #.
DAF6-CD B3 D4       2995 ( 16)         CALL    DOREAD          ;and read it.
DAF9-C3 D3 D5       2996 (  9)         JP      SETNREC         ;and set the next record to be accessed.
DAFC-               2997       ;
DAFC-               2998       ;   Read error occured. Set status and return.
DAFC-               2999       ;
DAFC-C3 06 D4       3000 (  9) RDSEQ3:         JP      IOERR1
DAFF-               3001       ;
DAFF-               3002       ;   Write the next sequential record.
DAFF-               3003       ;
DAFF-3E 01          3004 (  6) WTSEQ:  LD      A,1             ;set sequential access mode.
DB01-32 D6 DE       3005 ( 13)         LD      (MODE),A
DB04-3E 00          3006 (  6) WTSEQ1:         LD      A,0             ;allow an addition empty extent to be opened.
DB06-32 D4 DE       3007 ( 13)         LD      (RDWRTFLG),A
DB09-CD 55 D6       3008 ( 16)         CALL    CHKWPRT         ;check write protect status.
DB0C-2A 44 D4       3009 ( 15)         LD      HL,(PARAMS)
DB0F-CD 48 D6       3010 ( 16)         CALL    CKROF1          ;check for read only file, (HL) already set to fcb.
DB12-CD BC D5       3011 ( 16)         CALL    STRDATA         ;put updated data into fcb.
DB15-3A E4 DE       3012 ( 12)         LD      A,(SAVNREC)     ;get record number to write.
DB18-FE 80          3013 (  6)         CP      128             ;within range?
DB1A-D2 06 D4       3014 ( 6+)         JP      NC,IOERR1       ;no, error(?).
DB1D-CD 78 D5       3015 ( 16)         CALL    COMBLK          ;compute block number.
DB20-CD 85 D5       3016 ( 16)         CALL    CHKBLK          ;check number.
DB23-0E 00          3017 (  6)         LD      C,0             ;is there one to write to?
DB25-C2 6F DB       3018 ( 6+)         JP      NZ,WTSEQ6       ;yes, go do it.
DB28-CD 3F D5       3019 ( 16)         CALL    GETBLOCK        ;get next block number within fcb to use.
DB2B-32 D8 DE       3020 ( 13)         LD      (RELBLOCK),A    ;and save.
DB2E-01 00 00       3021 (  9)         LD      BC,0            ;start looking for space from the start
DB31-B7             3022 (  4)         OR      A               ;if none allocated as yet.
DB32-CA 3C DB       3023 ( 6+)         JP      Z,WTSEQ2
DB35-4F             3024 (  4)         LD      C,A             ;extract previous block number from fcb
DB36-0B             3025 (  4)         DEC     BC              ;so we can be closest to it.
DB37-CD 5F D5       3026 ( 16)         CALL    EXTBLK
DB3A-44             3027 (  4)         LD      B,H
DB3B-4D             3028 (  4)         LD      C,L
DB3C-CD BF D8       3029 ( 16) WTSEQ2:         CALL    FNDSPACE        ;find the next empty block nearest number (BC).
DB3F-7D             3030 (  4)         LD      A,L             ;check for a zero number.
DB40-B4             3031 (  4)         OR      H
DB41-C2 49 DB       3032 ( 6+)         JP      NZ,WTSEQ3
DB44-3E 02          3033 (  6)         LD      A,2             ;no more space?
DB46-C3 02 D4       3034 (  9)         JP      SETSTAT
DB49-22 E6 DE       3035 ( 20) WTSEQ3:         LD      (BLKNMBR),HL    ;save block number to access.
DB4C-EB             3036 (  3)         EX      DE,HL           ;put block number into (DE).
DB4D-2A 44 D4       3037 ( 15)         LD      HL,(PARAMS)     ;now we must update the fcb for this
DB50-01 10 00       3038 (  9)         LD      BC,16           ;newly allocated block.
DB53-09             3039 (  7)         ADD     HL,BC
DB54-3A DE DE       3040 ( 12)         LD      A,(BIGDISK)     ;8 or 16 bit block numbers?
DB57-B7             3041 (  4)         OR      A
DB58-3A D8 DE       3042 ( 12)         LD      A,(RELBLOCK)    ;(* update this entry *)
DB5B-CA 65 DB       3043 ( 6+)         JP      Z,WTSEQ4        ;zero means 16 bit ones.
DB5E-CD 65 D6       3044 ( 16)         CALL    ADDA2HL         ;(HL)=(HL)+(A)
DB61-73             3045 (  7)         LD      (HL),E          ;store new block number.
DB62-C3 6D DB       3046 (  9)         JP      WTSEQ5
DB65-4F             3047 (  4) WTSEQ4:         LD      C,A             ;compute spot in this 16 bit table.
DB66-06 00          3048 (  6)         LD      B,0
DB68-09             3049 (  7)         ADD     HL,BC
DB69-09             3050 (  7)         ADD     HL,BC
DB6A-73             3051 (  7)         LD      (HL),E          ;stuff block number (DE) there.
DB6B-23             3052 (  4)         INC     HL
DB6C-72             3053 (  7)         LD      (HL),D
DB6D-0E 02          3054 (  6) WTSEQ5:         LD      C,2             ;set (C) to indicate writing to un-used disk space.
DB6F-3A 46 D4       3055 ( 12) WTSEQ6:         LD      A,(STATUS)      ;are we ok so far?
DB72-B7             3056 (  4)         OR      A
DB73-C0             3057 ( 5+)         RET     NZ
DB74-C5             3058 ( 11)         PUSH    BC              ;yes, save write flag for bios (register C).
DB75-CD 8B D5       3059 ( 16)         CALL    LOGICAL         ;convert (BLKNMBR) over to loical sectors.
DB78-3A D6 DE       3060 ( 12)         LD      A,(MODE)        ;get access mode flag (1=sequential,
DB7B-3D             3061 (  4)         DEC     A               ;0=random, 2=special?).
DB7C-3D             3062 (  4)         DEC     A
DB7D-C2 BC DB       3063 ( 6+)         JP      NZ,WTSEQ9
DB80-               3064       ;
DB80-               3065       ;   Special random i/o from function #40. Maybe for M/PM, but the
DB80-               3066       ; current block, if it has not been written to, will be zeroed
DB80-               3067       ; out and then written (reason?).
DB80-               3068       ;
DB80-C1             3069 (  9)         POP     BC
DB81-C5             3070 ( 11)         PUSH    BC
DB82-79             3071 (  4)         LD      A,C             ;get write status flag (2=writing unused space).
DB83-3D             3072 (  4)         DEC     A
DB84-3D             3073 (  4)         DEC     A
DB85-C2 BC DB       3074 ( 6+)         JP      NZ,WTSEQ9
DB88-E5             3075 ( 11)         PUSH    HL
DB89-2A BA DE       3076 ( 15)         LD      HL,(DIRBUF)     ;zero out the directory buffer.
DB8C-57             3077 (  4)         LD      D,A             ;note that (A) is zero here.
DB8D-77             3078 (  7) WTSEQ7:         LD      (HL),A
DB8E-23             3079 (  4)         INC     HL
DB8F-14             3080 (  4)         INC     D               ;do 128 bytes.
DB90-F2 8D DB       3081 ( 6+)         JP      P,WTSEQ7
DB93-CD E1 D6       3082 ( 16)         CALL    DIRDMA          ;tell the bios the dma address for directory access.
DB96-2A E8 DE       3083 ( 15)         LD      HL,(LOGSECT)    ;get sector that starts current block.
DB99-0E 02          3084 (  6)         LD      C,2             ;set 'writing to unused space' flag.
DB9B-22 E6 DE       3085 ( 20) WTSEQ8:         LD      (BLKNMBR),HL    ;save sector to write.
DB9E-C5             3086 ( 11)         PUSH    BC
DB9F-CD D2 D4       3087 ( 16)         CALL    TRKSEC1         ;determine its track and sector numbers.
DBA2-C1             3088 (  9)         POP     BC
DBA3-CD B9 D4       3089 ( 16)         CALL    DOWRITE         ;now write out 128 bytes of zeros.
DBA6-2A E6 DE       3090 ( 15)         LD      HL,(BLKNMBR)    ;get sector number.
DBA9-0E 00          3091 (  6)         LD      C,0             ;set normal write flag.
DBAB-3A C5 DE       3092 ( 12)         LD      A,(BLKMASK)     ;determine if we have written the entire
DBAE-47             3093 (  4)         LD      B,A             ;physical block.
DBAF-A5             3094 (  4)         AND     L
DBB0-B8             3095 (  4)         CP      B
DBB1-23             3096 (  4)         INC     HL              ;prepare for the next one.
DBB2-C2 9B DB       3097 ( 6+)         JP      NZ,WTSEQ8       ;continue until (BLKMASK+1) sectors written.
DBB5-E1             3098 (  9)         POP     HL              ;reset next sector number.
DBB6-22 E6 DE       3099 ( 20)         LD      (BLKNMBR),HL
DBB9-CD DB D6       3100 ( 16)         CALL    DEFDMA          ;and reset dma address.
DBBC-               3101       ;
DBBC-               3102       ;   Normal disk write. Set the desired track and sector then
DBBC-               3103       ; do the actual write.
DBBC-               3104       ;
DBBC-CD D2 D4       3105 ( 16) WTSEQ9:         CALL    TRKSEC1         ;determine track and sector for this write.
DBBF-C1             3106 (  9)         POP     BC              ;get write status flag.
DBC0-C5             3107 ( 11)         PUSH    BC
DBC1-CD B9 D4       3108 ( 16)         CALL    DOWRITE         ;and write this out.
DBC4-C1             3109 (  9)         POP     BC
DBC5-3A E4 DE       3110 ( 12)         LD      A,(SAVNREC)     ;get number of records in file.
DBC8-21 E2 DE       3111 (  9)         LD      HL,SAVNXT       ;get last record written.
DBCB-BE             3112 (  6)         CP      (HL)
DBCC-DA D3 DB       3113 ( 6+)         JP      C,WTSEQ10
DBCF-77             3114 (  7)         LD      (HL),A          ;we have to update record count.
DBD0-34             3115 ( 10)         INC     (HL)
DBD1-0E 02          3116 (  6)         LD      C,2
DBD3-               3117       ;
DBD3-               3118       ;*   This area has been patched to correct disk update problem
DBD3-               3119       ;* when using blocking and de-blocking in the BIOS.
DBD3-               3120       ;
DBD3-00             3121 (  3) WTSEQ10: NOP                    ;was 'dcr c'
DBD4-00             3122 (  3)         NOP                     ;was 'dcr c'
DBD5-21 00 00       3123 (  9)         LD      HL,0            ;was 'jnz wtseq99'
DBD8-               3124       ;
DBD8-               3125       ; *   End of patch.
DBD8-               3126       ;
DBD8-F5             3127 ( 11)         PUSH    AF
DBD9-CD 6A D6       3128 ( 16)         CALL    GETS2           ;set 'extent written to' flag.
DBDC-E6 7F          3129 (  6)         AND     7FH             ;(* clear bit 7 *)
DBDE-77             3130 (  7)         LD      (HL),A
DBDF-F1             3131 (  9)         POP     AF              ;get record count for this extent.
DBE0-FE 7F          3132 (  6) WTSEQ99: CP     127             ;is it full?
DBE2-C2 01 DC       3133 ( 6+)         JP      NZ,WTSEQ12
DBE5-3A D6 DE       3134 ( 12)         LD      A,(MODE)        ;yes, are we in sequential mode?
DBE8-FE 01          3135 (  6)         CP      1
DBEA-C2 01 DC       3136 ( 6+)         JP      NZ,WTSEQ12
DBED-CD D3 D5       3137 ( 16)         CALL    SETNREC         ;yes, set next record number.
DBF0-CD 5B DA       3138 ( 16)         CALL    GETNEXT         ;and get next empty space in directory.
DBF3-21 46 D4       3139 (  9)         LD      HL,STATUS       ;ok?
DBF6-7E             3140 (  6)         LD      A,(HL)
DBF7-B7             3141 (  4)         OR      A
DBF8-C2 FF DB       3142 ( 6+)         JP      NZ,WTSEQ11
DBFB-3D             3143 (  4)         DEC     A               ;yes, set record count to -1.
DBFC-32 E4 DE       3144 ( 13)         LD      (SAVNREC),A
DBFF-36 00          3145 (  9) WTSEQ11: LD     (HL),0          ;clear status.
DC01-C3 D3 D5       3146 (  9) WTSEQ12: JP     SETNREC         ;set next record to access.
DC04-               3147       ;
DC04-               3148       ;   For random i/o, set the fcb for the desired record number
DC04-               3149       ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
DC04-               3150       ; used as follows:
DC04-               3151       ;
DC04-               3152       ;       fcb+35            fcb+34            fcb+33
DC04-               3153       ;  |     'r-2'      |      'r-1'      |      'r-0'     |
DC04-               3154       ;  |7             0 | 7             0 | 7             0|
DC04-               3155       ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
DC04-               3156       ;  |    overflow   | | extra |  extent   |   record #  |
DC04-               3157       ;  | ______________| |_extent|__number___|_____________|
DC04-               3158       ;                     also 's2'
DC04-               3159       ;
DC04-               3160       ;   On entry, register (C) contains 0ffh if this is a read
DC04-               3161       ; and thus we can not access unwritten disk space. Otherwise,
DC04-               3162       ; another extent will be opened (for writing) if required.
DC04-               3163       ;
DC04-AF             3164 (  4) POSITION:  XOR  A               ;set random i/o flag.
DC05-32 D6 DE       3165 ( 13)         LD      (MODE),A
DC08-               3166       ;
DC08-               3167       ;   Special entry (function #40). M/PM ?
DC08-               3168       ;
DC08-C5             3169 ( 11) POSITN1: PUSH   BC              ;save read/write flag.
DC09-2A 44 D4       3170 ( 15)         LD      HL,(PARAMS)     ;get address of fcb.
DC0C-EB             3171 (  3)         EX      DE,HL
DC0D-21 21 00       3172 (  9)         LD      HL,33           ;now get byte 'r0'.
DC10-19             3173 (  7)         ADD     HL,DE
DC11-7E             3174 (  6)         LD      A,(HL)
DC12-E6 7F          3175 (  6)         AND     7FH             ;keep bits 0-6 for the record number to access.
DC14-F5             3176 ( 11)         PUSH    AF
DC15-7E             3177 (  6)         LD      A,(HL)          ;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
DC16-17             3178 (  3)         RLA
DC17-23             3179 (  4)         INC     HL
DC18-7E             3180 (  6)         LD      A,(HL)
DC19-17             3181 (  3)         RLA
DC1A-E6 1F          3182 (  6)         AND     1FH             ;and save this in bits 0-4 of (C).
DC1C-4F             3183 (  4)         LD      C,A             ;this is the extent byte.
DC1D-7E             3184 (  6)         LD      A,(HL)          ;now get the extra extent byte.
DC1E-1F             3185 (  3)         RRA
DC1F-1F             3186 (  3)         RRA
DC20-1F             3187 (  3)         RRA
DC21-1F             3188 (  3)         RRA
DC22-E6 0F          3189 (  6)         AND     0FH
DC24-47             3190 (  4)         LD      B,A             ;and save it in (B).
DC25-F1             3191 (  9)         POP     AF              ;get record number back to (A).
DC26-23             3192 (  4)         INC     HL              ;check overflow byte 'r2'.
DC27-6E             3193 (  6)         LD      L,(HL)
DC28-2C             3194 (  4)         INC     L
DC29-2D             3195 (  4)         DEC     L
DC2A-2E 06          3196 (  6)         LD      L,6             ;prepare for error.
DC2C-C2 8C DC       3197 ( 6+)         JP      NZ,POSITN5      ;out of disk space error.
DC2F-21 20 00       3198 (  9)         LD      HL,32           ;store record number into fcb.
DC32-19             3199 (  7)         ADD     HL,DE
DC33-77             3200 (  7)         LD      (HL),A
DC34-21 0C 00       3201 (  9)         LD      HL,12           ;and now check the extent byte.
DC37-19             3202 (  7)         ADD     HL,DE
DC38-79             3203 (  4)         LD      A,C
DC39-96             3204 (  6)         SUB     (HL)            ;same extent as before?
DC3A-C2 48 DC       3205 ( 6+)         JP      NZ,POSITN2
DC3D-21 0E 00       3206 (  9)         LD      HL,14           ;yes, check extra extent byte 's2' also.
DC40-19             3207 (  7)         ADD     HL,DE
DC41-78             3208 (  4)         LD      A,B
DC42-96             3209 (  6)         SUB     (HL)
DC43-E6 7F          3210 (  6)         AND     7FH
DC45-CA 80 DC       3211 ( 6+)         JP      Z,POSITN3       ;same, we are almost done then.
DC48-               3212       ;
DC48-               3213       ;  Get here when another extent is required.
DC48-               3214       ;
DC48-C5             3215 ( 11) POSITN2: PUSH   BC
DC49-D5             3216 ( 11)         PUSH    DE
DC4A-CD A3 D9       3217 ( 16)         CALL    CLOSEIT         ;close current extent.
DC4D-D1             3218 (  9)         POP     DE
DC4E-C1             3219 (  9)         POP     BC
DC4F-2E 03          3220 (  6)         LD      L,3             ;prepare for error.
DC51-3A 46 D4       3221 ( 12)         LD      A,(STATUS)
DC54-3C             3222 (  4)         INC     A
DC55-CA 85 DC       3223 ( 6+)         JP      Z,POSITN4       ;close error.
DC58-21 0C 00       3224 (  9)         LD      HL,12           ;put desired extent into fcb now.
DC5B-19             3225 (  7)         ADD     HL,DE
DC5C-71             3226 (  7)         LD      (HL),C
DC5D-21 0E 00       3227 (  9)         LD      HL,14           ;and store extra extent byte 's2'.
DC60-19             3228 (  7)         ADD     HL,DE
DC61-70             3229 (  7)         LD      (HL),B
DC62-CD 52 D9       3230 ( 16)         CALL    OPENIT          ;try and get this extent.
DC65-3A 46 D4       3231 ( 12)         LD      A,(STATUS)      ;was it there?
DC68-3C             3232 (  4)         INC     A
DC69-C2 80 DC       3233 ( 6+)         JP      NZ,POSITN3
DC6C-C1             3234 (  9)         POP     BC              ;no. can we create a new one (writing?).
DC6D-C5             3235 ( 11)         PUSH    BC
DC6E-2E 04          3236 (  6)         LD      L,4             ;prepare for error.
DC70-0C             3237 (  4)         INC     C
DC71-CA 85 DC       3238 ( 6+)         JP      Z,POSITN4       ;nope, reading unwritten space error.
DC74-CD 25 DA       3239 ( 16)         CALL    GETEMPTY        ;yes we can, try to find space.
DC77-2E 05          3240 (  6)         LD      L,5             ;prepare for error.
DC79-3A 46 D4       3241 ( 12)         LD      A,(STATUS)
DC7C-3C             3242 (  4)         INC     A
DC7D-CA 85 DC       3243 ( 6+)         JP      Z,POSITN4       ;out of space?
DC80-               3244       ;
DC80-               3245       ;   Normal return location. Clear error code and return.
DC80-               3246       ;
DC80-C1             3247 (  9) POSITN3: POP    BC              ;restore stack.
DC81-AF             3248 (  4)         XOR     A               ;and clear error code byte.
DC82-C3 02 D4       3249 (  9)         JP      SETSTAT
DC85-               3250       ;
DC85-               3251       ;   Error. Set the 's2' byte to indicate this (why?).
DC85-               3252       ;
DC85-E5             3253 ( 11) POSITN4: PUSH   HL
DC86-CD 6A D6       3254 ( 16)         CALL    GETS2
DC89-36 C0          3255 (  9)         LD      (HL),0C0H
DC8B-E1             3256 (  9)         POP     HL
DC8C-               3257       ;
DC8C-               3258       ;   Return with error code (presently in L).
DC8C-               3259       ;
DC8C-C1             3260 (  9) POSITN5: POP    BC
DC8D-7D             3261 (  4)         LD      A,L             ;get error code.
DC8E-32 46 D4       3262 ( 13)         LD      (STATUS),A
DC91-C3 79 D6       3263 (  9)         JP      SETS2B7
DC94-               3264       ;
DC94-               3265       ;   Read a random record.
DC94-               3266       ;
DC94-0E FF          3267 (  6) READRAN: LD     C,0FFH          ;set 'read' status.
DC96-CD 04 DC       3268 ( 16)         CALL    POSITION        ;position the file to proper record.
DC99-CC C2 DA       3269 ( 6+)         CALL    Z,RDSEQ1        ;and read it as usual (if no errors).
DC9C-C9             3270 (  9)         RET
DC9D-               3271       ;
DC9D-               3272       ;   Write to a random record.
DC9D-               3273       ;
DC9D-0E 00          3274 (  6) WRITERAN:  LD   C,0             ;set 'writing' flag.
DC9F-CD 04 DC       3275 ( 16)         CALL    POSITION        ;position the file to proper record.
DCA2-CC 04 DB       3276 ( 6+)         CALL    Z,WTSEQ1        ;and write as usual (if no errors).
DCA5-C9             3277 (  9)         RET
DCA6-               3278       ;
DCA6-               3279       ;   Compute the random record number. Enter with (HL) pointing
DCA6-               3280       ; to a fcb an (DE) contains a relative location of a record
DCA6-               3281       ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
DCA6-               3282       ; byte, and (A) the 'r2' byte.
DCA6-               3283       ;
DCA6-               3284       ;   On return, the zero flag is set if the record is within
DCA6-               3285       ; bounds. Otherwise, an overflow occured.
DCA6-               3286       ;
DCA6-EB             3287 (  3) COMPRAND:  EX   DE,HL           ;save fcb pointer in (DE).
DCA7-19             3288 (  7)         ADD     HL,DE           ;compute relative position of record #.
DCA8-4E             3289 (  6)         LD      C,(HL)          ;get record number into (BC).
DCA9-06 00          3290 (  6)         LD      B,0
DCAB-21 0C 00       3291 (  9)         LD      HL,12           ;now get extent.
DCAE-19             3292 (  7)         ADD     HL,DE
DCAF-7E             3293 (  6)         LD      A,(HL)          ;compute (BC)=(record #)+(extent)*128.
DCB0-0F             3294 (  3)         RRCA                    ;move lower bit into bit 7.
DCB1-E6 80          3295 (  6)         AND     80H             ;and ignore all other bits.
DCB3-81             3296 (  4)         ADD     A,C             ;add to our record number.
DCB4-4F             3297 (  4)         LD      C,A
DCB5-3E 00          3298 (  6)         LD      A,0             ;take care of any carry.
DCB7-88             3299 (  4)         ADC     A,B
DCB8-47             3300 (  4)         LD      B,A
DCB9-7E             3301 (  6)         LD      A,(HL)          ;now get the upper bits of extent into
DCBA-0F             3302 (  3)         RRCA                    ;bit positions 0-3.
DCBB-E6 0F          3303 (  6)         AND     0FH             ;and ignore all others.
DCBD-80             3304 (  4)         ADD     A,B             ;add this in to 'r1' byte.
DCBE-47             3305 (  4)         LD      B,A
DCBF-21 0E 00       3306 (  9)         LD      HL,14           ;get the 's2' byte (extra extent).
DCC2-19             3307 (  7)         ADD     HL,DE
DCC3-7E             3308 (  6)         LD      A,(HL)
DCC4-87             3309 (  4)         ADD     A,A             ;and shift it left 4 bits (bits 4-7).
DCC5-87             3310 (  4)         ADD     A,A
DCC6-87             3311 (  4)         ADD     A,A
DCC7-87             3312 (  4)         ADD     A,A
DCC8-F5             3313 ( 11)         PUSH    AF              ;save carry flag (bit 0 of flag byte).
DCC9-80             3314 (  4)         ADD     A,B             ;now add extra extent into 'r1'.
DCCA-47             3315 (  4)         LD      B,A
DCCB-F5             3316 ( 11)         PUSH    AF              ;and save carry (overflow byte 'r2').
DCCC-E1             3317 (  9)         POP     HL              ;bit 0 of (L) is the overflow indicator.
DCCD-7D             3318 (  4)         LD      A,L
DCCE-E1             3319 (  9)         POP     HL              ;and same for first carry flag.
DCCF-B5             3320 (  4)         OR      L               ;either one of these set?
DCD0-E6 01          3321 (  6)         AND     01H             ;only check the carry flags.
DCD2-C9             3322 (  9)         RET
DCD3-               3323       ;
DCD3-               3324       ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
DCD3-               3325       ; reflect the last record used for a random (or other) file.
DCD3-               3326       ; This reads the directory and looks at all extents computing
DCD3-               3327       ; the largerst record number for each and keeping the maximum
DCD3-               3328       ; value only. Then 'r0', 'r1', and 'r2' will reflect this
DCD3-               3329       ; maximum record number. This is used to compute the space used
DCD3-               3330       ; by a random file.
DCD3-               3331       ;
DCD3-0E 0C          3332 (  6) RANSIZE: LD     C,12            ;look thru directory for first entry with
DCD5-CD 19 D8       3333 ( 16)         CALL    FINDFST         ;this name.
DCD8-2A 44 D4       3334 ( 15)         LD      HL,(PARAMS)     ;zero out the 'r0, r1, r2' bytes.
DCDB-11 21 00       3335 (  9)         LD      DE,33
DCDE-19             3336 (  7)         ADD     HL,DE
DCDF-E5             3337 ( 11)         PUSH    HL
DCE0-72             3338 (  7)         LD      (HL),D          ;note that (D)=0.
DCE1-23             3339 (  4)         INC     HL
DCE2-72             3340 (  7)         LD      (HL),D
DCE3-23             3341 (  4)         INC     HL
DCE4-72             3342 (  7)         LD      (HL),D
DCE5-CD F6 D6       3343 ( 16) RANSIZ1: CALL   CKFILPOS        ;is there an extent to process?
DCE8-CA 0D DD       3344 ( 6+)         JP      Z,RANSIZ3       ;no, we are done.
DCEB-CD 5F D6       3345 ( 16)         CALL    FCB2HL          ;set (HL) pointing to proper fcb in dir.
DCEE-11 0F 00       3346 (  9)         LD      DE,15           ;point to last record in extent.
DCF1-CD A6 DC       3347 ( 16)         CALL    COMPRAND        ;and compute random parameters.
DCF4-E1             3348 (  9)         POP     HL
DCF5-E5             3349 ( 11)         PUSH    HL              ;now check these values against those
DCF6-5F             3350 (  4)         LD      E,A             ;already in fcb.
DCF7-79             3351 (  4)         LD      A,C             ;the carry flag will be set if those
DCF8-96             3352 (  6)         SUB     (HL)            ;in the fcb represent a larger size than
DCF9-23             3353 (  4)         INC     HL              ;this extent does.
DCFA-78             3354 (  4)         LD      A,B
DCFB-9E             3355 (  6)         SBC     A,(HL)
DCFC-23             3356 (  4)         INC     HL
DCFD-7B             3357 (  4)         LD      A,E
DCFE-9E             3358 (  6)         SBC     A,(HL)
DCFF-DA 07 DD       3359 ( 6+)         JP      C,RANSIZ2
DD02-73             3360 (  7)         LD      (HL),E          ;we found a larger (in size) extent.
DD03-2B             3361 (  4)         DEC     HL              ;stuff these values into fcb.
DD04-70             3362 (  7)         LD      (HL),B
DD05-2B             3363 (  4)         DEC     HL
DD06-71             3364 (  7)         LD      (HL),C
DD07-CD 2E D8       3365 ( 16) RANSIZ2: CALL   FINDNXT         ;now get the next extent.
DD0A-C3 E5 DC       3366 (  9)         JP      RANSIZ1         ;continue til all done.
DD0D-E1             3367 (  9) RANSIZ3: POP    HL              ;we are done, restore the stack and
DD0E-C9             3368 (  9)         RET                     ;return.
DD0F-               3369       ;
DD0F-               3370       ;   Function to return the random record position of a given
DD0F-               3371       ; file which has been read in sequential mode up to now.
DD0F-               3372       ;
DD0F-2A 44 D4       3373 ( 15) SETRAN:         LD      HL,(PARAMS)     ;point to fcb.
DD12-11 20 00       3374 (  9)         LD      DE,32           ;and to last used record.
DD15-CD A6 DC       3375 ( 16)         CALL    COMPRAND        ;compute random position.
DD18-21 21 00       3376 (  9)         LD      HL,33           ;now stuff these values into fcb.
DD1B-19             3377 (  7)         ADD     HL,DE
DD1C-71             3378 (  7)         LD      (HL),C          ;move 'r0'.
DD1D-23             3379 (  4)         INC     HL
DD1E-70             3380 (  7)         LD      (HL),B          ;and 'r1'.
DD1F-23             3381 (  4)         INC     HL
DD20-77             3382 (  7)         LD      (HL),A          ;and lastly 'r2'.
DD21-C9             3383 (  9)         RET
DD22-               3384       ;
DD22-               3385       ;   This routine select the drive specified in (ACTIVE) and
DD22-               3386       ; update the login vector and bitmap table if this drive was
DD22-               3387       ; not already active.
DD22-               3388       ;
DD22-2A B0 DE       3389 ( 15) LOGINDRV:  LD   HL,(LOGIN)      ;get the login vector.
DD25-3A 43 D4       3390 ( 12)         LD      A,(ACTIVE)      ;get the default drive.
DD28-4F             3391 (  4)         LD      C,A
DD29-CD EB D5       3392 ( 16)         CALL    SHIFTR          ;position active bit for this drive
DD2C-E5             3393 ( 11)         PUSH    HL              ;into bit 0.
DD2D-EB             3394 (  3)         EX      DE,HL
DD2E-CD 5A D4       3395 ( 16)         CALL    SELECT          ;select this drive.
DD31-E1             3396 (  9)         POP     HL
DD32-CC 48 D4       3397 ( 6+)         CALL    Z,SLCTERR       ;valid drive?
DD35-7D             3398 (  4)         LD      A,L             ;is this a newly activated drive?
DD36-1F             3399 (  3)         RRA
DD37-D8             3400 ( 5+)         RET     C
DD38-2A B0 DE       3401 ( 15)         LD      HL,(LOGIN)      ;yes, update the login vector.
DD3B-4D             3402 (  4)         LD      C,L
DD3C-44             3403 (  4)         LD      B,H
DD3D-CD 0C D6       3404 ( 16)         CALL    SETBIT
DD40-22 B0 DE       3405 ( 20)         LD      (LOGIN),HL      ;and save.
DD43-C3 A4 D7       3406 (  9)         JP      BITMAP          ;now update the bitmap.
DD46-               3407       ;
DD46-               3408       ;   Function to set the active disk number.
DD46-               3409       ;
DD46-3A D7 DE       3410 ( 12) SETDSK:         LD      A,(EPARAM)      ;get parameter passed and see if this
DD49-21 43 D4       3411 (  9)         LD      HL,ACTIVE       ;represents a change in drives.
DD4C-BE             3412 (  6)         CP      (HL)
DD4D-C8             3413 ( 5+)         RET     Z
DD4E-77             3414 (  7)         LD      (HL),A          ;yes it does, log it in.
DD4F-C3 22 DD       3415 (  9)         JP      LOGINDRV
DD52-               3416       ;
DD52-               3417       ;   This is the 'auto disk select' routine. The firsst byte
DD52-               3418       ; of the fcb is examined for a drive specification. If non
DD52-               3419       ; zero then the drive will be selected and loged in.
DD52-               3420       ;
DD52-3E FF          3421 (  6) AUTOSEL: LD     A,0FFH          ;say 'auto-select activated'.
DD54-32 DF DE       3422 ( 13)         LD      (AUTO),A
DD57-2A 44 D4       3423 ( 15)         LD      HL,(PARAMS)     ;get drive specified.
DD5A-7E             3424 (  6)         LD      A,(HL)
DD5B-E6 1F          3425 (  6)         AND     1FH             ;look at lower 5 bits.
DD5D-3D             3426 (  4)         DEC     A               ;adjust for (1=A, 2=B) etc.
DD5E-32 D7 DE       3427 ( 13)         LD      (EPARAM),A      ;and save for the select routine.
DD61-FE 1E          3428 (  6)         CP      1EH             ;check for 'no change' condition.
DD63-D2 76 DD       3429 ( 6+)         JP      NC,AUTOSL1      ;yes, don't change.
DD66-3A 43 D4       3430 ( 12)         LD      A,(ACTIVE)      ;we must change, save currently active
DD69-32 E0 DE       3431 ( 13)         LD      (OLDDRV),A      ;drive.
DD6C-7E             3432 (  6)         LD      A,(HL)          ;and save first byte of fcb also.
DD6D-32 E1 DE       3433 ( 13)         LD      (AUTOFLAG),A    ;this must be non-zero.
DD70-E6 E0          3434 (  6)         AND     0E0H            ;whats this for (bits 6,7 are used for
DD72-77             3435 (  7)         LD      (HL),A          ;something)?
DD73-CD 46 DD       3436 ( 16)         CALL    SETDSK          ;select and log in this drive.
DD76-3A 42 D4       3437 ( 12) AUTOSL1: LD     A,(USERNO)      ;move user number into fcb.
DD79-2A 44 D4       3438 ( 15)         LD      HL,(PARAMS)     ;(* upper half of first byte *)
DD7C-B6             3439 (  6)         OR      (HL)
DD7D-77             3440 (  7)         LD      (HL),A
DD7E-C9             3441 (  9)         RET                     ;and return (all done).
DD7F-               3442       ;
DD7F-               3443       ;   Function to return the current cp/m version number.
DD7F-               3444       ;
DD7F-3E 22          3445 (  6) GETVER:         LD      A,022H          ;version 2.2
DD81-C3 02 D4       3446 (  9)         JP      SETSTAT
DD84-               3447       ;
DD84-               3448       ;   Function to reset the disk system.
DD84-               3449       ;
DD84-21 00 00       3450 (  9) RSTDSK:         LD      HL,0            ;clear write protect status and log
DD87-22 AE DE       3451 ( 20)         LD      (WRTPRT),HL     ;in vector.
DD8A-22 B0 DE       3452 ( 20)         LD      (LOGIN),HL
DD8D-AF             3453 (  4)         XOR     A               ;select drive 'A'.
DD8E-32 43 D4       3454 ( 13)         LD      (ACTIVE),A
DD91-21 80 00       3455 (  9)         LD      HL,TBUFF        ;setup default dma address.
DD94-22 B2 DE       3456 ( 20)         LD      (USERDMA),HL
DD97-CD DB D6       3457 ( 16)         CALL    DEFDMA
DD9A-C3 22 DD       3458 (  9)         JP      LOGINDRV        ;now log in drive 'A'.
DD9D-               3459       ;
DD9D-               3460       ;   Function to open a specified file.
DD9D-               3461       ;
DD9D-CD 73 D6       3462 ( 16) OPENFIL: CALL   CLEARS2         ;clear 's2' byte.
DDA0-CD 52 DD       3463 ( 16)         CALL    AUTOSEL         ;select proper disk.
DDA3-C3 52 D9       3464 (  9)         JP      OPENIT          ;and open the file.
DDA6-               3465       ;
DDA6-               3466       ;   Function to close a specified file.
DDA6-               3467       ;
DDA6-CD 52 DD       3468 ( 16) CLOSEFIL:  CALL AUTOSEL         ;select proper disk.
DDA9-C3 A3 D9       3469 (  9)         JP      CLOSEIT         ;and close the file.
DDAC-               3470       ;
DDAC-               3471       ;   Function to return the first occurence of a specified file
DDAC-               3472       ; name. If the first byte of the fcb is '?' then the name will
DDAC-               3473       ; not be checked (get the first entry no matter what).
DDAC-               3474       ;
DDAC-0E 00          3475 (  6) GETFST:         LD      C,0             ;prepare for special search.
DDAE-EB             3476 (  3)         EX      DE,HL
DDAF-7E             3477 (  6)         LD      A,(HL)          ;is first byte a '?'?
DDB0-FE 3F          3478 (  6)         CP      '?'
DDB2-CA C3 DD       3479 ( 6+)         JP      Z,GETFST1       ;yes, just get very first entry (zero length match).
DDB5-CD A7 D5       3480 ( 16)         CALL    SETEXT          ;get the extension byte from fcb.
DDB8-7E             3481 (  6)         LD      A,(HL)          ;is it '?'? if yes, then we want
DDB9-FE 3F          3482 (  6)         CP      '?'             ;an entry with a specific 's2' byte.
DDBB-C4 73 D6       3483 ( 6+)         CALL    NZ,CLEARS2      ;otherwise, look for a zero 's2' byte.
DDBE-CD 52 DD       3484 ( 16)         CALL    AUTOSEL         ;select proper drive.
DDC1-0E 0F          3485 (  6)         LD      C,15            ;compare bytes 0-14 in fcb (12&13 excluded).
DDC3-CD 19 D8       3486 ( 16) GETFST1: CALL   FINDFST         ;find an entry and then move it into
DDC6-C3 EA D6       3487 (  9)         JP      MOVEDIR         ;the users dma space.
DDC9-               3488       ;
DDC9-               3489       ;   Function to return the next occurence of a file name.
DDC9-               3490       ;
DDC9-2A DA DE       3491 ( 15) GETNXT:         LD      HL,(SAVEFCB)    ;restore pointers. note that no
DDCC-22 44 D4       3492 ( 20)         LD      (PARAMS),HL     ;other dbos calls are allowed.
DDCF-CD 52 DD       3493 ( 16)         CALL    AUTOSEL         ;no error will be returned, but the
DDD2-CD 2E D8       3494 ( 16)         CALL    FINDNXT         ;results will be wrong.
DDD5-C3 EA D6       3495 (  9)         JP      MOVEDIR
DDD8-               3496       ;
DDD8-               3497       ;   Function to delete a file by name.
DDD8-               3498       ;
DDD8-CD 52 DD       3499 ( 16) DELFILE: CALL   AUTOSEL         ;select proper drive.
DDDB-CD 9D D8       3500 ( 16)         CALL    ERAFILE         ;erase the file.
DDDE-C3 02 D8       3501 (  9)         JP      STSTATUS        ;set status and return.
DDE1-               3502       ;
DDE1-               3503       ;   Function to execute a sequential read of the specified
DDE1-               3504       ; record number.
DDE1-               3505       ;
DDE1-CD 52 DD       3506 ( 16) READSEQ: CALL   AUTOSEL         ;select proper drive then read.
DDE4-C3 BD DA       3507 (  9)         JP      RDSEQ
DDE7-               3508       ;
DDE7-               3509       ;   Function to write the net sequential record.
DDE7-               3510       ;
DDE7-CD 52 DD       3511 ( 16) WRTSEQ:         CALL    AUTOSEL         ;select proper drive then write.
DDEA-C3 FF DA       3512 (  9)         JP      WTSEQ
DDED-               3513       ;
DDED-               3514       ;   Create a file function.
DDED-               3515       ;
DDED-CD 73 D6       3516 ( 16) FCREATE: CALL   CLEARS2         ;clear the 's2' byte on all creates.
DDF0-CD 52 DD       3517 ( 16)         CALL    AUTOSEL         ;select proper drive and get the next
DDF3-C3 25 DA       3518 (  9)         JP      GETEMPTY        ;empty directory space.
DDF6-               3519       ;
DDF6-               3520       ;   Function to rename a file.
DDF6-               3521       ;
DDF6-CD 52 DD       3522 ( 16) RENFILE: CALL   AUTOSEL         ;select proper drive and then switch
DDF9-CD 17 D9       3523 ( 16)         CALL    CHGNAMES        ;file names.
DDFC-C3 02 D8       3524 (  9)         JP      STSTATUS
DDFF-               3525       ;
DDFF-               3526       ;   Function to return the login vector.
DDFF-               3527       ;
DDFF-2A B0 DE       3528 ( 15) GETLOG:         LD      HL,(LOGIN)
DE02-C3 2A DE       3529 (  9)         JP      GETPRM1
DE05-               3530       ;
DE05-               3531       ;   Function to return the current disk assignment.
DE05-               3532       ;
DE05-3A 43 D4       3533 ( 12) GETCRNT: LD     A,(ACTIVE)
DE08-C3 02 D4       3534 (  9)         JP      SETSTAT
DE0B-               3535       ;
DE0B-               3536       ;   Function to set the dma address.
DE0B-               3537       ;
DE0B-EB             3538 (  3) PUTDMA:         EX      DE,HL
DE0C-22 B2 DE       3539 ( 20)         LD      (USERDMA),HL    ;save in our space and then get to
DE0F-C3 DB D6       3540 (  9)         JP      DEFDMA          ;the bios with this also.
DE12-               3541       ;
DE12-               3542       ;   Function to return the allocation vector.
DE12-               3543       ;
DE12-2A C0 DE       3544 ( 15) GETALOC: LD     HL,(ALOCVECT)
DE15-C3 2A DE       3545 (  9)         JP      GETPRM1
DE18-               3546       ;
DE18-               3547       ;   Function to return the read-only status vector.
DE18-               3548       ;
DE18-2A AE DE       3549 ( 15) GETROV:         LD      HL,(WRTPRT)
DE1B-C3 2A DE       3550 (  9)         JP      GETPRM1
DE1E-               3551       ;
DE1E-               3552       ;   Function to set the file attributes (read-only, system).
DE1E-               3553       ;
DE1E-CD 52 DD       3554 ( 16) SETATTR: CALL   AUTOSEL         ;select proper drive then save attributes.
DE21-CD 3C D9       3555 ( 16)         CALL    SAVEATTR
DE24-C3 02 D8       3556 (  9)         JP      STSTATUS
DE27-               3557       ;
DE27-               3558       ;   Function to return the address of the disk parameter block
DE27-               3559       ; for the current drive.
DE27-               3560       ;
DE27-2A BC DE       3561 ( 15) GETPARM: LD     HL,(DISKPB)
DE2A-22 46 D4       3562 ( 20) GETPRM1: LD     (STATUS),HL
DE2D-C9             3563 (  9)         RET
DE2E-               3564       ;
DE2E-               3565       ;   Function to get or set the user number. If (E) was (FF)
DE2E-               3566       ; then this is a request to return the current user number.
DE2E-               3567       ; Else set the user number from (E).
DE2E-               3568       ;
DE2E-3A D7 DE       3569 ( 12) GETUSER: LD     A,(EPARAM)      ;get parameter.
DE31-FE FF          3570 (  6)         CP      0FFH            ;get user number?
DE33-C2 3C DE       3571 ( 6+)         JP      NZ,SETUSER
DE36-3A 42 D4       3572 ( 12)         LD      A,(USERNO)      ;yes, just do it.
DE39-C3 02 D4       3573 (  9)         JP      SETSTAT
DE3C-E6 1F          3574 (  6) SETUSER: AND    1FH             ;no, we should set it instead. keep low
DE3E-32 42 D4       3575 ( 13)         LD      (USERNO),A      ;bits (0-4) only.
DE41-C9             3576 (  9)         RET
DE42-               3577       ;
DE42-               3578       ;   Function to read a random record from a file.
DE42-               3579       ;
DE42-CD 52 DD       3580 ( 16) RDRANDOM:  CALL AUTOSEL         ;select proper drive and read.
DE45-C3 94 DC       3581 (  9)         JP      READRAN
DE48-               3582       ;
DE48-               3583       ;   Function to compute the file size for random files.
DE48-               3584       ;
DE48-CD 52 DD       3585 ( 16) WTRANDOM:  CALL AUTOSEL         ;select proper drive and write.
DE4B-C3 9D DC       3586 (  9)         JP      WRITERAN
DE4E-               3587       ;
DE4E-               3588       ;   Function to compute the size of a random file.
DE4E-               3589       ;
DE4E-CD 52 DD       3590 ( 16) FILESIZE:  CALL AUTOSEL         ;select proper drive and check file length
DE51-C3 D3 DC       3591 (  9)         JP      RANSIZE
DE54-               3592       ;
DE54-               3593       ;   Function #37. This allows a program to log off any drives.
DE54-               3594       ; On entry, set (DE) to contain a word with bits set for those
DE54-               3595       ; drives that are to be logged off. The log-in vector and the
DE54-               3596       ; write protect vector will be updated. This must be a M/PM
DE54-               3597       ; special function.
DE54-               3598       ;
DE54-2A 44 D4       3599 ( 15) LOGOFF:         LD      HL,(PARAMS)     ;get drives to log off.
DE57-7D             3600 (  4)         LD      A,L             ;for each bit that is set, we want
DE58-2F             3601 (  3)         CPL                     ;to clear that bit in (LOGIN)
DE59-5F             3602 (  4)         LD      E,A             ;and (WRTPRT).
DE5A-7C             3603 (  4)         LD      A,H
DE5B-2F             3604 (  3)         CPL
DE5C-2A B0 DE       3605 ( 15)         LD      HL,(LOGIN)      ;reset the login vector.
DE5F-A4             3606 (  4)         AND     H
DE60-57             3607 (  4)         LD      D,A
DE61-7D             3608 (  4)         LD      A,L
DE62-A3             3609 (  4)         AND     E
DE63-5F             3610 (  4)         LD      E,A
DE64-2A AE DE       3611 ( 15)         LD      HL,(WRTPRT)
DE67-EB             3612 (  3)         EX      DE,HL
DE68-22 B0 DE       3613 ( 20)         LD      (LOGIN),HL      ;and save.
DE6B-7D             3614 (  4)         LD      A,L             ;now do the write protect vector.
DE6C-A3             3615 (  4)         AND     E
DE6D-6F             3616 (  4)         LD      L,A
DE6E-7C             3617 (  4)         LD      A,H
DE6F-A2             3618 (  4)         AND     D
DE70-67             3619 (  4)         LD      H,A
DE71-22 AE DE       3620 ( 20)         LD      (WRTPRT),HL     ;and save. all done.
DE74-C9             3621 (  9)         RET
DE75-               3622       ;
DE75-               3623       ;   Get here to return to the user.
DE75-               3624       ;
DE75-3A DF DE       3625 ( 12) GOBACK:         LD      A,(AUTO)        ;was auto select activated?
DE78-B7             3626 (  4)         OR      A
DE79-CA 92 DE       3627 ( 6+)         JP      Z,GOBACK1
DE7C-2A 44 D4       3628 ( 15)         LD      HL,(PARAMS)     ;yes, but was a change made?
DE7F-36 00          3629 (  9)         LD      (HL),0          ;(* reset first byte of fcb *)
DE81-3A E1 DE       3630 ( 12)         LD      A,(AUTOFLAG)
DE84-B7             3631 (  4)         OR      A
DE85-CA 92 DE       3632 ( 6+)         JP      Z,GOBACK1
DE88-77             3633 (  7)         LD      (HL),A          ;yes, reset first byte properly.
DE89-3A E0 DE       3634 ( 12)         LD      A,(OLDDRV)      ;and get the old drive and select it.
DE8C-32 D7 DE       3635 ( 13)         LD      (EPARAM),A
DE8F-CD 46 DD       3636 ( 16)         CALL    SETDSK
DE92-2A 10 D4       3637 ( 15) GOBACK1: LD     HL,(USRSTACK)   ;reset the users stack pointer.
DE95-F9             3638 (  4)         LD      SP,HL
DE96-2A 46 D4       3639 ( 15)         LD      HL,(STATUS)     ;get return status.
DE99-7D             3640 (  4)         LD      A,L             ;force version 1.4 compatability.
DE9A-44             3641 (  4)         LD      B,H
DE9B-C9             3642 (  9)         RET                     ;and go back to user.
DE9C-               3643       ;
DE9C-               3644       ;   Function #40. This is a special entry to do random i/o.
DE9C-               3645       ; For the case where we are writing to unused disk space, this
DE9C-               3646       ; space will be zeroed out first. This must be a M/PM special
DE9C-               3647       ; purpose function, because why would any normal program even
DE9C-               3648       ; care about the previous contents of a sector about to be
DE9C-               3649       ; written over.
DE9C-               3650       ;
DE9C-CD 52 DD       3651 ( 16) WTSPECL: CALL   AUTOSEL         ;select proper drive.
DE9F-3E 02          3652 (  6)         LD      A,2             ;use special write mode.
DEA1-32 D6 DE       3653 ( 13)         LD      (MODE),A
DEA4-0E 00          3654 (  6)         LD      C,0             ;set write indicator.
DEA6-CD 08 DC       3655 ( 16)         CALL    POSITN1         ;position the file.
DEA9-CC 04 DB       3656 ( 6+)         CALL    Z,WTSEQ1        ;and write (if no errors).
DEAC-C9             3657 (  9)         RET
DEAD-               3658       ;
DEAD-               3659       ;**************************************************************
DEAD-               3660       ;*
DEAD-               3661       ;*     BDOS data storage pool.
DEAD-               3662       ;*
DEAD-               3663       ;**************************************************************
DEAD-               3664       ;
DEAD-E5             3665       EMPTYFCB:  .DB  0E5H            ;empty directory segment indicator.
DEAE-00 00          3666       WRTPRT:         .DW     0               ;write protect status for all 16 drives.
DEB0-00 00          3667       LOGIN:  .DW     0               ;drive active word (1 bit per drive).
DEB2-80 00          3668       USERDMA: .DW    080H            ;user's dma address (defaults to 80h).
DEB4-               3669       ;
DEB4-               3670       ;   Scratch areas from parameter block.
DEB4-               3671       ;
DEB4-00 00          3672       SCRATCH1:  .DW  0               ;relative position within dir segment for file (0-3).
DEB6-00 00          3673       SCRATCH2:  .DW  0               ;last selected track number.
DEB8-00 00          3674       SCRATCH3:  .DW  0               ;last selected sector number.
DEBA-               3675       ;
DEBA-               3676       ;   Disk storage areas from parameter block.
DEBA-               3677       ;
DEBA-00 00          3678       DIRBUF:         .DW     0               ;address of directory buffer to use.
DEBC-00 00          3679       DISKPB:         .DW     0               ;contains address of disk parameter block.
DEBE-00 00          3680       CHKVECT: .DW    0               ;address of check vector.
DEC0-00 00          3681       ALOCVECT:  .DW  0               ;address of allocation vector (bit map).
DEC2-               3682       ;
DEC2-               3683       ;   Parameter block returned from the bios.
DEC2-               3684       ;
DEC2-00 00          3685       SECTORS: .DW    0               ;sectors per track from bios.
DEC4-00             3686       BLKSHFT: .DB    0               ;block shift.
DEC5-00             3687       BLKMASK: .DB    0               ;block mask.
DEC6-00             3688       EXTMASK: .DB    0               ;extent mask.
DEC7-00 00          3689       DSKSIZE: .DW    0               ;disk size from bios (number of blocks-1).
DEC9-00 00          3690       DIRSIZE: .DW    0               ;directory size.
DECB-00 00          3691       ALLOC0:         .DW     0               ;storage for first bytes of bit map (dir space used).
DECD-00 00          3692       ALLOC1:         .DW     0
DECF-00 00          3693       OFFSET:         .DW     0               ;first usable track number.
DED1-00 00          3694       XLATE:  .DW     0               ;sector translation table address.
DED3-               3695       ;
DED3-               3696       ;
DED3-00             3697       CLOSEFLG:  .DB  0               ;close flag (=0ffh is extent written ok).
DED4-00             3698       RDWRTFLG:  .DB  0               ;read/write flag (0ffh=read, 0=write).
DED5-00             3699       FNDSTAT: .DB    0               ;filename found status (0=found first entry).
DED6-00             3700       MODE:   .DB     0               ;I/o mode select (0=random, 1=sequential, 2=special random).
DED7-00             3701       EPARAM:         .DB     0               ;storage for register (E) on entry to bdos.
DED8-00             3702       RELBLOCK:  .DB  0               ;relative position within fcb of block number written.
DED9-00             3703       COUNTER: .DB    0               ;byte counter for directory name searches.
DEDA-00 00 00 00    3704       SAVEFCB: .DW    0,0             ;save space for address of fcb (for directory searches).
DEDE-00             3705       BIGDISK: .DB    0               ;if =0 then disk is > 256 blocks long.
DEDF-00             3706       AUTO:   .DB     0               ;if non-zero, then auto select activated.
DEE0-00             3707       OLDDRV:         .DB     0               ;on auto select, storage for previous drive.
DEE1-00             3708       AUTOFLAG:  .DB  0               ;if non-zero, then auto select changed drives.
DEE2-00             3709       SAVNXT:         .DB     0               ;storage for next record number to access.
DEE3-00             3710       SAVEXT:         .DB     0               ;storage for extent number of file.
DEE4-00 00          3711       SAVNREC: .DW    0               ;storage for number of records in file.
DEE6-00 00          3712       BLKNMBR: .DW    0               ;block number (physical sector) used within a file or logical sect
DEE8-00 00          3713       LOGSECT: .DW    0               ;starting logical (128 byte) sector of block (physical sector).
DEEA-00             3714       FCBPOS:         .DB     0               ;relative position within buffer for fcb of file of interest.
DEEB-00 00          3715       FILEPOS: .DW    0               ;files position within directory (0 to max entries -1).
DEED-               3716       ;
DEED-               3717       ;   Disk directory buffer checksum bytes. One for each of the
DEED-               3718       ; 16 possible drives.
DEED-               3719       ;
DEED-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00    3720       CKSUMTBL:  .DB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DEFD-               3721       ;
DEFD-               3722       ;   Extra space ?
DEFD-               3723       ;
DEFD-00 00 00 00    3724               .DB     0,0,0,0
DF01-               3725       ;
DF01-               3726       ;**************************************************************
DF01-               3727       ;*
DF01-               3728       ;*        B I O S   J U M P   T A B L E
DF01-               3729       ;*
DF01-               3730       ;**************************************************************
DF01-               3731       ;
DF01-C3 00 00       3732 (  9) BOOT:   JP      0               ;NOTE WE USE FAKE DESTINATIONS
DF04-C3 00 00       3733 (  9) WBOOT:  JP      0
DF07-C3 00 00       3734 (  9) CONST:  JP      0
DF0A-C3 00 00       3735 (  9) CONIN:  JP      0
DF0D-C3 00 00       3736 (  9) CONOUT:         JP      0
DF10-C3 00 00       3737 (  9) LIST:   JP      0
DF13-C3 00 00       3738 (  9) PUNCH:  JP      0
DF16-C3 00 00       3739 (  9) READER:         JP      0
DF19-C3 00 00       3740 (  9) HOME:   JP      0
DF1C-C3 00 00       3741 (  9) SELDSK:         JP      0
DF1F-C3 00 00       3742 (  9) SETTRK:         JP      0
DF22-C3 00 00       3743 (  9) SETSEC:         JP      0
DF25-C3 00 00       3744 (  9) SETDMA:         JP      0
DF28-C3 00 00       3745 (  9) READ:   JP      0
DF2B-C3 00 00       3746 (  9) WRITE:  JP      0
DF2E-C3 00 00       3747 (  9) PRSTAT:         JP      0
DF31-C3 00 00       3748 (  9) SECTRN:         JP      0
DF34-               3749       ;
DF34-               3750       ;*
DF34-               3751       ;******************   E N D   O F   C P / M   *****************
DF34-               3752       ;*
DF34-               3753
DF34-               3754               .END
