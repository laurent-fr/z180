0000-                  6           .SF bios.sym
0000-                  7
0000-                  8           .include ../../include/z180_defs.asm
0000-            I     1       ; ------------------------------------
0000-            I     2       ; Z180 constants
0000-            I     3       ; ------------------------------------
0000-            I     4
0000-            I     5       ; ASCI
0000-            I     6       ; ----------
0000-            I     7
0000-            I     8       ; ASCI Control Register A 0 (CNTLA0: 00H)
0000-            I     9       CNTLA0         .equ $00
0000-            I    10
0080-            I    11       CNTLA0_MPE     .equ $80
0040-            I    12       CNTLA0_RE      .equ $40
0020-            I    13       CNTLA0_TE      .equ $20
0010-            I    14       CNTLA0_RTS0    .equ $10
0008-            I    15       CNTLA0_EFR     .equ $08
0004-            I    16       CNTLA0_MOD2    .equ $04
0002-            I    17       CNTLA0_MOD1    .equ $02
0001-            I    18       CNTLA0_MOD0    .equ $01
0000-            I    19
0000-            I    20       ; ASCI Control Register A 1 (CNTLA1: 01H)
0001-            I    21       CNTLA1         .equ $01
0000-            I    22
0080-            I    23       CNTLA1_MPE     .equ $80
0040-            I    24       CNTLA1_RE      .equ $40
0020-            I    25       CNTLA1_TE      .equ $20
0010-            I    26       CNTLA1_CKA1D   .equ $10
0008-            I    27       CNTLA1_EFR     .equ $08
0004-            I    28       CNTLA1_MOD2    .equ $04
0002-            I    29       CNTLA1_MOD1    .equ $02
0001-            I    30       CNTLA1_MOD0    .equ $01
0000-            I    31
0000-            I    32       ; ASCI Control Register B 0 (CNTLB0: 02H)
0002-            I    33       CNTLB0         .equ $02
0000-            I    34
0080-            I    35       CNTLB0_MPBT    .equ $80
0040-            I    36       CNTLB0_MP      .equ $40
0020-            I    37       CNTLB0_CTS     .equ $20
0010-            I    38       CNTLB0_PEO     .equ $10
0008-            I    39       CNTLB0_DR      .equ $08
0004-            I    40       CNTLB0_SS2     .equ $04
0002-            I    41       CNTLB0_SS1     .equ $02
0001-            I    42       CNTLB0_SS0     .equ $01
0000-            I    43
0000-            I    44       ; ASCI Control Register B 1 (CNTLB1: 03H)
0003-            I    45       CNTLB1         .equ $03
0000-            I    46
0080-            I    47       CNTLB1_MPBT    .equ $80
0040-            I    48       CNTLB1_MP      .equ $40
0020-            I    49       CNTLB1_CTS     .equ $20
0010-            I    50       CNTLB1_PEO     .equ $10
0008-            I    51       CNTLB1_DR      .equ $08
0004-            I    52       CNTLB1_SS2     .equ $04
0002-            I    53       CNTLB1_SS1     .equ $02
0001-            I    54       CNTLB1_SS0     .equ $01
0000-            I    55
0000-            I    56       ; ASCI Status Register 0 (STAT0: 04H)
0004-            I    57       STAT0          .equ $04
0000-            I    58
0080-            I    59       STAT0_RDRF     .equ $80
0040-            I    60       STAT0_OVRN     .equ $40
0020-            I    61       STAT0_PE       .equ $20
0010-            I    62       STAT0_FE       .equ $10
0008-            I    63       STAT0_RIE      .equ $08
0004-            I    64       STAT0_DCD0     .equ $04
0002-            I    65       STAT0_TDRE     .equ $02
0001-            I    66       STAT0_TIE      .equ $01
0000-            I    67
0000-            I    68       ; ASCI Status Register 1 (STAT1: 05H)
0005-            I    69       STAT1          .equ $05
0000-            I    70
0080-            I    71       STAT1_RDRF     .equ $80
0040-            I    72       STAT1_OVRN     .equ $40
0020-            I    73       STAT1_PE       .equ $20
0010-            I    74       STAT1_FE       .equ $10
0008-            I    75       STAT1_RIE      .equ $08
0004-            I    76       STAT1_CTS1E    .equ $04
0002-            I    77       STAT1_TDRE     .equ $02
0001-            I    78       STAT1_TIE      .equ $01
0000-            I    79
0000-            I    80       ; ASCI Transmit Data Register Ch. 0 (TDR0: 06H)
0006-            I    81       TDR0           .equ $06
0000-            I    82
0000-            I    83       ; ASCI Transmit Data Register Ch. 1 (TDR1: 07H)
0007-            I    84       TDR1           .equ $07
0000-            I    85
0000-            I    86       ; ASCI Receive Data Register Ch. 0 (RDR0: 08H)
0008-            I    87       RDR0           .equ $08
0000-            I    88
0000-            I    89       ; ASCI Receive Data Register Ch. 1 (RDR1: 09H)
0009-            I    90       RDR1           .equ $09
0000-            I    91
0000-            I    92       ; ASCI0 Extension Control Register 0 (ASEXT0: 12H)
0012-            I    93       ASEXT0         .equ $12
0000-            I    94
0080-            I    95       ASEXT0_RDRFI   .equ $80
0040-            I    96       ASEXT0_DCD0D   .equ $40
0020-            I    97       ASEXT0_CTS0D   .equ $20
0010-            I    98       ASEXT0_X1      .equ $10
0008-            I    99       ASEXT0_BRG0    .equ $08
0004-            I   100       ASEXT0_BRKE    .equ $04
0002-            I   101       ASEXT0_BRK     .equ $02
0001-            I   102       ASEXT0_SBRK    .equ $01
0000-            I   103
0000-            I   104       ; ASCI1 Extension Control Register 1 (ASEXT1: 13H)
0013-            I   105       ASEXT1         .equ $13
0000-            I   106
0080-            I   107       ASEXT1_RDRFI   .equ $80
0010-            I   108       ASEXT1_X1      .equ $10
0008-            I   109       ASEXT1_BRG1    .equ $08
0004-            I   110       ASEXT1_BRKE    .equ $04
0002-            I   111       ASEXT1_BRK     .equ $02
0001-            I   112       ASEXT1_SBRK    .equ $01
0000-            I   113
0000-            I   114       ; ASCI0 Time Constant Low Register (ASTC0L : 1AH)
001A-            I   115       ASTC0L         .equ $1A
0000-            I   116       ; ASCI0 Time Constant High Register (ASTC0H: 1BH)
001B-            I   117       ASTC0H         .equ $1B
0000-            I   118       ; ASCI1 Time Constant Low Register (ASTC1L : 1AH)
001C-            I   119       ASTC1L         .equ $1C
0000-            I   120       ; ASCI1 Time Constant High Register (ASTC1H: 1BH)
001D-            I   121       ASTC1H         .equ $1D
0000-            I   122
0000-            I   123       ; CSI/0
0000-            I   124       ; ------------------------------------
0000-            I   125
0000-            I   126       ; CSI/O Control Register (CNTR: 0AH)
000A-            I   127       CNTR           .equ $0A
0000-            I   128
0080-            I   129       CNTR_EF        .equ $80
0040-            I   130       CNTR_EIE       .equ $40
0020-            I   131       CNTR_RE        .equ $20
0010-            I   132       CNTR_TE        .equ $10
0004-            I   133       CNTR_SS2       .equ $04
0002-            I   134       CNTR_SS1       .equ $02
0001-            I   135       CNTR_SS0       .equ $01
0000-            I   136
0000-            I   137       ; CSI/O Transmit/Receive Data Register (TRD: 0BH)
000B-            I   138       TRDR           .equ $0B
0000-            I   139
0000-            I   140       ; Timer
0000-            I   141       ; ------------------------------------
0000-            I   142
0000-            I   143       ; Data Register Ch 0 L (TMDR0L: 0CH)
000C-            I   144       TMDR0L         .equ $0C
0000-            I   145       ; Data Register Ch 0 H (TMDR0H: 0DH)
000D-            I   146       TMDR0H         .equ $0D
0000-            I   147       ; Reload Register Ch 0 L (RLDR0L: OEH)
000E-            I   148       RLDR0L         .equ $0E
0000-            I   149       ; Reload Register Ch 0 H (RLDR0H: 0FH)
000F-            I   150       RLDR0H         .equ $0F
0000-            I   151
0000-            I   152       ; Timer Control Register (TCR: 10H)
0010-            I   153       TCR            .equ $10
0000-            I   154
0080-            I   155       TCR_TIF1        .equ $80
0040-            I   156       TCR_TIF0        .equ $40
0020-            I   157       TCR_TIE1        .equ $20
0010-            I   158       TCR_TIE0        .equ $10
0008-            I   159       TCR_TOC1       .equ $08
0004-            I   160       TCR_TOC0       .equ $04
0002-            I   161       TCR_TDE1       .equ $02
0001-            I   162       TCR_TDE0       .equ $01
0000-            I   163
0000-            I   164       ; Data Register Ch 1 L (TMDR1L: 14h)
0014-            I   165       TMDR1L         .equ $14
0000-            I   166       ; Data Register Ch 1 H (TMDR1H: 15H)
0015-            I   167       TMDR1H         .equ $15
0000-            I   168       ; Reload Register Ch 1 L (RLDR1L: 16H)
0016-            I   169       RLDR1L         .equ $16
0000-            I   170       ; Reload Register Ch 1 H (RLDR1H: 17H)
0017-            I   171       RLDR1H         .equ $17
0000-            I   172
0000-            I   173       ; Others
0000-            I   174       ; ------------------------------------
0000-            I   175
0000-            I   176       ; Clock Multiplier Register (CMR: 1EH)
001E-            I   177       CMR            .equ $1E
0000-            I   178
0080-            I   179       CMR_X2         .equ $80
0000-            I   180
0000-            I   181       ; Free Running Counter (FRC: 18H)
0018-            I   182       FRC            .equ $18
0000-            I   183
0000-            I   184       ; CPU Control Register (CCR: 1FH)
001F-            I   185       CCR            .equ $1F
0080-            I   186       CCR_CD         .equ $80
0040-            I   187       CCR_SB1        .equ $40
0020-            I   188       CCR_BREXT      .equ $20
0010-            I   189       CCR_LNPHI      .equ $10
0008-            I   190       CCR_SB2        .equ $08
0004-            I   191       CCR_LNIO       .equ $04
0002-            I   192       CCR_LNCPU      .equ $02
0001-            I   193       CCR_LNAD       .equ $01
0000-            I   194
0000-            I   195       ; DMA
0000-            I   196       ; ---------------------------------------------------------------------------
0000-            I   197
0000-            I   198
0000-            I   199       ; DMA/WAIT Control Register (DCNTL: 32H)
0000-            I   200
0000-            I   201       ; INT
0000-            I   202       ; ---------------------------------------------------------------------------
0000-            I   203
0000-            I   204       ; Interrupt Vector Low Register (IL: 33H)
0033-            I   205       IL              .equ $33
0000-            I   206
0000-            I   207       ; INT/TRAP Control Register (ITC: 34H)
0034-            I   208       ITC             .equ $34
0000-            I   209
0080-            I   210       ITC_TRAP        .equ $80
0040-            I   211       ITC_UFO         .equ $40
0004-            I   212       ITC_ITE2        .equ $04
0002-            I   213       ITC_ITE1        .equ $02
0001-            I   214       ITC_ITE0        .equ $01
0000-            I   215
0000-            I   216
0000-            I   217       ; Refresh
0000-            I   218       ; ---------------------------------------------------------------------------
0000-            I   219
0000-            I   220       ; Refresh Control Register (RCR: 36H)
0036-            I   221       RCR            .equ $36
0080-            I   222       RCR_REFE       .equ $80
0040-            I   223       RCR_REFW       .equ $40
0002-            I   224       RCR_CYC1       .equ $02
0001-            I   225       RCR_CYC0       .equ $01
0000-            I   226
0000-            I   227       ; MMU
0000-            I   228       ; ---------------------------------------------------------------------------
0000-            I   229
0000-            I   230       ; MMU Common Base Register (CBR: 38H)
0038-            I   231       CBR            .equ $38
0000-            I   232       ; MMU Bank Base Register (BBR: 39H)
0039-            I   233       BBR            .equ $39
0000-            I   234       ; MMU Common/Bank Register (CBAR: 3AH)
003A-            I   235       CBAR           .equ $3A
0000-            I   236       ; I/O
0000-            I   237       ; ---------------------------------------------------------------------------
0000-            I   238
0000-            I   239       ; Operation Mode Control Register (OMCR: 3EH)
003E-            I   240       OMCR           .equ $3E
0000-            I   241
0080-            I   242       OMCR_M1E       .equ $80
0040-            I   243       OMCR_M1TE      .equ $40
0000-            I   244       ;OMCR_M1E       .equ $20
0000-            I   245
0000-            I   246       ; I/O Control Register (ICR: 3FH)
003F-            I   247       ICR            .equ $3F
0000-            I   248
0080-            I   249       ICR_IOA7       .equ $80
0040-            I   250       ICR_IOA6       .equ $40
0020-            I   251       ICR_IOSTP      .equ $20
0000-                  9
0000-                 10
0000-                 11
E000-                 12           .org $E000
E000-                 13
E000-                 14           ; SYSTEM
E000-C9               15 (  9) .int_noop:      ret
E001-                 16
E001-                 17           ; ASCI
E001-C3 58 E0         18 (  9) .asci0_init:        jp _asci0_init
E004-C3 7B E0         19 (  9) .int_asci0:         jp _int_asci0
E007-                 20
E007-C3 AE E0         21 (  9) .asci0_getc:        jp _asci0_getc
E00A-C3 C7 E0         22 (  9) .asci0_rx_empty:    jp _asci0_rx_empty
E00D-C3 CD E0         23 (  9) .asci0_putc:        jp _asci0_putc
E010-C3 DA E0         24 (  9) .asci0_puts:        jp _asci0_puts
E013-                 25
E013-C3 EA E0         26 (  9) .asci1_init:        jp _asci1_init
E016-C3 0D E1         27 (  9) .int_asci1:         jp _int_asci1
E019-                 28
E019-C3 40 E1         29 (  9) .asci1_getc:        jp _asci1_getc
E01C-C3 59 E1         30 (  9) .asci1_rx_empty:    jp _asci1_rx_empty
E01F-C3 5F E1         31 (  9) .asci1_putc:        jp _asci1_putc
E022-C3 6C E1         32 (  9) .asci1_puts:        jp _asci1_puts
E025-                 33
E025-                 34           ; VDU
E025-C3 FE E1         35 (  9) .vdu_init:          jp _vdu_init
E028-C3 2B E2         36 (  9) .int_vdu:           jp _int_vdu
E02B-                 37
E02B-C3 8A E2         38 (  9) .vdu_set_attr:      jp _vdu_set_attr
E02E-C3 8E E2         39 (  9) .vdu_cls:           jp _vdu_cls
E031-C3 B8 E2         40 (  9) .vdu_scroll_up:      jp _vdu_scroll_up
E034-C3 DE E2         41 (  9) .vdu_putc_term:      jp _vdu_putc_term
E037-C3 84 E3         42 (  9) .vdu_putc:           jp _vdu_putc
E03A-C3 A6 E3         43 (  9) .vdu_next_line:      jp _vdu_next_line
E03D-C3 C9 E3         44 (  9) .vdu_puts:           jp _vdu_puts
E040-                 45
E040-                 46           ; KBD
E040-C3 44 E4         47 (  9) .kbd_init:          jp _kbd_init
E043-C3 54 E4         48 (  9) .int_kbd:           jp _int_kbd
E046-C3 46 E5         49 (  9) .kbd_is_empty:       jp _kbd_is_empty
E049-C3 4C E5         50 (  9) .kbd_get_key:        jp _kbd_get_key
E04C-C3 64 E5         51 (  9) .kbd_wait_get_key:  jp _kbd_wait_get_key
E04F-                 52
E04F-                 53           ; SND
E04F-C3 C7 E7         54 (  9) .snd_init:          jp _snd_init
E052-C3 D2 E7         55 (  9) .int_snd:           jp _int_snd
E055-C3 FB E7         56 (  9) .snd_beep:          jp _snd_beep
E058-                 57
E058-                 58           ; RTC
E058-                 59
E058-                 60
E058-                 61           .include bios_asci.asm
E058-            I     1       ; ASCI
E058-            I     2       ; ----------------------------------------------------------------------------
E058-            I     3
E058-            I     4       ; init ASCI0
E058-            I     5       ; input : none
E058-            I     6       ; output : none
E058-            I     7       _asci0_init:
E058-            I     8           ; RE : Receiver Enable
E058-            I     9           ; TE : Transmitter Enable
E058-            I    10           ; MOD2 : 8 bits data ( No parity, 1 stop bit)
E058-3E 64       I    11 (  6)     ld a,CNTLA0_RE|CNTLA0_TE|CNTLA0_MOD2
E05A-ED 39 00    I    12 ( 13)     out0 (CNTLA0),a
E05D-            I    13
E05D-            I    14           ; DR=0
E05D-3E 00       I    15 (  6)     ld a,0
E05F-ED 39 02    I    16 ( 13)     out0 (CNTLB0),a
E062-            I    17
E062-            I    18           ; BRG0 : Enable 16 bit BRG counter
E062-            I    19           ; X1 ( + DR=0) : Clock mode = /1
E062-3E 18       I    20 (  6)     ld a,ASEXT0_BRG0|ASEXT0_X1
E064-ED 39 12    I    21 ( 13)     out0 (ASEXT0),a
E067-            I    22
E067-            I    23           ; 9600 bauds : TC=1665 (681H) --> 9603 bauds
E067-            I    24           ; TC = fphi/(2*baud rate*clock mode) - 2
E067-            I    25           ; TC = 32000000/(2*9600*1) - 2
E067-3E 81       I    26 (  6)     ld a,$81
E069-ED 39 1A    I    27 ( 13)     out0 (ASTC0L),a
E06C-3E 06       I    28 (  6)     ld a,$06
E06E-ED 39 1B    I    29 ( 13)     out0 (ASTC0H),a
E071-            I    30
E071-            I    31           ; RIE : enable Rx Interrupt
E071-3E 08       I    32 (  6)     ld a,STAT0_RIE
E073-ED 39 04    I    33 ( 13)     out0 (STAT0),a
E076-            I    34
E076-AF          I    35 (  4)     xor a                  ; init RX buffer
E077-32 7C E1    I    36 ( 13)     ld (asci0_buffer_pos),a
E07A-            I    37
E07A-C9          I    38 (  9)     ret
E07B-            I    39
E07B-            I    40       ; INT ASCI0
E07B-            I    41       ; put received char in ASCI0 RX buffer
E07B-            I    42       _int_asci0:
E07B-F5          I    43 ( 11)     push af
E07C-C5          I    44 ( 11)     push bc
E07D-D5          I    45 ( 11)     push de
E07E-E5          I    46 ( 11)     push hl
E07F-            I    47
E07F-            I    48       _int_asci0_test:
E07F-ED 38 04    I    49 ( 12)     in0 a,(STAT0)                ; check if there is a char in the FIFO
E082-ED 64 80    I    50 (  9)     tst STAT0_RDRF
E085-28 21       I    51 ( 6+)     jr Z,_int_asci0_exit
E087-            I    52
E087-ED 08 08    I    53 ( 12)     in0 c,(RDR0)                ; c <- received char
E08A-            I    54
E08A-            I    55           ; check for error
E08A-E6 70       I    56 (  6)     and STAT0_OVRN|STAT0_PE|STAT0_FE
E08C-28 0A       I    57 ( 6+)     jr Z,_int_asci0_ok
E08E-            I    58
E08E-ED 38 00    I    59 ( 12)     in0 a,(CNTLA0)           ; clear error
E091-E6 F7       I    60 (  6)     and CNTLA0_EFR!$FF
E093-ED 39 00    I    61 ( 13)     out0 (CNTLA0),a
E096-18 E7       I    62 (  8)     jr _int_asci0_test                    ; exit
E098-            I    63
E098-            I    64       _int_asci0_ok:
E098-16 00       I    65 (  6)     ld d,0                      ; hl <- asci0_buffer+(asci0_buffer_pos)
E09A-3A 7C E1    I    66 ( 12)     ld a,(asci0_buffer_pos)
E09D-5F          I    67 (  4)     ld e,a
E09E-21 7D E1    I    68 (  9)     ld hl,asci0_buffer
E0A1-19          I    69 (  7)     add hl,de
E0A2-            I    70
E0A2-3C          I    71 (  4)     inc a                       ; ; inc kbd_buffer_pos
E0A3-32 7C E1    I    72 ( 13)     ld (asci0_buffer_pos),a
E0A6-            I    73
E0A6-79          I    74 (  4)     ld a,c                      ; a <- received char
E0A7-77          I    75 (  7)     ld (hl),a                   ; save it to asci0_buffer+(asci0_buffer_pos)
E0A8-            I    76
E0A8-            I    77       _int_asci0_exit:
E0A8-E1          I    78 (  9)     pop hl
E0A9-D1          I    79 (  9)     pop de
E0AA-C1          I    80 (  9)     pop bc
E0AB-F1          I    81 (  9)     pop af
E0AC-FB          I    82 (  3)     ei
E0AD-C9          I    83 (  9)     ret
E0AE-            I    84
E0AE-            I    85       ; get a char on ASCI0 RX buffer
E0AE-            I    86       ; input : none
E0AE-            I    87       ; output : a <- received char
E0AE-            I    88       _asci0_getc:
E0AE-E5          I    89 ( 11)     push hl
E0AF-D5          I    90 ( 11)     push de
E0B0-            I    91
E0B0-3A 7C E1    I    92 ( 12)     ld a,(asci0_buffer_pos)     ; load buffer position
E0B3-F6 00       I    93 (  6)     or 0
E0B5-CA C4 E0    I    94 ( 6+)     jp  Z,_asci0_getc_exit      ; exit if 0
E0B8-            I    95
E0B8-3D          I    96 (  4)     dec a                       ; decrement and update buffer position
E0B9-32 7C E1    I    97 ( 13)     ld (asci0_buffer_pos),a
E0BC-            I    98
E0BC-16 00       I    99 (  6)     ld d,0                      ; get char in buffer
E0BE-5F          I   100 (  4)     ld e,a
E0BF-21 7D E1    I   101 (  9)     ld hl,asci0_buffer
E0C2-19          I   102 (  7)     add hl,de
E0C3-7E          I   103 (  6)     ld a,(hl)                   ; into A register
E0C4-            I   104
E0C4-            I   105       _asci0_getc_exit:
E0C4-            I   106
E0C4-D1          I   107 (  9)     pop de
E0C5-E1          I   108 (  9)     pop hl
E0C6-C9          I   109 (  9)     ret
E0C7-            I   110
E0C7-            I   111       ; check if rx buffer is empty
E0C7-            I   112       ; input : NONE
E0C7-            I   113       ; output : flag=Z if empty
E0C7-            I   114       _asci0_rx_empty:
E0C7-3A 7C E1    I   115 ( 12)     ld a,(asci0_buffer_pos)
E0CA-FE 00       I   116 (  6)     cp 0
E0CC-C9          I   117 (  9)     ret
E0CD-            I   118
E0CD-            I   119       ; put a char on asci0
E0CD-            I   120       ; input : a = char ascii code
E0CD-            I   121       ; output : none
E0CD-            I   122       _asci0_putc:
E0CD-F5          I   123 ( 11)     push af
E0CE-            I   124
E0CE-            I   125       _asci0_putc_wait:  ; wait for asci0 TX ready
E0CE-ED 38 04    I   126 ( 12)     in0 a,(STAT0) ; TDRE=1 -> empty
E0D1-E6 02       I   127 (  6)     and STAT0_TDRE
E0D3-28 F9       I   128 ( 6+)     jr Z,_asci0_putc_wait
E0D5-            I   129
E0D5-F1          I   130 (  9)     pop af
E0D6-ED 39 06    I   131 ( 13)     out0 (TDR0),a ; output the char to asci0
E0D9-            I   132
E0D9-C9          I   133 (  9)     ret
E0DA-            I   134
E0DA-            I   135       ; put a string on asci0
E0DA-            I   136       ; input : (hl) = address of null terminated string
E0DA-            I   137       ; output : none
E0DA-            I   138       _asci0_puts:
E0DA-E5          I   139 ( 11)     push hl
E0DB-F5          I   140 ( 11)     push af
E0DC-            I   141
E0DC-            I   142       _asci0_puts_loop:
E0DC-7E          I   143 (  6)     ld a,(hl)
E0DD-F6 00       I   144 (  6)     or 0
E0DF-28 06       I   145 ( 6+)     jr z,_asci0_puts_exit
E0E1-CD CD E0    I   146 ( 16)     call _asci0_putc
E0E4-23          I   147 (  4)     inc hl
E0E5-18 F5       I   148 (  8)     jr _asci0_puts_loop
E0E7-            I   149
E0E7-            I   150       _asci0_puts_exit:
E0E7-F1          I   151 (  9)     pop af
E0E8-E1          I   152 (  9)     pop hl
E0E9-C9          I   153 (  9)     ret
E0EA-            I   154
E0EA-            I   155       _asci1_init:
E0EA-            I   156           ; RE : Receiver Enable
E0EA-            I   157           ; TE : Transmitter Enable
E0EA-            I   158           ; MOD2 : 8 bits data ( No parity, 1 stop bit)
E0EA-3E 64       I   159 (  6)     ld a,CNTLA1_RE|CNTLA1_TE|CNTLA1_MOD2
E0EC-ED 39 01    I   160 ( 13)     out0 (CNTLA1),a
E0EF-            I   161
E0EF-            I   162           ; DR=0
E0EF-3E 00       I   163 (  6)     ld a,0
E0F1-ED 39 03    I   164 ( 13)     out0 (CNTLB1),a
E0F4-            I   165
E0F4-            I   166           ; BRG0 : Enable 16 bit BRG counter
E0F4-            I   167           ; X1 ( + DR=0) : Clock mode = /1
E0F4-3E 18       I   168 (  6)     ld a,ASEXT1_BRG1|ASEXT1_X1
E0F6-ED 39 13    I   169 ( 13)     out0 (ASEXT1),a
E0F9-            I   170
E0F9-            I   171           ; 9600 bauds : TC=1665 (681H) --> 9603 bauds
E0F9-            I   172           ; TC = fphi/(2*baud rate*clock mode) - 2
E0F9-            I   173           ; TC = 32000000/(2*9600*1) - 2
E0F9-3E 81       I   174 (  6)     ld a,$81
E0FB-ED 39 1C    I   175 ( 13)     out0 (ASTC1L),a
E0FE-3E 06       I   176 (  6)     ld a,$06
E100-ED 39 1D    I   177 ( 13)     out0 (ASTC1H),a
E103-            I   178
E103-            I   179           ; RIE : enable Rx Interrupt
E103-3E 08       I   180 (  6)     ld a,STAT1_RIE
E105-ED 39 05    I   181 ( 13)     out0 (STAT1),a
E108-            I   182
E108-AF          I   183 (  4)     xor a                  ; init RX buffer
E109-32 BD E1    I   184 ( 13)     ld (asci1_buffer_pos),a
E10C-            I   185
E10C-C9          I   186 (  9)     ret
E10D-            I   187
E10D-            I   188       _int_asci1:
E10D-F5          I   189 ( 11)     push af
E10E-C5          I   190 ( 11)     push bc
E10F-D5          I   191 ( 11)     push de
E110-E5          I   192 ( 11)     push hl
E111-            I   193
E111-            I   194       _int_asci1_test:
E111-ED 38 05    I   195 ( 12)     in0 a,(STAT1)                ; check if there is a char in the FIFO
E114-ED 64 80    I   196 (  9)     tst STAT1_RDRF
E117-28 21       I   197 ( 6+)     jr Z,_int_asci1_exit
E119-            I   198
E119-ED 08 09    I   199 ( 12)     in0 c,(RDR1)                ; c <- received char
E11C-            I   200
E11C-            I   201           ; check for error
E11C-E6 70       I   202 (  6)     and STAT1_OVRN|STAT1_PE|STAT1_FE
E11E-28 0A       I   203 ( 6+)     jr Z,_int_asci1_ok
E120-            I   204
E120-ED 38 01    I   205 ( 12)     in0 a,(CNTLA1)           ; clear error
E123-E6 F7       I   206 (  6)     and CNTLA1_EFR!$FF
E125-ED 39 01    I   207 ( 13)     out0 (CNTLA1),a
E128-18 E7       I   208 (  8)     jr _int_asci1_test                    ; exit
E12A-            I   209
E12A-            I   210       _int_asci1_ok:
E12A-16 00       I   211 (  6)     ld d,0                      ; hl <- asci0_buffer+(asci0_buffer_pos)
E12C-3A BD E1    I   212 ( 12)     ld a,(asci1_buffer_pos)
E12F-5F          I   213 (  4)     ld e,a
E130-21 BE E1    I   214 (  9)     ld hl,asci1_buffer
E133-19          I   215 (  7)     add hl,de
E134-            I   216
E134-3C          I   217 (  4)     inc a                       ; ; inc kbd_buffer_pos
E135-32 BD E1    I   218 ( 13)     ld (asci1_buffer_pos),a
E138-            I   219
E138-79          I   220 (  4)     ld a,c                      ; a <- received char
E139-77          I   221 (  7)     ld (hl),a                   ; save it to  asci1_buffer+(asci1_buffer_pos)
E13A-            I   222
E13A-            I   223       _int_asci1_exit:
E13A-E1          I   224 (  9)     pop hl
E13B-D1          I   225 (  9)     pop de
E13C-C1          I   226 (  9)     pop bc
E13D-F1          I   227 (  9)     pop af
E13E-FB          I   228 (  3)     ei
E13F-C9          I   229 (  9)     ret
E140-            I   230
E140-            I   231       _asci1_getc:
E140-E5          I   232 ( 11)     push hl
E141-D5          I   233 ( 11)     push de
E142-            I   234
E142-3A BD E1    I   235 ( 12)     ld a,(asci1_buffer_pos)     ; load buffer position
E145-F6 00       I   236 (  6)     or 0
E147-CA 56 E1    I   237 ( 6+)     jp  Z,_asci1_getc_exit      ; exit if 0
E14A-            I   238
E14A-3D          I   239 (  4)     dec a                       ; decrement and update buffer position
E14B-32 BD E1    I   240 ( 13)     ld (asci1_buffer_pos),a
E14E-            I   241
E14E-16 00       I   242 (  6)     ld d,0                      ; get char in buffer
E150-5F          I   243 (  4)     ld e,a
E151-21 BE E1    I   244 (  9)     ld hl,asci1_buffer
E154-19          I   245 (  7)     add hl,de
E155-7E          I   246 (  6)     ld a,(hl)                   ; into A register
E156-            I   247
E156-            I   248       _asci1_getc_exit:
E156-            I   249
E156-D1          I   250 (  9)     pop de
E157-E1          I   251 (  9)     pop hl
E158-C9          I   252 (  9)     ret
E159-            I   253
E159-            I   254       ; check if rx buffer is empty
E159-            I   255       ; input : NONE
E159-            I   256       ; output : flag=Z if empty
E159-            I   257       _asci1_rx_empty:
E159-3A BD E1    I   258 ( 12)     ld a,(asci1_buffer_pos)
E15C-FE 00       I   259 (  6)     cp 0
E15E-C9          I   260 (  9)     ret
E15F-            I   261
E15F-            I   262       ; put a char on asci1
E15F-            I   263       ; input : a = char ascii code
E15F-            I   264       ; output : none
E15F-            I   265       _asci1_putc:
E15F-F5          I   266 ( 11)     push af
E160-            I   267
E160-            I   268       _asci1_putc_wait:  ; wait for asci0 TX ready
E160-ED 38 05    I   269 ( 12)     in0 a,(STAT1) ; TDRE=1 -> empty
E163-E6 02       I   270 (  6)     and STAT1_TDRE
E165-28 F9       I   271 ( 6+)     jr Z,_asci1_putc_wait
E167-            I   272
E167-F1          I   273 (  9)     pop af
E168-ED 39 07    I   274 ( 13)     out0 (TDR1),a ; output the char to asci0
E16B-            I   275
E16B-C9          I   276 (  9)     ret
E16C-            I   277
E16C-            I   278       ; put a string on asci1
E16C-            I   279       ; input : (hl) = address of null terminated string
E16C-            I   280       ; output : none
E16C-            I   281       _asci1_puts:
E16C-E5          I   282 ( 11)     push hl
E16D-F5          I   283 ( 11)     push af
E16E-            I   284
E16E-            I   285       _asci1_puts_loop:
E16E-7E          I   286 (  6)     ld a,(hl)
E16F-F6 00       I   287 (  6)     or 0
E171-28 06       I   288 ( 6+)     jr z,_asci1_puts_exit
E173-CD 5F E1    I   289 ( 16)     call _asci1_putc
E176-23          I   290 (  4)     inc hl
E177-18 F5       I   291 (  8)     jr _asci1_puts_loop
E179-            I   292
E179-            I   293       _asci1_puts_exit:
E179-F1          I   294 (  9)     pop af
E17A-E1          I   295 (  9)     pop hl
E17B-C9          I   296 (  9)     ret
E17C-            I   297
E17C-            I   298       ; RAM
E17C-            I   299       asci0_buffer_pos:   .bs 1
E17D-            I   300       asci0_buffer:       .bs 64
E1BD-            I   301       asci1_buffer_pos:   .bs 1
E1BE-            I   302       asci1_buffer:       .bs 64
E1FE-                 62           .include bios_vdu.asm
E1FE-            I     1       ; VDU
E1FE-            I     2       ; ----------------------------------------------------------------------------
E1FE-            I     3
F000-            I     4       VDU_RAM   .equ $F000     ; Start of video RAM address
E1FE-            I     5
0001-            I     6       CURSOR_SOLID .equ 1
E1FE-            I     7
E1FE-            I     8
E1FE-            I     9       ; vdu_init
E1FE-            I    10       ; init the vdu system
E1FE-            I    11       ; input : none
E1FE-            I    12       ; output : none
E1FE-            I    13       _vdu_init:
E1FE-            I    14
E1FE-            I    15           ; clear screen
E1FE-CD 8E E2    I    16 ( 16)     call _vdu_cls
E201-            I    17
E201-            I    18           ; set PRT0 interrupt at 1/60s
E201-3E 1A       I    19 (  6)      ld a,$1A
E203-ED 39 0F    I    20 ( 13)      out0 (RLDR0H),a
E206-3E 0A       I    21 (  6)      ld a,$0A
E208-ED 39 0E    I    22 ( 13)      out0 (RLDR0L),a
E20B-            I    23
E20B-            I    24           ; enable PRT0 interrupt
E20B-ED 38 10    I    25 ( 12)     in0 a,(TCR)
E20E-F6 11       I    26 (  6)     or TCR_TIE0|TCR_TDE0
E210-ED 39 10    I    27 ( 13)     out0 (TCR),a
E213-            I    28
E213-            I    29           ; init variables
E213-AF          I    30 (  4)     xor a
E214-32 41 E4    I    31 ( 13)     ld (vdu_cursor_status),a        ; vdu_cursor_status <- 0
E217-32 43 E4    I    32 ( 13)     ld (vdu_term_flag),a            ; vdu_termc_flag <- 0
E21A-2A 3C E4    I    33 ( 15)     ld hl,(VDU_PTR)                 ; (vdu_cursor_ptr) <- (VDU_PTR)
E21D-22 3E E4    I    34 ( 20)     ld (vdu_cursor_ptr),hl
E220-23          I    35 (  4)     inc hl                          ; (vdu_cursor_save_attr) <- (VDU_ATTR+1)
E221-7E          I    36 (  6)     ld a,(hl)
E222-32 42 E4    I    37 ( 13)     ld (vdu_cursor_save_attr),a
E225-3E 1E       I    38 (  6)     ld a,30                         ; (vdu_cursor_blink) <- 30
E227-32 40 E4    I    39 ( 13)     ld (vdu_cursor_blink),a
E22A-            I    40
E22A-C9          I    41 (  9)     ret
E22B-            I    42
E22B-            I    43       _int_vdu:
E22B-F5          I    44 ( 11)     push af
E22C-E5          I    45 ( 11)     push hl
E22D-D5          I    46 ( 11)     push de
E22E-            I    47
E22E-ED 38 10    I    48 ( 12)     in0 a,(TCR)         ; clear TIFE0
E231-ED 38 0C    I    49 ( 12)     in0 a,(TMDR0L)
E234-            I    50
E234-2A 3E E4    I    51 ( 15)     ld hl,(vdu_cursor_ptr) ; compare vdu_cusror_ptr and VDU_PTR
E237-ED 5B 3C E4 I    52 ( 18)     ld de,(VDU_PTR)
E23B-            I    53
E23B-ED 52       I    54 ( 10)     sbc hl,de ; test if hl==de
E23D-7C          I    55 (  4)     ld a,h
E23E-B5          I    56 (  4)     or l
E23F-            I    57
E23F-28 21       I    58 ( 6+)     jr Z,_int_vdu_dec_blink_timer
E241-            I    59
E241-3A 41 E4    I    60 ( 12)     ld a,(vdu_cursor_status)  ; test if vdu_cursor_status==0
E244-FE 00       I    61 (  6)     cp 0
E246-CA 55 E2    I    62 ( 6+)     jp Z,_int_vdu_update_ptr
E249-            I    63
E249-2A 3E E4    I    64 ( 15)     ld hl,(vdu_cursor_ptr)  ; delete cursor at old location
E24C-23          I    65 (  4)     inc hl
E24D-3A 42 E4    I    66 ( 12)     ld a,(vdu_cursor_save_attr)
E250-77          I    67 (  7)     ld (hl),a
E251-            I    68
E251-AF          I    69 (  4)     xor a                      ; reset cursor status
E252-32 41 E4    I    70 ( 13)     ld (vdu_cursor_status),a
E255-            I    71
E255-            I    72       _int_vdu_update_ptr:
E255-2A 3C E4    I    73 ( 15)     ld hl,(VDU_PTR)
E258-22 3E E4    I    74 ( 20)     ld (vdu_cursor_ptr),hl  ; update cursor_ptr
E25B-18 16       I    75 (  8)     jr _int_vdu_do_blink
E25D-            I    76
E25D-23          I    77 (  4)     inc hl
E25E-7E          I    78 (  6)     ld a,(hl)
E25F-32 42 E4    I    79 ( 13)     ld (vdu_cursor_save_attr),a
E262-            I    80
E262-            I    81       _int_vdu_dec_blink_timer:
E262-            I    82
E262-3A 40 E4    I    83 ( 12)     ld a,(vdu_cursor_blink)     ; /60 divider for cursor blink
E265-3D          I    84 (  4)     dec a
E266-32 40 E4    I    85 ( 13)     ld (vdu_cursor_blink),a
E269-FE 00       I    86 (  6)     cp 0
E26B-C2 85 E2    I    87 ( 6+)     jp nz,_int_vdu_exit
E26E-            I    88
E26E-            I    89       _int_vdu_blink:
E26E-            I    90
E26E-3E 1E       I    91 (  6)     ld a,30                     ; set blink counter to 30 (1/2s blink speed)
E270-32 40 E4    I    92 ( 13)     ld (vdu_cursor_blink),a
E273-            I    93
E273-            I    94       _int_vdu_do_blink:
E273-            I    95
E273-2A 3C E4    I    96 ( 15)     ld hl,(VDU_PTR) ; reverse current location colour attribute
E276-23          I    97 (  4)     inc hl          ; hl <- current color attribute address
E277-7E          I    98 (  6)     ld a,(hl)
E278-07          I    99 (  3)     rlca
E279-07          I   100 (  3)     rlca
E27A-07          I   101 (  3)     rlca
E27B-07          I   102 (  3)     rlca
E27C-77          I   103 (  7)     ld (hl),a
E27D-            I   104
E27D-3A 41 E4    I   105 ( 12)     ld a,(vdu_cursor_status)     ; reverse cursor_status
E280-EE 01       I   106 (  6)     xor 1
E282-32 41 E4    I   107 ( 13)     ld (vdu_cursor_status),a
E285-            I   108
E285-            I   109
E285-            I   110       _int_vdu_exit:
E285-            I   111
E285-            I   112           ; TMP !
E285-            I   113           ;ld a,(vdu_cursor_status)
E285-            I   114           ;add '0'
E285-            I   115           ;ld hl,VDU_RAM
E285-            I   116           ;ld (hl),a
E285-            I   117
E285-            I   118           ;push bc
E285-            I   119           ;ld a,(VDU_X)
E285-            I   120           ;call _util_byte_to_ascii_hex
E285-            I   121           ;ld hl,VDU_RAM+10
E285-            I   122           ;ld a,b
E285-            I   123           ;ld (hl),a
E285-            I   124           ;inc hl
E285-            I   125           ;inc hl
E285-            I   126           ;ld a,c
E285-            I   127           ;ld (hl),a
E285-            I   128
E285-            I   129           ;ld a,(VDU_Y)
E285-            I   130           ;call _util_byte_to_ascii_hex
E285-            I   131           ;ld hl,VDU_RAM+16
E285-            I   132           ;ld a,b
E285-            I   133           ;ld (hl),a
E285-            I   134           ;inc hl
E285-            I   135           ;inc hl
E285-            I   136           ;ld a,c
E285-            I   137           ;ld (hl),a
E285-            I   138
E285-            I   139           ;ld a,(VDU_PTR+1)
E285-            I   140           ;call _util_byte_to_ascii_hex
E285-            I   141           ;ld hl,VDU_RAM+22
E285-            I   142           ;ld a,b
E285-            I   143           ;ld (hl),a
E285-            I   144           ;inc hl
E285-            I   145           ;inc hl
E285-            I   146           ;ld a,c
E285-            I   147           ;ld (hl),a
E285-            I   148
E285-            I   149           ;ld a,(VDU_PTR)
E285-            I   150           ;call _util_byte_to_ascii_hex
E285-            I   151           ;ld hl,VDU_RAM+26
E285-            I   152           ;ld a,b
E285-            I   153           ;ld (hl),a
E285-            I   154           ;inc hl
E285-            I   155           ;inc hl
E285-            I   156           ;ld a,c
E285-            I   157           ;ld (hl),a
E285-            I   158
E285-            I   159           ;ld a,(vdu_cursor_ptr+1)
E285-            I   160           ;call _util_byte_to_ascii_hex
E285-            I   161           ;ld hl,VDU_RAM+32
E285-            I   162           ;ld a,b
E285-            I   163           ;ld (hl),a
E285-            I   164           ;inc hl
E285-            I   165           ;inc hl
E285-            I   166           ;ld a,c
E285-            I   167           ;ld (hl),a
E285-            I   168
E285-            I   169           ;ld a,(vdu_cursor_ptr)
E285-            I   170           ;call _util_byte_to_ascii_hex
E285-            I   171           ;ld hl,VDU_RAM+36
E285-            I   172           ;ld a,b
E285-            I   173           ;ld (hl),a
E285-            I   174           ;inc hl
E285-            I   175           ;inc hl
E285-            I   176           ;ld a,c
E285-            I   177           ;ld (hl),a
E285-            I   178           ;pop bc
E285-            I   179
E285-D1          I   180 (  9)     pop de
E286-E1          I   181 (  9)     pop hl
E287-F1          I   182 (  9)     pop af
E288-FB          I   183 (  3)     ei
E289-C9          I   184 (  9)     ret
E28A-            I   185
E28A-            I   186       ; vdu_set_attr
E28A-            I   187       ; set the color attribute
E28A-            I   188       ; input : a = color attribute
E28A-            I   189       ; output : none
E28A-            I   190       _vdu_set_attr:
E28A-32 39 E4    I   191 ( 13)     ld (VDU_ATTR),a
E28D-C9          I   192 (  9)     ret
E28E-            I   193
E28E-            I   194       ; vdu_cls
E28E-            I   195       ; clear screen using VDU_ATTR color
E28E-            I   196       ; input : none
E28E-            I   197       ; output : none
E28E-            I   198       _vdu_cls:
E28E-D5          I   199 ( 11)     push de
E28F-E5          I   200 ( 11)     push hl
E290-F5          I   201 ( 11)     push af
E291-            I   202
E291-11 D0 07    I   203 (  9)     ld de,2000     ; number of chars
E294-21 00 F0    I   204 (  9)     ld hl,VDU_RAM    ; pointer to srart of ram
E297-3A 39 E4    I   205 ( 12)     ld a,(VDU_ATTR)  ; get color attribute
E29A-4F          I   206 (  4)     ld c,a
E29B-            I   207
E29B-            I   208       _vdu_cls_loop:
E29B-36 20       I   209 (  9)     ld (hl),$20     ; write space char.
E29D-23          I   210 (  4)     inc hl
E29E-71          I   211 (  7)     ld (hl),c       ; set color attribute
E29F-23          I   212 (  4)     inc hl
E2A0-1B          I   213 (  4)     dec de          ; update chars counter
E2A1-7A          I   214 (  4)     ld a,d         ; check if zero
E2A2-B3          I   215 (  4)     or e
E2A3-C2 9B E2    I   216 ( 6+)     jp nz,_vdu_cls_loop
E2A6-            I   217
E2A6-AF          I   218 (  4)     xor a          ; home cursor
E2A7-32 3A E4    I   219 ( 13)     ld (VDU_X),a    ; X=0
E2AA-32 3B E4    I   220 ( 13)     ld (VDU_Y),a    ; Y=0
E2AD-11 00 F0    I   221 (  9)     ld de,VDU_RAM   ; PTR = start of video RAM
E2B0-ED 53 3C E4 I   222 ( 20)     ld (VDU_PTR),de
E2B4-            I   223
E2B4-F1          I   224 (  9)     pop af
E2B5-E1          I   225 (  9)     pop hl
E2B6-D1          I   226 (  9)     pop de
E2B7-            I   227
E2B7-C9          I   228 (  9)     ret
E2B8-            I   229
E2B8-            I   230       ; vdu_scroll
E2B8-            I   231       ; scroll all the screen UP one line
E2B8-            I   232       ; input : none
E2B8-            I   233       ; output : none
E2B8-            I   234       _vdu_scroll_up:
E2B8-F5          I   235 ( 11)     push af
E2B9-E5          I   236 ( 11)     push hl
E2BA-D5          I   237 ( 11)     push de
E2BB-C5          I   238 ( 11)     push bc
E2BC-            I   239
E2BC-21 A0 F0    I   240 (  9)     ld hl,VDU_RAM+160 ; source pointer = start of 2nd line
E2BF-11 00 F0    I   241 (  9)     ld de,VDU_RAM ; destination pointer = start of 1st line
E2C2-01 00 0F    I   242 (  9)     ld bc,4000-160 ; all screen minus one line to move
E2C5-            I   243       _vdu_scroll_loop:
E2C5-ED A0       I   244 ( 12)     ldi     ; scroll the screen
E2C7-EA C5 E2    I   245 ( 6+)     jp pe,_vdu_scroll_loop
E2CA-            I   246                   ; here -> (de) points to the start of 25th line
E2CA-06 50       I   247 (  6)     ld b,80   ; 80 chars to fill on last line
E2CC-3A 39 E4    I   248 ( 12)     ld a,(VDU_ATTR) ; get current color attribute
E2CF-4F          I   249 (  4)     ld c,a
E2D0-            I   250       _vdu_scroll_loop_line25:
E2D0-3E 20       I   251 (  6)     ld a,' '
E2D2-12          I   252 (  7)     ld (de),a ; put a space character
E2D3-13          I   253 (  4)     inc de
E2D4-79          I   254 (  4)     ld a,c
E2D5-12          I   255 (  7)     ld (de),a ; ser the color attribute
E2D6-13          I   256 (  4)     inc de
E2D7-10 F7       I   257 ( 7+)     djnz _vdu_scroll_loop_line25
E2D9-            I   258
E2D9-C1          I   259 (  9)     pop bc
E2DA-D1          I   260 (  9)     pop de
E2DB-E1          I   261 (  9)     pop hl
E2DC-F1          I   262 (  9)     pop af
E2DD-C9          I   263 (  9)     ret
E2DE-            I   264
E2DE-            I   265       ; vdu_putc_term
E2DE-            I   266       ; put a char on the screen, at current location, with current attribute, interpreting special codes :
E2DE-            I   267       ;   VT-52 Terminal ( see http://toshyp.atari.org/en/VT_52_terminal.html )
E2DE-            I   268       ;   NUL - Null - 0x00
E2DE-            I   269       ;   BEL - Bell - 0x07
E2DE-            I   270       ;   BS - Backspace - 0x08
E2DE-            I   271       ;   HT - Tabulator - 0x09
E2DE-            I   272       ;   FF - Form feed - 0x0c
E2DE-            I   273       ;   CR - Carriage return - 0x0d
E2DE-            I   274       ;   LF - Line feed - 0x0a
E2DE-            I   275       ;   ESC A - Cursor up - 0x1b , A
E2DE-            I   276       ;   ESC B - Cursor down - 0x1b , B
E2DE-            I   277       ;   ESC C - Cursor right - 0x1b , C
E2DE-            I   278       ;   ESC D - Cursor left - 0x1b , D
E2DE-            I   279       ;   ESC E - Clear Screen - 0x1b , E
E2DE-            I   280       ;   ESC H - Cursor home - 0x1b , H
E2DE-            I   281       ;   ESC I - Cursor up and insert - 0x1b , I
E2DE-            I   282       ;   ESC J - Clear to end of scren - 0x1b , J
E2DE-            I   283       ;   ESC K - Clear to end of line - 0x1b , K
E2DE-            I   284       ;   ESC L - Insert line - 0x1b , L
E2DE-            I   285       ;   ESC M - Delete line - 0x1b , M
E2DE-            I   286       ;   ESC Y - Set cursor position - 0x1b , Y , ' '+x , ' '+y
E2DE-            I   287       ;   ESC l - Clear line - 0x1b , l
E2DE-            I   288       ;   ESC o - Clear to start of line - 0x1b , o
E2DE-            I   289       ;   ESC d - Clear to start of screen - 0x1b , d
E2DE-            I   290       ;   ESC b - Set text color - 0x1b , b , color
E2DE-            I   291
E2DE-            I   292       ;   ESC k - Restore cursor position - 0x1b , k
E2DE-            I   293       ;   ESC c - Set Background color - 0x1b , c , color
E2DE-            I   294       ;   ESC q - Normal video - 0x1b , q
E2DE-            I   295       ;   ESC p - Reverse video - 0x1b , p
E2DE-            I   296       ;   ESC j - Save cursor position - 0x1b , j
E2DE-            I   297
E2DE-            I   298       ;   ESC w - Wrap off - 0x1b , w
E2DE-            I   299       ;   ESC v - Wrap on - 0x1b , v
E2DE-            I   300       ;   ESC e - Show cursor
E2DE-            I   301       ;   ESC f - Hide cursor
E2DE-            I   302       ;   blink on
E2DE-            I   303       ;   blink off
E2DE-            I   304       ; input : a = char to print
E2DE-            I   305       ; output : none
E2DE-            I   306
E2DE-            I   307       _vdu_putc_term:
E2DE-            I   308
E2DE-            I   309           ;call _asci1_putc
E2DE-            I   310
E2DE-            I   311           ; TMP
E2DE-            I   312           ;push af
E2DE-            I   313           ;push bc
E2DE-            I   314           ;push hl
E2DE-            I   315           ;call _util_byte_to_ascii_hex
E2DE-            I   316           ;ld hl,VDU_RAM+42
E2DE-            I   317           ;ld a,b
E2DE-            I   318           ;ld (hl),a
E2DE-            I   319           ;inc hl
E2DE-            I   320           ;inc hl
E2DE-            I   321           ;ld a,c
E2DE-            I   322           ;ld (hl),a
E2DE-            I   323           ;pop hl
E2DE-            I   324           ;pop bc
E2DE-            I   325           ;pop af
E2DE-            I   326
E2DE-            I   327           ; check if a flag is set in vdu_term_flag
E2DE-E5          I   328 ( 11)     push hl                     ; <---- must be POPed in subprogram
E2DF-21 43 E4    I   329 (  9)     ld hl,vdu_term_flag
E2E2-            I   330
E2E2-CB 4E       I   331 (  9)     bit VDU_TERM_ESC,(hl)       ; check if previous char was ESC
E2E4-20 74       I   332 ( 6+)     jr NZ,_vdu_do_ESC2
E2E6-CB 56       I   333 (  9)     bit VDU_TERM_FCOL,(hl)      ; check if previous chars were ESC+'b'
E2E8-C2 6D E3    I   334 ( 6+)     jp NZ,_vdu_do_set_fcol2
E2EB-            I   335
E2EB-E1          I   336 (  9)     pop hl                      ; pop HL if no flag matched
E2EC-            I   337
E2EC-            I   338           ; non printable chars
E2EC-FE 00       I   339 (  6)     cp $00 ; NUL
E2EE-C8          I   340 ( 5+)     ret Z
E2EF-FE 07       I   341 (  6)     cp $07 ; BEL
E2F1-28 19       I   342 ( 6+)     jr Z,_vdu_do_bell
E2F3-FE 08       I   343 (  6)     cp  $08 ; BS
E2F5-28 19       I   344 ( 6+)     jr Z,_vdu_do_BS
E2F7-FE 0A       I   345 (  6)     cp $0A ; LF
E2F9-28 3D       I   346 ( 6+)     jr Z,_vdu_do_LF
E2FB-FE 0C       I   347 (  6)     cp $0C ; CS
E2FD-CA 8E E2    I   348 ( 6+)     jp Z,_vdu_cls
E300-FE 0D       I   349 (  6)     cp $0D ; CR
E302-28 2A       I   350 ( 6+)     jr Z,_vdu_do_CR
E304-FE 1B       I   351 (  6)     cp $1B ; ESC
E306-28 4A       I   352 ( 6+)     jr Z,_vdu_do_ESC
E308-            I   353
E308-            I   354           ; printable char
E308-CD 84 E3    I   355 ( 16)     call _vdu_putc
E30B-C9          I   356 (  9)     ret
E30C-            I   357
E30C-            I   358       _vdu_do_bell:
E30C-CD FB E7    I   359 ( 16)     call _snd_beep
E30F-C9          I   360 (  9)     ret
E310-            I   361
E310-            I   362       _vdu_do_BS:
E310-F5          I   363 ( 11)     push af
E311-E5          I   364 ( 11)     push hl
E312-            I   365
E312-3A 3A E4    I   366 ( 12)     ld a,(VDU_X)                ; go left if X>0
E315-FE 00       I   367 (  6)     cp 0
E317-CA 2B E3    I   368 ( 6+)     jp z,_vdu_do_BS_exit
E31A-            I   369
E31A-21 46 F0    I   370 (  9)     ld hl,VDU_RAM+70
E31D-36 42       I   371 (  9)     ld (hl),'B'
E31F-            I   372
E31F-3D          I   373 (  4)     dec a
E320-32 3A E4    I   374 ( 13)     ld (VDU_X),a
E323-2A 3C E4    I   375 ( 15)     ld hl,(VDU_PTR)
E326-2B          I   376 (  4)     dec hl
E327-2B          I   377 (  4)     dec hl
E328-22 3C E4    I   378 ( 20)     ld (VDU_PTR),hl
E32B-            I   379
E32B-            I   380       _vdu_do_BS_exit:
E32B-E1          I   381 (  9)     pop hl
E32C-F1          I   382 (  9)     pop af
E32D-C9          I   383 (  9)     ret
E32E-            I   384
E32E-            I   385
E32E-            I   386       _vdu_do_CR:
E32E-F5          I   387 ( 11)     push af
E32F-AF          I   388 (  4)     xor a
E330-32 3A E4    I   389 ( 13)     ld (VDU_X),a
E333-CD E7 E3    I   390 ( 16)     call _vdu_xy_to_ptr
E336-F1          I   391 (  9)     pop af
E337-C9          I   392 (  9)     ret
E338-            I   393
E338-            I   394
E338-            I   395       _vdu_do_LF:
E338-F5          I   396 ( 11)     push af
E339-3A 3B E4    I   397 ( 12)     ld a,(VDU_Y)
E33C-3C          I   398 (  4)     inc a
E33D-32 3B E4    I   399 ( 13)     ld (VDU_Y),a
E340-FE 19       I   400 (  6)     cp 25
E342-C2 4D E3    I   401 ( 6+)     jp nz,_vdu_do_LF_set_ptr
E345-CD B8 E2    I   402 ( 16)     call _vdu_scroll_up
E348-3E 18       I   403 (  6)     ld a,24
E34A-32 3B E4    I   404 ( 13)     ld (VDU_Y),a
E34D-            I   405       _vdu_do_LF_set_ptr:
E34D-CD E7 E3    I   406 ( 16)     call _vdu_xy_to_ptr
E350-F1          I   407 (  9)     pop af
E351-C9          I   408 (  9)     ret
E352-            I   409
E352-            I   410
E352-            I   411       ; ESC key
E352-            I   412       ; set VDU_TERM_ESC flag
E352-            I   413       _vdu_do_ESC:
E352-E5          I   414 ( 11)     push hl
E353-21 43 E4    I   415 (  9)     ld hl,vdu_term_flag
E356-CB CE       I   416 ( 13)     set VDU_TERM_ESC,(hl)
E358-E1          I   417 (  9)     pop hl
E359-C9          I   418 (  9)     ret
E35A-            I   419
E35A-            I   420       ; ESC key 2
E35A-            I   421       ; input : a <- char after ESC
E35A-            I   422       _vdu_do_ESC2:
E35A-            I   423                        ; reset ESC flag
E35A-21 43 E4    I   424 (  9)     ld hl,vdu_term_flag
E35D-CB 8E       I   425 ( 13)     res VDU_TERM_ESC,(hl)
E35F-E1          I   426 (  9)     pop hl                  ; "push hl" was in _vdu_putc_term
E360-            I   427
E360-FE 62       I   428 (  6)     cp 'b'
E362-28 01       I   429 ( 6+)     jr Z,_vdu_do_set_fcol
E364-            I   430
E364-C9          I   431 (  9)     ret
E365-            I   432
E365-            I   433       ; ESC + "b"
E365-            I   434       ; set VDU_TERM_FCOL flag
E365-            I   435       _vdu_do_set_fcol:
E365-E5          I   436 ( 11)     push hl
E366-21 43 E4    I   437 (  9)     ld hl,vdu_term_flag
E369-CB D6       I   438 ( 13)     set VDU_TERM_FCOL,(hl)
E36B-E1          I   439 (  9)     pop hl
E36C-C9          I   440 (  9)     ret
E36D-            I   441
E36D-            I   442       ; ESC + "b" + color
E36D-            I   443       ; reset VDU_TERM_FCOL flag and update foreground color in VDU_ATTR
E36D-            I   444       ; input : a : foreground color code (0-15)
E36D-            I   445       _vdu_do_set_fcol2:
E36D-F5          I   446 ( 11)     push af
E36E-C5          I   447 ( 11)     push bc
E36F-            I   448                       ; reset FCOL flag
E36F-21 43 E4    I   449 (  9)     ld hl,vdu_term_flag
E372-CB 96       I   450 ( 13)     res VDU_TERM_FCOL,(hl)
E374-            I   451
E374-E6 0F       I   452 (  6)     and $0F
E376-47          I   453 (  4)     ld b,a
E377-            I   454
E377-3A 39 E4    I   455 ( 12)     ld a,(VDU_ATTR)
E37A-E6 F0       I   456 (  6)     and $F0
E37C-B0          I   457 (  4)     or b
E37D-32 39 E4    I   458 ( 13)     ld (VDU_ATTR),a
E380-            I   459
E380-C1          I   460 (  9)     pop bc
E381-F1          I   461 (  9)     pop af
E382-            I   462
E382-E1          I   463 (  9)     pop hl ; "push hl" was in _vdu_putc_term
E383-C9          I   464 (  9)     ret
E384-            I   465
E384-            I   466       ; vdu_putc
E384-            I   467       ; put a char on the screen, at current location, with current attribute
E384-            I   468       ; input : a = char to display
E384-            I   469       ; output : none
E384-            I   470       _vdu_putc:
E384-F5          I   471 ( 11)     push af
E385-D5          I   472 ( 11)     push de
E386-            I   473
E386-ED 5B 3C E4 I   474 ( 18)     ld de,(VDU_PTR)
E38A-12          I   475 (  7)     ld (de),a           ; put char in a to current video memory location
E38B-13          I   476 (  4)     inc de              ; go to attribute
E38C-3A 39 E4    I   477 ( 12)     ld a,(VDU_ATTR)     ; fetch attribute from VDU_ATTR
E38F-12          I   478 (  7)     ld (de),a           ; write attribute to video memory
E390-13          I   479 (  4)     inc de              ; go to next char
E391-ED 53 3C E4 I   480 ( 20)     ld (VDU_PTR),de     ; save VDU_PTR
E395-3A 3A E4    I   481 ( 12)     ld a,(VDU_X)        ; get X position
E398-3C          I   482 (  4)     inc a               ; increment
E399-32 3A E4    I   483 ( 13)     ld (VDU_X),a
E39C-FE 50       I   484 (  6)     cp 80              ; next line ?
E39E-20 03       I   485 ( 6+)     jr nz,_vdu_putc_exit
E3A0-CD A6 E3    I   486 ( 16)     call _vdu_next_line
E3A3-            I   487
E3A3-            I   488       _vdu_putc_exit:
E3A3-            I   489
E3A3-D1          I   490 (  9)     pop de
E3A4-F1          I   491 (  9)     pop af
E3A5-C9          I   492 (  9)     ret
E3A6-            I   493
E3A6-            I   494       ; vdu_next_line
E3A6-            I   495       ; set cursor at the beginning of next line. Verticall scroll of the screen if we are at 25th line.
E3A6-            I   496       ; input: none
E3A6-            I   497       ; output: none
E3A6-            I   498       _vdu_next_line:
E3A6-F5          I   499 ( 11)     push af
E3A7-D5          I   500 ( 11)     push de
E3A8-            I   501
E3A8-AF          I   502 (  4)     xor a              ; reset X
E3A9-32 3A E4    I   503 ( 13)     ld (VDU_X),a
E3AC-3A 3B E4    I   504 ( 12)     ld a,(VDU_Y)        ; increment Y
E3AF-3C          I   505 (  4)     inc a
E3B0-32 3B E4    I   506 ( 13)     ld (VDU_Y),a
E3B3-FE 19       I   507 (  6)     cp 25               ; bottom of the screen ?
E3B5-20 0F       I   508 ( 6+)     jr nz,_vdu_next_line_exit
E3B7-CD B8 E2    I   509 ( 16)     call _vdu_scroll_up
E3BA-3E 18       I   510 (  6)     ld a,24             ; set Y to 24
E3BC-32 3B E4    I   511 ( 13)     ld (VDU_Y),a
E3BF-            I   512
E3BF-11 00 FF    I   513 (  9)     ld de,VDU_RAM+3840   ; set de to start of 24th line
E3C2-ED 53 3C E4 I   514 ( 20)     ld (VDU_PTR),de
E3C6-            I   515
E3C6-            I   516       _vdu_next_line_exit:
E3C6-D1          I   517 (  9)     pop de
E3C7-F1          I   518 (  9)     pop af
E3C8-C9          I   519 (  9)     ret
E3C9-            I   520
E3C9-            I   521       ; vdu_puts
E3C9-            I   522       ; display a text on the screen, at current location, with current color attrributes.
E3C9-            I   523       ; input : hl = pointer to a null terminated string
E3C9-            I   524       ; output : none
E3C9-            I   525       _vdu_puts:
E3C9-F5          I   526 ( 11)     push af
E3CA-E5          I   527 ( 11)     push hl
E3CB-            I   528
E3CB-            I   529       _vdu_puts_loop:
E3CB-7E          I   530 (  6)     ld a,(hl)   ; load char fromm string
E3CC-F6 00       I   531 (  6)     or 0
E3CE-28 06       I   532 ( 6+)     jr z,_vdu_puts_exit  ; exit if =0
E3D0-CD 84 E3    I   533 ( 16)     call _vdu_putc
E3D3-23          I   534 (  4)     inc hl  ; next character
E3D4-18 F5       I   535 (  8)     jr _vdu_puts_loop
E3D6-            I   536
E3D6-            I   537       _vdu_puts_exit:
E3D6-E1          I   538 (  9)     pop hl
E3D7-F1          I   539 (  9)     pop af
E3D8-C9          I   540 (  9)     ret
E3D9-            I   541
E3D9-            I   542       ; vdu_locate
E3D9-            I   543       ; set cursor position
E3D9-            I   544       ; input : b=X (0-79), c=Y (0-24)
E3D9-            I   545       ; output : none
E3D9-            I   546       _vdu_locate:
E3D9-F5          I   547 ( 11)     push af
E3DA-78          I   548 (  4)     ld a,b
E3DB-32 3A E4    I   549 ( 13)     ld (VDU_X),a
E3DE-79          I   550 (  4)     ld a,c
E3DF-32 3B E4    I   551 ( 13)     ld (VDU_Y),a
E3E2-CD E7 E3    I   552 ( 16)     call _vdu_xy_to_ptr
E3E5-F1          I   553 (  9)     pop af
E3E6-C9          I   554 (  9)     ret
E3E7-            I   555
E3E7-            I   556       _vdu_xy_to_ptr
E3E7-            I   557
E3E7-F5          I   558 ( 11)     push af
E3E8-E5          I   559 ( 11)     push hl
E3E9-D5          I   560 ( 11)     push de
E3EA-            I   561
E3EA-21 07 E4    I   562 (  9)     ld hl,vdu_line_ptr ; hl = pointer to array of start of line addresses
E3ED-16 00       I   563 (  6)     ld d,0  ; de = Y*2
E3EF-3A 3B E4    I   564 ( 12)     ld a,(VDU_Y)
E3F2-87          I   565 (  4)     add a,a
E3F3-5F          I   566 (  4)     ld e,a
E3F4-19          I   567 (  7)     add hl,de ; hl = pointer to start of line
E3F5-            I   568
E3F5-5E          I   569 (  6)     ld e,(hl)  ; de = (hl) = start of line address
E3F6-23          I   570 (  4)     inc hl
E3F7-56          I   571 (  6)     ld d,(hl)
E3F8-            I   572
E3F8-26 00       I   573 (  6)      ld h,0 ; hl=X*2
E3FA-3A 3A E4    I   574 ( 12)      ld a,(VDU_X)
E3FD-87          I   575 (  4)      add a,a
E3FE-6F          I   576 (  4)      ld l,a
E3FF-19          I   577 (  7)     add hl,de ; hl = start of line address + X*2
E400-            I   578
E400-            I   579
E400-22 3C E4    I   580 ( 20)     ld (VDU_PTR),hl ; save PTR
E403-            I   581
E403-D1          I   582 (  9)     pop de
E404-E1          I   583 (  9)     pop hl
E405-F1          I   584 (  9)     pop af
E406-C9          I   585 (  9)     ret
E407-            I   586
E407-            I   587       ; VDU DATA
E407-00 F0 A0 F0 
     40 F1 E0 F1 
     80 F2 20 F3 
     C0 F3 60 F4 
     00 F5 A0 F5 
     40 F6 E0 F6 I   588       vdu_line_ptr    .dw     $F000,$F0A0,$F140,$F1E0,$F280,$F320,$F3C0,$F460,$F500,$F5A0,$F640,$F6E0
E41F-80 F7 20 F8 
     C0 F8 60 F9 
     00 FA A0 FA 
     40 FB E0 FB 
     80 FC 20 FD 
     C0 FD 60 FE 
     00 FF       I   589                       .dw     $F780,$F820,$F8C0,$F960,$FA00,$FAA0,$FB40,$FBE0,$FC80,$FD20,$FDC0,$FE60,$FF00
E439-            I   590
E439-            I   591
E439-            I   592       ; RAM
E439-            I   593
E439-            I   594
E439-            I   595       VDU_ATTR            .bs 1   ; Color Attribute
E43A-            I   596       VDU_X               .bs 1   ; Current X position
E43B-            I   597       VDU_Y               .bs 1   ; Current Y position
E43C-            I   598       VDU_PTR             .bs 2     ; Current position in video RAM, should always be equal to
E43E-            I   599                               ; VDU_RAM + X*2 + Y*160
E43E-            I   600       vdu_cursor_ptr          .bs 2
E440-            I   601       vdu_cursor_blink      .bs 1
E441-            I   602       vdu_cursor_status     .bs 1
E442-            I   603       vdu_cursor_save_attr    .bs 1
E443-            I   604
0001-            I   605       VDU_TERM_ESC   .equ 1
0002-            I   606       VDU_TERM_FCOL .equ 2
0003-            I   607       VDU_TERM_BCOL .equ 3
E443-            I   608
E443-            I   609       vdu_term_flag   .bs 1
E444-                 63           .include bios_kbd.asm
E444-            I     1       ; KBD
E444-            I     2       ; ----------------------------------------------------------------------------
E444-            I     3
0080-            I     4       KBD_DATA    .equ $80
0081-            I     5       KBD_STATUS  .equ $81
E444-            I     6
E444-            I     7       ; bit 0 : shift
E444-            I     8       ; bit 1 : alt
E444-            I     9       ; bit 2 : caps lock
0000-            I    10       KBD_STATE_SHIFT .equ 0
0001-            I    11       KBD_STATE_ALT .equ 1
0002-            I    12       KBD_STATE_CAPS .equ 2
0003-            I    13       KBD_STATE_F0   .equ 3
0004-            I    14       KBD_STATE_E0  .equ 4
0005-            I    15       KBD_STATE_CTRL .equ 5
E444-            I    16
0004-            I    17       KBD_XOR_CAPS .equ 4
E444-            I    18
E444-            I    19
E444-            I    20       _kbd_init:
E444-            I    21           ; enable INT1
E444-ED 38 34    I    22 ( 12)     in0 a,(ITC)
E447-F6 02       I    23 (  6)     or ITC_ITE1
E449-ED 39 34    I    24 ( 13)     out0 (ITC),a
E44C-            I    25
E44C-            I    26           ; init keyboad variables
E44C-AF          I    27 (  4)     xor a
E44D-32 86 E7    I    28 ( 13)     ld (kbd_buffer_pos),a
E450-32 85 E7    I    29 ( 13)     ld (kbd_state),a
E453-            I    30
E453-C9          I    31 (  9)     ret
E454-            I    32
E454-            I    33       _int_kbd:
E454-F5          I    34 ( 11)     push af
E455-D9          I    35 (  3)     exx
E456-            I    36
E456-ED 38 80    I    37 ( 12)     in0 a,(KBD_DATA)            ; read scancode
E459-47          I    38 (  4)     ld b,a                      ; stored in B register
E45A-            I    39
E45A-            I    40       _int_kbd_test_F0:
E45A-FE F0       I    41 (  6)     cp $F0                      ; F0 = release key
E45C-C2 67 E4    I    42 ( 6+)     jp NZ,_int_kbd_test_E0
E45F-            I    43
E45F-21 85 E7    I    44 (  9)     ld hl,kbd_state             ; set F0 flag in kbd_state
E462-CB DE       I    45 ( 13)     set KBD_STATE_F0,(hl)
E464-C3 42 E5    I    46 (  9)     jp _int_kbd_exit
E467-            I    47
E467-            I    48       _int_kbd_test_E0:
E467-FE E0       I    49 (  6)     cp $E0                      ; E0 = extended scancodes
E469-C2 74 E4    I    50 ( 6+)     jp NZ,_int_kbd_check_state
E46C-            I    51
E46C-21 85 E7    I    52 (  9)     ld hl,kbd_state             ; set E0 flag in kbd_state
E46F-CB E6       I    53 ( 13)     set KBD_STATE_E0,(hl)
E471-C3 42 E5    I    54 (  9)     jp _int_kbd_exit
E474-            I    55
E474-            I    56       _int_kbd_check_state:
E474-3A 85 E7    I    57 ( 12)     ld a,(kbd_state)
E477-            I    58
E477-CB 5F       I    59 (  6)     bit KBD_STATE_F0,a          ; if previous scancode was F0, jumps to F0 routine
E479-C2 19 E5    I    60 ( 6+)     jp NZ,_int_kbd_F0            ; (release key)
E47C-            I    61
E47C-CB 67       I    62 (  6)     bit KBD_STATE_E0,a          ; if previous scancode was E0, jumps to E0 routinr
E47E-C2 12 E5    I    63 ( 6+)     jp NZ,_int_kbd_E0            ; (extended scancode)
E481-            I    64
E481-            I    65       _int_kbd_shift:                  ; manage SHIFT key
E481-78          I    66 (  4)     ld a,b
E482-FE 12       I    67 (  6)     cp $12 ; lshift
E484-CA 8C E4    I    68 ( 6+)     jp Z,_int_kbd_is_shift
E487-FE 59       I    69 (  6)     cp $59 ; rshift
E489-C2 94 E4    I    70 ( 6+)     jp NZ,_int_kbd_alt
E48C-            I    71
E48C-            I    72       _int_kbd_is_shift:
E48C-21 85 E7    I    73 (  9)     ld hl,kbd_state             ; set SHIFT flag in kbd_state
E48F-CB C6       I    74 ( 13)     set KBD_STATE_SHIFT,(hl)
E491-C3 42 E5    I    75 (  9)     jp _int_kbd_exit
E494-            I    76
E494-            I    77       _int_kbd_alt:                    ; manage ALT key
E494-FE 11       I    78 (  6)     cp $11
E496-C2 A1 E4    I    79 ( 6+)     jp NZ,_int_kbd_ctrl
E499-            I    80
E499-21 85 E7    I    81 (  9)     ld hl,kbd_state             ; set ALT flag in kbd_state
E49C-CB CE       I    82 ( 13)     set KBD_STATE_ALT,(hl)
E49E-C3 42 E5    I    83 (  9)     jp _int_kbd_exit
E4A1-            I    84
E4A1-            I    85       _int_kbd_ctrl:                  ; manage CTRL KEY
E4A1-FE 14       I    86 (  6)     cp $14
E4A3-C2 AB E4    I    87 ( 6+)     jp NZ,_int_kbd_capslock
E4A6-CB EE       I    88 ( 13)     set KBD_STATE_CTRL,(hl)
E4A8-C3 42 E5    I    89 (  9)     jp _int_kbd_exit
E4AB-            I    90
E4AB-            I    91       _int_kbd_capslock:                ; manage CAPS LOCK key
E4AB-FE 58       I    92 (  6)     cp $58
E4AD-C2 BA E4    I    93 ( 6+)     jp NZ,_int_kbd_get_key
E4B0-            I    94
E4B0-21 85 E7    I    95 (  9)     ld hl,kbd_state
E4B3-7E          I    96 (  6)     ld a,(hl)                   ; toggle CAPS LOCK flag in kbd_stte
E4B4-EE 04       I    97 (  6)     xor KBD_XOR_CAPS
E4B6-77          I    98 (  7)     ld (hl),a
E4B7-C3 42 E5    I    99 (  9)     jp _int_kbd_exit
E4BA-            I   100
E4BA-            I   101       _int_kbd_get_key:
E4BA-16 00       I   102 (  6)     ld d,0                      ; hl <- kbd_buffer+(kbd_buffer_pos)
E4BC-3A 86 E7    I   103 ( 12)     ld a,(kbd_buffer_pos)
E4BF-5F          I   104 (  4)     ld e,a
E4C0-21 87 E7    I   105 (  9)     ld hl,kbd_buffer
E4C3-19          I   106 (  7)     add hl,de
E4C4-E5          I   107 ( 11)     push hl                     ; save current buffer pointer on stack (1)
E4C5-            I   108
E4C5-2A 85 E7    I   109 ( 15)     ld hl,(kbd_state)
E4C8-            I   110
E4C8-            I   111       _int_kbd_get_key_caps:
E4C8-3E 01       I   112 (  6)     ld  a,1                    ; a==1 -> lowercase , a==0 -> shift
E4CA-            I   113
E4CA-CB 56       I   114 (  9)     bit KBD_STATE_CAPS,(hl)
E4CC-CA D1 E4    I   115 ( 6+)     jp Z,_int_kbd_get_key_shift
E4CF-EE 01       I   116 (  6)     xor 1                      ; a<-0 (shift)
E4D1-            I   117
E4D1-            I   118       _int_kbd_get_key_shift:
E4D1-CB 46       I   119 (  9)     bit KBD_STATE_SHIFT,(hl)
E4D3-CA D8 E4    I   120 ( 6+)     jp Z,_int_kbd_get_key_set_shift
E4D6-EE 01       I   121 (  6)     xor 1                       ; flip a
E4D8-            I   122
E4D8-            I   123       _int_kbd_get_key_set_shift:
E4D8-21 FC E5    I   124 (  9)     ld hl,scan_codes_shift
E4DB-EE 01       I   125 (  6)     xor 1
E4DD-CA F0 E4    I   126 ( 6+)     jp Z,_int_kbd_get_key_scancode
E4E0-            I   127
E4E0-21 85 E7    I   128 (  9)     ld hl,kbd_state
E4E3-CB 4E       I   129 (  9)     bit KBD_STATE_ALT,(hl)      ; use ALT scancode set if ALT flag==1
E4E5-CA ED E4    I   130 ( 6+)     jp Z,_int_kbd_get_key_set_lowcase
E4E8-21 7F E6    I   131 (  9)     ld hl,scan_codes_alt
E4EB-18 03       I   132 (  8)     jr _int_kbd_get_key_scancode
E4ED-            I   133
E4ED-            I   134       _int_kbd_get_key_set_lowcase:
E4ED-21 79 E5    I   135 (  9)     ld hl,scan_codes
E4F0-            I   136
E4F0-            I   137       _int_kbd_get_key_scancode:
E4F0-78          I   138 (  4)     ld a,b
E4F1-CD 6F E5    I   139 ( 16)     call _kbd_decode_scancode
E4F4-E1          I   140 (  9)     pop hl                      ; get back current buffer pointer (see 1)
E4F5-            I   141
E4F5-FE 00       I   142 (  6)     cp 0                        ; do nothing if no code found
E4F7-CA 42 E5    I   143 ( 6+)     jp Z,_int_kbd_exit
E4FA-            I   144
E4FA-77          I   145 (  7)     ld (hl),a                   ; save it to  kbd_buffer+(kbd_buffer_pos)
E4FB-            I   146
E4FB-FE 0A       I   147 (  6)     cp 10                       ; insert CR if ASCII code == LF (10)
E4FD-C2 09 E5    I   148 ( 6+)     jp NZ,_kbd_int_incr_buffer_pos
E500-23          I   149 (  4)     inc hl
E501-3E 0D       I   150 (  6)     ld a,13
E503-77          I   151 (  7)     ld (hl),a
E504-7B          I   152 (  4)     ld a,e
E505-3C          I   153 (  4)     inc a
E506-32 86 E7    I   154 ( 13)     ld (kbd_buffer_pos),a
E509-            I   155
E509-            I   156       _kbd_int_incr_buffer_pos:
E509-3A 86 E7    I   157 ( 12)     ld a,(kbd_buffer_pos)               ; inc kbd_buffer_pos
E50C-3C          I   158 (  4)     inc a
E50D-32 86 E7    I   159 ( 13)     ld (kbd_buffer_pos),a
E510-18 30       I   160 (  8)     jr _int_kbd_exit
E512-            I   161
E512-            I   162       _int_kbd_E0:
E512-21 85 E7    I   163 (  9)     ld hl,kbd_state                     ; clear E0 flag in kbd_state
E515-CB A6       I   164 ( 13)     res KBD_STATE_E0,(hl)
E517-18 29       I   165 (  8)     jr _int_kbd_exit
E519-            I   166
E519-            I   167       _int_kbd_F0:
E519-21 85 E7    I   168 (  9)    ld hl,kbd_state                      ; clear F0 flag in kbd_state
E51C-CB 9E       I   169 ( 13)    res KBD_STATE_F0,(hl)
E51E-            I   170
E51E-78          I   171 (  4)    ld a,b                               ; clear SHIFT flag if key was LSHIFT
E51F-FE 12       I   172 (  6)    cp $12 ; LSHIFT
E521-C2 28 E5    I   173 ( 6+)    jp NZ,_int_kbd_F0_rshift
E524-CB 86       I   174 ( 13)    res KBD_STATE_SHIFT,(hl)
E526-18 1A       I   175 (  8)    jr _int_kbd_exit
E528-            I   176
E528-            I   177       _int_kbd_F0_rshift:                      ; clear SHIFT flag if key was RSHIFT
E528-FE 59       I   178 (  6)    cp $59 ; RSHIFT
E52A-C2 31 E5    I   179 ( 6+)    jp NZ,_int_kbd_F0_alt
E52D-CB 86       I   180 ( 13)    res KBD_STATE_SHIFT,(hl)
E52F-18 11       I   181 (  8)    jr _int_kbd_exit
E531-            I   182
E531-            I   183       _int_kbd_F0_alt:                         ; clear ALT flag if key was ALT
E531-FE 11       I   184 (  6)    cp $11 ; ALT
E533-C2 3B E5    I   185 ( 6+)    jp NZ,_int_kbd_F0_ctrl
E536-CB 8E       I   186 ( 13)    res KBD_STATE_ALT,(hl)
E538-C3 42 E5    I   187 (  9)    jp _int_kbd_exit
E53B-            I   188
E53B-            I   189       _int_kbd_F0_ctrl:                       ; clear CTRL flag if key was LCTRL
E53B-FE 14       I   190 (  6)     cp $14 ; LCTRL
E53D-C2 42 E5    I   191 ( 6+)     jp NZ,_int_kbd_exit
E540-CB AE       I   192 ( 13)     res KBD_STATE_CTRL,(hl)
E542-            I   193
E542-            I   194       _int_kbd_exit:
E542-D9          I   195 (  3)     exx                         ; end of keyboard interrupt routine.
E543-F1          I   196 (  9)     pop af
E544-FB          I   197 (  3)     ei
E545-C9          I   198 (  9)     ret
E546-            I   199
E546-            I   200       ; check if kbd buffer is empty
E546-            I   201       ; input : NONE
E546-            I   202       ; output : flag=Z if empty
E546-            I   203       _kbd_is_empty:
E546-3A 86 E7    I   204 ( 12)     ld a,(kbd_buffer_pos)
E549-FE 00       I   205 (  6)     cp 0
E54B-C9          I   206 (  9)     ret
E54C-            I   207
E54C-            I   208       ; Get next key in buffer
E54C-            I   209       _kbd_get_key:
E54C-D5          I   210 ( 11)     push de
E54D-E5          I   211 ( 11)     push hl
E54E-            I   212
E54E-3A 86 E7    I   213 ( 12)      ld a,(kbd_buffer_pos)
E551-            I   214
E551-FE 00       I   215 (  6)      cp 0                       ; exit value=0 if no key in buffer
E553-28 0C       I   216 ( 6+)      jr Z,_kbd_get_key_exit
E555-            I   217
E555-3D          I   218 (  4)      dec a
E556-32 86 E7    I   219 ( 13)      ld (kbd_buffer_pos),a
E559-16 00       I   220 (  6)      ld d,0
E55B-5F          I   221 (  4)      ld e,a
E55C-21 87 E7    I   222 (  9)      ld hl,kbd_buffer
E55F-19          I   223 (  7)      add hl,de
E560-7E          I   224 (  6)      ld a,(hl)
E561-            I   225
E561-            I   226       _kbd_get_key_exit:
E561-E1          I   227 (  9)     pop hl
E562-D1          I   228 (  9)     pop de
E563-C9          I   229 (  9)     ret
E564-            I   230
E564-            I   231       ; wait for and get a key
E564-            I   232       _kbd_wait_get_key:
E564-3A 86 E7    I   233 ( 12)     ld a,(kbd_buffer_pos)
E567-FE 00       I   234 (  6)     cp 0
E569-28 F9       I   235 ( 6+)     jr z,_kbd_wait_get_key
E56B-CD 4C E5    I   236 ( 16)     call _kbd_get_key
E56E-C9          I   237 (  9)     ret
E56F-            I   238
E56F-            I   239       ; input : a = scan code, hl = pointer to scan code table
E56F-            I   240       ; output : a = decoded scan code
E56F-            I   241       _kbd_decode_scancode:
E56F-D5          I   242 ( 11)     push de
E570-E5          I   243 ( 11)     push hl
E571-            I   244
E571-16 00       I   245 (  6)     ld d,0
E573-5F          I   246 (  4)     ld e,a
E574-19          I   247 (  7)     add hl,de
E575-7E          I   248 (  6)     ld a,(hl)
E576-            I   249
E576-E1          I   250 (  9)     pop hl
E577-D1          I   251 (  9)     pop de
E578-C9          I   252 (  9)     ret
E579-            I   253
E579-            I   254       scan_codes:
E579-            I   255           ; 00-0F : n/a F9 n/a F5 F3 F1 F2 F12 n/a F10 F8 F6 F4 TAB ² n/a
E579-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     09 C2 B2 00 I   256           .db 0,0,0,0,0,0,0,0,0,0,0,0,9,'²',0
E589-            I   257           ; 10-1F : n/a n/a LSHIFT n/a n/a a & n/a n/a n/a n/a w s q z é n/a
E589-00 00 00 00 
     00 61 26 00 
     00 00 77 73 
     71 7A 82 00 I   258           .db 0,0,0,0,0,'a','&',0,0,0,'w','s','q','z',130,0
E599-            I   259           ; 20-2F : n/a c x d e ' " n/a n/a SPACE v f t r ( n/a
E599-00 63 78 64 
     65 27 22 00 
     00 20 76 66 
     74 72 28 00 I   260           .db 0,'c','x','d','e',39,34,0,0,' ','v','f','t','r','(',0
E5A9-            I   261           ; 30-3F : n/a n b h g y - n/a n/a n/a , j u è _ n/a
E5A9-00 6E 62 68 
     67 79 2D 00 
     00 00 2C 6A 
     75 8A 5F 00 I   262           .db 0,'n','b','h','g','y','-',0,0,0,',','j','u',138,'_',0
E5B9-            I   263           ; 40-4F : n/a ; k i o à ç n/a n/a : ! l m p ) n/a
E5B9-00 3B 6B 69 
     6F 85 87 00 
     00 3A 21 6C 
     6D 70 29 00 I   264           .db 0,59,'k','i','o',133,135,0,0,':','!','l','m','p',')',0
E5C9-            I   265           ; 50-5F : n/a n/a ù n/a ^ = n/a n/a CAPS RSHIFT RETURN $ n/a * n/a n/a
E5C9-00 00 97 00 
     5E 3D 00 00 
     00 00 0A 24 
     00 2A 00 00 I   266           .db 0,0,151,0,'^','=',0,0,0,0,10,'$',0,'*',0,0
E5D9-            I   267           ; 60-6F : n/a < n/a n/a n/a n/a BACKSPACE n/a n/a PAD_1 n/a PAD_4 PAD_7 n/a n/a n/a
E5D9-00 3C 00 00 
     00 00 08 00 
     00 31 00 34 
     37 00 00 00 I   268           .db 0,'<',0,0,0,0,8,0,0,'1',0,'4','7',0,0,0
E5E9-            I   269           ; 70-7F : PAD_0 PAD_, PAD_2 PAD_5 PAD_6 PAD_8 ESC P_VERNUM F11 PAD_+ PAD_3 PAD_- PAD_* PAD_9 ARRET_DEFIL
E5E9-30 2C 32 35 
     36 38 1B 00 
     00 2B 33 2D 
     2A 39 00    I   270           .db '0',',','2','5','6','8',27,0,0,'+','3','-','*','9',0
E5F8-            I   271           ; 80-83 : n/a n/a n/a F7
E5F8-00 00 00 00 I   272           .db 0,0,0,0
E5FC-            I   273
E5FC-            I   274       scan_codes_shift:
E5FC-            I   275           ; 00-0F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a TAB n/a n/a
E5FC-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 09 00 00 I   276           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0
E60C-            I   277           ; 10-1F : n/a n/a n/a n/a n/a A 1 n/a n/a n/a n/a W S Q Z 2 n/a
E60C-00 00 00 00 
     00 41 31 00 
     00 00 57 53 
     51 5A 32 00 I   278           .db 0,0,0,0,0,'A','1',0,0,0,'W','S','Q','Z','2',0
E61C-            I   279           ; 20-2F : n/a C X D E 4 3 n/a n/a SPACE V F T R 5 n/a
E61C-00 43 58 44 
     45 34 33 00 
     00 20 56 46 
     54 52 35 00 I   280           .db 0,'C','X','D','E','4','3',0,0,' ','V','F','T','R','5',0
E62C-            I   281           ; 30-3F : n/a N B H G Y 6 n/a n/a n/a ? J U 7 8 n/a
E62C-00 4E 42 48 
     47 59 36 00 
     00 00 3F 4A 
     55 37 38 00 I   282           .db 0,'N','B','H','G','Y','6',0,0,0,'?','J','U','7','8',0
E63C-            I   283           ; 40-4F : n/a . K I O 0 9 n/a n/a / § L M P ° n/a
E63C-00 2E 4B 49 
     4F 30 39 00 
     00 2F 9E 4C 
     4D 50 A7 00 I   284           .db 0,'.','K','I','O','0','9',0,0,'/',158,'L','M','P',167,0
E64C-            I   285           ; 50-5F : n/a n/a % n/a ¨ + n/a n/a CAPS RSHIFT RETURN £ n/a µ n/a n/a
E64C-00 00 25 00 
     7E 2B 00 00 
     00 00 0A 9C 
     00 E6 00 00 I   286           .db 0,0,'%',0,126,'+',0,0,0,0,10,156,0,230,0,0
E65C-            I   287           ; 60-6F : n/a > n/a n/a n/a n/a BACKSPACE n/a n/a PAD_1 n/a PAD_4 PAD_7 n/a n/a n/a
E65C-00 3E 00 00 
     00 00 08 00 
     00 31 00 34 
     37 00 00 00 I   288           .db 0,'>',0,0,0,0,8,0,0,'1',0,'4','7',0,0,0
E66C-            I   289           ; 70-7F : PAD_0 PAD_, PAD_2 PAD_5 PAD_6 PAD_8 ESC P_VERNUM F11 PAD_+ PAD_3 PAD_- PAD_* PAD_9 ARRET_DEFIL
E66C-30 2C 32 35 
     36 38 1B 00 
     00 2B 33 2D 
     2A 39 00    I   290           .db '0',',','2','5','6','8',27,0,0,'+','3','-','*','9',0
E67B-            I   291           ; 80-83 : n/a n/a n/a F7
E67B-00 00 00 00 I   292           .db 0,0,0,0
E67F-            I   293
E67F-            I   294       scan_codes_alt:
E67F-            I   295           ; 00-0F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
E67F-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 I   296           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E68F-            I   297           ; 10-1F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a ~ n/a
E68F-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 7E 00 I   298           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,'~',0
E69F-            I   299           ; 20-2F : n/a n/a n/a n/a n/a { # n/a n/a SPACE n/a n/a n/a n/a [ n/a
E69F-00 00 00 00 
     00 7B 23 00 
     00 20 00 00 
     00 00 5B 00 I   300           .db 0,0,0,0,0,'{','#',0,0,' ',0,0,0,0,'[',0
E6AF-            I   301           ; 30-3F : n/a n/a n/a n/a n/a n/a | n/a n/a n/a n/a n/a n/a ` \ n/a
E6AF-00 00 00 00 
     00 00 7C 00 
     00 00 00 00 
     00 60 5C 00 I   302           .db 0,0,0,0,0,0,'|',0,0,0,0,0,0,'`',92,0
E6BF-            I   303           ; 40-4F : n/a n/a n/a n/a n/a @ ^ n/a n/a n/a n/a n/a n/a n/a ] n/a
E6BF-00 00 00 00 
     00 40 5E 00 
     00 00 00 00 
     00 00 5D 00 I   304           .db 0,0,0,0,0,'@','^',0,0,0,0,0,0,0,']',0
E6CF-            I   305           ; 50-5F : n/a n/a n/a n/a n/a } n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
E6CF-00 00 00 00 
     00 7D 00 00 
     00 00 00 00 
     00 00 00 00 I   306           .db 0,0,0,0,0,'}',0,0,0,0,0,0,0,0,0,0
E6DF-            I   307           ; 60-6F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
E6DF-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 I   308           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E6EF-            I   309           ; 70-7F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
E6EF-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 I   310           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E6FF-            I   311           ; 80-83 : n/a n/a n/a F7
E6FF-00 00 00 00 I   312           .db 0,0,0,0
E703-            I   313
E703-            I   314       scan_codes_ctrl:
E703-            I   315           ; 00-0F : n/a F9 n/a F5 F3 F1 F2 F12 n/a F10 F8 F6 F4 TAB ² n/a
E703-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00    I   316           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E712-            I   317           ; 10-1F : n/a n/a LSHIFT n/a n/a a & n/a n/a n/a n/a w s q z é n/a
E712-00 00 00 00 
     00 01 00 00 
     00 00 17 13 
     11 1A 00 00 I   318           .db 0,0,0,0,0,1,0,0,0,0,23,19,17,26,0,0
E722-            I   319           ; 20-2F : n/a c x d e ' " n/a n/a SPACE v f t r ( n/a
E722-00 03 18 04 
     05 00 00 00 
     00 00 16 06 
     14 12 00 00 I   320           .db 0,3,24,4,5,0,0,0,0,0,22,6,20,18,0,0
E732-            I   321           ; 30-3F : n/a n b h g y - n/a n/a n/a , j u è _ n/a
E732-00 0E 02 08 
     07 19 00 00 
     00 00 00 0A 
     15 00 00 00 I   322           .db 0,14,2,8,7,25,0,0,0,0,0,10,21,0,0,0
E742-            I   323           ; 40-4F : n/a ; k i o à ç n/a n/a : ! l m p ) n/a
E742-00 00 0B 09 
     0F 00 00 00 
     00 00 00 0C 
     0D 10 00 00 I   324           .db 0,0,11,9,15,0,0,0,0,0,0,12,13,16,0,0
E752-            I   325           ; 50-5F : n/a n/a ù n/a ^ = n/a n/a CAPS RSHIFT RETURN $ n/a * n/a n/a
E752-00 00 00 00 
     00 00 00 00 
     00 00 0A 00 
     00 00 00 00 I   326           .db 0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0
E762-            I   327           ; 60-6F : n/a < n/a n/a n/a n/a BACKSPACE n/a n/a PAD_1 n/a PAD_4 PAD_7 n/a n/a n/a
E762-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 I   328           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E772-            I   329           ; 70-7F : PAD_0 PAD_, PAD_2 PAD_5 PAD_6 PAD_8 ESC P_VERNUM F11 PAD_+ PAD_3 PAD_- PAD_* PAD_9 ARRET_DEFIL
E772-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00    I   330           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E781-            I   331           ; 80-83 : n/a n/a n/a F7
E781-00 00 00 00 I   332           .db 0,0,0,0
E785-            I   333
E785-            I   334
E785-            I   335            ; RAM
E785-            I   336       kbd_state: .bs 1
E786-            I   337       kbd_buffer_pos:    .bs 1
E787-            I   338       kbd_buffer: .bs 64
E7C7-                 64           .include bios_snd.asm
E7C7-            I     1       ; SND
E7C7-            I     2       ; ----------------------------------------------------------------------------
E7C7-            I     3
0082-            I     4       SND_REG       .equ $82
E7C7-            I     5
E7C7-            I     6       _snd_init:
E7C7-            I     7
E7C7-            I     8           ; init sound variables
E7C7-AF          I     9 (  4)     xor a
E7C8-32 1E E8    I    10 ( 13)     ld (snd_value),a
E7CB-32 1C E8    I    11 ( 13)     ld (snd_length),a
E7CE-32 1D E8    I    12 ( 13)     ld (snd_length+1),a
E7D1-C9          I    13 (  9)     ret
E7D2-            I    14
E7D2-            I    15       _int_snd:
E7D2-F5          I    16 ( 11)     push af
E7D3-D5          I    17 ( 11)     push de
E7D4-            I    18
E7D4-ED 38 10    I    19 ( 12)     in0 a,(TCR)         ; clear TIFE0
E7D7-ED 38 14    I    20 ( 12)     in0 a,(TMDR1L)
E7DA-            I    21
E7DA-ED 5B 1C E8 I    22 ( 18)     ld de,(snd_length)
E7DE-7A          I    23 (  4)     ld a,d
E7DF-B3          I    24 (  4)     or e
E7E0-20 00       I    25 ( 6+)     jr NZ,_int_snd_pitch
E7E2-            I    26
E7E2-            I    27            ; disable PRT1 interrupt
E7E2-            I    28           ;in0 a,(TCR)
E7E2-            I    29           ;and  $FF!TCR_TIE1!TCR_TDE1
E7E2-            I    30           ;out0 (TCR),a
E7E2-            I    31
E7E2-            I    32       _int_snd_pitch:
E7E2-1B          I    33 (  4)     dec de
E7E3-ED 53 1C E8 I    34 ( 20)     ld (snd_length),de
E7E7-            I    35
E7E7-3A 1E E8    I    36 ( 12)     ld a,(snd_value)
E7EA-EE FF       I    37 (  6)     xor 255
E7EC-32 1E E8    I    38 ( 13)     ld (snd_value),a
E7EF-D3 82       I    39 ( 10)     out (SND_REG),a
E7F1-            I    40
E7F1-3E 58       I    41 (  6)     ld a,'X' ; TMP !!
E7F3-11 00 F0    I    42 (  9)     ld de,$F000 ; TMP !!
E7F6-12          I    43 (  7)     ld (de),a : ; TMP !!
E7F7-            I    44
E7F7-D1          I    45 (  9)     pop de
E7F8-F1          I    46 (  9)     pop af
E7F9-FB          I    47 (  3)     ei
E7FA-C9          I    48 (  9)     ret
E7FB-            I    49
E7FB-            I    50
E7FB-            I    51       _snd_beep:
E7FB-C9          I    52 (  9)     ret
E7FC-F5          I    53 ( 11)     push af
E7FD-E5          I    54 ( 11)     push hl
E7FE-            I    55
E7FE-3E C8       I    56 (  6)     ld a,200
E800-32 1D E8    I    57 ( 13)     ld (snd_length+1),a
E803-3E C8       I    58 (  6)     ld a,200
E805-32 1C E8    I    59 ( 13)     ld (snd_length),a
E808-            I    60
E808-            I    61           ; set PRT1 interrupt speed
E808-21 8D 03    I    62 (  9)     ld hl,$038D
E80B-ED 21 17    I    63 ( 13)     out0 (RLDR1H),h
E80E-ED 29 16    I    64 ( 13)     out0 (RLDR1L),l
E811-            I    65
E811-            I    66           ; enable PRT1 interrupt
E811-ED 38 10    I    67 ( 12)     in0 a,(TCR)
E814-F6 22       I    68 (  6)     or TCR_TIE1|TCR_TDE1
E816-ED 39 10    I    69 ( 13)     out0 (TCR),a
E819-            I    70
E819-E1          I    71 (  9)     pop hl
E81A-F1          I    72 (  9)     pop af
E81B-C9          I    73 (  9)     ret
E81C-            I    74
E81C-            I    75
E81C-            I    76       ; RAM
E81C-            I    77
E81C-            I    78       snd_length  .bs 2
E81E-            I    79       snd_value   .bs 1
E81F-                 65
E81F-                 66           .include bios_util.asm
E81F-            I     1       ; UTIL
E81F-            I     2       ; ----------------------------------------------------------------------------
E81F-            I     3
E81F-            I     4       ; convert a byte to ASCII hex
E81F-            I     5       ; input : a = number to conver
E81F-            I     6       ; output : bc = 2 ascii bytes
E81F-            I     7       _util_byte_to_ascii_hex:
E81F-F5          I     8 ( 11)     push af
E820-            I     9
E820-47          I    10 (  4)     ld b,a
E821-E6 0F       I    11 (  6)     and $0F                     ; get lower 4 bits
E823-            I    12
E823-C6 30       I    13 (  6)     add '0'                        ; convert to ascii hex
E825-FE 3A       I    14 (  6)     cp ':'
E827-DA 2C E8    I    15 ( 6+)     jp C,_util_btah_1_AF
E82A-C6 07       I    16 (  6)     add 'A'-':'
E82C-            I    17       _util_btah_1_AF:
E82C-            I    18
E82C-4F          I    19 (  4)     ld c,a                  ; c <- ascii hex of lower 4 bits
E82D-            I    20
E82D-78          I    21 (  4)     ld a,b              ; get upper 4 bits
E82E-0F          I    22 (  3)     rrca
E82F-0F          I    23 (  3)     rrca
E830-0F          I    24 (  3)     rrca
E831-0F          I    25 (  3)     rrca
E832-E6 0F       I    26 (  6)     and $0F
E834-            I    27
E834-C6 30       I    28 (  6)     add '0'                   ; convert to ascii hex
E836-FE 3A       I    29 (  6)     cp ':'
E838-DA 3D E8    I    30 ( 6+)     jp C,_util_btah_2_AF
E83B-C6 07       I    31 (  6)     add 'A'-':'
E83D-            I    32       _util_btah_2_af:
E83D-            I    33
E83D-47          I    34 (  4)     ld b,a              ; b <- asci hex of upper 4 bits
E83E-            I    35
E83E-F1          I    36 (  9)     pop af
E83F-C9          I    37 (  9)     ret
