0000-                  6           .SF bios.sym
0000-                  7
0000-                  8           .include ../../include/z180_defs.asm
0000-            I     1       ; ------------------------------------
0000-            I     2       ; Z180 constants
0000-            I     3       ; ------------------------------------
0000-            I     4
0000-            I     5       ; ASCI
0000-            I     6       ; ----------
0000-            I     7
0000-            I     8       ; ASCI Control Register A 0 (CNTLA0: 00H)
0000-            I     9       CNTLA0         .equ $00
0000-            I    10
0080-            I    11       CNTLA0_MPE     .equ $80
0040-            I    12       CNTLA0_RE      .equ $40
0020-            I    13       CNTLA0_TE      .equ $20
0010-            I    14       CNTLA0_RTS0    .equ $10
0008-            I    15       CNTLA0_EFR     .equ $08
0004-            I    16       CNTLA0_MOD2    .equ $04
0002-            I    17       CNTLA0_MOD1    .equ $02
0001-            I    18       CNTLA0_MOD0    .equ $01
0000-            I    19
0000-            I    20       ; ASCI Control Register A 1 (CNTLA1: 01H)
0001-            I    21       CNTLA1         .equ $01
0000-            I    22
0080-            I    23       CNTLA1_MPE     .equ $80
0040-            I    24       CNTLA1_RE      .equ $40
0020-            I    25       CNTLA1_TE      .equ $20
0010-            I    26       CNTLA1_CKA1D   .equ $10
0008-            I    27       CNTLA1_EFR     .equ $08
0004-            I    28       CNTLA1_MOD2    .equ $04
0002-            I    29       CNTLA1_MOD1    .equ $02
0001-            I    30       CNTLA1_MOD0    .equ $01
0000-            I    31
0000-            I    32       ; ASCI Control Register B 0 (CNTLB0: 02H)
0002-            I    33       CNTLB0         .equ $02
0000-            I    34
0080-            I    35       CNTLB0_MPBT    .equ $80
0040-            I    36       CNTLB0_MP      .equ $40
0020-            I    37       CNTLB0_CTS     .equ $20
0010-            I    38       CNTLB0_PEO     .equ $10
0008-            I    39       CNTLB0_DR      .equ $08
0004-            I    40       CNTLB0_SS2     .equ $04
0002-            I    41       CNTLB0_SS1     .equ $02
0001-            I    42       CNTLB0_SS0     .equ $01
0000-            I    43
0000-            I    44       ; ASCI Control Register B 1 (CNTLB1: 03H)
0003-            I    45       CNTLB1         .equ $03
0000-            I    46
0080-            I    47       CNTLB1_MPBT    .equ $80
0040-            I    48       CNTLB1_MP      .equ $40
0020-            I    49       CNTLB1_CTS     .equ $20
0010-            I    50       CNTLB1_PEO     .equ $10
0008-            I    51       CNTLB1_DR      .equ $08
0004-            I    52       CNTLB1_SS2     .equ $04
0002-            I    53       CNTLB1_SS1     .equ $02
0001-            I    54       CNTLB1_SS0     .equ $01
0000-            I    55
0000-            I    56       ; ASCI Status Register 0 (STAT0: 04H)
0004-            I    57       STAT0          .equ $04
0000-            I    58
0080-            I    59       STAT0_RDRF     .equ $80
0040-            I    60       STAT0_OVRN     .equ $40
0020-            I    61       STAT0_PE       .equ $20
0010-            I    62       STAT0_FE       .equ $10
0008-            I    63       STAT0_RIE      .equ $08
0004-            I    64       STAT0_DCD0     .equ $04
0002-            I    65       STAT0_TDRE     .equ $02
0001-            I    66       STAT0_TIE      .equ $01
0000-            I    67
0000-            I    68       ; ASCI Status Register 1 (STAT1: 05H)
0005-            I    69       STAT1          .equ $05
0000-            I    70
0080-            I    71       STAT1_RDRF     .equ $80
0040-            I    72       STAT1_OVRN     .equ $40
0020-            I    73       STAT1_PE       .equ $20
0010-            I    74       STAT1_FE       .equ $10
0008-            I    75       STAT1_RIE      .equ $08
0004-            I    76       STAT1_CTS1E    .equ $04
0002-            I    77       STAT1_TDRE     .equ $02
0001-            I    78       STAT1_TIE      .equ $01
0000-            I    79
0000-            I    80       ; ASCI Transmit Data Register Ch. 0 (TDR0: 06H)
0006-            I    81       TDR0           .equ $06
0000-            I    82
0000-            I    83       ; ASCI Transmit Data Register Ch. 1 (TDR1: 07H)
0007-            I    84       TDR1           .equ $07
0000-            I    85
0000-            I    86       ; ASCI Receive Data Register Ch. 0 (RDR0: 08H)
0008-            I    87       RDR0           .equ $08
0000-            I    88
0000-            I    89       ; ASCI Receive Data Register Ch. 1 (RDR1: 09H)
0009-            I    90       RDR1           .equ $09
0000-            I    91
0000-            I    92       ; ASCI0 Extension Control Register 0 (ASEXT0: 12H)
0012-            I    93       ASEXT0         .equ $12
0000-            I    94
0080-            I    95       ASEXT0_RDRFI   .equ $80
0040-            I    96       ASEXT0_DCD0D   .equ $40
0020-            I    97       ASEXT0_CTS0D   .equ $20
0010-            I    98       ASEXT0_X1      .equ $10
0008-            I    99       ASEXT0_BRG0    .equ $08
0004-            I   100       ASEXT0_BRKE    .equ $04
0002-            I   101       ASEXT0_BRK     .equ $02
0001-            I   102       ASEXT0_SBRK    .equ $01
0000-            I   103
0000-            I   104       ; ASCI1 Extension Control Register 1 (ASEXT1: 13H)
0013-            I   105       ASEXT1         .equ $13
0000-            I   106
0080-            I   107       ASEXT1_RDRFI   .equ $80
0010-            I   108       ASEXT1_X1      .equ $10
0008-            I   109       ASEXT1_BRG1    .equ $08
0004-            I   110       ASEXT1_BRKE    .equ $04
0002-            I   111       ASEXT1_BRK     .equ $02
0001-            I   112       ASEXT1_SBRK    .equ $01
0000-            I   113
0000-            I   114       ; ASCI0 Time Constant Low Register (ASTC0L : 1AH)
001A-            I   115       ASTC0L         .equ $1A
0000-            I   116       ; ASCI0 Time Constant High Register (ASTC0H: 1BH)
001B-            I   117       ASTC0H         .equ $1B
0000-            I   118       ; ASCI1 Time Constant Low Register (ASTC1L : 1AH)
001C-            I   119       ASTC1L         .equ $1C
0000-            I   120       ; ASCI1 Time Constant High Register (ASTC1H: 1BH)
001D-            I   121       ASTC1H         .equ $1D
0000-            I   122
0000-            I   123       ; CSI/0
0000-            I   124       ; ------------------------------------
0000-            I   125
0000-            I   126       ; CSI/O Control Register (CNTR: 0AH)
000A-            I   127       CNTR           .equ $0A
0000-            I   128
0080-            I   129       CNTR_EF        .equ $80
0040-            I   130       CNTR_EIE       .equ $40
0020-            I   131       CNTR_RE        .equ $20
0010-            I   132       CNTR_TE        .equ $10
0004-            I   133       CNTR_SS2       .equ $04
0002-            I   134       CNTR_SS1       .equ $02
0001-            I   135       CNTR_SS0       .equ $01
0000-            I   136
0000-            I   137       ; CSI/O Transmit/Receive Data Register (TRD: 0BH)
000B-            I   138       TRDR           .equ $0B
0000-            I   139
0000-            I   140       ; Timer
0000-            I   141       ; ------------------------------------
0000-            I   142
0000-            I   143       ; Data Register Ch 0 L (TMDR0L: 0CH)
000C-            I   144       TMDR0L         .equ $0C
0000-            I   145       ; Data Register Ch 0 H (TMDR0H: 0DH)
000D-            I   146       TMDR0H         .equ $0D
0000-            I   147       ; Reload Register Ch 0 L (RLDR0L: OEH)
000E-            I   148       RLDR0L         .equ $0E
0000-            I   149       ; Reload Register Ch 0 H (RLDR0H: 0FH)
000F-            I   150       RLDR0H         .equ $0F
0000-            I   151
0000-            I   152       ; Timer Control Register (TCR: 10H)
0010-            I   153       TCR            .equ $10
0000-            I   154
0080-            I   155       TCR_TIF1        .equ $80
0040-            I   156       TCR_TIF0        .equ $40
0020-            I   157       TCR_TIE1        .equ $20
0010-            I   158       TCR_TIE0        .equ $10
0008-            I   159       TCR_TOC1       .equ $08
0004-            I   160       TCR_TOC0       .equ $04
0002-            I   161       TCR_TDE1       .equ $02
0001-            I   162       TCR_TDE0       .equ $01
0000-            I   163
0000-            I   164       ; Data Register Ch 1 L (TMDR1L: 14h)
0014-            I   165       TMDR1L         .equ $14
0000-            I   166       ; Data Register Ch 1 H (TMDR1H: 15H)
0015-            I   167       TMDR1H         .equ $15
0000-            I   168       ; Reload Register Ch 1 L (RLDR1L: 16H)
0016-            I   169       RLDR1L         .equ $16
0000-            I   170       ; Reload Register Ch 1 H (RLDR1H: 17H)
0017-            I   171       RLDR1H         .equ $17
0000-            I   172
0000-            I   173       ; Others
0000-            I   174       ; ------------------------------------
0000-            I   175
0000-            I   176       ; Clock Multiplier Register (CMR: 1EH)
001E-            I   177       CMR            .equ $1E
0000-            I   178
0080-            I   179       CMR_X2         .equ $80
0000-            I   180
0000-            I   181       ; Free Running Counter (FRC: 18H)
0018-            I   182       FRC            .equ $18
0000-            I   183
0000-            I   184       ; CPU Control Register (CCR: 1FH)
001F-            I   185       CCR            .equ $1F
0080-            I   186       CCR_CD         .equ $80
0040-            I   187       CCR_SB1        .equ $40
0020-            I   188       CCR_BREXT      .equ $20
0010-            I   189       CCR_LNPHI      .equ $10
0008-            I   190       CCR_SB2        .equ $08
0004-            I   191       CCR_LNIO       .equ $04
0002-            I   192       CCR_LNCPU      .equ $02
0001-            I   193       CCR_LNAD       .equ $01
0000-            I   194
0000-            I   195       ; DMA
0000-            I   196       ; ---------------------------------------------------------------------------
0000-            I   197
0000-            I   198
0000-            I   199       ; DMA/WAIT Control Register (DCNTL: 32H)
0000-            I   200
0000-            I   201       ; INT
0000-            I   202       ; ---------------------------------------------------------------------------
0000-            I   203
0000-            I   204       ; Interrupt Vector Low Register (IL: 33H)
0033-            I   205       IL              .equ $33
0000-            I   206
0000-            I   207       ; INT/TRAP Control Register (ITC: 34H)
0034-            I   208       ITC             .equ $34
0000-            I   209
0080-            I   210       ITC_TRAP        .equ $80
0040-            I   211       ITC_UFO         .equ $40
0004-            I   212       ITC_ITE2        .equ $04
0002-            I   213       ITC_ITE1        .equ $02
0001-            I   214       ITC_ITE0        .equ $01
0000-            I   215
0000-            I   216
0000-            I   217       ; Refresh
0000-            I   218       ; ---------------------------------------------------------------------------
0000-            I   219
0000-            I   220       ; Refresh Control Register (RCR: 36H)
0036-            I   221       RCR            .equ $36
0080-            I   222       RCR_REFE       .equ $80
0040-            I   223       RCR_REFW       .equ $40
0002-            I   224       RCR_CYC1       .equ $02
0001-            I   225       RCR_CYC0       .equ $01
0000-            I   226
0000-            I   227       ; MMU
0000-            I   228       ; ---------------------------------------------------------------------------
0000-            I   229
0000-            I   230       ; MMU Common Base Register (CBR: 38H)
0038-            I   231       CBR            .equ $38
0000-            I   232       ; MMU Bank Base Register (BBR: 39H)
0039-            I   233       BBR            .equ $39
0000-            I   234       ; MMU Common/Bank Register (CBAR: 3AH)
003A-            I   235       CBAR           .equ $3A
0000-            I   236       ; I/O
0000-            I   237       ; ---------------------------------------------------------------------------
0000-            I   238
0000-            I   239       ; Operation Mode Control Register (OMCR: 3EH)
003E-            I   240       OMCR           .equ $3E
0000-            I   241
0080-            I   242       OMCR_M1E       .equ $80
0040-            I   243       OMCR_M1TE      .equ $40
0000-            I   244       ;OMCR_M1E       .equ $20
0000-            I   245
0000-            I   246       ; I/O Control Register (ICR: 3FH)
003F-            I   247       ICR            .equ $3F
0000-            I   248
0080-            I   249       ICR_IOA7       .equ $80
0040-            I   250       ICR_IOA6       .equ $40
0020-            I   251       ICR_IOSTP      .equ $20
0000-                  9
0000-                 10
0000-                 11
E000-                 12           .org $E000
E000-                 13
E000-                 14           ; SYSTEM
E000-C9               15 (  9) .int_noop:      ret
E001-                 16
E001-                 17           ; ASCI
E001-C3 4C E0         18 (  9) .asci0_init:        jp _asci0_init
E004-C3 6F E0         19 (  9) .int_asci0:         jp _int_asci0
E007-                 20
E007-C3 A2 E0         21 (  9) .asci0_getc:        jp _asci0_getc
E00A-C3 BB E0         22 (  9) .asci0_rx_empty:    jp _asci0_rx_empty
E00D-C3 C1 E0         23 (  9) .asci0_putc:        jp _asci0_putc
E010-C3 CE E0         24 (  9) .asci0_puts:        jp _asci0_puts
E013-                 25
E013-C3 DE E0         26 (  9) .asci1_init:        jp _asci1_init
E016-C3 01 E1         27 (  9) .int_asci1:         jp _int_asci1
E019-                 28
E019-C3 34 E1         29 (  9) .asci1_getc:        jp _asci1_getc
E01C-C3 4D E1         30 (  9) .asci1_rx_empty:    jp _asci1_rx_empty
E01F-C3 53 E1         31 (  9) .asci1_putc:        jp _asci1_putc
E022-C3 60 E1         32 (  9) .asci1_puts:        jp _asci1_puts
E025-                 33
E025-                 34           ; VDU
E025-C3 F2 E1         35 (  9) .vdu_init:          jp _vdu_init
E028-C3 14 E2         36 (  9) .int_vdu:           jp _int_vdu
E02B-                 37
E02B-C3 6E E2         38 (  9) .vdu_set_attr:      jp _vdu_set_attr
E02E-C3 72 E2         39 (  9) .vdu_cls:           jp _vdu_cls
E031-C3 9C E2         40 (  9) .vdu_scroll_up      jp _vdu_scroll_up
E034-C3 C2 E2         41 (  9) .vdu_putc_term      jp _vdu_putc_term
E037-C3 05 E3         42 (  9) .vdu_putc           jp _vdu_putc
E03A-C3 27 E3         43 (  9) .vdu_next_line      jp _vdu_next_line
E03D-C3 4B E3         44 (  9) .vdu_puts           jp _vdu_puts
E040-                 45
E040-                 46           ; KBD
E040-C3 C4 E3         47 (  9) .kbd_init:          jp _kbd_init
E043-C3 D4 E3         48 (  9) .int_kbd:           jp _int_kbd
E046-C3 B2 E4         49 (  9) .kbd_is_empty       jp _kbd_is_empty
E049-C3 B8 E4         50 (  9) .kbd_get_key        jp _kbd_get_key
E04C-                 51
E04C-                 52           ; SND
E04C-                 53
E04C-                 54           ; RTC
E04C-                 55
E04C-                 56
E04C-                 57           .include bios_asci.asm
E04C-            I     1       ; ASCI
E04C-            I     2       ; ----------------------------------------------------------------------------
E04C-            I     3
E04C-            I     4       ; init ASCI0
E04C-            I     5       ; input : none
E04C-            I     6       ; output : none
E04C-            I     7       _asci0_init:
E04C-            I     8           ; RE : Receiver Enable
E04C-            I     9           ; TE : Transmitter Enable
E04C-            I    10           ; MOD2 : 8 bits data ( No parity, 1 stop bit)
E04C-3E 64       I    11 (  6)     ld a,CNTLA0_RE|CNTLA0_TE|CNTLA0_MOD2
E04E-ED 39 00    I    12 ( 13)     out0 (CNTLA0),a
E051-            I    13
E051-            I    14           ; DR=0
E051-3E 00       I    15 (  6)     ld a,0
E053-ED 39 02    I    16 ( 13)     out0 (CNTLB0),a
E056-            I    17
E056-            I    18           ; BRG0 : Enable 16 bit BRG counter
E056-            I    19           ; X1 ( + DR=0) : Clock mode = /1
E056-3E 18       I    20 (  6)     ld a,ASEXT0_BRG0|ASEXT0_X1
E058-ED 39 12    I    21 ( 13)     out0 (ASEXT0),a
E05B-            I    22
E05B-            I    23           ; 9600 bauds : TC=1665 (681H) --> 9603 bauds
E05B-            I    24           ; TC = fphi/(2*baud rate*clock mode) - 2
E05B-            I    25           ; TC = 32000000/(2*9600*1) - 2
E05B-3E 81       I    26 (  6)     ld a,$81
E05D-ED 39 1A    I    27 ( 13)     out0 (ASTC0L),a
E060-3E 06       I    28 (  6)     ld a,$06
E062-ED 39 1B    I    29 ( 13)     out0 (ASTC0H),a
E065-            I    30
E065-            I    31           ; RIE : enable Rx Interrupt
E065-3E 08       I    32 (  6)     ld a,STAT0_RIE
E067-ED 39 04    I    33 ( 13)     out0 (STAT0),a
E06A-            I    34
E06A-AF          I    35 (  4)     xor a                  ; init RX buffer
E06B-32 70 E1    I    36 ( 13)     ld (asci0_buffer_pos),a
E06E-            I    37
E06E-C9          I    38 (  9)     ret
E06F-            I    39
E06F-            I    40       ; INT ASCI0
E06F-            I    41       ; put received char in ASCI0 RX buffer
E06F-            I    42       _int_asci0:
E06F-F5          I    43 ( 11)     push af
E070-C5          I    44 ( 11)     push bc
E071-D5          I    45 ( 11)     push de
E072-E5          I    46 ( 11)     push hl
E073-            I    47
E073-            I    48       _int_asci0_test:
E073-ED 38 04    I    49 ( 12)     in0 a,(STAT0)                ; check if there is a char in the FIFO
E076-ED 64 80    I    50 (  9)     tst STAT0_RDRF
E079-28 21       I    51 ( 6+)     jr Z,_int_asci0_exit
E07B-            I    52
E07B-ED 08 08    I    53 ( 12)     in0 c,(RDR0)                ; c <- received char
E07E-            I    54
E07E-            I    55           ; check for error
E07E-E6 70       I    56 (  6)     and STAT0_OVRN|STAT0_PE|STAT0_FE
E080-28 0A       I    57 ( 6+)     jr Z,_int_asci0_ok
E082-            I    58
E082-ED 38 00    I    59 ( 12)     in0 a,(CNTLA0)           ; clear error
E085-E6 F7       I    60 (  6)     and CNTLA0_EFR!$FF
E087-ED 39 00    I    61 ( 13)     out0 (CNTLA0),a
E08A-18 E7       I    62 (  8)     jr _int_asci0_test                    ; exit
E08C-            I    63
E08C-            I    64       _int_asci0_ok:
E08C-16 00       I    65 (  6)     ld d,0                      ; hl <- asci0_buffer+(asci0_buffer_pos)
E08E-3A 70 E1    I    66 ( 12)     ld a,(asci0_buffer_pos)
E091-5F          I    67 (  4)     ld e,a
E092-21 71 E1    I    68 (  9)     ld hl,asci0_buffer
E095-19          I    69 (  7)     add hl,de
E096-            I    70
E096-3C          I    71 (  4)     inc a                       ; ; inc kbd_buffer_pos
E097-32 70 E1    I    72 ( 13)     ld (asci0_buffer_pos),a
E09A-            I    73
E09A-79          I    74 (  4)     ld a,c                      ; a <- received char
E09B-77          I    75 (  7)     ld (hl),a                   ; save it to asci0_buffer+(asci0_buffer_pos)
E09C-            I    76
E09C-            I    77       _int_asci0_exit:
E09C-E1          I    78 (  9)     pop hl
E09D-D1          I    79 (  9)     pop de
E09E-C1          I    80 (  9)     pop bc
E09F-F1          I    81 (  9)     pop af
E0A0-FB          I    82 (  3)     ei
E0A1-C9          I    83 (  9)     ret
E0A2-            I    84
E0A2-            I    85       ; get a char on ASCI0 RX buffer
E0A2-            I    86       ; input : none
E0A2-            I    87       ; output : a <- received char
E0A2-            I    88       _asci0_getc:
E0A2-E5          I    89 ( 11)     push hl
E0A3-D5          I    90 ( 11)     push de
E0A4-            I    91
E0A4-3A 70 E1    I    92 ( 12)     ld a,(asci0_buffer_pos)     ; load buffer position
E0A7-F6 00       I    93 (  6)     or 0
E0A9-CA B8 E0    I    94 ( 6+)     jp  Z,_asci0_getc_exit      ; exit if 0
E0AC-            I    95
E0AC-3D          I    96 (  4)     dec a                       ; decrement and update buffer position
E0AD-32 70 E1    I    97 ( 13)     ld (asci0_buffer_pos),a
E0B0-            I    98
E0B0-16 00       I    99 (  6)     ld d,0                      ; get char in buffer
E0B2-5F          I   100 (  4)     ld e,a
E0B3-21 71 E1    I   101 (  9)     ld hl,asci0_buffer
E0B6-19          I   102 (  7)     add hl,de
E0B7-7E          I   103 (  6)     ld a,(hl)                   ; into A register
E0B8-            I   104
E0B8-            I   105       _asci0_getc_exit:
E0B8-            I   106
E0B8-D1          I   107 (  9)     pop de
E0B9-E1          I   108 (  9)     pop hl
E0BA-C9          I   109 (  9)     ret
E0BB-            I   110
E0BB-            I   111       ; check if rx buffer is empty
E0BB-            I   112       ; input : NONE
E0BB-            I   113       ; output : flag=Z if empty
E0BB-            I   114       _asci0_rx_empty:
E0BB-3A 70 E1    I   115 ( 12)     ld a,(asci0_buffer_pos)
E0BE-FE 00       I   116 (  6)     cp 0
E0C0-C9          I   117 (  9)     ret
E0C1-            I   118
E0C1-            I   119       ; put a char on asci0
E0C1-            I   120       ; input : a = char ascii code
E0C1-            I   121       ; output : none
E0C1-            I   122       _asci0_putc:
E0C1-F5          I   123 ( 11)     push af
E0C2-            I   124
E0C2-            I   125       _asci0_putc_wait:  ; wait for asci0 TX ready
E0C2-ED 38 04    I   126 ( 12)     in0 a,(STAT0) ; TDRE=1 -> empty
E0C5-E6 02       I   127 (  6)     and STAT0_TDRE
E0C7-28 F9       I   128 ( 6+)     jr Z,_asci0_putc_wait
E0C9-            I   129
E0C9-F1          I   130 (  9)     pop af
E0CA-ED 39 06    I   131 ( 13)     out0 (TDR0),a ; output the char to asci0
E0CD-            I   132
E0CD-C9          I   133 (  9)     ret
E0CE-            I   134
E0CE-            I   135       ; put a string on asci0
E0CE-            I   136       ; input : (hl) = address of null terminated string
E0CE-            I   137       ; output : none
E0CE-            I   138       _asci0_puts:
E0CE-E5          I   139 ( 11)     push hl
E0CF-F5          I   140 ( 11)     push af
E0D0-            I   141
E0D0-            I   142       _asci0_puts_loop:
E0D0-7E          I   143 (  6)     ld a,(hl)
E0D1-F6 00       I   144 (  6)     or 0
E0D3-28 06       I   145 ( 6+)     jr z,_asci0_puts_exit
E0D5-CD C1 E0    I   146 ( 16)     call _asci0_putc
E0D8-23          I   147 (  4)     inc hl
E0D9-18 F5       I   148 (  8)     jr _asci0_puts_loop
E0DB-            I   149
E0DB-            I   150       _asci0_puts_exit:
E0DB-F1          I   151 (  9)     pop af
E0DC-E1          I   152 (  9)     pop hl
E0DD-C9          I   153 (  9)     ret
E0DE-            I   154
E0DE-            I   155       _asci1_init:
E0DE-            I   156           ; RE : Receiver Enable
E0DE-            I   157           ; TE : Transmitter Enable
E0DE-            I   158           ; MOD2 : 8 bits data ( No parity, 1 stop bit)
E0DE-3E 64       I   159 (  6)     ld a,CNTLA1_RE|CNTLA1_TE|CNTLA1_MOD2
E0E0-ED 39 01    I   160 ( 13)     out0 (CNTLA1),a
E0E3-            I   161
E0E3-            I   162           ; DR=0
E0E3-3E 00       I   163 (  6)     ld a,0
E0E5-ED 39 03    I   164 ( 13)     out0 (CNTLB1),a
E0E8-            I   165
E0E8-            I   166           ; BRG0 : Enable 16 bit BRG counter
E0E8-            I   167           ; X1 ( + DR=0) : Clock mode = /1
E0E8-3E 18       I   168 (  6)     ld a,ASEXT1_BRG1|ASEXT1_X1
E0EA-ED 39 13    I   169 ( 13)     out0 (ASEXT1),a
E0ED-            I   170
E0ED-            I   171           ; 9600 bauds : TC=1665 (681H) --> 9603 bauds
E0ED-            I   172           ; TC = fphi/(2*baud rate*clock mode) - 2
E0ED-            I   173           ; TC = 32000000/(2*9600*1) - 2
E0ED-3E 81       I   174 (  6)     ld a,$81
E0EF-ED 39 1C    I   175 ( 13)     out0 (ASTC1L),a
E0F2-3E 06       I   176 (  6)     ld a,$06
E0F4-ED 39 1D    I   177 ( 13)     out0 (ASTC1H),a
E0F7-            I   178
E0F7-            I   179           ; RIE : enable Rx Interrupt
E0F7-3E 08       I   180 (  6)     ld a,STAT1_RIE
E0F9-ED 39 05    I   181 ( 13)     out0 (STAT1),a
E0FC-            I   182
E0FC-AF          I   183 (  4)     xor a                  ; init RX buffer
E0FD-32 B1 E1    I   184 ( 13)     ld (asci1_buffer_pos),a
E100-            I   185
E100-C9          I   186 (  9)     ret
E101-            I   187
E101-            I   188       _int_asci1:
E101-F5          I   189 ( 11)     push af
E102-C5          I   190 ( 11)     push bc
E103-D5          I   191 ( 11)     push de
E104-E5          I   192 ( 11)     push hl
E105-            I   193
E105-            I   194       _int_asci1_test:
E105-ED 38 05    I   195 ( 12)     in0 a,(STAT1)                ; check if there is a char in the FIFO
E108-ED 64 80    I   196 (  9)     tst STAT1_RDRF
E10B-28 21       I   197 ( 6+)     jr Z,_int_asci1_exit
E10D-            I   198
E10D-ED 08 09    I   199 ( 12)     in0 c,(RDR1)                ; c <- received char
E110-            I   200
E110-            I   201           ; check for error
E110-E6 70       I   202 (  6)     and STAT1_OVRN|STAT1_PE|STAT1_FE
E112-28 0A       I   203 ( 6+)     jr Z,_int_asci1_ok
E114-            I   204
E114-ED 38 01    I   205 ( 12)     in0 a,(CNTLA1)           ; clear error
E117-E6 F7       I   206 (  6)     and CNTLA1_EFR!$FF
E119-ED 39 01    I   207 ( 13)     out0 (CNTLA1),a
E11C-18 E7       I   208 (  8)     jr _int_asci1_test                    ; exit
E11E-            I   209
E11E-            I   210       _int_asci1_ok:
E11E-16 00       I   211 (  6)     ld d,0                      ; hl <- asci0_buffer+(asci0_buffer_pos)
E120-3A B1 E1    I   212 ( 12)     ld a,(asci1_buffer_pos)
E123-5F          I   213 (  4)     ld e,a
E124-21 B2 E1    I   214 (  9)     ld hl,asci1_buffer
E127-19          I   215 (  7)     add hl,de
E128-            I   216
E128-3C          I   217 (  4)     inc a                       ; ; inc kbd_buffer_pos
E129-32 B1 E1    I   218 ( 13)     ld (asci1_buffer_pos),a
E12C-            I   219
E12C-79          I   220 (  4)     ld a,c                      ; a <- received char
E12D-77          I   221 (  7)     ld (hl),a                   ; save it to  asci1_buffer+(asci1_buffer_pos)
E12E-            I   222
E12E-            I   223       _int_asci1_exit:
E12E-E1          I   224 (  9)     pop hl
E12F-D1          I   225 (  9)     pop de
E130-C1          I   226 (  9)     pop bc
E131-F1          I   227 (  9)     pop af
E132-FB          I   228 (  3)     ei
E133-C9          I   229 (  9)     ret
E134-            I   230
E134-            I   231       _asci1_getc:
E134-E5          I   232 ( 11)     push hl
E135-D5          I   233 ( 11)     push de
E136-            I   234
E136-3A B1 E1    I   235 ( 12)     ld a,(asci1_buffer_pos)     ; load buffer position
E139-F6 00       I   236 (  6)     or 0
E13B-CA 4A E1    I   237 ( 6+)     jp  Z,_asci1_getc_exit      ; exit if 0
E13E-            I   238
E13E-3D          I   239 (  4)     dec a                       ; decrement and update buffer position
E13F-32 B1 E1    I   240 ( 13)     ld (asci1_buffer_pos),a
E142-            I   241
E142-16 00       I   242 (  6)     ld d,0                      ; get char in buffer
E144-5F          I   243 (  4)     ld e,a
E145-21 B2 E1    I   244 (  9)     ld hl,asci1_buffer
E148-19          I   245 (  7)     add hl,de
E149-7E          I   246 (  6)     ld a,(hl)                   ; into A register
E14A-            I   247
E14A-            I   248       _asci1_getc_exit:
E14A-            I   249
E14A-D1          I   250 (  9)     pop de
E14B-E1          I   251 (  9)     pop hl
E14C-C9          I   252 (  9)     ret
E14D-            I   253
E14D-            I   254       ; check if rx buffer is empty
E14D-            I   255       ; input : NONE
E14D-            I   256       ; output : flag=Z if empty
E14D-            I   257       _asci1_rx_empty:
E14D-3A B1 E1    I   258 ( 12)     ld a,(asci1_buffer_pos)
E150-FE 00       I   259 (  6)     cp 0
E152-C9          I   260 (  9)     ret
E153-            I   261
E153-            I   262       ; put a char on asci1
E153-            I   263       ; input : a = char ascii code
E153-            I   264       ; output : none
E153-            I   265       _asci1_putc:
E153-F5          I   266 ( 11)     push af
E154-            I   267
E154-            I   268       _asci1_putc_wait:  ; wait for asci0 TX ready
E154-ED 38 05    I   269 ( 12)     in0 a,(STAT1) ; TDRE=1 -> empty
E157-E6 02       I   270 (  6)     and STAT1_TDRE
E159-28 F9       I   271 ( 6+)     jr Z,_asci1_putc_wait
E15B-            I   272
E15B-F1          I   273 (  9)     pop af
E15C-ED 39 07    I   274 ( 13)     out0 (TDR1),a ; output the char to asci0
E15F-            I   275
E15F-C9          I   276 (  9)     ret
E160-            I   277
E160-            I   278       ; put a string on asci1
E160-            I   279       ; input : (hl) = address of null terminated string
E160-            I   280       ; output : none
E160-            I   281       _asci1_puts:
E160-E5          I   282 ( 11)     push hl
E161-F5          I   283 ( 11)     push af
E162-            I   284
E162-            I   285       _asci1_puts_loop:
E162-7E          I   286 (  6)     ld a,(hl)
E163-F6 00       I   287 (  6)     or 0
E165-28 06       I   288 ( 6+)     jr z,_asci1_puts_exit
E167-CD 53 E1    I   289 ( 16)     call _asci1_putc
E16A-23          I   290 (  4)     inc hl
E16B-18 F5       I   291 (  8)     jr _asci1_puts_loop
E16D-            I   292
E16D-            I   293       _asci1_puts_exit:
E16D-F1          I   294 (  9)     pop af
E16E-E1          I   295 (  9)     pop hl
E16F-C9          I   296 (  9)     ret
E170-            I   297
E170-            I   298       ; RAM
E170-            I   299       asci0_buffer_pos:   .bs 1
E171-            I   300       asci0_buffer:       .bs 64
E1B1-            I   301       asci1_buffer_pos:   .bs 1
E1B2-            I   302       asci1_buffer:       .bs 64
E1F2-                 58           .include bios_vdu.asm
E1F2-            I     1       ; VDU
E1F2-            I     2       ; ----------------------------------------------------------------------------
E1F2-            I     3
F000-            I     4       VDU_RAM   .equ $F000     ; Start of video RAM address
E1F2-            I     5
0001-            I     6       CURSOR_SOLID .equ 1
E1F2-            I     7
E1F2-            I     8
E1F2-            I     9       ; vdu_init
E1F2-            I    10       ; init the vdu system
E1F2-            I    11       ; input : none
E1F2-            I    12       ; output : none
E1F2-            I    13       _vdu_init:
E1F2-            I    14
E1F2-            I    15           ; clear screen
E1F2-CD 72 E2    I    16 ( 16)     call _vdu_cls
E1F5-            I    17
E1F5-            I    18           ; set PRT0 interrupt at 1/60s
E1F5-3E 1A       I    19 (  6)      ld a,$1A
E1F7-ED 39 0F    I    20 ( 13)      out0 (RLDR0H),a
E1FA-3E 0A       I    21 (  6)      ld a,$0A
E1FC-ED 39 0E    I    22 ( 13)      out0 (RLDR0L),a
E1FF-            I    23
E1FF-            I    24           ; enable PRT0 interrupt
E1FF-3E 11       I    25 (  6)     ld a, TCR_TIE0|TCR_TDE0
E201-ED 39 10    I    26 ( 13)     out0 (TCR),a
E204-            I    27
E204-AF          I    28 (  4)     xor a
E205-32 C3 E3    I    29 ( 13)     ld (vdu_cursor_status),a
E208-2A BE E3    I    30 ( 15)     ld hl,(VDU_PTR)
E20B-22 C0 E3    I    31 ( 20)     ld (vdu_cursor_ptr),hl
E20E-3E 1E       I    32 (  6)     ld a,30
E210-32 C2 E3    I    33 ( 13)     ld (vdu_cursor_blink),a
E213-            I    34
E213-            I    35
E213-C9          I    36 (  9)     ret
E214-            I    37
E214-            I    38       _int_vdu:
E214-F5          I    39 ( 11)     push af
E215-E5          I    40 ( 11)     push hl
E216-D5          I    41 ( 11)     push de
E217-            I    42
E217-ED 38 10    I    43 ( 12)     in0 a,(TCR)         ; clear TIFE0
E21A-ED 38 0C    I    44 ( 12)     in0 a,(TMDR0L)
E21D-            I    45
E21D-2A C0 E3    I    46 ( 15)     ld hl,(vdu_cursor_ptr) ; compare vdu_cusror_ptr and VDU_PTR
E220-ED 5B BE E3 I    47 ( 18)     ld de,(VDU_PTR)
E224-            I    48
E224-B7          I    49 (  4)     or a                    ; "16 bits cp"
E225-ED 52       I    50 ( 10)     sbc hl,de
E227-19          I    51 (  7)     add hl,de
E228-            I    52
E228-30 1C       I    53 ( 6+)     jr nc,_int_vdu_blink
E22A-            I    54
E22A-3E C3       I    55 (  6)     ld a,vdu_cursor_status
E22C-FE 00       I    56 (  6)     cp 0
E22E-C2 46 E2    I    57 ( 6+)     jp nz,_int_vdu_blink
E231-            I    58
E231-2A C0 E3    I    59 ( 15)     ld hl,(vdu_cursor_ptr)  ; delete cursor at old location
E234-23          I    60 (  4)     inc hl
E235-7E          I    61 (  6)     ld a,(hl)
E236-07          I    62 (  3)     rlca
E237-07          I    63 (  3)     rlca
E238-07          I    64 (  3)     rlca
E239-07          I    65 (  3)     rlca
E23A-77          I    66 (  7)     ld (hl),a
E23B-            I    67
E23B-ED 53 C0 E3 I    68 ( 20)     ld (vdu_cursor_ptr),de  ; update cursor_ptr
E23F-            I    69
E23F-3E 01       I    70 (  6)     ld a,1
E241-32 C3 E3    I    71 ( 13)     ld (vdu_cursor_status),a
E244-            I    72
E244-18 19       I    73 (  8)     jr _int_vdu_reverse_cursor ; display cursor at new location
E246-            I    74
E246-            I    75       _int_vdu_blink:
E246-3A C2 E3    I    76 ( 12)     ld a,(vdu_cursor_blink)     ; /60 divider for cursor blink
E249-3D          I    77 (  4)     dec a
E24A-32 C2 E3    I    78 ( 13)     ld (vdu_cursor_blink),a
E24D-FE 00       I    79 (  6)     cp 0
E24F-C2 69 E2    I    80 ( 6+)     jp nz,_int_vdu_exit
E252-            I    81
E252-3E 1E       I    82 (  6)     ld a,30
E254-32 C2 E3    I    83 ( 13)     ld (vdu_cursor_blink),a
E257-            I    84
E257-3A C3 E3    I    85 ( 12)     ld a,(vdu_cursor_status)
E25A-EE 01       I    86 (  6)     xor 1
E25C-32 C3 E3    I    87 ( 13)     ld (vdu_cursor_status),a
E25F-            I    88
E25F-            I    89       _int_vdu_reverse_cursor:
E25F-            I    90
E25F-2A BE E3    I    91 ( 15)     ld hl,(VDU_PTR)
E262-23          I    92 (  4)     inc hl          ; hl <- current color attribute address
E263-7E          I    93 (  6)     ld a,(hl)
E264-07          I    94 (  3)     rlca
E265-07          I    95 (  3)     rlca
E266-07          I    96 (  3)     rlca
E267-07          I    97 (  3)     rlca
E268-77          I    98 (  7)     ld (hl),a
E269-            I    99
E269-            I   100       _int_vdu_exit:
E269-D1          I   101 (  9)     pop de
E26A-E1          I   102 (  9)     pop hl
E26B-F1          I   103 (  9)     pop af
E26C-FB          I   104 (  3)     ei
E26D-C9          I   105 (  9)     ret
E26E-            I   106
E26E-            I   107       ; vdu_set_attr
E26E-            I   108       ; set the color attribute
E26E-            I   109       ; input : a = color attribute
E26E-            I   110       ; output : none
E26E-            I   111       _vdu_set_attr:
E26E-32 BB E3    I   112 ( 13)     ld (VDU_ATTR),a
E271-C9          I   113 (  9)     ret
E272-            I   114
E272-            I   115       ; vdu_cls
E272-            I   116       ; clear screen using VDU_ATTR color
E272-            I   117       ; input : none
E272-            I   118       ; output : none
E272-            I   119       _vdu_cls:
E272-D5          I   120 ( 11)     push de
E273-E5          I   121 ( 11)     push hl
E274-F5          I   122 ( 11)     push af
E275-            I   123
E275-11 D0 07    I   124 (  9)     ld de,2000     ; number of chars
E278-21 00 F0    I   125 (  9)     ld hl,VDU_RAM    ; pointer to srart of ram
E27B-3A BB E3    I   126 ( 12)     ld a,(VDU_ATTR)  ; get color attribute
E27E-4F          I   127 (  4)     ld c,a
E27F-            I   128
E27F-            I   129       _vdu_cls_loop:
E27F-36 20       I   130 (  9)     ld (hl),$20     ; write space char.
E281-23          I   131 (  4)     inc hl
E282-71          I   132 (  7)     ld (hl),c       ; set color attribute
E283-23          I   133 (  4)     inc hl
E284-1B          I   134 (  4)     dec de          ; update chars counter
E285-7A          I   135 (  4)     ld a,d         ; check if zero
E286-B3          I   136 (  4)     or e
E287-C2 7F E2    I   137 ( 6+)     jp nz,_vdu_cls_loop
E28A-            I   138
E28A-AF          I   139 (  4)     xor a          ; home cursor
E28B-32 BC E3    I   140 ( 13)     ld (VDU_X),a    ; X=0
E28E-32 BD E3    I   141 ( 13)     ld (VDU_Y),a    ; Y=0
E291-11 00 F0    I   142 (  9)     ld de,VDU_RAM   ; PTR = start of video RAM
E294-ED 53 BE E3 I   143 ( 20)     ld (VDU_PTR),de
E298-            I   144
E298-F1          I   145 (  9)     pop af
E299-E1          I   146 (  9)     pop hl
E29A-D1          I   147 (  9)     pop de
E29B-            I   148
E29B-C9          I   149 (  9)     ret
E29C-            I   150
E29C-            I   151       ; vdu_scroll
E29C-            I   152       ; scroll all the screen UP one line
E29C-            I   153       ; input : none
E29C-            I   154       ; output : none
E29C-            I   155       _vdu_scroll_up:
E29C-F5          I   156 ( 11)     push af
E29D-E5          I   157 ( 11)     push hl
E29E-D5          I   158 ( 11)     push de
E29F-C5          I   159 ( 11)     push bc
E2A0-            I   160
E2A0-21 A0 F0    I   161 (  9)     ld hl,VDU_RAM+160 ; source pointer = start of 2nd line
E2A3-11 00 F0    I   162 (  9)     ld de,VDU_RAM ; destination pointer = start of 1st line
E2A6-01 00 0F    I   163 (  9)     ld bc,4000-160 ; all screen minus one line to move
E2A9-            I   164       _vdu_scroll_loop:
E2A9-ED A0       I   165 ( 12)     ldi     ; scroll the screen
E2AB-EA A9 E2    I   166 ( 6+)     jp pe,_vdu_scroll_loop
E2AE-            I   167                   ; here -> (de) points to the start of 25th line
E2AE-06 50       I   168 (  6)     ld b,80   ; 80 chars to fill on last line
E2B0-3A BB E3    I   169 ( 12)     ld a,(VDU_ATTR) ; get current color attribute
E2B3-4F          I   170 (  4)     ld c,a
E2B4-            I   171       _vdu_scroll_loop_line25:
E2B4-3E 20       I   172 (  6)     ld a,' '
E2B6-12          I   173 (  7)     ld (de),a ; put a space character
E2B7-13          I   174 (  4)     inc de
E2B8-79          I   175 (  4)     ld a,c
E2B9-12          I   176 (  7)     ld (de),a ; ser the color attribute
E2BA-13          I   177 (  4)     inc de
E2BB-10 F7       I   178 ( 7+)     djnz _vdu_scroll_loop_line25
E2BD-            I   179
E2BD-C1          I   180 (  9)     pop bc
E2BE-D1          I   181 (  9)     pop de
E2BF-E1          I   182 (  9)     pop hl
E2C0-F1          I   183 (  9)     pop af
E2C1-C9          I   184 (  9)     ret
E2C2-            I   185
E2C2-            I   186       ; vdu_putc_term
E2C2-            I   187       ; put a char on the screen, at current location, with current attribute, interpreting special codes :
E2C2-            I   188       ;   VT-52 Terminal ( see http://toshyp.atari.org/en/VT_52_terminal.html )
E2C2-            I   189       ;   BS - Backspace - 0x08
E2C2-            I   190       ;   BEL - Bell - 0x07
E2C2-            I   191       ;   ESC J - Clear to end of scren - 0x1b , J
E2C2-            I   192       ;   ESC K - Clear to end of line - 0x1b , K
E2C2-            I   193       ;   ESC E - Clear Screen - 0x1b , E
E2C2-            I   194       ;   ESC l - Clear line - 0x1b , l
E2C2-            I   195       ;   ESC o - Clear to start of line - 0x1b , o
E2C2-            I   196       ;   ESC d - Clear to start of screen - 0x1b , d
E2C2-            I   197       ;   ESC B - Cursor down - 0x1b , B
E2C2-            I   198       ;   ESC H - Cursor home - 0x1b , H
E2C2-            I   199       ;   ESC D - Cursor left - 0x1b , D
E2C2-            I   200       ;   ESC C - Cursor right - 0x1b , C
E2C2-            I   201       ;   ESC A - Cursor up - 0x1b , A
E2C2-            I   202       ;   ESC M - Delete line - 0x1b , M
E2C2-            I   203       ;   ESC Y - Set cursor position - 0x1b , Y , ' '+x , ' '+y
E2C2-            I   204       ;   ESC b - Set text color - 0x1b , b , color
E2C2-            I   205       ;   ESC L - Insert line - 0x1b , L
E2C2-            I   206       ;   LF - Line feed - 0x0a
E2C2-            I   207       ;   ESC k - Restore cursor position - 0x1b , k
E2C2-            I   208       ;   ESC c - Set Background color - 0x1b , c , color
E2C2-            I   209       ;   CR - Carriage return - 0x0d
E2C2-            I   210       ;   ESC q - Normal video - 0x1b , q
E2C2-            I   211       ;   ESC p - Reverse video - 0x1b , p
E2C2-            I   212       ;   ESC j - Save cursor position - 0x1b , j
E2C2-            I   213       ;   ESC I - Cursor up and insert - 0x1b , I
E2C2-            I   214       ;   FF - Form feed - 0x0c
E2C2-            I   215       ;   HT - Tabulator - 0x09
E2C2-            I   216       ;   ESC w - Wrap off - 0x1b , w
E2C2-            I   217       ;   ESC v - Wrap on - 0x1b , v
E2C2-            I   218       ;   ESC e - Show cursor
E2C2-            I   219       ;   ESC f - Hide cursor
E2C2-            I   220       ;   blink on
E2C2-            I   221       ;   blink off
E2C2-            I   222       ; input : a = char to print
E2C2-            I   223       ; output : none
E2C2-            I   224
E2C2-            I   225       _vdu_putc_term:
E2C2-            I   226
E2C2-            I   227
E2C2-            I   228       _vdu_putc_term_LF:
E2C2-FE 0A       I   229 (  6)     cp $0A
E2C4-20 05       I   230 ( 6+)     jr nz,_vdu_putc_term_CS
E2C6-CD EB E2    I   231 ( 16)     call _vdu_do_LF
E2C9-18 15       I   232 (  8)     jr _vdu_putc_term_exit
E2CB-            I   233
E2CB-            I   234       _vdu_putc_term_CS:
E2CB-FE 0C       I   235 (  6)     cp $0C
E2CD-20 05       I   236 ( 6+)     jr nz,_vdu_putc_term_CR
E2CF-CD 72 E2    I   237 ( 16)     call _vdu_cls
E2D2-18 0C       I   238 (  8)     jr _vdu_putc_term_exit
E2D4-            I   239
E2D4-            I   240       _vdu_putc_term_CR:
E2D4-FE 0D       I   241 (  6)    cp $0D
E2D6-20 05       I   242 ( 6+)    jr nz,_vdu_putc_term_print
E2D8-CD E1 E2    I   243 ( 16)    call _vdu_do_CR
E2DB-18 03       I   244 (  8)    jr _vdu_putc_term_exit
E2DD-            I   245
E2DD-            I   246       _vdu_putc_term_print:
E2DD-CD 05 E3    I   247 ( 16)     call _vdu_putc
E2E0-            I   248
E2E0-            I   249       _vdu_putc_term_exit:
E2E0-C9          I   250 (  9)     ret
E2E1-            I   251
E2E1-            I   252       _vdu_do_CR:
E2E1-F5          I   253 ( 11)     push af
E2E2-AF          I   254 (  4)     xor a
E2E3-32 BC E3    I   255 ( 13)     ld (VDU_X),a
E2E6-CD 69 E3    I   256 ( 16)     call _vdu_xy_to_ptr
E2E9-F1          I   257 (  9)     pop af
E2EA-C9          I   258 (  9)     ret
E2EB-            I   259
E2EB-            I   260
E2EB-            I   261       _vdu_do_LF:
E2EB-F5          I   262 ( 11)     push af
E2EC-3A BD E3    I   263 ( 12)     ld a,(VDU_Y)
E2EF-3C          I   264 (  4)     inc a
E2F0-32 BD E3    I   265 ( 13)     ld (VDU_Y),a
E2F3-FE 19       I   266 (  6)     cp 25
E2F5-C2 00 E3    I   267 ( 6+)     jp nz,_vdu_do_LF_set_ptr
E2F8-CD 9C E2    I   268 ( 16)     call _vdu_scroll_up
E2FB-3E 18       I   269 (  6)     ld a,24
E2FD-32 BD E3    I   270 ( 13)     ld (VDU_Y),a
E300-            I   271       _vdu_do_LF_set_ptr:
E300-CD 69 E3    I   272 ( 16)     call _vdu_xy_to_ptr
E303-F1          I   273 (  9)     pop af
E304-C9          I   274 (  9)     ret
E305-            I   275
E305-            I   276
E305-            I   277       ; vdu_putc
E305-            I   278       ; put a char on the screen, at current location, with current attribute
E305-            I   279       ; input : a = char to display
E305-            I   280       ; output : none
E305-            I   281       _vdu_putc:
E305-F5          I   282 ( 11)     push af
E306-D5          I   283 ( 11)     push de
E307-            I   284
E307-ED 5B BE E3 I   285 ( 18)     ld de,(VDU_PTR)
E30B-12          I   286 (  7)     ld (de),a           ; put char in a to current video memory location
E30C-13          I   287 (  4)     inc de              ; go to attribute
E30D-3A BB E3    I   288 ( 12)     ld a,(VDU_ATTR)     ; fetch attribute from VDU_ATTR
E310-12          I   289 (  7)     ld (de),a           ; write attribute to video memory
E311-13          I   290 (  4)     inc de              ; go to next char
E312-3A BC E3    I   291 ( 12)     ld a,(VDU_X)        ; get X position
E315-3C          I   292 (  4)     inc a               ; increment
E316-32 BC E3    I   293 ( 13)     ld (VDU_X),a
E319-FE 50       I   294 (  6)     cp 80              ; next line ?
E31B-20 03       I   295 ( 6+)     jr nz,_vdu_putc_exit
E31D-CD 27 E3    I   296 ( 16)     call _vdu_next_line
E320-            I   297
E320-            I   298       _vdu_putc_exit:
E320-ED 53 BE E3 I   299 ( 20)     ld (VDU_PTR),de
E324-            I   300
E324-D1          I   301 (  9)     pop de
E325-F1          I   302 (  9)     pop af
E326-C9          I   303 (  9)     ret
E327-            I   304
E327-            I   305       ; vdu_next_line
E327-            I   306       ; set cursor at the beginning of next line. Verticall scroll of the screen if we are at 25th line.
E327-            I   307       ; input: none
E327-            I   308       ; output: none
E327-            I   309       _vdu_next_line:
E327-F5          I   310 ( 11)     push af
E328-D5          I   311 ( 11)     push de
E329-            I   312
E329-3E 00       I   313 (  6)     ld a,0              ; reset X
E32B-32 BC E3    I   314 ( 13)     ld (VDU_X),a
E32E-3A BD E3    I   315 ( 12)     ld a,(VDU_Y)        ; increment Y
E331-3C          I   316 (  4)     inc a
E332-32 BD E3    I   317 ( 13)     ld (VDU_Y),a
E335-FE 19       I   318 (  6)     cp 25               ; bottom of the screen ?
E337-20 0F       I   319 ( 6+)     jr nz,_vdu_next_line_exit
E339-CD 9C E2    I   320 ( 16)     call _vdu_scroll_up
E33C-3E 18       I   321 (  6)     ld a,24             ; set Y to 24
E33E-32 BD E3    I   322 ( 13)     ld (VDU_Y),a
E341-            I   323
E341-11 00 FF    I   324 (  9)     ld de,VDU_RAM+3840   ; set de to start of 24th line
E344-ED 53 BE E3 I   325 ( 20)     ld (VDU_PTR),de
E348-            I   326
E348-            I   327       _vdu_next_line_exit:
E348-D1          I   328 (  9)     pop de
E349-F1          I   329 (  9)     pop af
E34A-C9          I   330 (  9)     ret
E34B-            I   331
E34B-            I   332       ; vdu_puts
E34B-            I   333       ; display a text on the screen, at current location, with current color attrributes.
E34B-            I   334       ; input : hl = pointer to a null terminated string
E34B-            I   335       ; output : none
E34B-            I   336       _vdu_puts:
E34B-F5          I   337 ( 11)     push af
E34C-E5          I   338 ( 11)     push hl
E34D-            I   339
E34D-            I   340       _vdu_puts_loop:
E34D-7E          I   341 (  6)     ld a,(hl)   ; load char fromm string
E34E-F6 00       I   342 (  6)     or 0
E350-28 06       I   343 ( 6+)     jr z,_vdu_puts_exit  ; exit if =0
E352-CD 05 E3    I   344 ( 16)     call _vdu_putc
E355-23          I   345 (  4)     inc hl  ; next character
E356-18 F5       I   346 (  8)     jr _vdu_puts_loop
E358-            I   347
E358-            I   348       _vdu_puts_exit:
E358-E1          I   349 (  9)     pop hl
E359-F1          I   350 (  9)     pop af
E35A-C9          I   351 (  9)     ret
E35B-            I   352
E35B-            I   353       ; vdu_locate
E35B-            I   354       ; set cursor position
E35B-            I   355       ; input : b=X (0-79), c=Y (0-24)
E35B-            I   356       ; output : none
E35B-            I   357       _vdu_locate:
E35B-F5          I   358 ( 11)     push af
E35C-78          I   359 (  4)     ld a,b
E35D-32 BC E3    I   360 ( 13)     ld (VDU_X),a
E360-79          I   361 (  4)     ld a,c
E361-32 BD E3    I   362 ( 13)     ld (VDU_Y),a
E364-CD 69 E3    I   363 ( 16)     call _vdu_xy_to_ptr
E367-F1          I   364 (  9)     pop af
E368-C9          I   365 (  9)     ret
E369-            I   366
E369-            I   367       _vdu_xy_to_ptr
E369-            I   368
E369-F5          I   369 ( 11)     push af
E36A-E5          I   370 ( 11)     push hl
E36B-D5          I   371 ( 11)     push de
E36C-            I   372
E36C-21 89 E3    I   373 (  9)     ld hl,vdu_line_ptr ; hl = pointer to array of start of line addresses
E36F-16 00       I   374 (  6)     ld d,0  ; de = Y*2
E371-3A BD E3    I   375 ( 12)     ld a,(VDU_Y)
E374-87          I   376 (  4)     add a,a
E375-5F          I   377 (  4)     ld e,a
E376-19          I   378 (  7)     add hl,de ; hl = pointer to start of line
E377-            I   379
E377-5E          I   380 (  6)     ld e,(hl)  ; de = (hl) = start of line address
E378-23          I   381 (  4)     inc hl
E379-56          I   382 (  6)     ld d,(hl)
E37A-            I   383
E37A-26 00       I   384 (  6)      ld h,0 ; hl=X*2
E37C-3A BC E3    I   385 ( 12)      ld a,(VDU_X)
E37F-87          I   386 (  4)      add a,a
E380-6F          I   387 (  4)      ld l,a
E381-19          I   388 (  7)     add hl,de ; hl = start of line address + X*2
E382-            I   389
E382-            I   390
E382-22 BE E3    I   391 ( 20)     ld (VDU_PTR),hl ; save PTR
E385-            I   392
E385-D1          I   393 (  9)     pop de
E386-E1          I   394 (  9)     pop hl
E387-F1          I   395 (  9)     pop af
E388-C9          I   396 (  9)     ret
E389-            I   397
E389-            I   398       ; VDU DATA
E389-00 F0 A0 F0 
     40 F1 E0 F1 
     80 F2 20 F3 
     C0 F3 60 F4 
     00 F5 A0 F5 
     40 F6 E0 F6 I   399       vdu_line_ptr    .dw     $F000,$F0A0,$F140,$F1E0,$F280,$F320,$F3C0,$F460,$F500,$F5A0,$F640,$F6E0
E3A1-80 F7 20 F8 
     C0 F8 60 F9 
     00 FA A0 FA 
     40 FB E0 FB 
     80 FC 20 FD 
     C0 FD 60 FE 
     00 FF       I   400                       .dw     $F780,$F820,$F8C0,$F960,$FA00,$FAA0,$FB40,$FBE0,$FC80,$FD20,$FDC0,$FE60,$FF00
E3BB-            I   401
E3BB-            I   402
E3BB-            I   403       ; RAM
E3BB-            I   404
E3BB-            I   405
E3BB-            I   406       VDU_ATTR            .bs 1   ; Color Attribute
E3BC-            I   407       VDU_X               .bs 1   ; Current X position
E3BD-            I   408       VDU_Y               .bs 1   ; Current Y position
E3BE-            I   409       VDU_PTR             .bs 2     ; Current position in video RAM, should always be equal to
E3C0-            I   410                               ; VDU_RAM + X*2 + Y*160
E3C0-            I   411       vdu_cursor_ptr          .bs 2
E3C2-            I   412       vdu_cursor_blink      .bs 1
E3C3-            I   413       vdu_cursor_status     .bs 1
E3C4-                 59           .include bios_kbd.asm
E3C4-            I     1       ; KBD
E3C4-            I     2       ; ----------------------------------------------------------------------------
E3C4-            I     3
0080-            I     4       KBD_DATA    .equ $80
0081-            I     5       KBD_STATUS  .equ $81
E3C4-            I     6
E3C4-            I     7       ; bit 0 : shift
E3C4-            I     8       ; bit 1 : alt
E3C4-            I     9       ; bit 2 : caps lock
0000-            I    10       KBD_STATE_SHIFT .equ 0
0001-            I    11       KBD_STATE_ALT .equ 1
0002-            I    12       KBD_STATE_CAPS .equ 2
0003-            I    13       KBD_STATE_F0   .equ 3
0004-            I    14       KBD_STATE_E0  .equ 4
E3C4-            I    15
0004-            I    16       KBD_XOR_CAPS .equ 4
E3C4-            I    17
E3C4-            I    18
E3C4-            I    19       _kbd_init:
E3C4-            I    20           ; enable INT1
E3C4-ED 38 34    I    21 ( 12)     in0 a,(ITC)
E3C7-F6 02       I    22 (  6)     or ITC_ITE1
E3C9-ED 39 34    I    23 ( 13)     out0 (ITC),a
E3CC-            I    24
E3CC-            I    25           ; init keyboad variables
E3CC-AF          I    26 (  4)     xor a
E3CD-32 65 E6    I    27 ( 13)     ld (kbd_buffer_pos),a
E3D0-32 64 E6    I    28 ( 13)     ld (kbd_state),a
E3D3-            I    29
E3D3-C9          I    30 (  9)     ret
E3D4-            I    31
E3D4-            I    32       _int_kbd:
E3D4-F5          I    33 ( 11)     push af
E3D5-D9          I    34 (  3)     exx
E3D6-            I    35
E3D6-ED 38 80    I    36 ( 12)     in0 a,(KBD_DATA)            ; read scancode
E3D9-47          I    37 (  4)     ld b,a                      ; stored in B register
E3DA-            I    38
E3DA-            I    39       _int_kbd_test_F0:
E3DA-FE F0       I    40 (  6)     cp $F0                      ; F0 = release key
E3DC-C2 E7 E3    I    41 ( 6+)     jp NZ,_int_kbd_test_E0
E3DF-            I    42
E3DF-21 64 E6    I    43 (  9)     ld hl,kbd_state             ; set F0 flag in kbd_state
E3E2-CB DE       I    44 ( 13)     set KBD_STATE_F0,(hl)
E3E4-C3 AE E4    I    45 (  9)     jp _int_kbd_exit
E3E7-            I    46
E3E7-            I    47       _int_kbd_test_E0:
E3E7-FE E0       I    48 (  6)     cp $E0                      ; E0 = extended scancodes
E3E9-C2 F4 E3    I    49 ( 6+)     jp NZ,_int_kbd_check_state
E3EC-            I    50
E3EC-21 64 E6    I    51 (  9)     ld hl,kbd_state             ; set E0 flag in kbd_state
E3EF-CB E6       I    52 ( 13)     set KBD_STATE_E0,(hl)
E3F1-C3 AE E4    I    53 (  9)     jp _int_kbd_exit
E3F4-            I    54
E3F4-            I    55       _int_kbd_check_state:
E3F4-3A 64 E6    I    56 ( 12)     ld a,(kbd_state)
E3F7-            I    57
E3F7-CB 5F       I    58 (  6)     bit KBD_STATE_F0,a          ; if previous scancode was F0, jumps to F0 routine
E3F9-C2 8F E4    I    59 ( 6+)     jp NZ,_int_kbd_F0            ; (release key)
E3FC-            I    60
E3FC-CB 67       I    61 (  6)     bit KBD_STATE_E0,a          ; if previous scancode was E0, jumps to E0 routinr
E3FE-C2 88 E4    I    62 ( 6+)     jp NZ,_int_kbd_E0            ; (extended scancode)
E401-            I    63
E401-            I    64       _int_kbd_shift:                  ; manage SHIFT key
E401-78          I    65 (  4)     ld a,b
E402-FE 12       I    66 (  6)     cp $12 ; lshift
E404-CA 0C E4    I    67 ( 6+)     jp Z,_int_kbd_is_shift
E407-FE 59       I    68 (  6)     cp $59 ; rshift
E409-C2 14 E4    I    69 ( 6+)     jp NZ,_int_kbd_alt
E40C-            I    70
E40C-            I    71       _int_kbd_is_shift:
E40C-21 64 E6    I    72 (  9)     ld hl,kbd_state             ; set SHIFT flag in kbd_state
E40F-CB C6       I    73 ( 13)     set KBD_STATE_SHIFT,(hl)
E411-C3 AE E4    I    74 (  9)     jp _int_kbd_exit
E414-            I    75
E414-            I    76       _int_kbd_alt:                    ; manage ALT key
E414-FE 11       I    77 (  6)     cp $11
E416-C2 21 E4    I    78 ( 6+)     jp NZ,_int_kbd_capslock
E419-            I    79
E419-21 64 E6    I    80 (  9)     ld hl,kbd_state             ; set ALT flag in kbd_state
E41C-CB CE       I    81 ( 13)     set KBD_STATE_ALT,(hl)
E41E-C3 AE E4    I    82 (  9)     jp _int_kbd_exit
E421-            I    83
E421-            I    84       _int_kbd_capslock:                ; manage CAPS LOCK key
E421-FE 58       I    85 (  6)     cp $58
E423-C2 30 E4    I    86 ( 6+)     jp NZ,_int_kbd_get_key
E426-            I    87
E426-21 64 E6    I    88 (  9)     ld hl,kbd_state
E429-7E          I    89 (  6)     ld a,(hl)                   ; toggle CAPS LOCK flag in kbd_stte
E42A-EE 04       I    90 (  6)     xor KBD_XOR_CAPS
E42C-77          I    91 (  7)     ld (hl),a
E42D-C3 AE E4    I    92 (  9)     jp _int_kbd_exit
E430-            I    93
E430-            I    94       _int_kbd_get_key:
E430-16 00       I    95 (  6)     ld d,0                      ; hl <- kbd_buffer+(kbd_buffer_pos)
E432-3A 65 E6    I    96 ( 12)     ld a,(kbd_buffer_pos)
E435-5F          I    97 (  4)     ld e,a
E436-21 66 E6    I    98 (  9)     ld hl,kbd_buffer
E439-19          I    99 (  7)     add hl,de
E43A-E5          I   100 ( 11)     push hl                     ; save current buffer pointer on stack (1)
E43B-            I   101
E43B-2A 64 E6    I   102 ( 15)     ld hl,(kbd_state)
E43E-            I   103
E43E-            I   104       _int_kbd_get_key_caps:
E43E-3E 01       I   105 (  6)     ld  a,1                    ; a==1 -> lowercase , a==0 -> shift
E440-            I   106
E440-CB 56       I   107 (  9)     bit KBD_STATE_CAPS,(hl)
E442-CA 47 E4    I   108 ( 6+)     jp Z,_int_kbd_get_key_shift
E445-EE 01       I   109 (  6)     xor 1                      ; a<-0 (shift)
E447-            I   110
E447-            I   111       _int_kbd_get_key_shift:
E447-CB 46       I   112 (  9)     bit KBD_STATE_SHIFT,(hl)
E449-CA 4E E4    I   113 ( 6+)     jp Z,_int_kbd_get_key_set_shift
E44C-EE 01       I   114 (  6)     xor 1                       ; flip a
E44E-            I   115
E44E-            I   116       _int_kbd_get_key_set_shift:
E44E-21 5D E5    I   117 (  9)     ld hl,scan_codes_shift
E451-EE 01       I   118 (  6)     xor 1
E453-CA 66 E4    I   119 ( 6+)     jp Z,_int_kbd_get_key_scancode
E456-            I   120
E456-21 64 E6    I   121 (  9)     ld hl,kbd_state
E459-CB 4E       I   122 (  9)     bit KBD_STATE_ALT,(hl)      ; use ALT scancode set if ALT flag==1
E45B-CA 63 E4    I   123 ( 6+)     jp Z,_int_kbd_get_key_set_lowcase
E45E-21 E0 E5    I   124 (  9)     ld hl,scan_codes_alt
E461-18 03       I   125 (  8)     jr _int_kbd_get_key_scancode
E463-            I   126
E463-            I   127       _int_kbd_get_key_set_lowcase:
E463-21 DA E4    I   128 (  9)     ld hl,scan_codes
E466-            I   129
E466-            I   130       _int_kbd_get_key_scancode:
E466-78          I   131 (  4)     ld a,b
E467-CD D0 E4    I   132 ( 16)     call _kbd_decode_scancode
E46A-E1          I   133 (  9)     pop hl                      ; get back current buffer pointer (see 1)
E46B-            I   134
E46B-FE 00       I   135 (  6)     cp 0                        ; do nothing if no code found
E46D-CA AE E4    I   136 ( 6+)     jp Z,_int_kbd_exit
E470-            I   137
E470-77          I   138 (  7)     ld (hl),a                   ; save it to  kbd_buffer+(kbd_buffer_pos)
E471-            I   139
E471-FE 0A       I   140 (  6)     cp 10                       ; insert CR if ASCII code == LF (10)
E473-C2 7F E4    I   141 ( 6+)     jp NZ,_kbd_int_incr_buffer_pos
E476-23          I   142 (  4)     inc hl
E477-3E 0D       I   143 (  6)     ld a,13
E479-77          I   144 (  7)     ld (hl),a
E47A-7B          I   145 (  4)     ld a,e
E47B-3C          I   146 (  4)     inc a
E47C-32 65 E6    I   147 ( 13)     ld (kbd_buffer_pos),a
E47F-            I   148
E47F-            I   149       _kbd_int_incr_buffer_pos:
E47F-3A 65 E6    I   150 ( 12)     ld a,(kbd_buffer_pos)               ; inc kbd_buffer_pos
E482-3C          I   151 (  4)     inc a
E483-32 65 E6    I   152 ( 13)     ld (kbd_buffer_pos),a
E486-18 26       I   153 (  8)     jr _int_kbd_exit
E488-            I   154
E488-            I   155       _int_kbd_E0:
E488-21 64 E6    I   156 (  9)     ld hl,kbd_state                     ; clear E0 flag in kbd_state
E48B-CB A6       I   157 ( 13)     res KBD_STATE_E0,(hl)
E48D-18 1F       I   158 (  8)     jr _int_kbd_exit
E48F-            I   159
E48F-            I   160       _int_kbd_F0:
E48F-21 64 E6    I   161 (  9)    ld hl,kbd_state                      ; clear F0 flag in kbd_state
E492-CB 9E       I   162 ( 13)    res KBD_STATE_F0,(hl)
E494-            I   163
E494-78          I   164 (  4)    ld a,b                               ; clear SHIFT flag if key was LSHIFT
E495-FE 12       I   165 (  6)    cp $12 ; LSHIFT
E497-C2 9E E4    I   166 ( 6+)    jp NZ,_int_kbd_F0_rshift
E49A-CB 86       I   167 ( 13)    res KBD_STATE_SHIFT,(hl)
E49C-18 10       I   168 (  8)    jr _int_kbd_exit
E49E-            I   169
E49E-            I   170       _int_kbd_F0_rshift:                      ; clear SHIFT flag if key was LSHIFT
E49E-FE 59       I   171 (  6)    cp $59 ; RSHIFT
E4A0-C2 A7 E4    I   172 ( 6+)    jp NZ,_int_kbd_F0_alt
E4A3-CB 86       I   173 ( 13)    res KBD_STATE_SHIFT,(hl)
E4A5-18 07       I   174 (  8)    jr _int_kbd_exit
E4A7-            I   175
E4A7-            I   176       _int_kbd_F0_alt:                         ; clear ALT flag if key was LSHIFT
E4A7-FE 11       I   177 (  6)    cp $11 ; ALT
E4A9-C2 AE E4    I   178 ( 6+)    jp NZ,_int_kbd_exit
E4AC-CB 8E       I   179 ( 13)    res KBD_STATE_ALT,(hl)
E4AE-            I   180
E4AE-            I   181       _int_kbd_exit:
E4AE-D9          I   182 (  3)     exx                         ; end of keyboard interrupt routine.
E4AF-F1          I   183 (  9)     pop af
E4B0-FB          I   184 (  3)     ei
E4B1-C9          I   185 (  9)     ret
E4B2-            I   186
E4B2-            I   187       ; check if kbd buffer is empty
E4B2-            I   188       ; input : NONE
E4B2-            I   189       ; output : flag=Z if empty
E4B2-            I   190       _kbd_is_empty:
E4B2-3A 65 E6    I   191 ( 12)     ld a,(kbd_buffer_pos)
E4B5-FE 00       I   192 (  6)     cp 0
E4B7-C9          I   193 (  9)     ret
E4B8-            I   194
E4B8-            I   195       ; Get next key in buffer
E4B8-            I   196       _kbd_get_key:
E4B8-D5          I   197 ( 11)     push de
E4B9-E5          I   198 ( 11)     push hl
E4BA-            I   199
E4BA-3A 65 E6    I   200 ( 12)      ld a,(kbd_buffer_pos)
E4BD-            I   201
E4BD-FE 00       I   202 (  6)      cp 0                       ; exit value=0 if no key in buffer
E4BF-28 0C       I   203 ( 6+)      jr Z,_kbd_get_key_exit
E4C1-            I   204
E4C1-3D          I   205 (  4)      dec a
E4C2-32 65 E6    I   206 ( 13)      ld (kbd_buffer_pos),a
E4C5-16 00       I   207 (  6)      ld d,0
E4C7-5F          I   208 (  4)      ld e,a
E4C8-21 66 E6    I   209 (  9)      ld hl,kbd_buffer
E4CB-19          I   210 (  7)      add hl,de
E4CC-7E          I   211 (  6)      ld a,(hl)
E4CD-            I   212
E4CD-            I   213       _kbd_get_key_exit:
E4CD-E1          I   214 (  9)     pop hl
E4CE-D1          I   215 (  9)     pop de
E4CF-C9          I   216 (  9)     ret
E4D0-            I   217
E4D0-            I   218       ; input : a = scan code, hl = pointer to scan code table
E4D0-            I   219       ; output : a = decoded scan code
E4D0-            I   220       _kbd_decode_scancode:
E4D0-D5          I   221 ( 11)     push de
E4D1-E5          I   222 ( 11)     push hl
E4D2-            I   223
E4D2-16 00       I   224 (  6)     ld d,0
E4D4-5F          I   225 (  4)     ld e,a
E4D5-19          I   226 (  7)     add hl,de
E4D6-7E          I   227 (  6)     ld a,(hl)
E4D7-            I   228
E4D7-E1          I   229 (  9)     pop hl
E4D8-D1          I   230 (  9)     pop de
E4D9-C9          I   231 (  9)     ret
E4DA-            I   232
E4DA-            I   233       scan_codes:
E4DA-            I   234           ; 00-0F : n/a F9 n/a F5 F3 F1 F2 F12 n/a F10 F8 F6 F4 TAB  n/a
E4DA-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     09 C2 B2 00 I   235           .db 0,0,0,0,0,0,0,0,0,0,0,0,9,'',0
E4EA-            I   236           ; 10-1F : n/a n/a LSHIFT n/a n/a a & n/a n/a n/a n/a w s q z  n/a
E4EA-00 00 00 00 
     00 61 26 00 
     00 00 77 73 
     71 7A 82 00 I   237           .db 0,0,0,0,0,'a','&',0,0,0,'w','s','q','z',130,0
E4FA-            I   238           ; 20-2F : n/a c x d e ' " n/a n/a SPACE v f t r ( n/a
E4FA-00 63 78 64 
     65 27 22 00 
     00 20 76 66 
     74 72 28 00 I   239           .db 0,'c','x','d','e',39,34,0,0,' ','v','f','t','r','(',0
E50A-            I   240           ; 30-3F : n/a n b h g y - n/a n/a n/a , j u  _ n/a
E50A-00 6E 62 68 
     67 79 2D 00 
     00 00 2C 6A 
     75 8A 5F 00 I   241           .db 0,'n','b','h','g','y','-',0,0,0,',','j','u',138,'_',0
E51A-            I   242           ; 40-4F : n/a ; k i o   n/a n/a : ! l m p ) n/a
E51A-00 3B 6B 69 
     6F 85 87 00 
     00 3A 21 6C 
     6D 70 29 00 I   243           .db 0,59,'k','i','o',133,135,0,0,':','!','l','m','p',')',0
E52A-            I   244           ; 50-5F : n/a n/a  n/a ^ = n/a n/a CAPS RSHIFT RETURN $ n/a * n/a n/a
E52A-00 00 97 00 
     5E 3D 00 00 
     00 00 0A 24 
     00 2A 00 00 I   245           .db 0,0,151,0,'^','=',0,0,0,0,10,'$',0,'*',0,0
E53A-            I   246           ; 60-6F : n/a < n/a n/a n/a n/a BACKSPACE n/a n/a PAD_1 n/a PAD_4 PAD_7 n/a n/a n/a
E53A-00 3C 00 00 
     00 00 08 00 
     00 31 00 34 
     37 00 00 00 I   247           .db 0,'<',0,0,0,0,8,0,0,'1',0,'4','7',0,0,0
E54A-            I   248           ; 70-7F : PAD_0 PAD_, PAD_2 PAD_5 PAD_6 PAD_8 ESC P_VERNUM F11 PAD_+ PAD_3 PAD_- PAD_* PAD_9 ARRET_DEFIL
E54A-30 2C 32 35 
     36 38 00 00 
     00 2B 33 2D 
     2A 39 00    I   249           .db '0',',','2','5','6','8',0,0,0,'+','3','-','*','9',0
E559-            I   250           ; 80-83 : n/a n/a n/a F7
E559-00 00 00 00 I   251           .db 0,0,0,0
E55D-            I   252
E55D-            I   253       scan_codes_shift:
E55D-            I   254           ; 00-0F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a TAB n/a n/a
E55D-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 09 00 00 I   255           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0
E56D-            I   256           ; 10-1F : n/a n/a n/a n/a n/a A 1 n/a n/a n/a n/a W S Q Z 2 n/a
E56D-00 00 00 00 
     00 41 31 00 
     00 00 57 53 
     51 5A 32 00 I   257           .db 0,0,0,0,0,'A','1',0,0,0,'W','S','Q','Z','2',0
E57D-            I   258           ; 20-2F : n/a C X D E 4 3 n/a n/a SPACE V F T R 5 n/a
E57D-00 43 58 44 
     45 34 33 00 
     00 20 56 46 
     54 52 35 00 I   259           .db 0,'C','X','D','E','4','3',0,0,' ','V','F','T','R','5',0
E58D-            I   260           ; 30-3F : n/a N B H G Y 6 n/a n/a n/a ? J U 7 8 n/a
E58D-00 4E 42 48 
     47 59 36 00 
     00 00 3F 4A 
     55 37 38 00 I   261           .db 0,'N','B','H','G','Y','6',0,0,0,'?','J','U','7','8',0
E59D-            I   262           ; 40-4F : n/a . K I O 0 9 n/a n/a /  L M P  n/a
E59D-00 2E 4B 49 
     4F 30 39 00 
     00 2F 9E 4C 
     4D 50 A7 00 I   263           .db 0,'.','K','I','O','0','9',0,0,'/',158,'L','M','P',167,0
E5AD-            I   264           ; 50-5F : n/a n/a % n/a  + n/a n/a CAPS RSHIFT RETURN  n/a  n/a n/a
E5AD-00 00 25 00 
     7E 2B 00 00 
     00 00 0A 9C 
     00 E6 00 00 I   265           .db 0,0,'%',0,126,'+',0,0,0,0,10,156,0,230,0,0
E5BD-            I   266           ; 60-6F : n/a > n/a n/a n/a n/a BACKSPACE n/a n/a PAD_1 n/a PAD_4 PAD_7 n/a n/a n/a
E5BD-00 3E 00 00 
     00 00 08 00 
     00 31 00 34 
     37 00 00 00 I   267           .db 0,'>',0,0,0,0,8,0,0,'1',0,'4','7',0,0,0
E5CD-            I   268           ; 70-7F : PAD_0 PAD_, PAD_2 PAD_5 PAD_6 PAD_8 ESC P_VERNUM F11 PAD_+ PAD_3 PAD_- PAD_* PAD_9 ARRET_DEFIL
E5CD-30 2C 32 35 
     36 38 00 00 
     00 2B 33 2D 
     2A 39 00    I   269           .db '0',',','2','5','6','8',0,0,0,'+','3','-','*','9',0
E5DC-            I   270           ; 80-83 : n/a n/a n/a F7
E5DC-00 00 00 00 I   271           .db 0,0,0,0
E5E0-            I   272
E5E0-            I   273       scan_codes_alt:
E5E0-            I   274           ; 00-0F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
E5E0-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 I   275           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E5F0-            I   276           ; 10-1F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a ~ n/a
E5F0-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 7E 00 I   277           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,'~',0
E600-            I   278           ; 20-2F : n/a n/a n/a n/a n/a { # n/a n/a SPACE n/a n/a n/a n/a [ n/a
E600-00 00 00 00 
     00 7B 23 00 
     00 20 00 00 
     00 00 5B 00 I   279           .db 0,0,0,0,0,'{','#',0,0,' ',0,0,0,0,'[',0
E610-            I   280           ; 30-3F : n/a n/a n/a n/a n/a n/a | n/a n/a n/a n/a n/a n/a ` \ n/a
E610-00 00 00 00 
     00 00 7C 00 
     00 00 00 00 
     00 60 5C 00 I   281           .db 0,0,0,0,0,0,'|',0,0,0,0,0,0,'`',92,0
E620-            I   282           ; 40-4F : n/a n/a n/a n/a n/a @ ^ n/a n/a n/a n/a n/a n/a n/a ] n/a
E620-00 00 00 00 
     00 40 5E 00 
     00 00 00 00 
     00 00 5D 00 I   283           .db 0,0,0,0,0,'@','^',0,0,0,0,0,0,0,']',0
E630-            I   284           ; 50-5F : n/a n/a n/a n/a n/a } n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
E630-00 00 00 00 
     00 7D 00 00 
     00 00 00 00 
     00 00 00 00 I   285           .db 0,0,0,0,0,'}',0,0,0,0,0,0,0,0,0,0
E640-            I   286           ; 60-6F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
E640-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 I   287           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E650-            I   288           ; 70-7F : n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
E650-00 00 00 00 
     00 00 00 00 
     00 00 00 00 
     00 00 00 00 I   289           .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E660-            I   290           ; 80-83 : n/a n/a n/a F7
E660-00 00 00 00 I   291           .db 0,0,0,0
E664-            I   292
E664-            I   293
E664-            I   294            ; RAM
E664-            I   295       kbd_state: .bs 1
E665-            I   296       kbd_buffer_pos:    .bs 1
E666-            I   297       kbd_buffer: .bs 64
